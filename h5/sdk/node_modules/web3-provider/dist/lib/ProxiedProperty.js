"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
class ProxiedProperty {
    constructor(property, parentProvider, props) {
        this.parentProvider = parentProvider;
        this.propsPath = props;
        this.property = property;
        const handler = { construct: this.construct, get: this.get, apply: (_, __, ___) => __awaiter(this, void 0, void 0, function* () { return null; }) };
        if (typeof property === 'function')
            if ((property.constructor && property.constructor.name === 'AsyncFunction')
                || property.request)
                handler.apply = this.applyAsync;
            else
                handler.apply = this.applySync;
        const self = this;
        return new Proxy(function () { return self; }, handler);
    }
    construct(getSelf, args) {
        const self = getSelf();
        self.propsPath[self.propsPath.length - 1].args = args;
        self.propsPath[self.propsPath.length - 1].isClass = true;
        const selfClassInstance = new self.property(...args);
        return new ProxiedProperty(selfClassInstance, self.parentProvider, self.propsPath);
    }
    applySync(getSelf, _, functionArgs) {
        const self = getSelf();
        let lastError = new Error();
        let retries = 0;
        let val;
        let targetFunction = self.property;
        self.propsPath[self.propsPath.length - 1].args = functionArgs;
        while (retries <= self.parentProvider.options.retriesOnError)
            try {
                val = targetFunction(...functionArgs);
                if (val === null && self.parentProvider.options.retryOnNullResponse)
                    throw new Error('Web3Provider::gotNullResponse');
                break;
            }
            catch (e) {
                retries++;
                lastError = e;
                targetFunction = self.propsPath.reduce((acc, { name, args, isClass }, idx) => {
                    if (args) {
                        if (isClass)
                            return new acc[name](...args);
                        const f = acc[name];
                        if (idx === self.propsPath.length - 1)
                            return f;
                        return f(...args);
                    }
                    return acc[name];
                }, self.parentProvider.nextInstance());
            }
        if (val === undefined)
            throw lastError;
        if (typeof val !== 'function')
            return val;
        return new ProxiedProperty(val, self.parentProvider, self.propsPath); // support for function chaining
    }
    applyAsync(getSelf, _, functionArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            const self = getSelf();
            let lastError = new Error();
            let retries = 0;
            let val;
            let targetFunction = self.property;
            self.propsPath[self.propsPath.length - 1].args = functionArgs;
            while (retries <= self.parentProvider.options.retriesOnError)
                try {
                    val = yield targetFunction(...functionArgs);
                    if (val === null && self.parentProvider.options.retryOnNullResponse)
                        throw new Error('Web3Provider::gotNullResponse');
                    break;
                }
                catch (e) {
                    retries++;
                    lastError = e;
                    targetFunction = self.propsPath.reduce((acc, { name, args, isClass }, idx) => {
                        if (args) {
                            if (isClass)
                                return new acc[name](...args);
                            const f = acc[name];
                            if (idx === self.propsPath.length - 1)
                                return f;
                            return f(...args);
                        }
                        return acc[name];
                    }, self.parentProvider.nextInstance());
                }
            if (val === undefined)
                throw lastError;
            if (typeof val !== 'function')
                return val;
            return new ProxiedProperty(val, self.parentProvider, self.propsPath); // support for function chaining
        });
    }
    get(getSelf, prop) {
        const self = getSelf();
        if (self.hasOwnProperty(prop))
            return self[prop];
        if (self.property[prop] === undefined)
            return undefined;
        const newProp = { name: prop };
        const newProps = self.propsPath.concat(newProp);
        return new ProxiedProperty(self.property[prop], self.parentProvider, newProps);
    }
}
exports.default = ProxiedProperty;
//# sourceMappingURL=ProxiedProperty.js.map