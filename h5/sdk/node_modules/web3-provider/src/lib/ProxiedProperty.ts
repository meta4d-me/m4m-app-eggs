import IProp from './interfaces/IProp';
import IWeb3Provider from './interfaces/IWeb3Provider';


export default class ProxiedProperty {
    parentProvider :IWeb3Provider;
    propsPath :IProp[];
    property :() => any | object;

    constructor(property :any, parentProvider :any, props :IProp[]) {
        this.parentProvider = parentProvider;
        this.propsPath = props;
        this.property = property;

        const handler = { construct: this.construct, get: this.get, apply: async (_, __, ___) :Promise<any> => null  };

        if (typeof property === 'function')
            if ((property.constructor && property.constructor.name === 'AsyncFunction')
                || property.request)
                handler.apply = this.applyAsync;
            else
                handler.apply = this.applySync;

        const self :ProxiedProperty = this;
        return new Proxy(function() { return self; }, handler);
    }

    construct(getSelf, args) {
        const self = getSelf();
        self.propsPath[self.propsPath.length - 1].args = args;
        self.propsPath[self.propsPath.length - 1].isClass = true;
        const selfClassInstance = new self.property(...args);

        return new ProxiedProperty(selfClassInstance, self.parentProvider, self.propsPath);
    }

    applySync(getSelf, _, functionArgs) {
        const self = getSelf();

        let lastError :Error = new Error();
        let retries :number = 0;
        let val :any;
        let targetFunction = self.property;

        self.propsPath[self.propsPath.length - 1].args = functionArgs;
        while (retries <= self.parentProvider.options.retriesOnError)
            try {
                val = targetFunction(...functionArgs);
                if (val === null && self.parentProvider.options.retryOnNullResponse)
                    throw new Error('Web3Provider::gotNullResponse');

                break;
            }
            catch (e) {
                retries++;
                lastError = e;

                targetFunction = self.propsPath.reduce((acc, { name, args, isClass }, idx) => {
                    if (args) {
                        if (isClass)
                            return new acc[name](...args);
                        const f = acc[name];
                        if (idx === self.propsPath.length - 1)
                            return f;
                        return f(...args);
                    }
                    return acc[name];
                }, self.parentProvider.nextInstance());
            }

        if (val === undefined) throw lastError;

        if (typeof val !== 'function')
            return val;

        return new ProxiedProperty(val, self.parentProvider, self.propsPath); // support for function chaining
    }

    async applyAsync(getSelf, _, functionArgs) {
        const self = getSelf();

        let lastError :Error = new Error();
        let retries :number = 0;
        let val :any;
        let targetFunction = self.property;
        self.propsPath[self.propsPath.length - 1].args = functionArgs;
        while (retries <= self.parentProvider.options.retriesOnError)
            try {
                val = await targetFunction(...functionArgs);
                if (val === null && self.parentProvider.options.retryOnNullResponse)
                    throw new Error('Web3Provider::gotNullResponse');

                break;
            }
            catch (e) {
                retries++;
                lastError = e;
                targetFunction = self.propsPath.reduce((acc, { name, args, isClass }, idx) => {
                    if (args) {
                        if (isClass)
                            return new acc[name](...args);
                        const f = acc[name];
                        if (idx === self.propsPath.length - 1)
                            return f;
                        return f(...args);
                    }
                    return acc[name];
                }, self.parentProvider.nextInstance());
            }

        if (val === undefined) throw lastError;
        if (typeof val !== 'function')
            return val;

        return new ProxiedProperty(val, self.parentProvider, self.propsPath); // support for function chaining
    }


    get(getSelf :any, prop :string) {
        const self = getSelf();

        if (self.hasOwnProperty(prop))
            return self[prop];

        if (self.property[prop] === undefined)
            return undefined;

        const newProp :IProp = { name: prop };
        const newProps :IProp[] = self.propsPath.concat(newProp);

        return new ProxiedProperty(self.property[prop], self.parentProvider, newProps);
    }
}

