/// <reference types="../../lib/node_modules/@types/engine" />
/// <reference types="../../lib/node_modules/@types/wxEngine" />
declare module "Data/UIComponentBaseData" {
    export enum DirectionType {
        Vertical = 0,
        Horizontal = 1,
        UP = 2,
        DOWN = 3
    }
    export abstract class UIComponentBaseData {
        index: number;
        width: number;
        height: number;
        abstract Clone(): any;
    }
}
declare module "Data/CellData" {
    import { UIComponentBaseData } from "Data/UIComponentBaseData";
    export class CellData extends UIComponentBaseData {
        selectIcon: m4m.framework.transform2D;
        data: any;
        showTip: boolean;
        enabled: boolean;
        Clone(): CellData;
    }
}
declare module "Data/Cell" {
    import { CellData } from "Data/CellData";
    export class Cell extends m4m.framework.behaviour2d implements m4m.framework.I2DPointListener {
        protected baseData: CellData;
        get cellData(): CellData;
        set cellData(value: CellData);
        get index(): number;
        name: string;
        clickCallBackFun: Function;
        private static readonly helpV2;
        private cellClass;
        private btn;
        onPlay(): void;
        setCellClass(value: any): void;
        selectFun(selectbool: boolean): void;
        setData(value: any): void;
        dispose(): void;
        pointerDownFun(): void;
        onPointEvent(canvas: m4m.framework.canvas, ev: m4m.framework.PointEvent, oncap: boolean): void;
        protected pointerClickFun(): void;
        private addBtn;
    }
}
declare module "Data/CheckBoxComponent" {
    export class CheckBoxComponent extends m4m.framework.behaviour2d {
        checkType: CheckType;
        btn: m4m.framework.button;
        callBackFun: Function;
        private _checkState;
        private assetMgr;
        private image;
        private baseName;
        private iconSprStr;
        onPlay(): void;
        set value(value: boolean);
        get value(): boolean;
        btnClick_event(): void;
        private init;
    }
    export enum CheckType {
        Default = 1,
        Special = 2
    }
}
declare module "Data/Dictionary" {
    export class Dictionary {
        _keys: any[];
        _values: any[];
        constructor(init?: {
            key: any;
            value: any;
        }[]);
        Add(key: any, value: any): void;
        Remove(key: any): void;
        GetValue(key: any): any;
        GetKey(value: any): any;
        get keys(): any[];
        get values(): any[];
        ContainsKey(key: any): boolean;
        get count(): number;
        Clear(): void;
    }
}
declare module "Data/EventDispatcher" {
    import { Dictionary } from "Data/Dictionary";
    export class EventDispatcher {
        events: Dictionary;
        addEventListener(evnetType: string, fun: Function): void;
        removeEventListener(evnetType: string, fun: Function): void;
        dispatchEvent(evnetType: string, ...args: any[]): void;
    }
}
declare module "Tools/ioTool" {
    export class ioTool extends m4m.io.binTool {
        constructor();
        readVector3(): m4m.math.vector3;
        readVector4(): m4m.math.vector4;
        readVector3Array(): m4m.math.vector3[];
        readReshsArray(): number[][];
        readNumArray(): number[];
    }
}
declare module "Data/Map" {
    /**
     * 清空Map
     */
    export class cMap<V> {
        constructor(obj?: object);
        /** 存放数据 */
        private data;
        /**
         * 清空Map
         */
        clear(): void;
        /**
         * 判断是否包含指定Key
         * @param key
         */
        has(key: number | string): boolean;
        /**
         * 放入一个键值对
         * @param key
         * @param value
         */
        set(key: number | string, value: V): this;
        /**
         * 获取某键对应的值
         * @param  key
         * @return  value
         */
        get(key: number | string): V;
        /**
         * 删除一个键值对
         * @param  key
         */
        delete(key: number | string): boolean;
        /**
         * 遍历Map,执行处理函数
         * @param fn  回调函数 function(key,value){..}
         */
        forEach(fn: (value: V, key: number | string) => void): void;
        /**
         * 异步遍历Map,执行处理函数
         * @param fn  回调函数 function(key,value){..}
         */
        forEachAsync(fn: (value: V, key: number | string) => Promise<void>): Promise<void>;
        /**
         * 克隆Map,返回克隆Map
         */
        clone(): cMap<V>;
        /**
         * 获取键值对数量
         */
        get size(): number;
    }
}
declare module "Data/ExcelDataBase" {
    import { ioTool } from "Tools/ioTool";
    import { EventDispatcher } from "Data/EventDispatcher";
    import { cMap } from "Data/Map";
    export class ExcelDataBase extends EventDispatcher {
        static excelData: string;
        static excelSplitData: string;
        private static _listMap;
        private static loadedDic;
        private static loadingDic;
        protected static get _list(): cMap<any>;
        protected static set _list(v: cMap<any>);
        static getDataByIDCallBack(id: number, callBack: Function): void;
        static getDataByID(id: number): Promise<any>;
        static getAllData(): Promise<cMap<any>>;
        static getAllDataCallBack(callBack: Function): void;
        static parseData(bytes: ioTool): void;
        private static loadArrayBuffer;
    }
}
declare module "Tools/engineParallel/spInterface" {
    export enum engineParallelType {
        /** 纯源引擎 */
        none = 0,
        /** 微信引擎 */
        wxEngine = 1,
        /** qq引擎 */
        qqEngine = 2,
        /** 抖音引擎 */
        ttEngine = 3
    }
    export enum spComponentType {
        /** 相机组件 */
        camera = 0,
        /** 模型渲染组件 */
        meshRenderer = 1,
        /** 蒙皮模型渲染 组件 */
        skinMeshRenderer = 2,
        /** 粒子系统 组件 */
        particleSystem = 3,
        /** 拖尾 */
        trailRenderer = 4,
        /** 动画播放 */
        animPlayer = 5
    }
    /** 销毁接口 */
    export interface IDispose {
        dispose(): any;
    }
    /** 重置接口 */
    export interface IReset {
        reset(): any;
    }
    /** 简配 gameObject 节点 接口 */
    export interface ISpGameObject extends IDispose {
        /** 是否是静态 */
        isStatic: boolean;
        /** 层 */
        layer: number;
        /** 标签信息 */
        tag: string;
        /** 可见性 */
        visible: boolean;
        /** raw 数据 */
        rawHandle: any;
        /** transform */
        transform: ISpTransform;
        /** name */
        name: string;
        /** 获取节点ID */
        getID(): number;
        /** 场景transform 根节点 */
        getRootNode(): ISpTransform;
        /** 获得组件 */
        getFirstComponent(type: spComponentType): ISpComponent;
        /** 获取全部组件 */
        getComponents(type: spComponentType): ISpComponent[];
        /** 添加组件通过类型 */
        addComponent(type: spComponentType): ISpComponent;
        /** 清理 */
        dispose(): any;
    }
    /**
     * 简配 组件接口
     */
    export interface ISpComponent extends IDispose {
        /** 全局识别ID , 初始化时被赋予*/
        id: string;
        /** 原始数据 */
        rawHandle: any;
        /** go 对象引用 */
        gameObject: ISpGameObject;
        /** 组件类型 */
        compType: spComponentType;
    }
    export interface ISPRenderer extends ISpComponent {
        /** 获取材质ID */
        getMaterialID(matIdx?: number): number;
        /** 获取当前的 材质数量 */
        getMaterialsCount(): number;
        /**
         * 设置材质 float 值
         * @param key
         * @param value
         * @param matIdx 材质的索引
         */
        setMaterialFloat(key: string, value: number, matIdx?: number): any;
        /**
         * 设置材质 vector4 值
         * @param key
         * @param value
         * @param matIdx 材质的索引
         */
        setMaterialVector4(key: string, value: m4m.math.vector4, matIdx?: number): any;
        /**
         * 设置贴图
         * @param key 材质key
         * @param valueTex 贴图值
         * @param matIdx 材质索引
         */
        setTexture(key: string, valueTex: any, matIdx?: number): any;
        /** shader 名字 */
        getShaderName(matIdx?: number): string;
        /**
         * 设置 shader
         * @param shaderSrc  shader 标识字符串
         * @param matIdx 材质的索引
         */
        setShader(shaderSrc: string, matIdx?: number): Promise<void>;
        /** 缓存了的数量 */
        cachedCount(): number;
        /**
         * 缓存当前的 材质状态
         * @param globalMatKey 全局共享 材质key
         */
        cacheCurrMaterial(globalMatKey?: string): number;
        /** 恢复当前材质状态到指定ID */
        restoreMaterial(cacheID: number): any;
        /** 最后恢复的缓存材质ID ， 默认 -1 */
        getLastRestoreID(): number;
    }
    /**
     * 简配 相机组件
     */
    export interface ISpCamera extends ISpComponent {
        /** fov 值 */
        fov: number;
        /** 相机远剪裁面 */
        far: number;
        /** 相机近剪裁面 */
        near: number;
    }
    /**
     * 简配 模型渲染组件
     */
    export interface ISpMeshRenderer extends ISPRenderer {
        /** 渲染 队列优先级值 */
        queue: number;
        /** 开启 gpuInstanceing  */
        enableGpuInstancing: boolean;
    }
    /**
     * 简配 skin meshRenderer
     */
    export interface ISpSkinnedMeshRenderer extends ISPRenderer {
        /**  */
        isSkinnedMeshRenderer: boolean;
    }
    /**
     * 简配 effect
     */
    export interface ISpParticleSystem extends ISPRenderer {
        /** 是循环播放 */
        beloop: boolean;
        /**
         * 播放粒子系统
         * @param onPlayEnd 播放结束回调
         */
        play(onPlayEnd?: () => void): any;
        /** 停止播放 */
        stop(): any;
        /** 设置基础颜色 */
        setColor(_color: m4m.math.color): any;
    }
    /**
     * 简配 TrailRender
     */
    export interface ISpTrailRender extends ISPRenderer {
        /** 拖尾颜色 */
        color: m4m.math.color;
        /** 播放拖尾 */
        play(): any;
        /** 停止播放 */
        stop(): any;
        /**
         * 设置速度
         * @param speed
         */
        setSpeed(speed: number): any;
        /**
         * 设置拖尾宽度
         * @param Width
         */
        setWidth(Width: number): any;
    }
    export interface IPlayAnim {
        /** 停止播放 */
        stop(): any;
        /**
         * 播放动画通过 片段名
         * @param clipName 片段名
         * @param onPlayend 播放完毕回调函数
         * @param blendTime 融合时间
         * @param endframe  播放到 指定 帧
         * @param speed     播放速度
         * @param beRevert  是否反向播
         */
        playAnimByName(clipName: string, onPlayend?: () => any, blendTime?: number, endframe?: number, speed?: number, beRevert?: boolean): any;
    }
    /**
     *   简配 动画播放组件
     */
    export interface ISpAnimPlayer extends ISpComponent, IPlayAnim {
    }
    /**
     * 简配 transform组件
     */
    export interface ISpTransform extends IDispose {
        /** 引擎平台类型 */
        engineType: engineParallelType;
        /** 开启 使用Instanceing */
        needGpuInstancBatcher: boolean;
        /** 视锥剔除开关 */
        enableCulling: boolean;
        /** name */
        name: string;
        /** raw 数据 */
        rawHandle: any;
        /** gameObject */
        gameObject: ISpGameObject;
        /** 本地旋转四元数 */
        localRotate: m4m.math.quaternion;
        /**本地位移*/
        localPosition: m4m.math.vector3;
        /** 本地缩放*/
        localScale: m4m.math.vector3;
        /** 本地旋转的欧拉角*/
        localEulerAngles: m4m.math.vector3;
        /** 子数量 */
        childrenCount: number;
        /** 获取子节点通过索引 */
        getChildByIdx(childIdx: number): ISpTransform;
        /**
         * 添加子物体实例
         * @param node 子物体实例
         */
        addChild(node: ISpTransform): void;
        /**
         * 移除所有子物体
         */
        removeAllChild(needDispose?: boolean): void;
        /**
         * 移除指定子物体
         * @param node 子物体实例
         */
        removeChild(node: ISpTransform): void;
        /**
         * 查找自己以及子物体中是否有指定名称的transform
         * @param name
         */
        find(name: string): ISpTransform;
        /** 获取世界坐标系下的旋转 */
        getWorldRotate(): m4m.math.quaternion;
        /** 设置transform世界空间下的旋转 */
        setWorldRotate(rotate: m4m.math.quaternion): void;
        /** 获取世界坐标系下的位移 */
        getWorldPosition(): m4m.math.vector3;
        /** 设置transform世界空间下的位移 */
        setWorldPosition(pos: m4m.math.vector3): void;
        /** 获取世界坐标系下的缩放 */
        getWorldScale(): m4m.math.vector3;
        /** 设置世界坐标系下的缩放 */
        setWorldScale(scale: m4m.math.vector3): void;
        /**
         * 设置transform的世界矩阵 通过计算得到本地矩阵实现
         * @param mat 世界空间下矩阵
         */
        setWorldMatrix(mat: m4m.math.matrix): void;
        /** 获取世界矩阵 */
        getWorldMatrix(): m4m.math.matrix;
        /** 获取本地矩阵 */
        getLocalMatrix(): m4m.math.matrix;
        /**旋转当前transform到z轴指向给定坐标
         * @param point 给定的坐标
         */
        lookatPoint(point: m4m.math.vector3): void;
        /**public
        * 获取世界坐标系下当前z轴的朝向
        */
        getForwardInWorld(out: m4m.math.vector3): void;
        /**
         * 获取世界坐标系下当前x轴的朝向
         */
        getRightInWorld(out: m4m.math.vector3): void;
        /**
         * 获取世界坐标系下y轴的朝向
         */
        getUpInWorld(out: m4m.math.vector3): void;
        /** 获取父节点 */
        getParent(): ISpTransform;
        /** 获取 aabb 的max */
        getAabbMax(): m4m.math.vector3;
        /** 获取 aabb 的min */
        getAabbMin(): m4m.math.vector3;
        /** 获取 aabb 的中心点 */
        getAabbCenter(): m4m.math.vector3;
        /** 释放当前transform */
        dispose(): void;
    }
    export interface ISpCustomComp {
        /** 是否激活 */
        enabled: boolean;
        /** go */
        gameObject: ISpGameObject;
        /** 初始化使用 */
        start(): void;
        /** 初始化使用 在start 之后 */
        onPlay(): void;
        /** 每帧调用一次 */
        update(delta: number): void;
        remove(): void;
    }
    export interface ISpCustomCompAdapter {
        /** 获取 自定义组件对象 */
        getComp(): any;
        /** 设置激活状态 */
        setEnabled(enabled: boolean): any;
        /** 获取激活状态 */
        getEnabled(): boolean;
        /** 添加 */
        addCompToGO(_customComp: ISpCustomComp): any;
    }
    export interface ISpPrefab {
        rawHandle: any;
        /** 获取一个clone 实例 */
        getCloneTrans(): ISpTransform;
        /** 获取唯一id */
        getGUID(): number;
    }
    /** 动画播放 工具 */
    export interface ISpAnimPlayerHandle extends IPlayAnim, IDispose {
        /** 停止播放 */
        stop(): any;
        /** 当前片段总时长 */
        currClipTotalTime(): number;
        /** 获取当前播放的动画片段名 */
        getCurrClipName(): string;
        /**
         * 获取指定动画片段的播放时长
         * @param simpleClipName 源动画片段名（不包含后缀）
         */
        getClipTotalTime(simpleClipName: string): number;
        /** 设置当前片段播放到指定 单位化时间点 */
        setCurrClipNormalizedTime(normalLizedTime: number): any;
        /** 获取当前clip 的 NormalizedTime */
        getCurrClipNormalizedTime(): number;
        /** 当前是播放状态 */
        isPlay(): boolean;
        /** 是否 有指定clipName 的 片段 */
        hasClip(clipName: string): any;
        /**
        * 注册 动画时间轴事件 回调响应对象
        * @param eventActObj      动画时间事件 回调触发对象
        */
        regTimeEventCallbackObj(eventActObj: object): any;
        /**
         * 设置 动画时间轴事件 参数
         * @param simpleClipName    动画片段名
         * @param timePoint         事件时间点
         * @param _actFunName       行为方法名
         * @param val               事件传递的参数
         */
        setTimeEvent(simpleClipName: string, timePoint: number, _actFunName: string, val: string): any;
        /** 释放 */
        dispose(): void;
    }
}
declare module "Tools/GameInfoUtil" {
    export class GameInfoUtil {
        static brand: string;
        static model: string;
        static version: string;
        static systemStr: string;
        static SDKVersion: string;
        /** 头像URL */
        static avatarUrl: string;
        static wxName: string;
        static province: string;
        static city: string;
        static gender: number;
        private static dic;
        static compareSDKVersion(minSDKver: string, needTip?: boolean): boolean;
    }
}
declare module "Tools/miniGame" {
    import { engineParallelType } from "Tools/engineParallel/spInterface";
    type SocketTask = {
        send(p: any): any;
        close(p: any): any;
        onOpen(cb: Function): any;
        onClose(cb: Function): any;
        onError(cb: Function): any;
        onMessage(cb: Function): any;
    };
    type socketConnectOption = {
        url: string;
        protocols?: string[];
        timeout?: number;
        success?: Function;
        fail?: Function;
        complete?: Function;
        header?: object;
        tcpNoDelay?: boolean;
        perMessageDeflate?: boolean;
    };
    export enum miniAPIType {
        none = 0,
        wechat = 1,
        qq = 2,
        tikTok = 3,
        vivo = 4,
        oppo = 5
    }
    /**
     *  小游戏平台API
     */
    export class miniGame {
        /** 引擎并行类型(m4mH5 , 微信牛肉丸 ， qq性能引擎) */
        static engineParallel: engineParallelType;
        /** 账号凭证 */
        static token: string;
        /** 获取小游戏启动时的参数
            scene	number	启动小游戏的场景值
            query	Object	启动小游戏的 query 参数
            shareTicket	string	shareTicket，详见获取更多转发信息
            referrerInfo	object	来源信息。从另一个小程序、公众号或 App 进入小程序时返回。否则返回 {}。(参见后文注意)
        */
        static LaunchOptions: any;
        /** 自己的用户信息 */
        static myUserInfo: any;
        /** 小游戏平台类型 */
        static miniType: miniAPIType;
        /**系统信息 */
        static wxSystemInfo: any;
        static AuthorizeButton: any;
        static lxstr: string;
        static versionUpDateStr: string;
        static flashSaleStartStr: string;
        static isActivitySubscribe: boolean;
        static isVersionUpDateSubscribe: boolean;
        static isSubscribe: boolean;
        private static uiMgr;
        private static miniObj;
        private static readonly scopeUif;
        private static sharedCanvas;
        /** miniGame 初始化 */
        private static PreInit;
        /** 初始化 */
        static init(uiMgr: any): void;
        /**
         * 刷新SystemInfo
         * @param callBackFun 结束回调
         */
        static refreshSystemInfo(callBackFun: (err: any) => any): void;
        /** 获取API 版本 */
        static getAPIVersion(): any;
        /** 短震动 */
        static vibrateShort(): void;
        /** 长震动 */
        static vibrateLong(): void;
        static openMiniPrograme(appid: string, path: string): void;
        /** 刷新SharedCanvas */
        static refSharedCanvas(): void;
        /** 设置 头像Icon跟随 或者 全屏 画板模式 */
        static setHeadFollowMode(isHFollow: boolean, portrailFollowMgr: any): void;
        /** 获取用户info */
        static getUserInfo(callback: Function): Promise<unknown>;
        /** 显示用户授权按钮 */
        static showUserAuthorizeBtn(callback: Function, onTapFun?: Function, onckUserInfoScope?: Function): void;
        /**
         * 创建用户信息按钮
         * @param p 参数
         */
        static createUserInfoButton(p: {}): any;
        static ckUserInfoScope(callback: (isOk: boolean) => any): void;
        /** 触发GC */
        static triggerGC(): void;
        static loadFun(url: any, callBack: any, fail: any): void;
        /**
         * http request 接口
         * @param p 参数
         */
        static request(p: {}): void;
        /**
         * http request 接口 , Simple 接口
         * dataType 固定为 json
         * 回调函数返回参 data == res.data
         * @param method
         * @param url
         * @param data
         * @param success 成功回调函数
         * @param complete 完成回调函数
         * @param fail 失败回调函数
         */
        static requestSimple(method: any, url: string, data: any, success?: (data: any) => any, complete?: (data: any) => any, fail?: (data: any) => any): void;
        /** 保存图片到相册 */
        static saveImageToPhotosAlbum(filePath: string): void;
        /**存个人数据*/
        static saveData(fName: string, _data: object, callBack: Function, _fial: Function): void;
        /** 请求获取 保存的数据*/
        static reqData(fName: string, callBack: (data: any) => any, _fial: Function): void;
        /**显示模态对话框*/
        static showModal(p: {}): void;
        /** 调用接口获取登录凭证 */
        static login(p: {}): void;
        /**
         * 获取小游戏启动时的参数
         */
        static getLaunchOptionsSync(): any;
        /**
         * 获取转发详细信息
         * @param p 参数
         */
        static getShareInfo(p: {}): void;
        /**
         * 调起客户端小游戏订阅消息界面
         * @param p 参数
         */
        static requestSubscribeMessage(p: {}): void;
        /**
         *  创建内部 audio 上下文 InnerAudioContext 对象。
         */
        static createInnerAudioContext(): any;
        /**
         * 监听内存不足告警事件
         * @param f 内存不足告警事件的回调函数
         */
        static onMemoryWarning(f: Function): void;
        /**
         * 可以修改渲染帧率。默认渲染帧率为 60 帧每秒。修改后，requestAnimationFrame 的回调频率会发生改变。
         * @param fps 帧率，有效范围 1 - 60。
         */
        static setPreferredFramesPerSecond(fps: number): any;
        /**
         * 监听小游戏隐藏到后台事件
         * @param f
         */
        static onHide(f: Function): void;
        /**
         * 监听小游戏回到前台的事件
         * @param f
         */
        static onShow(f: Function): void;
        /**
         * 监听鼠标按键按下事件
         * @param f
         */
        static onMouseDown(f: (p: {}) => any): void;
        /**
         * 监听鼠标按键弹起事件
         * @param f
         */
        static onMouseUp(f: (p: {}) => any): void;
        /**
        * 显示键盘
        */
        static showKeyboard(keyBoardObj: {}): void;
        /**
         * 监听键盘输入事件
         * @param f
         */
        static onKeyboardInput(f: (p: {}) => any): void;
        /**
         * 取消监听键盘输入事件
         * @param f
         */
        static offKeyboardInput(f: (p: {}) => any): void;
        /**
        * 监听用户点击键盘 Confirm 按钮时的事件
        */
        static onKeyboardConfirm(keyBoardObj: {}): void;
        /**
        * 取消监听用户点击键盘 Confirm 按钮时的事件
        */
        static offKeyboardConfirm(keyBoardObj: {}): void;
        /**
        * 发起米大师支付
        */
        static requestMidasPayment(fun: {}): void;
        /**
         * 隐藏键盘
         * @param f
         */
        static hideKeyboard(obj: {}): void;
        /**
         * 统计 场景分析上报
         */
        static reportUserBehaviorBranchAnalytics(branchId: string, branchDim: number, eventType: number): void;
        /**
         * 获取 离屏canvas
         * @param customID
         */
        static getOffScreenCanvas(customID: string): HTMLCanvasElement;
        /**
         * 加载分包
         * @param p
         */
        static loadSubpackage(p: {
            name: string;
            fail?(res: any): any;
            success?(res: any): any;
        }): {
            onProgressUpdate(res: any): any;
        };
        /**
         * 连接 webSocket
         * @param p 选项
         * @returns Socket任务对象
         */
        static connectSocket(p: socketConnectOption): SocketTask;
        private static _loadImgFun;
        private static ckInitSCanvas;
        private static setSCanvasWH;
        private static setfullMode;
    }
}
declare module "Loader/LoaderLibManager" {
    type cbFun = (isSuccess: boolean) => void;
    export class LoaderLibManager {
        private static instance;
        static get Instance(): LoaderLibManager;
        private codeMap;
        private idIdx;
        addLib(lib: string, callback?: (isSuccess: boolean) => void): void;
        removeLib(lib: string): boolean;
        /**
         * 加载 小游戏平台的分包
         * @param packageName 分包名
         * @param callback 回调函数
         */
        addSubpackage(packageName: string, callback?: cbFun): void;
    }
}
declare module "Data/ExcelDataMgr" {
    export class ExcelDataMgr {
        private static jsPath;
        private static isInitAll;
        /**
         * 初始设置
         * @param jsPath 自动加载JS 文件的路径 （例："lib/node_modules/@types/"）
         */
        static init(jsPath: string): void;
        static initAllDataClass(cb: Function): void;
        static initDataClassByName(className: string, cb: Function): void;
        private static getLoadFun;
        private static getLibString;
    }
}
declare module "PSDUI/UiTools" {
    export class UiTools {
        static cloneUi<T>(old: T): T;
        private static cloneUiClass;
    }
}
declare module "Data/GridData" {
    import { CellData } from "Data/CellData";
    export class GridData {
        /***列*/
        columns: number;
        /***行*/
        rows: number;
        offsetX: number;
        offsetY: number;
        bagType: number;
        initXPlace: number;
        initYPlace: number;
        cellLayoutX: m4m.framework.layoutOption;
        cellLayoutY: m4m.framework.layoutOption;
        cellData: CellData;
        cell: any;
        parentTrans: m4m.framework.transform2D;
        cellName: string;
    }
}
declare module "Data/ListModel" {
    /** 收缩列表容器
     * （常用包裹数据容器）
     */
    export class ListModel<T> extends m4m.AEvent {
        /** 容器名字 */
        get listName(): string;
        /** 所属位置标记*/
        get place(): number;
        /** 容器的数组 */
        get list(): T[];
        /** 二分插入法 */
        private static insertSortWithBinarySearch;
        /** 容器最大值 */
        get Max(): number;
        set Max(value: number);
        /** 容器尺寸 */
        get count(): number;
        /** 存放东西的数量 */
        get HaveCount(): number;
        /**
         * 收缩列表容器
         * @param listName 容器名字标记
         * @param place 所属位置标记
         */
        constructor(listName?: string, place?: number);
        private eventData;
        private _listName;
        private _place;
        private _list;
        private _emptyIdxArr;
        private _max;
        /**
         * 获取指定索引位置的元素
         * @param index 索引
         */
        getValue(index: number): T;
        /**
         * 设置指定位置的元素(成功：true 失败 ： false)
         * @param index 索引
         * @param value 元素
         */
        setValue(index: number, value: T): boolean;
        /**
         * 添加到空位 (成功：true 失败 ： false)
         * @param obj 被添加对象
         */
        add(obj: T): boolean;
        /**
         * 清理容器所有的元素
         * @param reset 重置 (max 到 0)
         */
        clear(reset?: boolean): void;
        /**
         * 删除指定位置的元素
         * @param index 索引位置
         */
        RemoveAt(index: number): T;
        /**
         * 删除元素
         * @param obj
         * @param index
         */
        remove(obj: T, index?: number): T;
        /**
         * 设置数据
         * @param source
         */
        setSource(source: T[], clear?: boolean): void;
        /**
         * 找空格子 , 返回找到的索引值
         */
        freeIndex(): number;
        /**
         * 检查是否有指定数量空格子
         * @param num 数量
         */
        FindFreeNum(num: number): boolean;
        /**
         * 添加事件监听
         * @param eventType
         * @param listener
         * @param thisArg
         */
        addListener<K extends keyof IListModelEventMap>(eventType: K, listener: (ev: ListModelEventData<T>) => any, thisArg: any): void;
        /**
         * 移除事件监听
         * @param eventType
         * @param listener
         * @param thisArg
         */
        removeListener<K extends keyof IListModelEventMap>(eventType: K, listener: Function, thisArg: any): void;
        /** 刷新空索引的数组 */
        private refreshEmptyIdxs;
        private insertToEmpytIdxs;
        private deleteOfEmpytIdxs;
    }
    class ListModelEventData<T> {
        /** 事件发送者 */
        readonly dispatcher: ListModel<T>;
        /** 元素索引值 */
        index: number;
        /** 元素对象 */
        obj: T;
        constructor(dispatcher: ListModel<T>, listName: string);
        set(index: number, obj: T): void;
    }
    interface IListModelEventMap {
        /** 添加元素 */
        "ADD": "ADD";
        /** 最大值变化 */
        "MAX_CHANGE": "MAX_CHANGE";
        /** 重设置尺寸 */
        "RESIZE": "RESIZE";
        /** 清理全部元素 */
        "CLEAR": "CLEAR";
        /** 删除元素 */
        "REMOVE": "REMOVE";
    }
}
declare module "Data/Grid" {
    import { Cell } from "Data/Cell";
    import { GridData } from "Data/GridData";
    import { ListModel } from "Data/ListModel";
    export class Grid {
        set visible(value: boolean);
        get girdData(): GridData;
        set SelectIndex(value: number);
        get SelectIndex(): number;
        listModelEvent: boolean;
        selectCallBackFun: Function;
        name: string;
        constructor(base: GridData);
        private _selectIndex;
        private baseData;
        private _list;
        private downFun;
        private addEventFun;
        private removeEventFun;
        private clearEventFun;
        private _listModel;
        private _width;
        private _height;
        getCellList(): Cell[];
        create(): void;
        setListModel(itemListModel: ListModel<any>): void;
        getWidth(): number;
        getHeight(): number;
        getAddOffsetWidth(): number;
        getAddOffsetHeight(): number;
        reshUIPosFun(): void;
        dispose(): void;
        private cell_singleClickHandler;
        private AddEventHandler;
        private RemoveEventHandler;
        private setNullFun;
        private ClearEventHandler;
    }
}
declare module "Loader/loader" {
    export class loader {
        /** loader已经结束 */
        get isEnd(): boolean;
        preName: string;
        assetmgr: m4m.framework.assetMgr;
        id: number;
        url: string;
        priority: number;
        /** 加载进度 0-1 */
        progress: number;
        /** 资源总大小 */
        resSize: number;
        /** 加载了的资源大小 */
        loadedSize: number;
        fileCount: number;
        fileLoadedCount: number;
        /** 加载中的时间 */
        loadingTime: number;
        /** 加载完毕 */
        onEnd: (l: loader) => any;
        /** 加载失败 */
        onLoadFail: (l: loader) => any;
        /** 进度更新 */
        onProgress: (prog: any, Loadfiles: any, loadSize: any) => any;
        constructor(url: string, preName?: string);
        /** 等待最大时间 */
        private readonly waitMaxTime;
        private _isEnd;
        private lastckTime;
        /** 超时重试 次数 */
        private timeOutTryLoadCount;
        load(): void;
        /**
         * 检查超时
         * @param currTime 当前时间
         */
        ckOfTimeOut(currTime: number): void;
        private downLoadFinish;
        private onloading;
        private retryLaod;
    }
}
declare module "Loader/loadMgr" {
    import { loader } from "Loader/loader";
    export class loadMgr {
        static get Instance(): loadMgr;
        private get assetMgr();
        /** 并行加载最大数量 */
        maxLoadingCount: number;
        constructor();
        private static _instance;
        private endCaseDic;
        private loadedDic;
        private addLoadDic;
        private waitLoaders;
        private loadingLoaders;
        private index;
        private readonly ckTimeoutGap;
        private _assetMgr;
        /**
         * 异步并行加载  资源列表
         * @param urls
         * @param priority
         */
        syncLoadList(urls: string[], priority?: number): Promise<unknown>;
        /**
         * 异步加载
         * @param url
         * @param priority
         */
        syncLoad(url: string, priority?: number): Promise<unknown>;
        /**
         * 加载 Asset 通过 ，文件夹路径 + 资源名
         * @param dirPath  文件夹路径
         * @param assName   资源名
         * @param endFun 结束回调方法
         * @param priority 优先级
         */
        loadByName(dirPath: string, assName: string, endFun: (url: string, assName: string) => any, priority?: number): void;
        /**
         * 加载 Asset to 引擎环境
         * @argument url 资源url
         * @argument endFun loader end 回调方法
         * @argument priority 优先级 默认0 ，值越大越优先
         */
        load(url: string, endFun: (url: string) => any, priority?: number): loader;
        /**
         * 加载 并返回资源对象
         * @param url
         * @param priority
         */
        syncLoadGain<T extends m4m.framework.IAsset>(url: string, priority?: number): Promise<T>;
        private loopCkLoaderTimeOut;
        private addLoader;
        private doLoad;
        private getNext;
        private onLoadEndOne;
        private onLoadFail;
    }
}
declare module "Tools/engineParallel/m4m/gdCamera" {
    import { m4mGO } from "Tools/engineParallel/spGameObject";
    import { ISpCamera, spComponentType, ISpGameObject } from "Tools/engineParallel/spInterface";
    /** 简配 camera 组件  */
    export class gdCamera implements ISpCamera {
        get fov(): number;
        set fov(v: number);
        get far(): number;
        set far(v: number);
        get near(): number;
        set near(v: number);
        rawHandle: m4m.framework.camera;
        compType: spComponentType;
        gameObject: ISpGameObject;
        id: string;
        constructor(rawCam: m4m.framework.camera, go: m4mGO);
        dispose(): void;
    }
}
declare module "Tools/engineParallel/wxEngine/wxCamera" {
    import { wxEngineGO } from "Tools/engineParallel/spGameObject";
    import { ISpCamera, spComponentType } from "Tools/engineParallel/spInterface";
    import engine from "engine";
    /** 简配 camera 组件  */
    export class wxCamera implements ISpCamera {
        get fov(): number;
        set fov(v: number);
        get far(): number;
        set far(v: number);
        get near(): number;
        set near(v: number);
        rawHandle: engine.Camera;
        compType: spComponentType;
        gameObject: wxEngineGO;
        id: string;
        constructor(raw: engine.Camera, go: wxEngineGO);
        private isWxCamera;
        dispose(): void;
    }
}
declare module "Tools/engineParallel/m4m/gdMaterialcacher" {
    import { IDispose } from "Tools/engineParallel/spInterface";
    type IMats = {
        materials: m4m.framework.material[];
    };
    /**
     * 材质处理器
     */
    export class gdMaterialcacher implements IDispose {
        constructor(rawHandle: IMats);
        private rawHandle;
        private cacheIdCount;
        private cacheMatsMap;
        private _lastRestoreID;
        cacheCurrMaterial(globalMatKey?: string): number;
        cachedCount(): number;
        restoreMaterial(cacheID: number): void;
        getLastRestoreID(): number;
        dispose(): void;
    }
}
declare module "Tools/engineParallel/m4m/gdMeshRenderer" {
    import { m4mGO } from "Tools/engineParallel/spGameObject";
    import { spComponentType, ISpMeshRenderer } from "Tools/engineParallel/spInterface";
    /** 简配 camera 组件  */
    export class gdMeshRenderer implements ISpMeshRenderer {
        private static get assetMgr();
        get enableGpuInstancing(): boolean;
        set enableGpuInstancing(v: boolean);
        get queue(): number;
        set queue(v: number);
        id: string;
        rawHandle: m4m.framework.meshRenderer;
        compType: spComponentType;
        gameObject: m4mGO;
        constructor(rawCam: m4m.framework.meshRenderer, go: m4mGO);
        private static _assetMgr;
        private matHandle;
        getLastRestoreID(): number;
        getMaterialsCount(): number;
        cacheCurrMaterial(globalMatKey?: string): number;
        cachedCount(): number;
        restoreMaterial(cacheID: number): void;
        getShaderName(matIdx?: number): string;
        getMaterialID(idx?: number): number;
        setShader(shaderSrc: string, idx?: number): Promise<void>;
        setMaterialFloat(key: string, value: number, idx?: number): void;
        setMaterialVector4(key: string, value: m4m.math.vector4, idx?: number): void;
        setTexture(key: string, valueTex: m4m.framework.texture, matIdx?: number): void;
        dispose(): void;
    }
}
declare module "Tools/engineParallel/m4m/gdSkinnedMeshRenderer" {
    import { m4mGO } from "Tools/engineParallel/spGameObject";
    import { ISpSkinnedMeshRenderer, spComponentType } from "Tools/engineParallel/spInterface";
    export class gdSkinnedMeshRenderer implements ISpSkinnedMeshRenderer {
        private static get assetMgr();
        readonly isSkinnedMeshRenderer: boolean;
        id: string;
        rawHandle: m4m.framework.skinnedMeshRenderer;
        compType: spComponentType;
        gameObject: m4mGO;
        constructor(raw: m4m.framework.skinnedMeshRenderer, go: m4mGO);
        private static _assetMgr;
        private matHandle;
        getLastRestoreID(): number;
        getMaterialID(matIdx?: number): number;
        getMaterialsCount(): number;
        setMaterialFloat(key: string, value: number, matIdx?: number): void;
        setMaterialVector4(key: string, value: m4m.math.vector4, matIdx?: number): void;
        setTexture(key: string, valueTex: m4m.framework.texture, matIdx?: number): void;
        getShaderName(matIdx?: number): string;
        setShader(shaderSrc: string, idx?: number): Promise<void>;
        cacheCurrMaterial(globalMatKey?: string): number;
        restoreMaterial(cacheID: number): void;
        cachedCount(): number;
        dispose(): void;
    }
}
declare module "Tools/engineParallel/m4m/gdParticleSystem" {
    import { m4mGO } from "Tools/engineParallel/spGameObject";
    import { ISpParticleSystem as ISpParticleSystem, spComponentType } from "Tools/engineParallel/spInterface";
    /** 简配 camera 组件  */
    export class gdParticleSystem implements ISpParticleSystem {
        id: string;
        rawHandle: m4m.framework.f14EffectSystem;
        gameObject: m4mGO;
        compType: spComponentType;
        constructor(raw: m4m.framework.f14EffectSystem, go: m4mGO);
        setColor(_color: m4m.math.color): void;
        getLastRestoreID(): number;
        get beloop(): boolean;
        set beloop(v: boolean);
        stop(): void;
        play(onPlayEnd?: () => void): void;
        getMaterialID(matIdx?: number): number;
        getMaterialsCount(): number;
        setMaterialFloat(key: string, value: number, matIdx?: number): void;
        setMaterialVector4(key: string, value: m4m.math.vector4, matIdx?: number): void;
        setTexture(key: string, valueTex: any, matIdx?: number): void;
        getShaderName(matIdx?: number): string;
        setShader(shaderSrc: string, matIdx?: number): any;
        cachedCount(): number;
        cacheCurrMaterial(globalMatKey?: string): number;
        restoreMaterial(cacheID: number): void;
        dispose(): void;
    }
}
declare module "Tools/engineParallel/m4m/gdTrailRenderer" {
    import { m4mGO } from "Tools/engineParallel/spGameObject";
    import { spComponentType, ISpTrailRender } from "Tools/engineParallel/spInterface";
    /** 简配 TrailRenderer 组件  */
    export class gdTrailRenderer implements ISpTrailRender {
        id: string;
        rawHandle: m4m.framework.trailRender;
        gameObject: m4mGO;
        compType: spComponentType;
        constructor(raw: m4m.framework.trailRender, go: m4mGO);
        getLastRestoreID(): number;
        setSpeed(speed: number): void;
        setWidth(width: number): void;
        get color(): m4m.math.color;
        set color(v: m4m.math.color);
        stop(): void;
        play(): void;
        getMaterialID(matIdx?: number): number;
        getMaterialsCount(): number;
        setMaterialFloat(key: string, value: number, matIdx?: number): void;
        setMaterialVector4(key: string, value: m4m.math.vector4, matIdx?: number): void;
        setTexture(key: string, valueTex: any, matIdx?: number): void;
        getShaderName(matIdx?: number): string;
        setShader(shaderSrc: string, matIdx?: number): any;
        cachedCount(): number;
        cacheCurrMaterial(globalMatKey?: string): number;
        restoreMaterial(cacheID: number): void;
        dispose(): void;
    }
}
declare module "Tools/engineParallel/m4m/gdAnimPlayer" {
    import { m4mGO } from "Tools/engineParallel/spGameObject";
    import { spComponentType, ISpAnimPlayer } from "Tools/engineParallel/spInterface";
    /** m4m录制帧蒙皮动画组件 ISpAnimPlayer 封装  */
    export class gdAnimPlayer implements ISpAnimPlayer {
        id: string;
        rawHandle: m4m.framework.aniplayer;
        gameObject: m4mGO;
        compType: spComponentType;
        constructor(raw: m4m.framework.aniplayer, go: m4mGO);
        stop(): void;
        playAnimByName(clipName: string, onPlayend?: () => any, blendTime?: number, endframe?: number, speed?: number, beRevert?: boolean): void;
        dispose(): void;
    }
}
declare module "Data/ReuseArray" {
    /**
     * 复用数组 ，用于频繁重复创建数组容器的场景(减少GC消耗)
     */
    export class ReuseArray<T> {
        private arr;
        private buoy;
        /** 获取 Array 对象 */
        getArray(): T[];
        /** 获取当前长度 */
        get length(): number;
        set length(val: number);
        push(val: T): void;
        /** 获取指定索引的值 */
        get(index: number): T;
        /** 数组所有值置为null  */
        clear(): void;
    }
}
declare module "Time/TimeUtil" {
    export class TimeUtil {
        static init(app: m4m.framework.application, FrameRate?: number): void;
        /** 游戏启动时的世间  (单位 毫秒)*/
        static get appStartupTime(): number;
        /** 从游戏启动到现在的真实时间 (单位 毫秒)*/
        static get realtimeSinceStartup(): number;
        /** 当前间隔时间 (单位 毫秒)*/
        static get stepGapTime(): number;
        /**
         * 获取当前时间 (单位 毫秒)
         */
        static get time(): number;
        /**
         * 完成最后一帧所用的时间（单位 秒）
         */
        static get deltaTime(): number;
        /**
         * 物理和其他固定帧速率更新的时间间隔（单位 秒）。
         */
        static get fixedDeltaTime(): number;
        /** 全局时间缩放 */
        static get timeScale(): number;
        static set timeScale(v: number);
        /** 时间缩放值的逆值 */
        static get inverseTimeScale(): number;
        /** 真实不受 时间缩放影响的 DeltaTime */
        static get realDeltaTime(): number;
        private static update;
        static _appStartupTime: number;
        private static timeArr;
        private static fTimeArr;
        private static timeSection;
        private static ftimeSection;
        private static app;
        private static _lastStepTime;
        private static lastFixedT;
        private static _fixedDeltaTime;
        private static _timeScale;
        private static _inverseTimeScale;
        private static _realDeltaTime;
        private static lastTime;
    }
}
declare module "Tools/engineParallel/AnimTimeEventHandle" {
    import { cMap } from "Data/Map";
    import { IDispose } from "Tools/engineParallel/spInterface";
    type animTimeData = {
        [time: number]: {
            actFunName: string;
            value: any;
        };
    };
    /**
     * 动画时间轴事件控制器
     */
    export class AnimTimeEventHandle {
        clipTimeEventDic: cMap<animTimeData>;
        updateDic: cMap<AnimTimeEventNode>;
        /** 注册update */
        regUpdata(p: AnimTimeEventNode, nodeID: string): boolean;
        /** 注销update */
        unregUpdate(p: AnimTimeEventNode, nodeID: string): void;
    }
    export class AnimTimeEventNode implements IDispose {
        constructor(playerObj: any);
        private _currHasTimeEvent;
        private _lastTimeEvnetPoint;
        private _timeEventActObj;
        private _playerObj;
        dispose(): void;
        get playerObj(): Object;
        /**
        * 注册 动画时间轴事件 回调响应对象
        * @param eventActObj      动画时间事件 回调触发对象
        */
        regTimeEventCallbackObj(eventActObj: object): void;
        /**
         * 设置 动画时间轴事件 参数
         * @param simpleClipName    动画片段名
         * @param timePoint         事件时间点
         * @param _actFunName       行为方法名
         * @param val               事件传递的参数
         */
        setTimeEvent(handel: AnimTimeEventHandle, clipName: string, timePoint: number, _actFunName: string, val: string): void;
        /**
         * 检查clip是否需要注册
         * @param handel
         * @param clipName  片段名
         * @param nodeID    动画播放器节点ID
         */
        ckRegUpdate(handel: AnimTimeEventHandle, clipName: string, nodeID: string): boolean;
        /**
         * 检查 时间轴事件update 检测
         * @param handel
         * @param clipName
         * @param currClipTime 当前片段的播放时间
         * @param currClipTotalTime 当前片段的总播放时长
         * @returns
         */
        ckTimeEventUpdate(handel: AnimTimeEventHandle, clipName: string, currClipTime: number, currClipTotalTime: number): void;
        /** 检查 时间轴事件通过范围 */
        private ckTimeEventRange;
    }
}
declare module "Tools/engineParallel/wxEngine/wxAnimPlayer" {
    import engine from "engine";
    import { wxEngineGO } from "Tools/engineParallel/spGameObject";
    import { IReset, ISpAnimPlayer, ISpAnimPlayerHandle, spComponentType } from "Tools/engineParallel/spInterface";
    export class wxAnimPlayer implements ISpAnimPlayerHandle, ISpAnimPlayer, IReset {
        static update(dt: number): void;
        private static TimeEventUpdate;
        private static chcekPlayend;
        private static calcNormalizedTime;
        id: string;
        rawHandle: engine.Animator;
        gameObject: wxEngineGO;
        compType: spComponentType;
        constructor(raw: engine.Animator, go: wxEngineGO);
        private static waitePlayEndMap;
        private static removeArr;
        private static animTimeEventHD;
        private animTimeEventNode;
        private _isPlaying;
        private stateInfoMap;
        private clipTimeLenMap;
        private currClipName;
        getCurrClipName(): string;
        stop(): void;
        playAnimByName(simpleClipName: string, onPlayend?: () => any, blendTime?: number, endframe?: number, speed?: number, beRevert?: boolean): void;
        currClipTotalTime(): number;
        getClipTotalTime(simpleClipName: string): number;
        setCurrClipNormalizedTime(normalLizedTime: number): void;
        getCurrClipNormalizedTime(): number;
        isPlay(): boolean;
        hasClip(simpleClipName: string): boolean;
        dispose(): void;
        reset(): void;
        regTimeEventCallbackObj(eventActObj: object): void;
        setTimeEvent(simpleClipName: string, timePoint: number, _actFunName: string, val: string): void;
        /**
         * 获取 当前在播放动画到的时间点
         */
        private getCurrClipTime;
        private addPlayEndFun;
        private ensureStateInit;
        private tryGetState;
        private _playAnimByName;
        private clearPlayEndFuns;
    }
}
declare module "Tools/engineParallel/wxEngine/wxMaterialcacher" {
    import engine from "engine";
    import { IDispose } from "Tools/engineParallel/spInterface";
    type IMats = {
        materialCount: number;
        getSharedMaterialAtIndex(idx: number): engine.Material;
        setMaterialAtIndex(mat: engine.Material, idx: number): void;
    };
    /**
     * 材质处理器
     */
    export class wxMaterialcacher implements IDispose {
        private static get shaderName2IDMap();
        private static get wxShaderNameMap();
        /**
         * 初始化
         * @param m4mShaderNames shader 名字
         * @param wxShaderPath  微信shader路径
         * @param addSuffixList wxShader ID 名需要增加 .shader 后缀的列表
         */
        static init(m4mShaderNames: string[], wxShaderPath: string, addSuffixList?: string[]): void;
        constructor(rawHandle: IMats);
        private static wxShaderPath;
        private static m4mShaderNames;
        private static addSuffixList;
        private static readonly addSuffixMap;
        private static _shaderName2IDMap;
        private static _shaderm4mName2WxNameMap;
        private static _wxShaderNameMap;
        private rawHandle;
        private cacheIdCount;
        private cacheMatsMap;
        private _lastRestoreID;
        getMaterialID(matIdx?: number): number;
        setMaterialFloat(key: string, value: number, matIdx?: number): void;
        setMaterialVector4(key: string, value: m4m.math.vector4, matIdx?: number): void;
        setTexture(key: string, valueTex: engine.Texture2D, matIdx?: number): void;
        getShaderName(matIdx?: number): string;
        setShader(shaderID: string, matIdx?: number): Promise<void>;
        cacheCurrMaterial(globalMatKey?: string): number;
        cachedCount(): number;
        restoreMaterial(cacheID: number): void;
        getLastRestoreID(): number;
        dispose(): void;
    }
}
declare module "Tools/engineParallel/wxEngine/wxMeshRenderer" {
    import engine from "engine";
    import { wxEngineGO } from "Tools/engineParallel/spGameObject";
    import { ISpMeshRenderer, spComponentType } from "Tools/engineParallel/spInterface";
    /** 简配 gdMeshRenderer 组件  */
    export class wxMeshRenderer implements ISpMeshRenderer {
        id: string;
        rawHandle: engine.MeshRenderer;
        gameObject: wxEngineGO;
        compType: spComponentType;
        queue: number;
        enableGpuInstancing: boolean;
        constructor(raw: engine.MeshRenderer, go: wxEngineGO);
        private matHandle;
        getLastRestoreID(): number;
        getMaterialsCount(): number;
        getMaterialID(matIdx?: number): number;
        setMaterialFloat(key: string, value: number, matIdx?: number): void;
        setMaterialVector4(key: string, value: m4m.math.vector4, matIdx?: number): void;
        setTexture(key: string, valueTex: engine.Texture2D, matIdx?: number): void;
        getShaderName(matIdx?: number): string;
        setShader(shaderID: string, matIdx?: number): Promise<void>;
        cachedCount(): number;
        cacheCurrMaterial(globalMatKey?: string): number;
        restoreMaterial(cacheID: number): void;
        dispose(): void;
    }
}
declare module "Tools/engineParallel/wxEngine/wxSkinnedMeshRenderer" {
    import { wxMeshRenderer } from "Tools/engineParallel/wxEngine/wxMeshRenderer";
    export class wxSkinnedMeshRenderer extends wxMeshRenderer {
        readonly isSkinnedMeshRenderer: boolean;
    }
}
declare module "Tools/engineParallel/wxEngine/wxParticleSystemt" {
    import engine from "engine";
    import { wxEngineGO } from "Tools/engineParallel/spGameObject";
    import { ISpParticleSystem as ISpParticleSystem, spComponentType } from "Tools/engineParallel/spInterface";
    /** 简配 camera 组件  */
    export class wxParticleSystemt implements ISpParticleSystem {
        id: string;
        rawHandle: engine.Particle;
        gameObject: wxEngineGO;
        compType: spComponentType;
        constructor(raw: engine.Particle, go: wxEngineGO);
        setColor(_color: m4m.math.color): void;
        getLastRestoreID(): number;
        get beloop(): boolean;
        set beloop(v: boolean);
        stop(): void;
        play(onPlayEnd?: () => void): void;
        getMaterialID(matIdx?: number): number;
        getMaterialsCount(): number;
        setMaterialFloat(key: string, value: number, matIdx?: number): void;
        setMaterialVector4(key: string, value: m4m.math.vector4, matIdx?: number): void;
        setTexture(key: string, valueTex: any, matIdx?: number): void;
        getShaderName(matIdx?: number): string;
        setShader(shaderSrc: string, matIdx?: number): any;
        cachedCount(): number;
        cacheCurrMaterial(globalMatKey?: string): number;
        restoreMaterial(cacheID: number): void;
        dispose(): void;
    }
}
declare module "Tools/engineParallel/wxEngine/wxTrailRenderer" {
    import engine from "engine";
    import { wxEngineGO } from "Tools/engineParallel/spGameObject";
    import { ISpGameObject, ISpTrailRender, spComponentType } from "Tools/engineParallel/spInterface";
    /** 简配 gdMeshRenderer 组件  */
    export class wxTrailRenderer implements ISpTrailRender {
        color: m4m.math.color;
        id: string;
        rawHandle: engine.TrailRenderer;
        gameObject: ISpGameObject;
        compType: spComponentType;
        constructor(raw: engine.TrailRenderer, go: wxEngineGO);
        private matHandle;
        getLastRestoreID(): number;
        play(): void;
        stop(): void;
        setSpeed(speed: number): void;
        setWidth(Width: number): void;
        getMaterialID(matIdx?: number): number;
        getMaterialsCount(): number;
        setMaterialFloat(key: string, value: number, matIdx?: number): void;
        setMaterialVector4(key: string, value: m4m.math.vector4, matIdx?: number): void;
        setTexture(key: string, valueTex: any, matIdx?: number): void;
        getShaderName(matIdx?: number): string;
        setShader(shaderSrc: string, matIdx?: number): Promise<void>;
        cachedCount(): number;
        cacheCurrMaterial(globalMatKey?: string): number;
        restoreMaterial(cacheID: number): void;
        dispose(): void;
    }
}
declare module "Tools/gameMathUtil" {
    /**
     * 游戏 辅助工具类
     */
    export class gameMathUtil {
        static G: number;
        /** 计算墙面反射  , 返回 新的角度*/
        static calcReboundWall(bulletAngle: number, wallBody: any, hitPoint: m4m.math.Ivec2): number;
        /**
         * 计算角度 通过 二维向量
         * @param x 向量x
         * @param y 向量y
         * @param isRadian angle 是否是弧度
         */
        static calcAngleByVec(x: any, y: any, isRadian?: boolean): number;
        /**
         * 计算二维向量 通过 指定角度
         * @param angle 向量x
         * @param out 向量y
         * @param isRadian angle 是否是弧度
         */
        static calcVec2ByAngle(angle: number, out: m4m.math.vector2, isRadian?: boolean): void;
        /**
         * Get an angle into -180 to +180 range
         */
        static FixAnglePlusMinusDegrees(ang: number): number;
        /**
         * Get an angle into 0-360 range
         */
        static FixAngleDegrees(ang: number): number;
        /** As above, in radians */
        static FixAngleRadians(ang: number): number;
        /** As above, in radians */
        static FixAnglePlusMinusRadians(ang: number): number;
        static MoveTowardsAngle(current: number, target: number, maxDelta: number): number;
        static MoveToward(current: number, target: number, maxDelta: number): number;
        static DeltaAngle(current: number, target: number): number;
        static Repeat(t: number, length: number): number;
        static ToAngleDegreesXY(v: m4m.math.vector3): number;
        /** 角度 angle sin */
        static sin(angle: number): number;
        /** 角度 angle cos*/
        static cos(angle: number): number;
        /**
         * 获取指定向量的角度值
         * @param x 向量x值
         * @param y 向量y值
         * @param isRadian 是否是弧度制
         */
        static getAngle(x: number, y: number, isRadian?: boolean): number;
        /**
         * Remap a value from one range (in0 -> in1, CLAMPED) to a different range (out0 -> out1).
         * Use this to interpolate between 2 values (out0, out1) based on where some other number (value) sits
         * between two other values (in0, in1).
         */
        static Remap(value: number, in0: number, in1: number, out0: number, out1: number): number;
        /** 获取随机数 ， isInteger 为true 是返回 整数 (注：rmax 值是取不到的 ) */
        static RandRange(rmin: number, rmax: number, isInteger?: boolean): number;
        static Rand01(): number;
        static RandMinus1To1(): number;
        static RandAngleDegrees(): number;
        static RandAngleRadians(): number;
        static RandBool(): boolean;
        /**
         * 噪音缩放系数
         * @param noiseRange 波动噪音范围（不能为负数数）
         */
        static noiseScale(noiseRange: number): number;
        /** 单位圆内随机 */
        static RandInsideUnitCircle(out: m4m.math.vector3): void;
        /** 单位球内随机 */
        static RandInsideUnitSphere(out: m4m.math.vector3): void;
        /** 单位圆上的随机 */
        static RandOnUnitCircle(out: m4m.math.vector3): void;
        /** 单位正方形内的随机 */
        static RandInUnitSquare(out: m4m.math.vector3): void;
        /** 单位正方形上的随机 */
        static RandOnUnitSquare(out: m4m.math.vector3): void;
        /** 单位球面上随机 */
        static RandOnUnitSphere(out: m4m.math.vector3): void;
        static InverseLerp(a: number, b: number, c: number): number;
        static DotFacingPoint(objectPos: m4m.math.vector3, objectVel: m4m.math.vector3, targetPos: m4m.math.vector3): number;
        static vec3DisSqr(a: m4m.math.vector3, b: m4m.math.vector3): number;
        static vec2DisSqr(a: m4m.math.Ivec2, b: m4m.math.Ivec2): number;
        static vec2SqrLength(src: m4m.math.Ivec2): number;
        static vec3ClampMagnitude(src: m4m.math.vector3, maxLength: number, outV3: m4m.math.vector3): void;
        /** Ivec2 接口克隆 */
        static Ivec2Clone(src: m4m.math.Ivec2, out: m4m.math.Ivec2): void;
        /** Ivec3 接口克隆 */
        static Ivec3Clone(src: m4m.math.Ivec3, out: m4m.math.Ivec3): void;
        /** Iquat 接口克隆 */
        static IquatClone(src: m4m.math.Iquat, out: m4m.math.Iquat): void;
        /**
         * 将transform 的世界方向向量 ， 转换到 本地 方向向量
         * @param targetTran transform对象
         * @param srcDir 世界方向向量
         * @param outDir 本地方向向量
         */
        static InverseTransformDirection(targetTran: m4m.framework.transform, srcDir: m4m.math.vector3, outDir: m4m.math.vector3): void;
        static GetInterceptDirectionXY(from: m4m.math.vector3, speed: number, destPos: m4m.math.vector3, destVel: m4m.math.vector3, outV3: m4m.math.vector3): void;
        static GetSimpleSplinePoint(p0: m4m.math.vector3, p1: m4m.math.vector3, p2: m4m.math.vector3, t: number, outV3: m4m.math.vector3): void;
        static rotateByAxis(trans: m4m.framework.transform, axis: m4m.math.vector3, speed: number): void;
        static ScaleFromPerc(f: number): number;
        static ScaleFromPercClamped(f: number): number;
        /**
         * Rotates a rotation from towards to.
         * @param from
         * @param to
         * @param maxDegreesDelta
         * @param out result
         */
        static quatRotateTowards(from: m4m.math.quaternion, to: m4m.math.quaternion, maxDegreesDelta: number, out: m4m.math.quaternion): m4m.math.quaternion;
        /**
         * The dot product between two rotations.
         * @param a
         * @param b
         */
        static quatDot(a: m4m.math.quaternion, b: m4m.math.quaternion): number;
        /**
         * Returns the angle in degrees between two rotations a and b.
         * @param a
         * @param b
         */
        static quatAngle(a: m4m.math.quaternion, b: m4m.math.quaternion): number;
        static vec3Multiplier(_in: m4m.math.vector3, v: number, out: m4m.math.vector3): void;
        /**
        * 16进制颜色转10进制
        * @param str 16 进制rgb 颜色数据字符串（例如ffffff）
        * @param out
        */
        static color16To10(str: string, out: m4m.math.color | m4m.math.vector4): void;
        /** 16 进制转 rgb */
        static hexToRgb(hex: string): number[];
        /**
         * 计算数值队列的方差
         * @param nums 数值队列
         */
        static variance(nums: number[]): number;
        /**
         * 二分插入法
         * @param insertNum 要插入的数值
         * @param arr 被插入的数组
         */
        static insertSortWithBinarySearch(insertNum: number, arr: number[]): void;
        /** 缓动方法 IN => Out
         * p : 过程进度
         * MaxVal : 过程的最大值
         * mathIn : in 过程的 tween方法
         * mathOut : out 过程的 tween方法
        */
        static tweenInOut(p: number, MaxVal: number, methodIn: m4m.framework.tweenMethod, methodOut: m4m.framework.tweenMethod): number;
        /** 变换到角度系数 */
        static readonly toDeg = 57.29578;
        /** 变换到弧度系数 */
        static readonly toRadian = 0.0174532924;
        static readonly TwoPi: number;
        static readonly mDefaultMaxDampingScale = 0.125;
        private static readonly vector3Zero;
        private static readonly helpVec3;
        private static readonly helpVec3v1;
        private static readonly helpVec3v2;
        private static readonly helpVec3v3;
        private static readonly helpVec3v4;
        private static readonly helpQuat;
        private static readonly helpMtx;
        private static readonly helpMtx1;
        private static readonly helpMtx2;
        private static readonly helpMtx3;
    }
}
declare module "Tools/FrameMgr" {
    export class FrameMgr implements m4m.framework.IUserCode {
        private static funDic;
        private static removeDic;
        private static funList;
        private static removeList;
        static Add(callback: Function, thisObj: any): void;
        static Remove(callback: Function, thisObj: any): void;
        private idxs;
        onUpdate(delta: number): void;
        onStart(app: m4m.framework.application): void;
        isClosed(): boolean;
    }
}
declare module "Tools/engineParallel/m4m/gdKeyFrameAnimPlayer" {
    import { m4mGO } from "Tools/engineParallel/spGameObject";
    import { spComponentType, ISpAnimPlayer, ISpAnimPlayerHandle } from "Tools/engineParallel/spInterface";
    /** m4m 关键帧差值非蒙皮动画组件 ISpAnimPlayer 封装  */
    export class gdKeyFrameAnimPlayer implements ISpAnimPlayer, ISpAnimPlayerHandle {
        id: string;
        rawHandle: m4m.framework.keyFrameAniPlayer;
        gameObject: m4mGO;
        compType: spComponentType;
        constructor(raw: m4m.framework.keyFrameAniPlayer, go: m4mGO);
        private static readonly suffix;
        private static animTimeEventHD;
        private static hasSetUpdate;
        private animTimeEventNode;
        currClipTotalTime(): number;
        getCurrClipName(): string;
        getClipTotalTime(simpleClipName: string): number;
        setCurrClipNormalizedTime(normalLizedTime: number): number;
        getCurrClipNormalizedTime(): number;
        isPlay(): boolean;
        hasClip(clipName: string): boolean;
        regTimeEventCallbackObj(eventActObj: object): void;
        setTimeEvent(simpleClipName: string, timePoint: number, _actFunName: string, val: string): void;
        stop(): void;
        playAnimByName(clipName: string, onPlayend?: () => any, blendTime?: number, endframe?: number, speed?: number, beRevert?: boolean): void;
        dispose(): void;
        private static activeUpdate;
        private static update;
    }
}
declare module "Tools/engineParallel/spGameObject" {
    import { ISpGameObject, ISpTransform, spComponentType, ISpComponent, engineParallelType } from "Tools/engineParallel/spInterface";
    import engine from "engine";
    /**
     * m4m go
     */
    export class m4mGO implements ISpGameObject {
        get layer(): number;
        set layer(v: number);
        get visible(): boolean;
        set visible(v: boolean);
        get isStatic(): boolean;
        set isStatic(v: boolean);
        get tag(): string;
        set tag(v: string);
        get name(): string;
        set name(v: string);
        /** 是否是关键帧差值播放器 */
        isKeyFramePlayer: boolean;
        private static getRawCompStr;
        private static getCompID;
        private static getSpCompByType;
        transform: gdTransform;
        rawHandle: m4m.framework.gameObject;
        constructor(rawGo: m4m.framework.gameObject, trans?: gdTransform);
        private static readonly helpArr;
        private _rootNode;
        private componentsMap;
        getID(): number;
        getRootNode(): gdTransform;
        getFirstComponent(_type: spComponentType): ISpComponent;
        getComponents(_type: spComponentType): ISpComponent[];
        addComponent(_type: spComponentType): ISpComponent;
        dispose(): void;
        private makeComp;
    }
    /**
     * m4m transform
     */
    export class gdTransform implements ISpTransform {
        get name(): string;
        set name(v: string);
        get enableCulling(): boolean;
        set enableCulling(v: boolean);
        get needGpuInstancBatcher(): boolean;
        set needGpuInstancBatcher(v: boolean);
        private static packTran;
        get childrenCount(): number;
        get localRotate(): m4m.math.quaternion;
        set localRotate(v: m4m.math.quaternion);
        get localPosition(): m4m.math.vector3;
        set localPosition(v: m4m.math.vector3);
        get localScale(): m4m.math.vector3;
        set localScale(v: m4m.math.vector3);
        get localEulerAngles(): m4m.math.vector3;
        set localEulerAngles(v: m4m.math.vector3);
        static IDMap: {
            [transId: string]: gdTransform;
        };
        engineType: engineParallelType;
        gameObject: m4mGO;
        rawHandle: m4m.framework.transform;
        /**
         *
         * @param _rawhandle 原始 m4m transform 数据
         * @param _gameObject GO对象
         */
        constructor(_rawhandle?: m4m.framework.transform, _gameObject?: m4mGO);
        getChildByIdx(childIdx: number): gdTransform;
        addChild(node: gdTransform): void;
        removeAllChild(needDispose?: boolean): void;
        removeChild(node: gdTransform): void;
        find(name: string): gdTransform;
        getWorldRotate(): m4m.math.quaternion;
        setWorldRotate(rotate: m4m.math.quaternion): void;
        getWorldPosition(): m4m.math.vector3;
        setWorldPosition(pos: m4m.math.vector3): void;
        getWorldScale(): m4m.math.vector3;
        setWorldScale(scale: m4m.math.vector3): void;
        getWorldMatrix(): m4m.math.matrix;
        getLocalMatrix(): m4m.math.matrix;
        setWorldMatrix(mat: m4m.math.matrix): void;
        lookatPoint(point: m4m.math.vector3): void;
        getForwardInWorld(out: m4m.math.vector3): void;
        getRightInWorld(out: m4m.math.vector3): void;
        getUpInWorld(out: m4m.math.vector3): void;
        getParent(): gdTransform;
        getAabbMax(): m4m.math.vector3;
        getAabbMin(): m4m.math.vector3;
        getAabbCenter(): m4m.math.vector3;
        dispose(): void;
        private getWorldTranslate;
    }
    /**
     * wxEngine go
     */
    export class wxEngineGO implements ISpGameObject {
        get layer(): number;
        set layer(v: number);
        get visible(): boolean;
        set visible(v: boolean);
        get isStatic(): boolean;
        set isStatic(v: boolean);
        get tag(): string;
        set tag(v: string);
        get name(): string;
        set name(v: string);
        private static getRawCompType;
        private static getSpCompByType;
        transform: wxTransform;
        rawHandle: engine.Entity;
        constructor(rawGo: engine.Entity);
        private static readonly helpArr;
        private _rootNode;
        private componentsMap;
        getID(): number;
        getRootNode(): ISpTransform;
        getFirstComponent(_type: spComponentType): ISpComponent;
        getComponents(_type: spComponentType): ISpComponent[];
        addComponent(_type: spComponentType): ISpComponent;
        dispose(): void;
        private makeComp;
        /** 获取节点的第一个组件 */
        private getNodeFirstComponent;
        private getNodeComponentsInChildren;
    }
    export class wxTransform implements ISpTransform {
        private static packTran;
        get name(): string;
        set name(v: string);
        get enableCulling(): boolean;
        set enableCulling(v: boolean);
        get needGpuInstancBatcher(): boolean;
        set needGpuInstancBatcher(v: boolean);
        get localRotate(): any;
        set localRotate(v: any);
        get localPosition(): any;
        set localPosition(v: any);
        get localScale(): any;
        set localScale(v: any);
        get localEulerAngles(): any;
        set localEulerAngles(v: any);
        get childrenCount(): number;
        static IDMap: {
            [transId: string]: wxTransform;
        };
        rawHandle: engine.Transform3D;
        gameObject: wxEngineGO;
        engineType: engineParallelType;
        constructor(_rawhandle?: any, _gameObject?: wxEngineGO);
        private static readonly helpMtx;
        private static readonly helpMtx1;
        private static readonly helpMtxWx;
        private static readonly helpMtxWx1;
        private static readonly helpV3;
        private static readonly helpV3v1;
        private static readonly helpQuat;
        private static readonly helpQuat1;
        private static readonly helpQuatWx;
        private static readonly helpQuatWx1;
        private static readonly helpV3Wx;
        private static readonly helpV3Wx1;
        private static readonly helpUp;
        private static readonly helpRight;
        private static readonly helpFoward;
        private static readonly cacheTrans;
        private static count;
        private _helpDataMap;
        private readonly _helpPos;
        private readonly _helpScale;
        private readonly _helpEuler;
        private readonly _helpWRotate;
        private readonly _helpWPos;
        private readonly _helpWScale;
        private readonly _helpWorldMatrix;
        private readonly _helpLocalMatrix;
        private _aabbMax;
        private _aabbMin;
        private _aabbCenter;
        getChildByIdx(childIdx: number): wxTransform;
        addChild(node: ISpTransform): void;
        /**
         * 删除所有child
         * @param needDispose 是否需要销毁
         */
        removeAllChild(needDispose?: boolean): void;
        removeChild(node: wxTransform): void;
        find(name: string): wxTransform;
        getWorldRotate(): m4m.math.quaternion;
        setWorldRotate(rotate: m4m.math.quaternion): void;
        getWorldPosition(): m4m.math.vector3;
        setWorldPosition(pos: m4m.math.vector3): void;
        getWorldScale(): m4m.math.vector3;
        setWorldScale(scale: m4m.math.vector3): void;
        getWorldMatrix(): m4m.math.matrix;
        getLocalMatrix(): m4m.math.matrix;
        setWorldMatrix(mat: m4m.math.matrix): void;
        getForwardInWorld(out: m4m.math.vector3): void;
        getRightInWorld(out: m4m.math.vector3): void;
        getUpInWorld(out: m4m.math.vector3): void;
        lookatPoint(point: m4m.math.vector3): void;
        getParent(): wxTransform;
        getAabbMax(): m4m.math.vector3;
        getAabbMin(): m4m.math.vector3;
        getAabbCenter(): m4m.math.vector3;
        dispose(): void;
        private getData;
        /**
         * 查找第一个对象，通过节点树以下
         * @param rootNode 节点对象
         * @param nodeName
         */
        private findNodeFirst;
        private getWorldTranslate;
    }
}
declare module "Tools/engineParallel/m4m/gdCustomCompAdapter" {
    import { ISpCustomCompAdapter, ISpCustomComp } from "Tools/engineParallel/spInterface";
    /**
     * 自定义组件 连接
     */
    export class gdCustomCompAdapter extends m4m.framework.behaviour implements ISpCustomCompAdapter {
        private spCustomComp;
        private _enabled;
        getComp(): ISpCustomComp;
        setEnabled(enabled: boolean): void;
        getEnabled(): boolean;
        addCompToGO(_customComp: ISpCustomComp): void;
        start(): void;
        /** 初始化使用 在start 之后 */
        onPlay(): void;
        /** 每帧调用一次 */
        update(delta: number): void;
        /** 组件被清理时调用 */
        remove(): void;
    }
}
declare module "Tools/engineParallel/wxEngine/wxCustomCompAdapter" {
    import { ISpCustomCompAdapter, ISpCustomComp } from "Tools/engineParallel/spInterface";
    /**
     * 自定义组件 连接
     */
    export class wxCustomCompAdapter extends engine.Script implements ISpCustomCompAdapter {
        private spCustomComp;
        private _enabled;
        getComp(): ISpCustomComp;
        /** 设置激活状态 */
        setEnabled(enabled: boolean): void;
        /** 获取激活状态 */
        getEnabled(): boolean;
        addCompToGO(_customComp: ISpCustomComp): void;
        onAwake(): void;
        /** 初始化使用 在start 之后 */
        onStart(): void;
        /** 每帧调用一次 */
        onUpdate(delta: number): void;
        /** 组件被清理时调用 */
        onDestroy(): void;
    }
}
declare module "Tools/LateUpdateMgr" {
    export class LateUpdateMgr {
        static Add(callback: Function, thisObj: any): void;
        static Remove(callback: Function, thisObj: any): void;
        static onUpdate(delta: number): void;
        static idxs: any[];
        private static funDic;
        private static removeDic;
        private static funList;
        private static removeList;
    }
}
declare module "animation/animLoadPlayer" {
    import { ISpAnimPlayerHandle } from "Tools/engineParallel/spInterface";
    /** 动画加载播放控制组件 */
    export class AnimLoadPlayer implements ISpAnimPlayerHandle {
        /** 清理字典容器中指定url的数据  */
        static clearDic(url: string): void;
        /** 已经加载所有 动画片段 */
        get isLoadedAll(): boolean;
        /** 通过aniplayer 组件获取 clipnames  */
        static getClipNames(aplayer: m4m.framework.aniplayer, outClipNames: string[], cutString?: string): void;
        private static activeUpdate;
        private static update;
        static extendCreatClipOption: {
            matchStr: string;
            attachSuffix: string;
            creatFun(url: string): Promise<m4m.framework.animationClip>;
        };
        aplayer: m4m.framework.aniplayer;
        onLoadedClips: (ap: AnimLoadPlayer) => any;
        /**
         * 动画加载播放控制组件
         * @param prefabName 预设体资源名
         * @param clips 需要加载的动画片段列表
         * @param aplayer 引擎 aniplayer 组件实例
         * @param loadPath 加载文件路径
         */
        constructor(prefabName: string, clips: string[], aplayer: m4m.framework.aniplayer, loadPath?: string, outUrls?: string[]);
        private static readonly suffix;
        private static animTimeEventHD;
        private static animClipDic;
        private static clipLoadingDic;
        private static clipWaitLoadDic;
        private static hasSetUpdate;
        private animTimeEventNode;
        private lastWaitIdx;
        private lastwaitOnPlayend;
        private lastBlendTime;
        private lastEndframe;
        private lastSpeed;
        private lastbeRevert;
        private prefabName;
        private clips;
        private clipNameMap;
        private loadLen;
        private loadingCount;
        private _isLoadedAll;
        getCurrClipName(): string;
        currClipTotalTime(): number;
        getClipTotalTime(simpleClipName: string): number;
        getCurrClipNormalizedTime(): number;
        setCurrClipNormalizedTime(normalLizedTime: number): void;
        isPlay(): boolean;
        stop(): void;
        /** 播放动画通过 传入的clip索引 */
        playAnimByIdx(idx: number, onPlayend?: () => any, blendTime?: number, endframe?: number, speed?: number, beRevert?: boolean): void;
        /** 播放动画通过 clip 名 */
        playAnimByName(simpleClipName: string, onPlayend?: () => any, blendTime?: number, endframe?: number, speed?: number, beRevert?: boolean): void;
        /** 停止播放 的动画 */
        stopAnim(): void;
        /** 是否有 clipName 动画*/
        hasClip(simpleClipName: string): boolean;
        dispose(): void;
        regTimeEventCallbackObj(eventActObj: object): void;
        setTimeEvent(simpleClipName: string, timePoint: number, _actFunName: string, val: string): void;
        private getIsExtend;
        private loadAnims;
        private doLoad;
        private doWaitLoadFun;
        private onloadOne;
        /**
         * 获取 当前在播放动画到的时间点
         */
        private getCurrClipTime;
    }
}
declare module "Tools/engineParallel/parallelEngineTool" {
    import { ISpTransform, ISpCustomComp, ISpCamera, ISpAnimPlayer, ISpAnimPlayerHandle, engineParallelType, ISpMeshRenderer } from "Tools/engineParallel/spInterface";
    import engine from "engine";
    /**
     * 创建 一个原生transform 对象，通过引擎类型
     * @param eType 引擎类型
     */
    export function createRawTransform(eType: engineParallelType): m4m.framework.transform | engine.Transform3D;
    /**
     * 获取 SP transfrom
     * @param rawTran 原始 Trans对象
     * @param forceType 强制指定引擎类型
     */
    export function getSpTransform(rawTran: m4m.framework.transform | engine.Transform3D): ISpTransform;
    /**
     * 添加 自定义组件
     * @param _trans 节点对象
     * @param _customCompClass T 类对象
     */
    export function addSpCustomComp<T extends ISpCustomComp>(_trans: ISpTransform, _customCompClass: any): T;
    /**
     * 获取 自定义组件第一个
     * @param _trans 节点对象
     * @param _customCompClass T 类对象
     */
    export function getFirstSpCustomComp<T extends ISpCustomComp>(_trans: ISpTransform, _customCompClass: any): T;
    export function getSpAnimPlayerHandle(player: ISpAnimPlayer, prefabName?: string): ISpAnimPlayerHandle;
    /**
     * 多引擎并行接入处理工具类
     */
    export function wxEngineEnvSet(): void;
    export class spAPP {
        /** 获取webglcontext */
        static getWebglCtx(): WebGL2RenderingContext;
        /** 获取主相机 */
        static getMainCamera(): ISpCamera;
        /**
         * 是否已经有全局材质
         * @param matKey 材质标识Key
         */
        static hasGlobalMaterial(matKey: string): boolean;
        /**
         * 设置全局材质，通过制定的现有材质
         * @param matKey 材质标识Key
         * @param _renderer 渲染对象(meshRenderer)
         * @param matIdx 渲染对象中的材质队列中的索引（默认0）
         * @returns 是否成功
         */
        static setGlobalMaterial(matKey: string, _renderer: ISpMeshRenderer, matIdx?: number): boolean;
        /**
         * 获取 全局材质
         * @param matKey 材质指定key
         * @param forceCreate 为空 强制创建一个
         * @param etype 引擎类型 ， 默认指定 全局引擎状态
         */
        static getGlobalMaterial(matKey: string, forceCreate?: boolean, etype?: engineParallelType): any;
        /**
         * 设置无效
         * @param enable
         */
        static setEnableFog(enable: boolean): void;
        /** 性能引擎 类型 */
        static engineParallel: engineParallelType;
        /** 性能引擎同步相机 */
        static syncParallelEngineCamera: ISpCamera;
        /** 角色资源路径 */
        static rolePath: string;
        private static readonly m4mGlobalMats;
        private static readonly wxGlobalMats;
    }
}
declare module "Tools/engineParallel/m4m/gdPrefab" {
    import { ISpPrefab, ISpTransform } from "Tools/engineParallel/spInterface";
    export class gdPrefab implements ISpPrefab {
        rawHandle: m4m.framework.prefab;
        constructor(rawHandle: m4m.framework.prefab);
        getCloneTrans(): ISpTransform;
        getGUID(): number;
    }
}
declare module "Tools/engineParallel/wxEngine/wxPrefab" {
    import { ISpPrefab, ISpTransform } from "Tools/engineParallel/spInterface";
    export class wxPrefab implements ISpPrefab {
        rawHandle: any;
        constructor(rawHandle: any);
        getCloneTrans(): ISpTransform;
        getGUID(): number;
    }
}
declare module "Loader/otherPlan/PropertieType" {
    export enum PropertieType {
        typeString = 0,
        typeByte = 1,
        typeSByte = 2,
        typeInt16 = 3,
        typeUInt16 = 4,
        typeInt32 = 5,
        typeUInt32 = 6,
        typeInt64 = 7,
        typeUInt64 = 8,
        typeFloat = 9,
        typeLong = 10,
        typeDouble = 11,
        typeBool = 12,
        typeVector2 = 13,
        typeVector3 = 14,
        typeVector4 = 15,
        typeColor = 16,
        typeBounds = 17,
        typeQuaternion = 18,
        typeF14EffectSystem = 19,
        typeImageSetting = 20,
        typeMat = 21,
        typeGameObject = 22,
        typeMesh = 23,
        typeKeyFrameAnimtionClip = 24,
        typeLinerenderer = 25,
        typeParticleSystem = 26,
        typeBoxcollider = 27,
        typeAniplayer = 28,
        typeSkinnedMeshRenderer = 29,
        typeMeshRenderer = 30,
        typeMeshFilter = 31,
        typeMeshcollider = 32,
        typeAsbone = 33,
        typeF4skinnedMeshRenderer = 34,
        typeTPoseInfo = 35,
        typePoseBoneMatrix = 36,
        typeF14effCmop = 37,
        typeKeyFrameAniPlayer = 38,
        typeAnimationCurve1 = 39,
        typekey = 40,
        typeGradient = 41,
        typeAlphaKey = 42,
        typeColorKey = 43,
        typeParticleMainModule = 44,
        typeParticleEmissionModule = 45,
        typeParticleShapeModule = 46,
        typeParticleVelocityOverLifetimeModule = 47,
        typeParticleLimitVelocityOverLifetimeModule = 48,
        typeParticleInheritVelocityModule = 49,
        typeColorBySpeed = 50,
        typeSizeOverLifetime = 51,
        typeNoise = 52,
        typeTextureSheetAnimation = 53,
        typeMinMaxCurve = 54,
        typeMinMaxGradient = 55,
        typeBurst = 56,
        typePrefab = 57,
        typeNumber4 = 58,
        listString = 100,
        listByte = 101,
        listSByte = 102,
        listInt16 = 103,
        listUInt16 = 104,
        listInt32 = 105,
        listUInt32 = 106,
        listInt64 = 107,
        listUInt64 = 108,
        listFloat = 109,
        listLong = 110,
        listDouble = 111,
        listBool = 112,
        listVector2 = 113,
        listVector3 = 114,
        listVector4 = 115,
        listColor = 116,
        listBounds = 117,
        listQuaternion = 118,
        listF14EffectSystem = 119,
        listImageSetting = 120,
        listMat = 121,
        listGameObject = 122,
        listMesh = 123,
        listKeyFrameAnimtionClip = 124,
        listLinerenderer = 125,
        listParticleSystem = 126,
        listBoxcollider = 127,
        listAniplayer = 128,
        listSkinnedMeshRenderer = 129,
        listMeshRenderer = 130,
        listMeshFilter = 131,
        listMeshcollider = 132,
        listAsbone = 133,
        listF4skinnedMeshRenderer = 134,
        listTPoseInfo = 135,
        listPoseBoneMatrix = 136,
        listF14effCmop = 137,
        listKeyFrameAniPlayer = 138,
        listAnimationCurve1 = 139,
        listkey = 140,
        listGradient = 141,
        listAlphaKey = 142,
        listColorKey = 143,
        listParticleMainModule = 144,
        listParticleEmissionModule = 145,
        listParticleShapeModule = 146,
        listParticleVelocityOverLifetimeModule = 147,
        listParticleLimitVelocityOverLifetimeModule = 148,
        listParticleInheritVelocityModule = 149,
        listColorBySpeed = 150,
        listSizeOverLifetime = 151,
        listNoise = 152,
        listTextureSheetAnimation = 153,
        listMinMaxCurve = 154,
        listMinMaxGradient = 155,
        listBurst = 156,
        listPrefab = 157,
        listNumber4 = 158,
        arrayString = 200,
        arrayByte = 201,
        arraySByte = 202,
        arrayInt16 = 203,
        arrayUInt16 = 204,
        arrayInt32 = 205,
        arrayUInt32 = 206,
        arrayInt64 = 207,
        arrayUInt64 = 208,
        arrayFloat = 209,
        arrayLong = 210,
        arrayDouble = 211,
        arrayBool = 212,
        arrayVector2 = 213,
        arrayVector3 = 214,
        arrayVector4 = 215,
        arrayColor = 216,
        arrayBounds = 217,
        arrayQuaternion = 218,
        arrayF14EffectSystem = 219,
        arrayImageSetting = 220,
        arrayMat = 221,
        arrayGameObject = 222,
        arrayMesh = 223,
        arrayKeyFrameAnimtionClip = 224,
        arrayLinerenderer = 225,
        arrayParticleSystem = 226,
        arrayBoxcollider = 227,
        arrayAniplayer = 228,
        arraySkinnedMeshRenderer = 229,
        arrayMeshRenderer = 230,
        arrayMeshFilter = 231,
        arrayMeshcollider = 232,
        arrayAsbone = 233,
        arrayF4skinnedMeshRenderer = 234,
        arrayTPoseInfo = 235,
        arrayPoseBoneMatrix = 236,
        arrayF14effCmop = 237,
        arrayKeyFrameAniPlayer = 238,
        arrayAnimationCurve1 = 239,
        arraykey = 240,
        arrayGradient = 241,
        arrayAlphaKey = 242,
        arrayColorKey = 243,
        arrayParticleMainModule = 244,
        arrayParticleEmissionModule = 245,
        arrayParticleShapeModule = 246,
        arrayParticleVelocityOverLifetimeModule = 247,
        arrayParticleLimitVelocityOverLifetimeModule = 248,
        arrayParticleInheritVelocityModule = 249,
        arrayColorBySpeed = 250,
        arraySizeOverLifetime = 251,
        arrayNoise = 252,
        arrayTextureSheetAnimation = 253,
        arrayMinMaxCurve = 254,
        arrayMinMaxGradient = 255,
        arrayBurst = 256,
        arrayPrefab = 257,
        arrayNumber4 = 258,
        typeClass = 1000,
        listClass = 1100,
        arrayClass = 1200
    }
}
declare module "Loader/otherPlan/dataType/tPoseInfo" {
    export class tPoseInfo {
        static classType: typeof tPoseInfo;
        tranName: string;
        tposeq: m4m.math.quaternion;
        tposep: m4m.math.vector3;
    }
}
declare module "Loader/otherPlan/dataType/PoseBoneMatrix" {
    export class PoseBoneMatrix {
        static classType: typeof PoseBoneMatrix;
        r: m4m.math.quaternion;
        t: m4m.math.vector3;
    }
}
declare module "Loader/otherPlan/dataType/number4" {
    export class number4 {
        static classType: typeof number4;
        v0: number;
        v1: number;
        v2: number;
        v3: number;
    }
}
declare module "Loader/otherPlan/dataType/readEnums" {
    export enum nameEnum {
        Mesh = 1,
        Bounds = 2,
        subMeshInfo = 3,
        ImageSetting = 4,
        Mat = 5,
        mapUniInfo = 6,
        Prefab = 7,
        gameObjectInfo = 8,
        meshFilter = 9,
        meshRenderer = 10,
        fileInfo = 11,
        skinnedMeshRenderer = 12,
        meshcollider = 13,
        keyFrameAniPlayer = 14,
        f14EffectSystem = 15,
        layer = 16,
        Singlemeshdata = 17,
        frame = 18,
        f14effCmop = 19,
        att = 20,
        ParticleSystem = 21,
        ParticleMainModule = 22,
        MinMaxCurve = 23,
        AnimationCurve1 = 24,
        MinMaxGradient = 25,
        Gradient = 26,
        ParticleEmissionModule = 27,
        burst = 28,
        ParticleShapeModule = 29,
        ParticleVelocityOverLifetimeModule = 30,
        ParticleLimitVelocityOverLifetimeModule = 31,
        ParticleInheritVelocityModule = 32,
        ColorBySpeed = 33,
        alphaKey = 34,
        colorKey = 35,
        SizeOverLifetime = 36,
        key = 37,
        Noise = 38,
        TextureSheetAnimation = 39,
        particlesystem = 40,
        aniplayer = 41,
        Aniclip = 42,
        asbone = 43,
        spherecollider = 44,
        water = 45,
        godray = 46,
        boxcollider = 47
    }
    export enum prtEnum {
        Mesh$meshName = 1,
        Mesh$originVF = 2,
        Mesh$bounds = 3,
        Bounds$extents = 4,
        Bounds$center = 5,
        Mesh$posCount = 6,
        Mesh$trisindex = 7,
        Mesh$subMesh = 8,
        subMeshInfo$size = 9,
        Mesh$tmpVArr = 10,
        Mesh$minimum = 11,
        Mesh$maximum = 12,
        Mesh$fileName = 13,
        Mesh$length = 14,
        Mesh$name = 15,
        ImageSetting$imageName = 16,
        ImageSetting$filterMode = 17,
        ImageSetting$format = 18,
        ImageSetting$mipmap = 19,
        ImageSetting$wrap = 20,
        ImageSetting$premultiplyAlpha = 21,
        ImageSetting$fileName = 22,
        ImageSetting$length = 23,
        ImageSetting$name = 24,
        Mat$shader = 25,
        Mat$srcshader = 26,
        Mat$mapUniform = 27,
        mapUniInfo$type = 28,
        mapUniInfo$value = 29,
        Mat$fileName = 30,
        Mat$length = 31,
        Mat$name = 32,
        Prefab$tranName = 33,
        Prefab$localRotate = 34,
        Prefab$localScale = 35,
        Prefab$gameObject = 36,
        gameObjectInfo$tag = 37,
        gameObjectInfo$components = 38,
        meshFilter$mesh = 39,
        meshRenderer$materials = 40,
        meshRenderer$lightmapIndex = 41,
        Prefab$insid = 42,
        Prefab$fileName = 43,
        Prefab$length = 44,
        Prefab$name = 45,
        fileInfo$fileCount = 46,
        Prefab$children = 47,
        Prefab$localTranslate = 48,
        Mesh$vec10tpose = 49,
        skinnedMeshRenderer$materials = 50,
        skinnedMeshRenderer$center = 51,
        skinnedMeshRenderer$size = 52,
        skinnedMeshRenderer$mesh = 53,
        skinnedMeshRenderer$rootBone = 54,
        skinnedMeshRenderer$bones = 55,
        Mesh$guid = 56,
        Mesh$zip_length = 57,
        ImageSetting$guid = 58,
        ImageSetting$zip_length = 59,
        Mat$guid = 60,
        Mat$zip_length = 61,
        Prefab$guid = 62,
        Prefab$zip_length = 63,
        subMeshInfo$matIndex = 64,
        subMeshInfo$start = 65,
        gameObjectInfo$layer = 66,
        Mat$InstanceID = 67,
        f14EffectSystem$Name = 68,
        f14EffectSystem$lifeTime = 69,
        f14EffectSystem$beloop = 70,
        f14EffectSystem$layers = 71,
        layer$Name = 72,
        layer$type = 73,
        layer$singlemeshdata = 74,
        Singlemeshdata$mesh = 75,
        Singlemeshdata$material = 76,
        Singlemeshdata$position = 77,
        Singlemeshdata$scale = 78,
        Singlemeshdata$euler = 79,
        Singlemeshdata$color = 80,
        Singlemeshdata$tex_ST = 81,
        Singlemeshdata$uvType = 82,
        Singlemeshdata$bindAxis = 83,
        layer$frames = 84,
        frame$frameindex = 85,
        f14EffectSystem$fileName = 86,
        f14EffectSystem$length = 87,
        f14EffectSystem$name = 88,
        f14effCmop$f14eff = 89,
        frame$colorAtts = 90,
        att$name = 91,
        att$value = 92,
        frame$vec3Atts = 93,
        frame$vec4Atts = 94,
        ParticleSystem$main = 95,
        ParticleMainModule$duration = 96,
        ParticleMainModule$startDelay = 97,
        MinMaxCurve$constant = 98,
        MinMaxCurve$constantMax = 99,
        MinMaxCurve$curve = 100,
        MinMaxCurve$curveMax = 101,
        MinMaxCurve$curveMin = 102,
        ParticleMainModule$startLifetime = 103,
        ParticleMainModule$startSpeed = 104,
        ParticleMainModule$startSize = 105,
        ParticleMainModule$startSizeX = 106,
        ParticleMainModule$startSizeY = 107,
        ParticleMainModule$startSizeZ = 108,
        ParticleMainModule$gravityModifier = 109,
        ParticleMainModule$maxParticles = 110,
        ParticleMainModule$playOnAwake = 111,
        ParticleMainModule$scalingMode = 112,
        ParticleMainModule$simulationSpeed = 113,
        ParticleMainModule$startColor = 114,
        MinMaxGradient$color = 115,
        MinMaxGradient$colorMax = 116,
        MinMaxGradient$gradient = 117,
        MinMaxGradient$gradientMax = 118,
        MinMaxGradient$gradientMin = 119,
        ParticleMainModule$startRotation = 120,
        ParticleMainModule$startRotationX = 121,
        ParticleMainModule$startRotationY = 122,
        ParticleMainModule$startRotationZ = 123,
        ParticleSystem$emission = 124,
        ParticleEmissionModule$enabled = 125,
        ParticleEmissionModule$rateOverDistance = 126,
        ParticleEmissionModule$rateOverTime = 127,
        ParticleEmissionModule$bursts = 128,
        burst$cycleCount = 129,
        burst$maxCount = 130,
        burst$minCount = 131,
        burst$repeatInterval = 132,
        ParticleSystem$shape = 133,
        ParticleShapeModule$angle = 134,
        ParticleShapeModule$arc = 135,
        ParticleShapeModule$arcSpeed = 136,
        ParticleShapeModule$box = 137,
        ParticleShapeModule$length = 138,
        ParticleShapeModule$radius = 139,
        ParticleShapeModule$radiusSpeed = 140,
        ParticleSystem$velocityOverLifetime = 141,
        ParticleVelocityOverLifetimeModule$x = 142,
        ParticleVelocityOverLifetimeModule$y = 143,
        ParticleVelocityOverLifetimeModule$z = 144,
        ParticleSystem$limitVelocityOverLifetime = 145,
        ParticleLimitVelocityOverLifetimeModule$dampen = 146,
        ParticleLimitVelocityOverLifetimeModule$limit = 147,
        ParticleLimitVelocityOverLifetimeModule$limitX = 148,
        ParticleLimitVelocityOverLifetimeModule$limitY = 149,
        ParticleLimitVelocityOverLifetimeModule$limitZ = 150,
        ParticleSystem$inheritVelocity = 151,
        ParticleInheritVelocityModule$curve = 152,
        ParticleSystem$forceOverLifetime = 153,
        ParticleSystem$colorOverLifetime = 154,
        ColorBySpeed$color = 155,
        Gradient$alphaKeys = 156,
        alphaKey$alpha = 157,
        alphaKey$time = 158,
        Gradient$colorKeys = 159,
        colorKey$color = 160,
        colorKey$time = 161,
        ColorBySpeed$enabled = 162,
        ParticleSystem$colorBySpeed = 163,
        ParticleSystem$sizeOverLifetime = 164,
        SizeOverLifetime$enabled = 165,
        SizeOverLifetime$size = 166,
        AnimationCurve1$postWrapMode = 167,
        AnimationCurve1$preWrapMode = 168,
        AnimationCurve1$keys = 169,
        key$inTangent = 170,
        key$outTangent = 171,
        key$time = 172,
        key$value = 173,
        MinMaxCurve$curveMultiplier = 174,
        MinMaxCurve$mode = 175,
        SizeOverLifetime$x = 176,
        SizeOverLifetime$y = 177,
        SizeOverLifetime$z = 178,
        ParticleSystem$sizeBySpeed = 179,
        ParticleSystem$rotationOverLifetime = 180,
        ParticleSystem$rotationBySpeed = 181,
        ParticleSystem$noise = 182,
        ParticleSystem$textureSheetAnimation = 183,
        TextureSheetAnimation$cycleCount = 184,
        TextureSheetAnimation$frameOverTime = 185,
        TextureSheetAnimation$numTilesX = 186,
        TextureSheetAnimation$numTilesY = 187,
        TextureSheetAnimation$startFrame = 188,
        TextureSheetAnimation$useRandomRow = 189,
        TextureSheetAnimation$uvChannelMask = 190,
        ParticleSystem$fileName = 191,
        ParticleSystem$length = 192,
        ParticleSystem$guid = 193,
        ParticleSystem$zip_length = 194,
        ParticleSystem$name = 195,
        ParticleShapeModule$shapeType = 196,
        particlesystem$particleSystemData = 197,
        particlesystem$material = 198,
        Singlemeshdata$beBillboard = 199,
        ParticleMainModule$loop = 200,
        MinMaxCurve$constantMin = 201,
        ParticleShapeModule$enabled = 202,
        Noise$damping = 203,
        Noise$frequency = 204,
        Noise$octaveCount = 205,
        Noise$octaveMultiplier = 206,
        Noise$octaveScale = 207,
        Noise$quality = 208,
        Noise$remap = 209,
        Noise$remapMultiplier = 210,
        Noise$remapX = 211,
        Noise$remapXMultiplier = 212,
        Noise$remapY = 213,
        Noise$remapYMultiplier = 214,
        Noise$remapZ = 215,
        Noise$remapZMultiplier = 216,
        Noise$scrollSpeed = 217,
        Noise$strength = 218,
        Noise$strengthMultiplier = 219,
        Noise$strengthX = 220,
        Noise$strengthXMultiplier = 221,
        Noise$strengthY = 222,
        Noise$strengthYMultiplier = 223,
        Noise$strengthZ = 224,
        Noise$strengthZMultiplier = 225,
        TextureSheetAnimation$enabled = 226,
        aniplayer$clips = 227,
        Aniclip$fileName = 228,
        Aniclip$aniclipName = 229,
        Aniclip$fps = 230,
        Aniclip$loop = 231,
        Aniclip$boneCount = 232,
        Aniclip$bones = 233,
        Aniclip$indexDic = 234,
        Aniclip$frameCount = 235,
        Aniclip$frames = 236,
        aniplayer$bones = 237,
        aniplayer$startPos = 238,
        aniplayer$animNames = 239,
        skinnedMeshRenderer$player = 240,
        Aniclip$hasScaled = 241,
        Mat$queue = 242,
        spherecollider$radius = 243,
        ParticleShapeModule$randomDirectionAmount = 244,
        meshRenderer$lightmapScaleOffset = 245,
        meshRenderer$layer = 246,
        water$copyFrom = 247,
        water$defNumVertsPerRow = 248,
        boxcollider$center = 249,
        boxcollider$size = 250
    }
    export enum typeEnum {
        Mesh$meshName = 0,
        Mesh$originVF = 4,
        Mesh$bounds = 1000,
        Bounds$extents = 14,
        Bounds$center = 14,
        Mesh$posCount = 5,
        Mesh$trisindex = 106,
        Mesh$subMesh = 1100,
        subMeshInfo$size = 5,
        Mesh$tmpVArr = 109,
        Mesh$minimum = 14,
        Mesh$maximum = 14,
        Mesh$fileName = 0,
        Mesh$length = 5,
        Mesh$name = 0,
        ImageSetting$imageName = 0,
        ImageSetting$filterMode = 0,
        ImageSetting$format = 0,
        ImageSetting$mipmap = 12,
        ImageSetting$wrap = 0,
        ImageSetting$premultiplyAlpha = 12,
        ImageSetting$fileName = 0,
        ImageSetting$length = 5,
        ImageSetting$name = 0,
        Mat$shader = 0,
        Mat$srcshader = 0,
        Mat$mapUniform = 300,
        mapUniInfo$type = 5,
        mapUniInfo$value = 0,
        Mat$fileName = 0,
        Mat$length = 5,
        Mat$name = 0,
        Prefab$tranName = 0,
        Prefab$localRotate = 18,
        Prefab$localScale = 14,
        Prefab$gameObject = 1000,
        gameObjectInfo$tag = 0,
        gameObjectInfo$components = 1100,
        meshFilter$mesh = 0,
        meshRenderer$materials = 100,
        meshRenderer$lightmapIndex = 5,
        Prefab$insid = 5,
        Prefab$fileName = 0,
        Prefab$length = 5,
        Prefab$name = 0,
        fileInfo$fileCount = 300,
        Prefab$children = 1100,
        Prefab$localTranslate = 14,
        Mesh$vec10tpose = 109,
        skinnedMeshRenderer$materials = 100,
        skinnedMeshRenderer$center = 14,
        skinnedMeshRenderer$size = 14,
        skinnedMeshRenderer$mesh = 0,
        skinnedMeshRenderer$rootBone = 5,
        skinnedMeshRenderer$bones = 105,
        Mesh$guid = 0,
        Mesh$zip_length = 5,
        ImageSetting$guid = 0,
        ImageSetting$zip_length = 5,
        Mat$guid = 0,
        Mat$zip_length = 5,
        Prefab$guid = 0,
        Prefab$zip_length = 5,
        subMeshInfo$matIndex = 5,
        subMeshInfo$start = 5,
        gameObjectInfo$layer = 5,
        Mat$InstanceID = 0,
        f14EffectSystem$Name = 0,
        f14EffectSystem$lifeTime = 9,
        f14EffectSystem$beloop = 12,
        f14EffectSystem$layers = 1100,
        layer$Name = 0,
        layer$type = 0,
        layer$singlemeshdata = 1000,
        Singlemeshdata$mesh = 0,
        Singlemeshdata$material = 0,
        Singlemeshdata$position = 0,
        Singlemeshdata$scale = 0,
        Singlemeshdata$euler = 0,
        Singlemeshdata$color = 0,
        Singlemeshdata$tex_ST = 0,
        Singlemeshdata$uvType = 0,
        Singlemeshdata$bindAxis = 0,
        layer$frames = 1100,
        frame$frameindex = 5,
        f14EffectSystem$fileName = 0,
        f14EffectSystem$length = 5,
        f14EffectSystem$name = 0,
        f14effCmop$f14eff = 1000,
        frame$colorAtts = 1100,
        att$name = 0,
        att$value = 0,
        frame$vec3Atts = 1100,
        frame$vec4Atts = 1100,
        ParticleSystem$main = 1000,
        ParticleMainModule$duration = 9,
        ParticleMainModule$startDelay = 1000,
        MinMaxCurve$constant = 9,
        MinMaxCurve$constantMax = 9,
        MinMaxCurve$curve = 1000,
        MinMaxCurve$curveMax = 1000,
        MinMaxCurve$curveMin = 1000,
        ParticleMainModule$startLifetime = 1000,
        ParticleMainModule$startSpeed = 1000,
        ParticleMainModule$startSize = 1000,
        ParticleMainModule$startSizeX = 1000,
        ParticleMainModule$startSizeY = 1000,
        ParticleMainModule$startSizeZ = 1000,
        ParticleMainModule$gravityModifier = 1000,
        ParticleMainModule$maxParticles = 5,
        ParticleMainModule$playOnAwake = 12,
        ParticleMainModule$scalingMode = 5,
        ParticleMainModule$simulationSpeed = 9,
        ParticleMainModule$startColor = 1000,
        MinMaxGradient$color = 16,
        MinMaxGradient$colorMax = 16,
        MinMaxGradient$gradient = 1000,
        MinMaxGradient$gradientMax = 1000,
        MinMaxGradient$gradientMin = 1000,
        ParticleMainModule$startRotation = 1000,
        ParticleMainModule$startRotationX = 1000,
        ParticleMainModule$startRotationY = 1000,
        ParticleMainModule$startRotationZ = 1000,
        ParticleSystem$emission = 1000,
        ParticleEmissionModule$enabled = 12,
        ParticleEmissionModule$rateOverDistance = 1000,
        ParticleEmissionModule$rateOverTime = 1000,
        ParticleEmissionModule$bursts = 1100,
        burst$cycleCount = 5,
        burst$maxCount = 5,
        burst$minCount = 5,
        burst$repeatInterval = 9,
        ParticleSystem$shape = 1000,
        ParticleShapeModule$angle = 9,
        ParticleShapeModule$arc = 9,
        ParticleShapeModule$arcSpeed = 1000,
        ParticleShapeModule$box = 14,
        ParticleShapeModule$length = 9,
        ParticleShapeModule$radius = 9,
        ParticleShapeModule$radiusSpeed = 1000,
        ParticleSystem$velocityOverLifetime = 1000,
        ParticleVelocityOverLifetimeModule$x = 1000,
        ParticleVelocityOverLifetimeModule$y = 1000,
        ParticleVelocityOverLifetimeModule$z = 1000,
        ParticleSystem$limitVelocityOverLifetime = 1000,
        ParticleLimitVelocityOverLifetimeModule$dampen = 9,
        ParticleLimitVelocityOverLifetimeModule$limit = 1000,
        ParticleLimitVelocityOverLifetimeModule$limitX = 1000,
        ParticleLimitVelocityOverLifetimeModule$limitY = 1000,
        ParticleLimitVelocityOverLifetimeModule$limitZ = 1000,
        ParticleSystem$inheritVelocity = 1000,
        ParticleInheritVelocityModule$curve = 1000,
        ParticleSystem$forceOverLifetime = 1000,
        ParticleSystem$colorOverLifetime = 1000,
        ColorBySpeed$color = 1000,
        Gradient$alphaKeys = 1100,
        alphaKey$alpha = 9,
        alphaKey$time = 9,
        Gradient$colorKeys = 1100,
        colorKey$color = 16,
        colorKey$time = 9,
        ColorBySpeed$enabled = 12,
        ParticleSystem$colorBySpeed = 1000,
        ParticleSystem$sizeOverLifetime = 1000,
        SizeOverLifetime$enabled = 12,
        SizeOverLifetime$size = 1000,
        AnimationCurve1$postWrapMode = 5,
        AnimationCurve1$preWrapMode = 5,
        AnimationCurve1$keys = 1100,
        key$inTangent = 9,
        key$outTangent = 9,
        key$time = 9,
        key$value = 9,
        MinMaxCurve$curveMultiplier = 9,
        MinMaxCurve$mode = 5,
        SizeOverLifetime$x = 1000,
        SizeOverLifetime$y = 1000,
        SizeOverLifetime$z = 1000,
        ParticleSystem$sizeBySpeed = 1000,
        ParticleSystem$rotationOverLifetime = 1000,
        ParticleSystem$rotationBySpeed = 1000,
        ParticleSystem$noise = 1000,
        ParticleSystem$textureSheetAnimation = 1000,
        TextureSheetAnimation$cycleCount = 5,
        TextureSheetAnimation$frameOverTime = 1000,
        TextureSheetAnimation$numTilesX = 5,
        TextureSheetAnimation$numTilesY = 5,
        TextureSheetAnimation$startFrame = 1000,
        TextureSheetAnimation$useRandomRow = 12,
        TextureSheetAnimation$uvChannelMask = 5,
        ParticleSystem$fileName = 0,
        ParticleSystem$length = 5,
        ParticleSystem$guid = 0,
        ParticleSystem$zip_length = 5,
        ParticleSystem$name = 0,
        ParticleShapeModule$shapeType = 5,
        particlesystem$particleSystemData = 0,
        particlesystem$material = 0,
        Singlemeshdata$beBillboard = 12,
        ParticleMainModule$loop = 12,
        MinMaxCurve$constantMin = 9,
        ParticleShapeModule$enabled = 12,
        Noise$damping = 12,
        Noise$frequency = 9,
        Noise$octaveCount = 5,
        Noise$octaveMultiplier = 9,
        Noise$octaveScale = 9,
        Noise$quality = 5,
        Noise$remap = 1000,
        Noise$remapMultiplier = 9,
        Noise$remapX = 1000,
        Noise$remapXMultiplier = 9,
        Noise$remapY = 1000,
        Noise$remapYMultiplier = 9,
        Noise$remapZ = 1000,
        Noise$remapZMultiplier = 9,
        Noise$scrollSpeed = 1000,
        Noise$strength = 1000,
        Noise$strengthMultiplier = 9,
        Noise$strengthX = 1000,
        Noise$strengthXMultiplier = 9,
        Noise$strengthY = 1000,
        Noise$strengthYMultiplier = 9,
        Noise$strengthZ = 1000,
        Noise$strengthZMultiplier = 9,
        TextureSheetAnimation$enabled = 12,
        aniplayer$clips = 1100,
        Aniclip$fileName = 0,
        Aniclip$aniclipName = 0,
        Aniclip$fps = 9,
        Aniclip$loop = 12,
        Aniclip$boneCount = 5,
        Aniclip$bones = 100,
        Aniclip$indexDic = 300,
        Aniclip$frameCount = 5,
        Aniclip$frames = 300,
        aniplayer$bones = 135,
        aniplayer$startPos = 136,
        aniplayer$animNames = 100,
        skinnedMeshRenderer$player = 5,
        Aniclip$hasScaled = 12,
        Mat$queue = 5,
        spherecollider$radius = 9,
        ParticleShapeModule$randomDirectionAmount = 9,
        meshRenderer$lightmapScaleOffset = 15,
        meshRenderer$layer = 5,
        water$copyFrom = 5,
        water$defNumVertsPerRow = 9,
        boxcollider$center = 14,
        boxcollider$size = 14
    }
}
declare module "Loader/otherPlan/dataType/AssetBundleFileInfo" {
    export class AssetBundleFileInfo {
        static classType: typeof AssetBundleFileInfo;
        fileName: string;
        length: number;
        guid: string;
        zip_length: number;
        oldVersions: boolean;
        name: string;
    }
}
declare module "Loader/otherPlan/loadTools" {
    export class loadTools {
        static urlCaseDic: {
            [url: string]: number;
        };
        static retryTime: number;
        static retryCount: number;
        /**
         *
         * @param url 加载路径
         * @param fun 加载结果回调函数
         * @param onprocess 加载进度
         * @param loadedFun 正常加载完成后回调
         */
        static xhrLoad(url: string, fun: (ContentData: any, _err: Error, isloadFail?: boolean) => void, onprocess: (curLength: number, totalLength: number) => void, responseType: XMLHttpRequestResponseType, loadedFun: (req: XMLHttpRequest) => void): void;
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 加载text资源
         * @param url 加载路径
         * @param fun 加载结果回调函数
         * @param onprocess 加载进度
         * @version m4m-m4m 1.0
         */
        static loadJson(url: string, fun: (_txt: string, _err: Error, isloadFail?: boolean) => void, onprocess?: (curLength: number, totalLength: number) => void): void;
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 加载arraybuffer资源
         * @param url 加载路径
         * @param fun 加载结果回调函数
         * @param onprocess 加载进度
         */
        static loadArrayBuffer(url: string, fun: (_bin: ArrayBuffer, _err: Error, isloadFail?: boolean) => void, onprocess?: (curLength: number, totalLength: number) => void): void;
    }
}
declare module "Loader/otherPlan/testReadTool" {
    import { AssetBundleFileInfo } from "Loader/otherPlan/dataType/AssetBundleFileInfo";
    import { cMap } from "Data/Map";
    export class fileInfo {
        static classType: typeof fileInfo;
        fileCount: cMap<number>;
    }
    export class testReadTool {
        static classType: typeof testReadTool;
        static tempListString: cMap<AssetBundleFileInfo[]>;
        static timer: cMap<number>;
        static index: number;
        /**
         * 加载资源组二进制数据
         * @param url
         */
        static loadAssetBoundleFiles(urll: string, isOnlyExportOne?: boolean): Promise<AssetBundleFileInfo[]>;
        static readInfoByBuffer(url: string, bd: ArrayBuffer): AssetBundleFileInfo[];
        static readArrayBuffer(url: string, cb: Function): void;
        /**
         * 解析类
         * @param br
         * @param classObj
         */
        private static readBytes;
        private static readFloat;
        static readListV3(br: ArrayBuffer, listLen: number, pos: number, cb: Function): void;
        /**
         * 解析数据
         * @param br
         * @param type
         */
        static aaaaaaa: number;
        static aaaaaaabbbbbbbbbb: number;
        private static readValue;
        static TypeListCount: cMap<number>;
        private static readTypes;
    }
}
declare module "Loader/otherPlan/dataType/Bounds" {
    export class Bounds {
        static classType: typeof Bounds;
        extents: m4m.math.vector3;
        size: m4m.math.vector3;
        center: m4m.math.vector3;
        min: m4m.math.vector3;
        max: m4m.math.vector3;
    }
}
declare module "Loader/otherPlan/dataType/Mesh" {
    import { AssetBundleFileInfo } from "Loader/otherPlan/dataType/AssetBundleFileInfo";
    import { Bounds } from "Loader/otherPlan/dataType/Bounds";
    import { number4 } from "Loader/otherPlan/dataType/number4";
    export class Mesh extends AssetBundleFileInfo {
        static classType: typeof Mesh;
        className: string;
        meshName: string;
        originVF: number;
        bounds: Bounds;
        posCount: number;
        position: m4m.math.vector3[];
        color: m4m.math.color[];
        colorex: m4m.math.color[];
        normal: m4m.math.vector3[];
        UV0: m4m.math.vector2[];
        UV1: m4m.math.vector2[];
        tangent: m4m.math.vector3[];
        blendIndex: number4[];
        blendWeight: number4[];
        vec10tpose: number[];
        trisindex: number[];
        subMesh: subMeshInfo[];
        tmpVArr: Float32Array;
        minimum: m4m.math.vector3;
        maximum: m4m.math.vector3;
    }
    class subMeshInfo {
        static classType: typeof subMeshInfo;
        matIndex: number;
        useVertexIndex: number;
        line: boolean;
        start: number;
        size: number;
    }
}
declare module "Loader/otherPlan/dataType/mapUniInfo" {
    export class mapUniInfo {
        static classType: typeof mapUniInfo;
        type: number;
        value: string;
    }
}
declare module "Loader/otherPlan/dataType/Mat" {
    import { cMap } from "Data/Map";
    import { AssetBundleFileInfo } from "Loader/otherPlan/dataType/AssetBundleFileInfo";
    import { mapUniInfo } from "Loader/otherPlan/dataType/mapUniInfo";
    export class Mat extends AssetBundleFileInfo {
        static classType: typeof Mat;
        shader: string;
        srcshader: string;
        queue: number;
        mapUniform: cMap<mapUniInfo>;
        InstanceID: string;
    }
}
declare module "Loader/otherPlan/dataType/subClip" {
    export class subClip {
        static classType: typeof subClip;
        name: string;
        loop: boolean;
        startframe: number;
        endframe: number;
    }
}
declare module "Loader/otherPlan/dataType/Aniclip" {
    import { cMap } from "Data/Map";
    import { subClip } from "Loader/otherPlan/dataType/subClip";
    export class Aniclip {
        static classType: typeof Aniclip;
        fileName: string;
        aniclipName: string;
        fps: number;
        hasScaled: boolean;
        loop: boolean;
        boneCount: number;
        bones: string[];
        indexDic: cMap<number>;
        subclipCount: number;
        subclips: subClip[];
        frameCount: number;
        frames: cMap<Float32Array>;
    }
}
declare module "Loader/otherPlan/dataType/keyFrame" {
    export class keyFrame {
        static classType: typeof keyFrame;
        time: number;
        value: number[];
    }
}
declare module "Loader/otherPlan/dataType/curve" {
    import { keyFrame } from "Loader/otherPlan/dataType/keyFrame";
    export class curve {
        static classType: typeof curve;
        path: string;
        type: string;
        propertyName: string;
        keyFrames: keyFrame[];
    }
}
declare module "Loader/otherPlan/dataType/KeyFrameAnimtionClip" {
    import { AssetBundleFileInfo } from "Loader/otherPlan/dataType/AssetBundleFileInfo";
    import { curve } from "Loader/otherPlan/dataType/curve";
    export class KeyFrameAnimtionClip extends AssetBundleFileInfo {
        static classType: typeof KeyFrameAnimtionClip;
        tag: string;
        frameRate: number;
        KeyFrameAnimtionlength: number;
        wrapMode: number;
        curves: curve[];
    }
}
declare module "Loader/otherPlan/dataType/nodeComponent" {
    import { Aniclip } from "Loader/otherPlan/dataType/Aniclip";
    import { tPoseInfo } from "Loader/otherPlan/dataType/tPoseInfo";
    import { PoseBoneMatrix } from "Loader/otherPlan/dataType/PoseBoneMatrix";
    import { KeyFrameAnimtionClip } from "Loader/otherPlan/dataType/KeyFrameAnimtionClip";
    export class nodeComponent {
        static classType: typeof nodeComponent;
        cmop: string;
    }
    export class boxcollider extends nodeComponent {
        static classType: typeof boxcollider;
        cmop: string;
        center: m4m.math.vector3;
        size: m4m.math.vector3;
    }
    export class aniplayer extends nodeComponent {
        static classType: typeof aniplayer;
        cmop: string;
        clips: Aniclip[];
        bones: tPoseInfo[];
        startPos: PoseBoneMatrix[];
        animNames: string[];
    }
    export class skinnedMeshRenderer extends nodeComponent {
        static classType: typeof skinnedMeshRenderer;
        cmop: string;
        materials: string[];
        center: m4m.math.vector3;
        size: m4m.math.vector3;
        mesh: string;
        rootBone: number;
        bones: number[];
        player: number;
    }
    export class meshFilter extends nodeComponent {
        static classType: typeof meshFilter;
        cmop: string;
        mesh: string;
    }
    export class meshRenderer extends nodeComponent {
        static classType: typeof meshRenderer;
        cmop: string;
        materials: string[];
        lightmapIndex: number;
        lightmapScaleOffset: m4m.math.quaternion;
        layer: number;
    }
    export class meshcollider extends nodeComponent {
        static classType: typeof meshcollider;
        cmop: string;
    }
    export class asbone extends nodeComponent {
        static classType: typeof asbone;
        cmop: string;
    }
    export class particlesystem extends nodeComponent {
        static classType: typeof particlesystem;
        cmop: string;
        particleSystemData: string;
        material: string;
        mesh: string;
        sortingFudge: number;
        pivot: m4m.math.vector3;
    }
    export class f14effCmop extends nodeComponent {
        static classType: typeof f14effCmop;
        cmop: string;
        f14eff: string;
        delay: number;
    }
    export class linerendererCmop extends nodeComponent {
        static classType: typeof linerendererCmop;
        cmop: string;
        lineRendererData: string;
        material: string;
    }
    export class keyFrameAniPlayer extends nodeComponent {
        static classType: typeof keyFrameAniPlayer;
        cmop: string;
        clips: KeyFrameAnimtionClip[];
    }
    export class spherecollider extends nodeComponent {
        static classType: typeof spherecollider;
        cmop: string;
        center: m4m.math.vector3;
        radius: number;
    }
    export class godray extends nodeComponent {
        static classType: typeof godray;
        cmop: string;
    }
    export class waterComp extends nodeComponent {
        static classType: typeof waterComp;
        cmop: string;
        copyFrom: number;
        defNumVertsPerRow: number;
    }
}
declare module "Loader/otherPlan/dataType/gameObjectInfo" {
    import { nodeComponent } from "Loader/otherPlan/dataType/nodeComponent";
    export class gameObjectInfo {
        static classType: typeof gameObjectInfo;
        layer: number;
        tag: string;
        components: nodeComponent[];
    }
}
declare module "Loader/otherPlan/dataType/Prefab" {
    import { AssetBundleFileInfo } from "Loader/otherPlan/dataType/AssetBundleFileInfo";
    import { gameObjectInfo } from "Loader/otherPlan/dataType/gameObjectInfo";
    export class Prefab extends AssetBundleFileInfo {
        static classType: typeof Prefab;
        tranName: string;
        localRotate: m4m.math.quaternion;
        localTranslate: m4m.math.vector3;
        localScale: m4m.math.vector3;
        gameObject: gameObjectInfo;
        children: Prefab[];
        insid: number;
    }
}
declare module "Loader/otherPlan/dataType/ImageSetting" {
    import { AssetBundleFileInfo } from "Loader/otherPlan/dataType/AssetBundleFileInfo";
    export class ImageSetting extends AssetBundleFileInfo {
        static classType: typeof ImageSetting;
        imageName: string;
        filterMode: string;
        format: string;
        mipmap: boolean;
        wrap: string;
        premultiplyAlpha: boolean;
        imageGuid: string;
    }
}
declare module "Loader/otherPlan/ktx" {
    /**
     *
     * for description see https://www.khronos.org/opengles/sdk/tools/KTX/
     * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/
     *
     * ported from https://github.com/BabylonJS/Babylon.js/blob/master/src/Misc/khronosTextureContainer.ts
     */
    export class KTXParse {
        private static HEADER_LEN;
        /**
         *
         * @param gl
         * @param arrayBuffer contents of the KTX container file
         * @param facesExpected should be either 1 or 6, based whether a cube texture or or
         */
        static parse(gl: WebGL2RenderingContext, arrayBuffer: ArrayBuffer, facesExpected?: number, loadMipmaps?: boolean): m4m.render.glTexture2D;
    }
}
declare module "Loader/otherPlan/pvr" {
    export class testPvrParse {
        height: number;
        width: number;
        constructor(gl: WebGL2RenderingContext);
        private version;
        private flags;
        private pixelFormatH;
        private pixelFormatL;
        private channelType;
        private depth;
        private numFaces;
        private mipMapCount;
        private metaDataSize;
        private gl;
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 解析pvr图片
         * @param _buffer 图片二进制数据
         * @version m4m 1.0
         */
        parse(_buffer: ArrayBuffer): m4m.render.glTexture2D;
        private parseV3;
    }
}
declare module "Time/TimerData" {
    export class TimerData {
        get isEnd(): boolean;
        set isEnd(value: boolean);
        id: number;
        isNeedLoop: boolean;
        currentCount: number;
        count: number;
        loopTime: number;
        oldTime: number;
        callback: Function;
        pause: boolean;
        countDownid: number;
        showLog: boolean;
        private _isEnd;
        tick(nowTime: number): void;
        disponse(): void;
    }
}
declare module "Time/CTimer" {
    import { TimerData } from "Time/TimerData";
    export class CTimer {
        static get Instance(): CTimer;
        static testC: boolean;
        removeList: TimerData[];
        constructor();
        private static instance;
        private list;
        private id;
        showTimer(): void;
        showConutDown(countDownid: number): void;
        countDown(time: number, rateTime: number, callback: Function, completeCallback: Function): number;
        pause(id: number, pause: boolean): void;
        stop(timerid: number): void;
        stopCountDown(countDownid: number): void;
        timer(time: number, count: number, callback: Function, countDownid?: number): number;
        timeDelay(delayTime: number, callback: Function, countDownid?: number): number;
        loopTimeUpdate(loopTime: number, callback: Function): number;
        Update(): void;
    }
}
declare module "Loader/otherPlan/LoaderManage" {
    import { cMap } from "Data/Map";
    import { Loader } from "Loader/otherPlan/Loader";
    export enum ResLoadType {
        NONE = 0,
        SCENE = 1
    }
    export enum LoadType {
        ARRAYBUFFER = 0,
        JSON = 1,
        IMAGE = 2
    }
    export class LoaderManage {
        static get Instance(): LoaderManage;
        static loaderCount: number;
        loaders: cMap<Loader>;
        currentLoaders: Loader[];
        waitLoaders: Loader[];
        constructor();
        private static instance;
        private index;
        private loadFailBackList;
        load(url: string, onLoadFinished: Function, data?: any, loadType?: LoadType): Loader;
        startLoader(): void;
        loaderEnd(loader: Loader): void;
        addLoader(loader: Loader): void;
        removeLoader(url: string): void;
        addFail(loader: Loader): void;
        private getNextLoader;
        private failBackFun;
    }
}
declare module "Loader/otherPlan/Loader" {
    import { LoadType } from "Loader/otherPlan/LoaderManage";
    import { cMap } from "Data/Map";
    export class Loader {
        id: number;
        endFunction: Function;
        loaderEvents: CallBackData[];
        url: string;
        priority: number;
        timeoutCount: number;
        timeout: number;
        userCount: number;
        progress: number;
        bytesLoaded: number;
        bytesTotal: number;
        timer: cMap<number>;
        fileCount: number;
        fileLoadedCount: number;
        loaderType: LoadType;
        bin: any;
        constructor();
        private _progressCallBack;
        private removeList;
        load(): any;
        dispose(): void;
        addProgressCallBack(value: Function): void;
        addCallBack(callBack: Function, obj: any): void;
        removeCallBack(callBack: Function): void;
    }
    class CallBackData {
        callback: Function;
        data: any;
        dispose(): void;
    }
}
declare module "Loader/otherPlan/testLoader" {
    import { Loader } from "Loader/otherPlan/Loader";
    enum LoadType {
        ARRAYBUFFER = 0,
        JSON = 1,
        IMAGE = 2
    }
    export class testLoader {
        fileCount: number;
        fileLoadedCount: number;
        sucessProgress: number;
        progress: number;
        private list;
        private loadedFile;
        private loadCallBack;
        private progressCallback;
        add(url: string, callback: Function, type?: LoadType): void;
        loaderEnd(loader: Loader, file: any): void;
        start(callback?: Function): void;
        LoadProgress(progress: number, fileLoadedCount: number, fileCount: number, bytesLoaded: number, bytesTotal: number): void;
    }
}
declare module "Scripts/multiToucher" {
    export class multiToucher extends m4m.framework.behaviour2d {
        private static regId;
        private static unregId;
        /** 初始化设置 overlay2D */
        static init(ol2d: m4m.framework.overlay2D, app: m4m.framework.application): void;
        /** 全局启用 多点触控的功能 */
        static enable: boolean;
        /** 是否吃事件（阻止事件穿透） */
        eatEvent: boolean;
        private static helpv2;
        private static helpv2v1;
        private static useIdMap;
        private static _ol2d;
        private static iptMgr;
        private static app;
        private static inited;
        private eventer;
        private touchId;
        private hasPointDown;
        private lastTouchDic;
        private ids;
        private readonly moveTolerance;
        private lastTouch;
        private hasPointUP;
        private lastPoint;
        private downPoint;
        /**
        * 添加point事件监听者
        * @param eventEnum 事件类型
        * @param func 事件触发回调方法 (Warn: 不要使用 func.bind() , 它会导致相等判断失败)
        * @param thisArg 回调方法执行者
        */
        addPointListener(eventEnum: m4m.event.PointEventEnum, func: (...args: any[]) => void, thisArg: any): void;
        /**
         * 移除point事件监听者
         * @param eventEnum 事件类型
         * @param func 事件触发回调方法
         * @param thisArg 回调方法执行者
         */
        removePointListener(eventEnum: m4m.event.PointEventEnum, func: (...args: any[]) => void, thisArg: any): void;
        onPlay(): void;
        update(delta: number): void;
        onPointEvent(canvas: m4m.framework.canvas, ev: m4m.framework.PointEvent, oncap: boolean): void;
        /** 重置状态 */
        resetSate(): void;
        remove(): void;
        private ckHaveNewTouch;
        private ckStratHit;
        private tryHit;
        private updateState;
    }
}
declare module "UIBase/metaUIManager" {
    export class metaUIManager {
        /** 给 子域分享画布 使用 */
        static shareCanvasImg: m4m.framework.rawImage2D;
        /** 全屏尺寸 img容器 */
        static scFullImg: m4m.framework.rawImage2D;
        /** 头像尺寸 img容器  */
        static scIconImg: m4m.framework.rawImage2D;
        /** 上层相机的 overLay , UI 上模型模式使用*/
        static topOverlay: m4m.framework.overlay2D;
        /** 相机的 overLay , UI 的承载实体 */
        static overlay: m4m.framework.overlay2D;
        /** UI 根节点 ，下层之下 */
        static downlayer: m4m.framework.transform2D;
        /** UI 根节点 ，底层 */
        static baselayer: m4m.framework.transform2D;
        /** UI 根节点 ，中层 */
        static midlayer: m4m.framework.transform2D;
        /** UI 根节点 ，高层 */
        static highlayer: m4m.framework.transform2D;
        /** UI 根节点 ，最高层 */
        static poplayer: m4m.framework.transform2D;
        /** uiPrefab 资源路径 */
        static uiPrefabPath: string;
        /** ui atlas 资源路径 */
        static atlasPath: string;
        static _layerIndexOverUI3d: number;
        protected static _fullScreenTran: m4m.framework.transform2D;
        /** 首屏显示的UI对象 */
        protected static firstDisplay: m4m.framework.transform2D;
        protected static isInited: boolean;
        protected static uiRoot: m4m.framework.transform2D;
        protected static _ActiveSelf: typeof metaUIManager;
        /** 跳跃层级map */
        private static leapLayerMap;
        /** insID Layer Map */
        private static uiInsIDLayerMap;
        /** leap layer渲染队列 */
        private static leapLayerQueue;
        private static cTIdx;
        private static _sCanvIconMode;
        private static _modelcam;
        private static leapRenderFunMap;
        private static FrontBefRenderFunMap;
        /** 当前激活中 变体子类 */
        static get ActiveSelf(): typeof metaUIManager;
        /** shareCanvas image 容器的 icon ，（isIconMode ? this.scIconImg : this.scFullImg）*/
        static get sCanvIconMode(): boolean;
        static set sCanvIconMode(isIconMode: boolean);
        /** UI之上显示 模型的专有层级 （默认 31）*/
        static get layerIndexOverUI3d(): number;
        static set layerIndexOverUI3d(v: number);
        /** UI 上模型相机 */
        static get modelCam(): m4m.framework.camera;
        /**
         * 初始化UIManager
         * @param uiWidth ui设计最大宽度分辨率
         * @param uiHeight ui设计最大高度分辨率
         * @param screenMatchRate 屏幕匹配率 ( 屏幕宽高匹配模式 (range 0-1  =0:固定宽  =1:固定高) )
         * @param uiPrefabPath UI prefab 资源路径
         * @param atlasPath ui atlas 资源路径
         */
        static init(uiWidth: number, uiHeight: number, screenMatchRate: number, uiPrefabPath: string, atlasPath: string): void;
        /** 清理首屏渲染显示UI */
        static clearFristDisplay(): void;
        /**
         * 全屏UI 事件 遮挡 或 开启
         * @param enable 开启UI事件遮挡
         */
        static fullScreenUIEventMask(enable: boolean): void;
        /**
         * 计算ui坐标 通过 屏幕坐标
         * @param x 屏幕坐标系 x
         * @param y 屏幕坐标系 y
         * @param uiPos vector2 ui坐标系postion
         */
        static screenPosToUIpos(x: number, y: number, uiPos: m4m.math.vector2): void;
        private static createTextrue;
        private static setHeadIcon;
        private static initModelOverCam;
        /**
         * 注册 top_overLay 渲染跳跃对象
         * @param insid 实例id
         * @param leapRenderFun
         * @param frontBefRenderFun
         * @param layer 层级值 最大值显示在最上面
         */
        static registerLeapRender(insid: number, leapRenderFun: (canvas: m4m.framework.canvas) => any, frontBefRenderFun: () => any, layer?: number): void;
        /**
         * 注销 top_overLay 渲染跳跃对象
         * @param insid 实例id
         */
        static unregisterLeapRender(insid: number): void;
        private static onFrontLay2dBeforRender;
        private static onTopLay2dBeforRender;
        private static refrashCamMask;
    }
}
declare module "UIBase/joyStick" {
    export class joyStick extends m4m.framework.behaviour2d {
        bottomImg: m4m.framework.image2D;
        overImg: m4m.framework.image2D;
        moveRange: number;
        /** 摇晃摇杆是的回调方法 */
        onShake: (x: any, y: any, dis: any) => any;
        /** 摇杆 释放松开 */
        onRelease: () => any;
        private static readonly helpv2;
        private static readonly helpv2v1;
        private static readonly helpv2v2;
        private mToucher;
        private hasDown;
        onPlay(): void;
        resetJoy(): void;
        update(delta: number): void;
        remove(): void;
        private onDown;
        private onMove;
        private onUp;
    }
}
declare module "UIBase/imgNum" {
    import { cMap } from "Data/Map";
    /** 图片拼接数值 控件 */
    export class imgNum extends m4m.framework.behaviour2d {
        static NumsMap: {
            [name: string]: cMap<m4m.framework.sprite>;
        };
        /** 素材的模板对象 */
        template: m4m.framework.image2D;
        /** 排列间隔 （默认23 ，一般取 0-9 中像素最宽的值） */
        gap: number;
        shellLayoutState: number;
        tranLayoutState: number;
        private static iconSprStr;
        private assetBundleName;
        private ImgArr;
        private baseName;
        private cacheColor;
        private inited;
        private extSupArr;
        /** 设置 模板对象 sprite 的AssetBundleName （默认情况不用处理 , 读取不到 再考虑设置） */
        setSpriteAssetBundleName(abName: string): void;
        /** 设置 值 */
        setNum(num: number): void;
        /** 设置 string值 */
        setStr(str: string): void;
        /** 设置 颜色 */
        setColor(color: m4m.math.color): void;
        onPlay(): void;
        update(delta: number): void;
        remove(): void;
        private subsIconParse;
        private init;
        private numImgToMap;
        private refreshImgs;
        private ckGenimg;
        private addShell;
    }
}
declare module "UIBase/uiFloat" {
    export class uiFloat extends m4m.framework.behaviour2d {
        floatIcon: m4m.framework.rawImage2D;
        clickBtn: m4m.framework.button;
        private clickTime;
        onPlay(): void;
        update(delta: number): void;
        testFun(): void;
        setBG(): void;
        private createBox;
        private onClick;
        private setIcon;
    }
}
declare module "UIBase/uiImageSlider" {
    export class uiImageSlider extends m4m.framework.behaviour2d {
        scrollRect: m4m.framework.scrollRect;
        content: m4m.framework.transform2D;
        imageTrans: m4m.framework.transform2D;
        imageBgTrans: m4m.framework.transform2D;
        private defIconHeight;
        private defYY;
        private moveInterval;
        private imageMoveInterval;
        onPlay(): void;
        setContentEnd(): void;
        private onMoveFun;
    }
}
declare module "UIBase/ubiAdvIcon" {
    export class ubiAdvIcon extends m4m.framework.behaviour2d {
        static readonly advW = 142;
        static readonly advH = 156;
        /** icon点击事件回调 */
        onClickIcon: Function;
        private icon;
        private intervals;
        private imglist;
        private imgTexs;
        private jumptargetAppid;
        private currAnimFun;
        private isShake;
        private waitCount;
        private shakeCount;
        private shakeTime;
        private shakeSpeed;
        private tp;
        private angleRange;
        private ranimCount;
        private playIdx;
        /** 设置icon 通过获取 的数据
         * res.id   跳转的appID
         * res.frames  序列图存放CDN URL
         * res.name  帧图 序列前缀
         * res.count 帧数量
         *
         * delay 延迟执行
         */
        setIcon(res: any, delay?: number): void;
        onPlay(): void;
        update(delta: number): void;
        remove(): void;
        private dosetIcon;
        private loadImg;
        private shakeAnim;
        private swFrameAnim;
        private swFrame_shake;
        private chageIconF;
    }
}
declare module "Tools/CrossPromotion" {
    export interface CrossPromotionEntity {
        /**
         * URLs of images for the entity to be displayed in GIF-like animation
         */
        frames: string[];
        /**
         * app id
         */
        appId: string;
        /**
         * URL of image for the entity to be displayed in static image
         */
        icon: string;
        /**
         * URL of Qrcode for the entity
         */
        qrcode: string;
        /**
         * code name of the mini game.
         */
        appCode: string;
        /**
         * weight is the chance of the entity to be displayed when we need to display entities ramdomly.
         */
        weight: number;
        /**
         * localized name of the entity. use zh for simplified Chinese.
         */
        displayName: {
            [key: string]: string;
        };
    }
    export class CrossPromotion {
        /**
         * flag if we should highlight crosspromotion button. For example add a red dot beside the button.
         */
        get displayDot(): boolean;
        /**
         * URL of the config file. You can change it before init for test purpose
         */
        configUrl: string;
        private popupEntities;
        private crossEntities;
        private cachedIndex;
        private entryName;
        private _displayDot;
        private inited;
        /**
         * fetch the config file from CDN
         * @param entryName entity name of current game
         */
        init(entryName: string): Promise<any>;
        /**
         * navigate to the mini program of the entity. If the mini program is not whitelisted, it will use QRCode.
         * this function will also record events on talkingdata if talkingdata is integrated.
         * @param entity the entity of the target mini game.
         * @param type the source's type.  cross means it comes from a GIF-like animation(using frames in entity to display the target entity)
         * @param params additional parameters to be added to talkingdata event
         */
        navigateToMiniProgram(entity: CrossPromotionEntity, type: "cross" | "popup", params?: Object): void;
        /**
         * Use QRCode for user to navigate to the mini program of the entity.
         * this function will also record events on talkingdata if talkingdata is integrated.
         * Unlike navigateToMiniProgram, we don't know if user really jump to the other game. Only click event will be recorded.
         * @param entity the entity of the target mini game.
         * @param type the source's type.  cross means it comes from a GIF-like animation(using frames in entity to display the target entity)
         * @param params additional parameters to be added to talkingdata event
         */
        previewQrcode(entity: CrossPromotionEntity, type: "cross" | "popup", params?: Object): void;
        /**
         * @deprecated return a random one in crossEntities
         */
        randomOne(): CrossPromotionEntity | null;
        /**
         * @deprecated return a cached one in crossEntities
         */
        getCached(): CrossPromotionEntity | null;
        /**
         * Get all the entities can be displayed in GIF-like animation
         */
        getCrossEntities(): CrossPromotionEntity[];
        /**
         * Get all the entities can be displayed in static image.
         */
        getPopupEntities(): CrossPromotionEntity[];
        private parseResponse;
        private parseCrossPromotionEntity;
    }
    export const crossPromo: CrossPromotion;
}
declare module "Tools/advMgr" {
    /** 内部广告 管理器 */
    import { ubiAdvIcon } from "UIBase/ubiAdvIcon";
    import { CrossPromotion } from "Tools/CrossPromotion";
    export class advMgr {
        static gameName: string;
        static ubiAdv: ubiAdvIcon;
        static crossPromotion: CrossPromotion;
        static advUrl: string;
        static sequenceAdvD: any;
        static inited: boolean;
        static onCrossPromotionInited: () => void;
        static init(): void;
        static settingAdvData: any[];
    }
}
declare module "UIBase/ubiPopupIcon" {
    import { CrossPromotionEntity } from "Tools/CrossPromotion";
    /**
     * ubi 游戏盒子推荐 icon
     */
    export class ubiPopupIcon extends m4m.framework.behaviour2d {
        static language: string;
        icon: m4m.framework.rawImage2D;
        lab: m4m.framework.label;
        private data;
        private inited;
        init(_data: CrossPromotionEntity, scale?: number): void;
    }
}
declare module "UIBase/uiRoll" {
    export class uiRoll extends m4m.framework.behaviour2d {
        bgPan1: m4m.framework.transform2D;
        bgPan2: m4m.framework.transform2D;
        bg1: m4m.framework.rawImage2D;
        bg2: m4m.framework.rawImage2D;
        onLoaded: Function;
        private bgArr;
        private moveSpeed;
        onPlay(): void;
        update(delta: number): void;
        setBG(TexPath: string): void;
        remove(): void;
        private setBg;
    }
}
declare module "UIBase/uiScaleDown" {
    export class uiScaleDown extends m4m.framework.behaviour2d {
        /** 是否循环播放 */
        isLoop: boolean;
        /** 播放速度 f/s (帧每秒)*/
        playSpeed: number;
        lastFun: Function;
        private runState;
        private mth;
        private time;
        private coutTime;
        private scale;
        onPlay(): void;
        play(): void;
        stop(): void;
        update(delta: number): void;
        remove(): void;
        private resTransform;
    }
}
declare module "UIBase/uiScaleAnimation" {
    export class uiScaleAnimation extends m4m.framework.behaviour2d {
        /** 是否循环播放 */
        isLoop: boolean;
        /** 播放速度 f/s (帧每秒)*/
        playSpeed: number;
        lastFun: Function;
        private runState;
        private mth;
        private time;
        private coutTime;
        private scale;
        onPlay(): void;
        play(): void;
        stop(): void;
        update(delta: number): void;
        remove(): void;
        private resTransform;
    }
}
declare module "UIBase/uiSpring" {
    export class uiSpring extends m4m.framework.behaviour2d {
        private num;
        private addNum;
        private isright;
        onPlay(): void;
        update(delta: number): void;
        setLeft(): void;
        remove(): void;
    }
}
declare module "UIBase/sequenceFrame" {
    /** 序列帧动画 */
    export class sequenceFrame extends m4m.framework.behaviour2d {
        /** 是否循环播放 */
        isLoop: boolean;
        /** 播放速率 f/s (每秒播放次数)*/
        get framerate(): number;
        set framerate(v: number);
        /**
         * 图集资源url
         * [已经弃用 , 请使用 setAssetUrl() 接口。]
         * @deprecated
         */
        ssAssetUrl: string;
        /**
         * 图集名
         * @deprecated
         */
        atlasName: string;
        /** sprite 列表 */
        private sps;
        private img;
        private isplay;
        /** 播放速率 f/s (每秒播放次数)*/
        private _framerate;
        /** 是否初始化了 */
        private inited;
        /** 帧间隔时间 */
        private _interval;
        /** 帧间隔 delata记时 */
        private frameDelata;
        /** 当前帧 */
        private currF;
        /** 图集资源URL */
        private _atlasAssetUrl;
        /** 单图集模式 */
        private _isSingleAtlasMode;
        onPlay(): void;
        /**
         * 设置图集资源的路径(设置后 走单图集 初始化模式 , 非必选)
         * 例如：xxx/图集名
         * @param atlasAssetUrl
         */
        setAssetUrl(atlasAssetUrl: string): void;
        /** 播放  */
        play(): void;
        /** 暂停播放 */
        stop(): void;
        update(delta: number): void;
        remove(): void;
        /** 初始化 */
        private init;
        /** 单图集模式 */
        private initBySingleAtlas;
        /** 模板最大值 初始化模式 */
        private initByMaxNum;
        /** 长度不够3 的补全 */
        private numStrFull3;
    }
}
declare module "Tools/PlatformUtil" {
    export class PlatformUtil {
        static recordWXPlatform: string;
        static get isPCWX(): boolean;
        static platform: string;
        /** 是低端 或 中端 设备 */
        static get LowOrMediumDevice(): boolean;
        static needUIscale: boolean;
        static systemQuality: SystemQualityType;
        static WXGetSystemPlatformType: PlatformType;
        static isIPhoneX: boolean;
        static isLiuHai: boolean;
        static isDevTool: boolean;
        /** 获取 平台类型信息 通过 navigator 对象 */
        static getTypeByBrowser(): PlatformType;
    }
    export enum SystemQualityType {
        low = 0,
        middle = 1,
        high = 2
    }
    export enum PlatformType {
        Android = 1,
        iPhone = 2,
        SymbianOS = 3,
        WindowsPhone = 4,
        iPad = 5,
        iPod = 6,
        PC = 7
    }
}
declare module "UIBase/uiBtnDown" {
    export class uiBtnDown extends m4m.framework.behaviour2d {
        scaleList: m4m.framework.transform2D[];
        currentPauseTime: number;
        currentIspause: boolean;
        currentScalNum: number;
        currentTrans: m4m.framework.transform2D;
        pauseTime: number;
        ispause: boolean;
        ScalNum: number;
        maxScaleNum: number;
        private scaleUp;
        private nowScaleNum;
        onPlay(): void;
        update(delta: number): void;
        remove(): void;
    }
}
declare module "Loader/otherPlan/testCreat" {
    import { cMap } from "Data/Map";
    import { PlatformType, SystemQualityType } from "Tools/PlatformUtil";
    export enum creatType {
        all = 0,
        noClip = 1,
        noMesh = 2
    }
    export class testCreat {
        /** 需要截获处理的资源路径 和 重定向后新的资源路径  { 截获路径:重定向路径 }*/
        static get pathReplaceMap(): {
            [srcPath: string]: string;
        };
        /** 项目资源 根路径 URL */
        static get CDNURL(): string;
        /**
         * 新资源加载工具 使用类初始
         * @param CDNURL    资源CDN RUL
         * @param systemQuality 游戏资源质量等级（高、中、低）
         * @param systemOS  OS 类型
         * @param carePathReplaceMap    设置需要截获处理的资源路径和重定向的资源路径 { 截获路径:重定向路径 }
         */
        static init(CDNURL: string, systemQuality: SystemQualityType, systemOS: PlatformType, carePathReplaceMap: {
            [srcPath: string]: string;
        }): void;
        private static setGetMesh;
        static getFilesByType(path: string, fileName: string, type: creatType, callBack: Function): void;
        static set systemQuality(v: number);
        static set systemOS(v: number);
        static disposeResByUrl(path: string): void;
        static createPfb(path: string, filePath: string): Promise<m4m.framework.prefab>;
        static createPfb2D(path: string, filePath: string): Promise<m4m.framework.prefab>;
        /**
         * 加载二进制获取数据并生成生成PREFAB
         * @param path
         * @param filePath
         */
        static creatTranByBuffer(path: string, filePath: string): Promise<m4m.framework.transform>;
        static creatTran2DByBuffer(path: string, filePath: string): Promise<m4m.framework.transform2D>;
        static loadJson(url: string): Promise<any>;
        static _loadJson(url: string, fun: (_txt: string, _err: Error, isloadFail?: boolean) => void, onprocess?: (curLength: number, totalLength: number) => void): void;
        static _loadImg(url: string, cb: (img: any, _err: any) => void): void;
        static loadImgMap: cMap<any>;
        static create(path: string): Promise<m4m.framework.transform2D | m4m.framework.transform>;
        static createTran(path: string): m4m.framework.transform2D | m4m.framework.transform;
        private static referenceComps;
        private static referenceComp;
        private static imgPathFix;
        private static setMat;
        private static makeAPrefab;
        private static makeAPrefab2D;
        private static setCompsToTran;
        private static setCompsToTran2D;
        private static makeAClip;
        private static makeAComp2D;
        private static makeAComp;
        private static createMesh;
        static creatAimClip(url: string, animName?: string): Promise<m4m.framework.animationClip>;
        static pfbList: cMap<m4m.framework.prefab>;
        static qualityString: string;
        static osString: string;
        static loadMap: cMap<any>;
        private static _CDNURL;
        private static isSetGetMesh;
        private static readonly allEnd;
        private static readonly noClipEnd;
        private static readonly noMeshEnd;
        private static readonly meshEnd;
        private static readonly tNormal;
        private static readonly tPVR;
        private static readonly tDDS;
        private static readonly tKTX;
        private static readonly tASCT;
        private static pfbResList;
        private static meshMap;
        private static _systemOS;
        private static fileList;
        private static aniplayer;
        private static _pathReplaceMap;
    }
}
declare module "UIBase/imgSpriteArrange" {
    import { cMap } from "Data/Map";
    /** 新图片拼接数值 控件 */
    export class imgSpriteArrange extends m4m.framework.behaviour2d {
        NumsMap: cMap<m4m.framework.sprite>;
        /** 素材的模板对象 */
        template: m4m.framework.image2D;
        gap: number;
        private static iconSprStr;
        private static extSupArr;
        private assetBundleName;
        private ImgArr;
        private baseName;
        private cacheColor;
        private inited;
        /** 设置 值 */
        setNum(num: number): void;
        /** 设置 string值 */
        setStr(str: string): void;
        /** 设置 颜色 */
        setColor(color: m4m.math.color): void;
        onPlay(): void;
        update(delta: number): void;
        remove(): void;
        private subsIconParse;
        private init;
        private numImgToMap;
        private refreshImgs;
    }
}
declare module "UIBase/uiEventDiscard" {
    /**
     * UI 事件 全屏蔽 组件
     */
    export class uiEventDiscard extends m4m.framework.behaviour2d implements m4m.framework.I2DPointListener {
        /** 强制要命中UI 矩形 才隔断事件 */
        foucsHited: boolean;
        private static readonly helpV2;
        onPointEvent(canvas: m4m.framework.canvas, ev: m4m.framework.PointEvent, oncap: boolean): void;
    }
}
declare module "Tools/ZIPTool" {
    /**
     * zip 工具
     */
    export class ZIPTool {
        /**
         * 加载Zip 文件
         * @param file 完整 zip 文件路径
         * @returns ZipPackage
         */
        static loadZip(file: string): Promise<ZipPackage>;
    }
    export type ZipPackage = {
        files: {
            [fileName: string]: IZipFile;
        };
    };
    export interface IZipFile {
        /** 是否是文件夹 */
        dir: boolean;
        name: string;
        date: Date;
        comment: string;
        options: object;
        /** 解压获取数据 */
        async<T extends keyof ZipFileType>(type: T): Promise<any>;
    }
    type ZipFileType = {
        base64: any;
        text: any;
        string: any;
        binarystring: any;
        array: any;
        uint8array: any;
        arraybuffer: any;
        blob: any;
        nodebuffer: any;
    };
}
declare module "Tools/commTool" {
    import { cMap } from "Data/Map";
    import { engineParallelType, ISpAnimPlayerHandle, ISpCamera, ISpPrefab, ISpTransform } from "Tools/engineParallel/spInterface";
    import { wxPrefab } from "Tools/engineParallel/wxEngine/wxPrefab";
    import { imgNum } from "UIBase/imgNum";
    import { sequenceFrame } from "UIBase/sequenceFrame";
    import { imgSpriteArrange } from "UIBase/imgSpriteArrange";
    /** 通用 Tool */
    export class commTool {
        static readonly toDeg = 57.29578;
        static readonly toRadian = 0.0174532924;
        static readonly cachLayerTag = "__cachLayerTag__";
        static readonly hasCachLayerTag = "__hasCachLayer__";
        /** 加载过的prefab 存放Map */
        static PrefebMap: cMap<ISpPrefab>;
        static loadedTextsMap: cMap<string>;
        private static readonly helpV2;
        private static readonly helpV2v1;
        private static readonly helpV3;
        private static readonly helpV3v1;
        private static readonly helpQuat;
        private static readonly AttachSubToSceneTag;
        private static readonly careTypeList;
        private static setUIShaderCount;
        /** 图面 id 极速器 */
        private static imgIdCounter;
        /** 加载 的贴图缓存容器 */
        private static loadedTexsDic;
        /** wx 加载 的贴图缓存容器 */
        private static loadedTexsDicWX;
        /**
         * 改变层级（递归）
         * @param tran
         * @returns
         */
        static changeLayerGUI(tran: ISpTransform, targetLayer: number): void;
        /**
         * 等待 全屏点击了一下
         */
        static waitFullScreenOnceDown(): Promise<any>;
        /**
         * 对组件 进行点击模拟
         * @param compObj   组件对象（必须实现I2DPointListener接口的组件 ）
         * @param _uiPointX  输入的 坐标点X
         * @param _uiPointY  输入的 坐标点Y
         */
        static clickSimulation<T extends m4m.framework.I2DPointListener & m4m.framework.I2DComponent>(compObj: T, uiPointX?: number, uiPointY?: number): void;
        /**
         * 通过 UI全局路径 获取 UI对象
         * @param UICanvas ui的canvas 对象
         * @param uiPath UI全局路径
         */
        static getUIByPath(UICanvas: m4m.framework.canvas, uiPath: string): m4m.framework.transform2D;
        /**
         * 通过 3D节点全局路径 获取 节点对象
         * @param nodePath 节点全局路径
         */
        static get3DNodeByPath(nodePath: string): m4m.framework.transform;
        /**
         * 通过 节点全局路径 获取 节点对象
         * @param nodeRoot root 节点
         * @param nodePath 全局路径
         */
        private static getTransByPath;
        /**
         * 获取 节点 通过 path
         * @param arr
         * @param uiName
         * @param repeatIdx
         */
        private static getTransByArr;
        /**
         * 获取 UI 的全局路径(字符串)
         * @param ui
         */
        static getUIPathStr(ui: m4m.framework.transform2D): string;
        /**
         * 获取 3d节点 的全局路径(字符串)
         * @param ui
         */
        static get3DPathStr(node: m4m.framework.transform): string;
        /**
         * 获取 trans 的全局路径(字符串)
         * @param TransNode trans节点
         */
        private static getTransPathStr;
        /**
         * 获取 节点 的全局路径
         * @param TransNode trans对象节点
         */
        private static getTransPath;
        /**
         * 将节点 改造成 UI事件屏蔽节点
         * @param trans UI节点对象
         * @param foucsHited 是否强制 点中UI才屏蔽
         * @returns
         */
        static makeUIEventDiscard(trans: m4m.framework.transform2D, foucsHited?: boolean): void;
        /**
         * 屏幕坐标转换到UI 世界坐标
         * @param x screenPos.x
         * @param y screenPos.y
         * @param outUiPos ui世界坐标
         */
        static screenPosToUIpos(x: number, y: number, outUiPos: m4m.math.vector2): void;
        /**
         * UI 世界坐标转换到 屏幕坐标
         * @param x UIPos.x
         * @param y UIPos.y
         * @param outScreenPos 屏幕坐标
         */
        static UIPosToScreenPos(x: number, y: number, outScreenPos: m4m.math.vector2): void;
        /**
         * 通过屏幕坐标 获取 3D 空间坐标
         * @param x screenPos.x
         * @param y screenPos.y
         * @param out3DPos 3D 空间坐标
         * @param watchCam 观察相机
         * @param zDepth 相对于相机观察平面的距离(相机Z 深度)
         */
        static calcu3DPosByScreenPos(x: number, y: number, out3DPos: m4m.math.vector3, watchCam: ISpCamera, zDepth?: number): void;
        /**
         * 通过给定UI 坐标计算3D空间 坐标
         * @param cam 相机
         * @param canvas UI的canvas
         * @param _3DPos 3d 空间坐标
         * @param outUIPos ui坐标
         */
        static calcuUIPosBy3DPos(cam: m4m.framework.camera, canvas: m4m.framework.canvas, _3DPos: m4m.math.vector3, outUIPos: m4m.math.vector2): void;
        /**
         * 设置UI 渲染组件的 shader
         * @param shaderResName
         * @param renderer 渲染组件对象（image2D、rawImage、label..）
         * @param needNewMaterial 切换成新的材质,替换老的材质
         */
        static setUIShader(shaderResName: string, renderer: m4m.framework.IRectRenderer, needNewMaterial?: boolean): void;
        /**
         * 获取2d组件 通过指定类(帮助获取组件的父类)
         * @param classType 类
         * @param gameObj 游戏对象，组件容器
         */
        static getComponentByType2d(classType: any, gameObj: m4m.framework.transform2D): m4m.framework.I2DComponent | m4m.framework.INodeComponent;
        /**
         * 获取组件 通过指定类(帮助获取组件的父类)
         * @param classType 类
         * @param gameObj 游戏对象，组件容器
         */
        static getComponentByType(classType: any, gameObj: m4m.framework.gameObject): m4m.framework.I2DComponent | m4m.framework.INodeComponent;
        private static _getComponentByType;
        private static instanceof_proto;
        /**
         * 克隆aabb 数据
         * @param traget 目标transom 节点对象
         * @param outAABB aabb 对象
         */
        static cloneAABB(traget: ISpTransform, outAABB: m4m.framework.aabb): void;
        /**
         * 添加 相机到场景
         * @param cam
         */
        static addCameraToscene(cam: ISpCamera): void;
        /**
         * 删除 场景中 相机
         * @param cam
         */
        static removeCameraFromScene(cam: ISpCamera): void;
        /**
         * 收集指定对象节点层级下的 所有 目标名 的节点
         * @param tran3d 指定对象节点
         * @param targetName 目标名
         * @param outFindList 收集的节点列表
         */
        static finds(tran3d: ISpTransform, targetName: string, outFindList: ISpTransform[]): void;
        /**
         * 收集指定对象节点层级下的 所有 目标名 的节点
         * @param tran2d 指定对象节点
         * @param targetName 目标名
         * @param outFindList 收集的节点列表
         */
        static finds_2d(tran2d: m4m.framework.transform2D, targetName: string, outFindList: m4m.framework.transform2D[]): void;
        /**
         * 搜索指定对象节点层级下的 目标名 的节点
         * @param tran2d 指定对象节点
         * @param targetName 目标名
         */
        static find_2d(tran2d: m4m.framework.transform2D, targetName: string): m4m.framework.transform2D;
        /**
         * 遍历 transfrom 所有子节点
         * @param t transform对象
         * @param fn 遍历检测方法 (函数 返回值 true ，中断遍历)
         * @returns
         */
        static forEachTransformTree(t: ISpTransform, fn: (value: ISpTransform) => any): any;
        /**
         * 遍历 transfrom2D 所有子节点
         * @param t transfrom2D 对象
         * @param fn 遍历检测方法 (函数 返回值 true ，中断遍历)
         * @returns
         */
        static forEachTransform2DTree(t: m4m.framework.transform2D, fn: (value: m4m.framework.transform2D) => any): any;
        /**
         * 解析 动画时间轴事件
         * @param data json 格式 ，{动画名:{时间点:[触发函数名,函数传参1,...]}}
         */
        static parseAnimTimeEvent(_animPlayH: ISpAnimPlayerHandle, data: string): void;
        /**
         * 构造一个 ImgNum 对象
         * @param templete 数值 模板对象
         */
        static makeImgNum(templete: m4m.framework.image2D, shellLayoutState?: number, tranLayoutState?: number): imgNum;
        /**
         * 构造一个 ImgNum 对象
         * @param templete 数值 模板对象
         */
        static makeImgSpriteArrange(templete: m4m.framework.image2D): imgSpriteArrange;
        /**
         * 构造一个 SequenceFrame 序列帧 对象
         * @param sfTran  最后一帧模板对象
         */
        static makeSequenceFrame(sfTran: m4m.framework.image2D): sequenceFrame;
        /**
         * 获取字典中的K-V 的数量
         * @param dic 字典对象
         */
        static getDicSubSize(dic: object): number;
        /**
         * 将相对 “当前游戏对象” 的坐标转化为基于世界坐标系的坐标
         * @param target 当前对象
         * @param point 以当前对象为基坐标的位置点
         * @param resultV3 场景世界坐标
         */
        static TransformPoint(target: ISpTransform, point: m4m.math.vector3, resultV3: m4m.math.vector3): void;
        /**
         * 异步加载预设体
         * @param dirPath 文件路径
         * @param prefabName 预设体资源名
         * @param priority 优先级 默认0
         */
        static loadPrefeb(dirPath: string, prefabName: string, priority?: number): Promise<ISpPrefab>;
        /**
         * 异步加载预设体 （微信引擎加载）
         * @param url 文件url
         */
        static loadPrefebURLWXEngin(url: string): Promise<wxPrefab>;
        /**
         * 异步加载预设体, 通过路径 + 资源名 （微信引擎加载）
         * @param dirPath
         * @param prefabName
         */
        static loadPrefebWXEngin(dirPath: string, prefabName: string): Promise<wxPrefab>;
        private static getCachePfbm4m;
        private static getCachePrefabKeyType;
        /**
         * 获取已经缓存了的 prefab资源
         * @param prefabKey 取值key
         */
        static getCachePrefabKey(prefabKey: string, eType?: engineParallelType): ISpPrefab;
        private static getPrefabKeyType;
        /**
         * 异步加载预设体, 通过路径 + 资源名 （微信引擎加载）
         * @param dirPath 文件路径
         * @param prefabName prefab名字
         */
        static getCachePrefab(dirPath: string, prefabName: string, eType?: engineParallelType): ISpPrefab;
        /**
         * 异步加载预设体 资源URL
         * @param prefabURL
         * @param priority
         */
        static loadPrefebURL(prefabURL: string, priority?: number): Promise<ISpPrefab>;
        /**
         * 获取AB包资源路径 通过URL
         * @param URL
         */
        static getABPathByURL(URL: string): string;
        /**
         * 获取资源名 通过URL
         * @param URL
         */
        static getResNameByURL(URL: string): string;
        /**
         * 同步加载 文本数据
         * @param url
         */
        static syncloadText(url: string): Promise<string>;
        private static ImgByLoad;
        /** 微信性能引擎版贴图 */
        private static ImgByLoadWX;
        /**
         * 加载贴图
         * @param url 资源RUL
         * @param callBack
         * @param needCache 是否缓存贴图对象（频繁加载的贴图推荐使用）
         */
        static loaderTextureFun(url: string, callBack: (_tex: m4m.framework.texture, _err?: any) => any, needCache?: boolean): void;
        /** 加载贴图 wx接口 */
        private static loaderTextureFunWX;
        /**
         * 加载指定类型的贴图
         * @param url 地址
         * @param callBack 回调方法
         * @param needCache 是否需要缓存
         * @param _etype 引擎类型
         */
        static loaderTextureByType(url: string, callBack: (_tex: any, _err?: any) => any, needCache?: boolean, etype?: engineParallelType): void;
        /**
         * 加载 的贴图缓存容器 , sync 版
         * @param rul
         * @param needCache 是否缓存贴图对象（频繁加载的贴图推荐使用）
         */
        static syncLoadTexture(rul: string, needCache?: boolean): Promise<m4m.framework.texture>;
        /**
        * 加载gltf 资源
        * @param gltfFolder  gltf 资源目录
        * @param file gltf 资源文件
        * @param IBLSettings IBL 的参数设置
        * @returns
        */
        static loadGLTF(gltfFolder: string, file: string, IBLSettings?: {
            exposure: number;
            specularIntensity: number;
            diffuseIntensity: number;
        }): Promise<m4m.framework.transform>;
        /**
         * 获取gltf模型对象
         * @param gltf gltf模型资源对象
         * @param gltfFolder gltf 资源文件所在目录
         * @param IBLSettings IBL 的参数设置
         */
        static getGLTFModel(gltf: m4m.framework.gltf, gltfFolder: string, IBLSettings?: {
            exposure: number;
            specularIntensity: number;
            diffuseIntensity: number;
        }): Promise<m4m.framework.transform>;
        /**
         *  卸载清理 贴图
         * @param url 需卸载原Url
         */
        static unLoadTexture(url: string): void;
        /**
         * 加载 cube 纹理
         * @param folder
         * @param images
         * @returns
         */
        static loadCubeTexture(folder: string, images?: string[]): Promise<m4m.framework.texture>;
        /**
         * 加载 cube 纹理 通过zip包
         * @param filePath zip文件完全路径
         * @param images 子图名
         * @returns
         */
        static loadCubeTextureZip(filePath: string, images?: string[]): Promise<m4m.framework.texture>;
        private static makeCubeTex;
        /**
         * 从当前 transform 遍历所有节点
         * @param tran transform对象
         * @param ergodicFun 遍历时回调方法
         */
        static ergodicTranNode<T extends m4m.framework.transform2D | m4m.framework.transform>(tran: T, ergodicFun: (tran: T) => void): void;
        /**
         * 开启 test Asset animclip 资源模式
         * @param matchStr url 识别匹配的字符串
         */
        static enableAnimclipAssetVerTest(matchStr: string): void;
        static viaShare(query: any, tdTool: any, joinTool: any): any;
        /** 缓动方法 IN => Out
         * p : 过程进度
         * MaxVal : 过程的最大值
         * mathIn : in 过程的 tween方法
         * mathOut : out 过程的 tween方法
        */
        static tweenInOut(p: number, MaxVal: number, methodIn: m4m.framework.tweenMethod, methodOut: m4m.framework.tweenMethod): number;
        static color16To10(str: string, out: m4m.math.color | m4m.math.vector4): void;
    }
}
declare module "Data/HtmlLabelText" {
    export class HtmlLabelText {
        textList: HtmlLabelData[];
        transform: m4m.framework.transform2D;
        linespace: number;
        constructor(parentTrans: m4m.framework.transform2D, lab?: m4m.framework.label);
        private static fontStart;
        private static fontEnd;
        private static fontTagEnd;
        private static fontTagList;
        private static imageStart;
        private static imageEnd;
        private static imageTagList;
        private labSize;
        private baseList;
        private transitList;
        private lineDic;
        private _list;
        private parentTrans;
        private endNum;
        private static getFontTagDataFun;
        private static getImageTagDataFun;
        setText(str: string): void;
        extractImageAttr(): void;
        extractImageAttrFun(str: string, line: number, color: m4m.math.color): void;
        extractTextAttr(): void;
        extractTextAttrFun(str: string, index: number, line: number): void;
        splitStrText(str: string, line: number): void;
        detectionTextFun(str: string, index: number): void;
        addImageData(imageName: string, line: number, color: m4m.math.color): void;
        addTextData(str: string, line: number, color: m4m.math.color): void;
        addTransitTextData(str: string, line: number, color: m4m.math.color): void;
        clear(): void;
        dispose(): void;
        private getImageNameFun;
        private getTexFun;
        private getTextColorFun;
        private getImageData;
        private getTextData;
        private getTextBaseData;
        private create;
        private getLabel;
    }
    export class HtmlLabelBaseData {
        text: string;
        line: number;
    }
    export class HtmlLabelData extends HtmlLabelBaseData {
        imageName: string;
        color: m4m.math.color;
        x: number;
        y: number;
        dispose(): void;
    }
    export class HtmlTagData {
        tagStart: string;
        tagEnd: string;
        titleTagEnd: string;
    }
}
declare module "Data/RotateComponents" {
    export class RotateComponents extends m4m.framework.behaviour2d {
        callBackFun: Function;
        timeCallBack: number;
        private angleSpeed;
        private gapTime;
        private newDaTime;
        private dnum;
        private _start;
        update(delta: number): void;
        start(): void;
        stop(): void;
    }
}
declare module "Data/ScrollRectExtend" {
    export class ScrollRectExtend extends m4m.framework.behaviour2d {
        scrollRect: m4m.framework.scrollRect;
        offsetUpY: number;
        offsetDownY: number;
        private _list;
        private worldPos;
        private worldEndPos;
        onPlay(): void;
        setList(list: any[]): void;
        upDateTrans(): void;
        private onMoveFun;
    }
}
declare module "Data/SliderComponent" {
    export class SliderComponent extends m4m.framework.behaviour2d {
        progressbar: m4m.framework.progressbar;
        btn: m4m.framework.button;
        protected _transWidth: number;
        onPlay(): void;
        set setSliderBtn(value: any);
        btnDown_event(): void;
    }
}
declare module "Data/TabData" {
    import { UIComponentBaseData } from "Data/UIComponentBaseData";
    export class TabData extends UIComponentBaseData {
        selectIcon: m4m.framework.transform2D;
        enabled: boolean;
        Clone(): TabData;
    }
}
declare module "Data/Tab" {
    import { TabData } from "Data/TabData";
    export class Tab extends m4m.framework.behaviour2d {
        protected baseData: TabData;
        get tabData(): TabData;
        set tabData(value: TabData);
        get index(): number;
        name: string;
        clickCallBackFun: Function;
        private tabClass;
        protected btn: m4m.framework.button;
        onPlay(): void;
        setTabClass(value: any): void;
        selectFun(selectbool: boolean): void;
        initData(value: any): void;
        setData(value: any): void;
        dispose(): void;
        protected pointerClickFun(): void;
    }
}
declare module "Data/TabListData" {
    import { TabData } from "Data/TabData";
    import { DirectionType } from "Data/UIComponentBaseData";
    export class TabListData {
        layoutType: DirectionType;
        offset: number;
        initXPlace: number;
        initYPlace: number;
        tabLayoutX: m4m.framework.layoutOption;
        tabLayoutY: m4m.framework.layoutOption;
        tabData: TabData;
        tab: any;
        parentTrans: m4m.framework.transform2D;
        tabName: string;
        list: any[];
    }
}
declare module "Data/TabList" {
    import { TabListData } from "Data/TabListData";
    export class TabList {
        set visible(value: boolean);
        get tabListData(): TabListData;
        set SelectIndex(value: number);
        selectCallBackFun: Function;
        name: string;
        constructor(base: TabListData);
        private baseData;
        private _list;
        private _width;
        private _height;
        private downFun;
        create(): void;
        setList(dataList: any[]): void;
        getWidth(): number;
        getHeight(): number;
        dispose(): void;
        private tab_singleClickHandler;
    }
}
declare module "Data/ViewBaseData" {
    export interface ViewBaseData {
        dispose(): any;
    }
}
declare module "Data/aStar" {
    /**
     * A* pathFind Pathfinding Algorithm
     */
    export class aStar {
        /**
         * 外部 合法验证接口
         * Verify the validity of this coordinate externally , if validity need return "true"
         * @argument x x of coordinate
         * @argument y y of coordinate
         */
        outFilter: (x: number, y: number) => boolean;
        private openList;
        private closeList;
        private endx;
        private endy;
        private cupPoints;
        /**
         * 寻找获取 start点 到 end点 的最短路径 ，计算返回是否成功 ， outPath ： 路径坐标数组[x,y,x1,y1...]
         * Find the shortest path between "start" "end" two points
         *
         * @argument start_x coordinate x of Start Point
         * @argument start_y coordinate y of Start Point
         * @argument end_x coordinate y of End Point
         * @argument end_y coordinate y of End Point
         * @argument outPath Calculation result of Path , format is [x,y,x1,y1,x2,y2.........]
         */
        findPath(start_x: number, start_y: number, end_x: number, end_y: number, outPath: number[]): boolean;
        private calcH;
        private findAddNeighbor;
        private filterNeighbor;
        private listHas;
    }
}
declare module "Data/rtree" {
    /******************************************************************************
        rtree.js - General-Purpose Non-Recursive Javascript R-Tree Library
        Version 0.6.2, December 5st 2009
    
      Copyright (c) 2009 Jon-Carlos Rivera
      
      Permission is hereby granted, free of charge, to any person obtaining
      a copy of this software and associated documentation files (the
      "Software"), to deal in the Software without restriction, including
      without limitation the rights to use, copy, modify, merge, publish,
      distribute, sublicense, and/or sell copies of the Software, and to
      permit persons to whom the Software is furnished to do so, subject to
      the following conditions:
      
      The above copyright notice and this permission notice shall be
      included in all copies or substantial portions of the Software.
      
      THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
      MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
      NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
      LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
      OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
      WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    
        Jon-Carlos Rivera - imbcmdth@hotmail.com
    ******************************************************************************/
    type Rect = {
        x: number;
        y: number;
        w: number;
        h: number;
    };
    /**
     * RTree - A simple r-tree structure for great results.
     * @constructor
     */
    export class RTree {
        constructor(width: any);
        private _MinWidth;
        private _MaxWidth;
        private _T;
        private idCache;
        private hitStack;
        private hsBuoy;
        get_tree(): {
            x: number;
            y: number;
            w: number;
            h: number;
            id: string;
            nodes: any[];
        };
        set_tree(newTree: any, _where: any): any;
        search(rect: Rect, returnNode: boolean, returnArray: any[]): any;
        /**
         * 拓展搜索方法 （返回 索引列表长度）
         * @param rect 搜索矩形范围
         * @param out 返回的索引列表
         */
        searchExtend(rect: Rect, out: any[]): number;
        toJSON(rect: any, tree: any): string;
        remove(rect: any, obj: any): any;
        insert(rect: Rect, obj: any): void;
        private isArray;
        private _name_to_id;
        private _removeSubtree;
        private _choose_leaf_subtree;
        private _linear_split;
        private _pick_next;
        private _pick_linear;
        private _attach_data;
        private _search_subtree;
        private _insert_subtree;
        private _search_subtreeExtend;
    }
}
declare module "Loader/otherPlan/CombineLoader" {
    import { Loader } from "Loader/otherPlan/Loader";
    export class CombineLoader {
        fileCount: number;
        fileLoadedCount: number;
        sucessProgress: number;
        progress: number;
        private list;
        private callback;
        add(url: string, callback: Function, progress: Function): Loader;
        loaderEnd(loader: Loader): void;
        start(): void;
        LoadProgress(progress: number, fileLoadedCount: number, fileCount: number, bytesLoaded: number, bytesTotal: number): void;
    }
}
declare module "Loader/otherPlan/dataType/key" {
    export class key {
        static classType: typeof key;
        inTangent: number;
        outTangent: number;
        time: number;
        value: number;
    }
}
declare module "Loader/otherPlan/dataType/AnimationCurve1" {
    import { key } from "Loader/otherPlan/dataType/key";
    export class AnimationCurve1 {
        static classType: typeof AnimationCurve1;
        postWrapMode: number;
        preWrapMode: number;
        keys: key[];
    }
}
declare module "Loader/otherPlan/dataType/AssetBundle" {
    import { cMap } from "Data/Map";
    import { AssetBundleFileInfo } from "Loader/otherPlan/dataType/AssetBundleFileInfo";
    export class AssetBundlea {
        static classType: typeof AssetBundlea;
        className: string;
        fileName: string;
        pathName: string;
        fileSize: cMap<number>;
        files: AssetBundleFileInfo[];
        totalLength: number;
        version: string;
        createtime: string;
    }
}
declare module "Loader/otherPlan/dataType/alphaKey" {
    export class alphaKey {
        static classType: typeof alphaKey;
        alpha: number;
        time: number;
    }
}
declare module "Loader/otherPlan/dataType/colorKey" {
    export class colorKey {
        static classType: typeof colorKey;
        color: m4m.math.color;
        time: number;
    }
}
declare module "Loader/otherPlan/dataType/Gradient" {
    import { alphaKey } from "Loader/otherPlan/dataType/alphaKey";
    import { colorKey } from "Loader/otherPlan/dataType/colorKey";
    export class Gradient {
        static classType: typeof Gradient;
        mode: number;
        alphaKeys: alphaKey[];
        colorKeys: colorKey[];
    }
}
declare module "Loader/otherPlan/dataType/ParticleSystem" {
    import { Gradient } from "Loader/otherPlan/dataType/Gradient";
    import { AnimationCurve1 } from "Loader/otherPlan/dataType/AnimationCurve1";
    import { AssetBundleFileInfo } from "Loader/otherPlan/dataType/AssetBundleFileInfo";
    export class ParticleSystem extends AssetBundleFileInfo {
        static classType: typeof ParticleSystem;
        main: ParticleMainModule;
        emission: ParticleEmissionModule;
        shape: ParticleShapeModule;
        velocityOverLifetime: ParticleVelocityOverLifetimeModule;
        limitVelocityOverLifetime: ParticleLimitVelocityOverLifetimeModule;
        inheritVelocity: ParticleInheritVelocityModule;
        forceOverLifetime: ParticleVelocityOverLifetimeModule;
        colorOverLifetime: ColorBySpeed;
        colorBySpeed: ColorBySpeed;
        sizeOverLifetime: SizeOverLifetime;
        sizeBySpeed: SizeOverLifetime;
        rotationOverLifetime: SizeOverLifetime;
        rotationBySpeed: SizeOverLifetime;
        noise: Noise;
        textureSheetAnimation: TextureSheetAnimation;
    }
    class ParticleMainModule {
        static classType: typeof ParticleMainModule;
        duration: number;
        loop: boolean;
        prewarm: boolean;
        startDelay: MinMaxCurve;
        startLifetime: MinMaxCurve;
        startSpeed: MinMaxCurve;
        useStartSize3D: boolean;
        useStartRotation3D: boolean;
        startSize: MinMaxCurve;
        startSizeX: MinMaxCurve;
        startSizeY: MinMaxCurve;
        startSizeZ: MinMaxCurve;
        gravityModifier: MinMaxCurve;
        maxParticles: number;
        playOnAwake: boolean;
        randomizeRotationDirection: number;
        scalingMode: number;
        simulationSpace: number;
        simulationSpeed: number;
        startColor: MinMaxGradient;
        startRotation: MinMaxCurve;
        startRotationX: MinMaxCurve;
        startRotationY: MinMaxCurve;
        startRotationZ: MinMaxCurve;
    }
    class MinMaxCurve {
        static classType: typeof MinMaxCurve;
        constant: number;
        constantMax: number;
        constantMin: number;
        curve: AnimationCurve1;
        curveMax: AnimationCurve1;
        curveMin: AnimationCurve1;
        curveMultiplier: number;
        mode: number;
    }
    class MinMaxGradient {
        static classType: typeof MinMaxGradient;
        color: m4m.math.color;
        colorMax: m4m.math.color;
        colorMin: m4m.math.color;
        gradient: Gradient;
        gradientMax: Gradient;
        gradientMin: Gradient;
    }
    class ParticleEmissionModule {
        static classType: typeof ParticleEmissionModule;
        enabled: boolean;
        rateOverDistance: MinMaxCurve;
        rateOverTime: MinMaxCurve;
        bursts: burst[];
    }
    class burst {
        static classType: typeof burst;
        cycleCount: number;
        maxCount: number;
        minCount: number;
        repeatInterval: number;
        time: number;
    }
    class ParticleShapeModule {
        static classType: typeof ParticleShapeModule;
        alignToDirection: boolean;
        angle: number;
        arc: number;
        arcMode: number;
        arcSpeed: MinMaxCurve;
        arcSpread: number;
        box: m4m.math.vector3;
        enabled: boolean;
        length: number;
        radius: number;
        radiusMode: number;
        radiusSpeed: MinMaxCurve;
        radiusSpread: number;
        randomDirectionAmount: number;
        shapeType: number;
        sphericalDirectionAmount: number;
    }
    class ParticleVelocityOverLifetimeModule {
        static classType: typeof ParticleVelocityOverLifetimeModule;
        enabled: boolean;
        space: number;
        x: MinMaxCurve;
        y: MinMaxCurve;
        z: MinMaxCurve;
    }
    class ParticleLimitVelocityOverLifetimeModule {
        static classType: typeof ParticleLimitVelocityOverLifetimeModule;
        dampen: number;
        enabled: boolean;
        limit: MinMaxCurve;
        limitX: MinMaxCurve;
        limitY: MinMaxCurve;
        limitZ: MinMaxCurve;
        separateAxes: boolean;
        space: number;
    }
    class ParticleInheritVelocityModule {
        static classType: typeof ParticleInheritVelocityModule;
        enabled: boolean;
        curve: MinMaxCurve;
        mode: number;
    }
    class ColorBySpeed {
        static classType: typeof ColorBySpeed;
        color: MinMaxGradient;
        enabled: boolean;
        range: m4m.math.vector2;
    }
    class SizeOverLifetime {
        static classType: typeof SizeOverLifetime;
        enabled: boolean;
        range: m4m.math.vector2;
        separateAxes: boolean;
        size: MinMaxCurve;
        x: MinMaxCurve;
        y: MinMaxCurve;
        z: MinMaxCurve;
    }
    class Noise {
        static classType: typeof Noise;
        enabled: boolean;
        damping: boolean;
        frequency: number;
        octaveCount: number;
        octaveMultiplier: number;
        octaveScale: number;
        quality: number;
        remap: MinMaxCurve;
        remapEnabled: boolean;
        remapMultiplier: number;
        remapX: MinMaxCurve;
        remapXMultiplier: number;
        remapY: MinMaxCurve;
        remapYMultiplier: number;
        remapZ: MinMaxCurve;
        remapZMultiplier: number;
        scrollSpeed: MinMaxCurve;
        scrollSpeedMultiplier: number;
        separateAxes: boolean;
        strength: MinMaxCurve;
        strengthMultiplier: number;
        strengthX: MinMaxCurve;
        strengthXMultiplier: number;
        strengthY: MinMaxCurve;
        strengthYMultiplier: number;
        strengthZ: MinMaxCurve;
        strengthZMultiplier: number;
    }
    class TextureSheetAnimation {
        static classType: typeof TextureSheetAnimation;
        animation: number;
        cycleCount: number;
        enabled: boolean;
        flipU: number;
        flipV: number;
        frameOverTime: MinMaxGradient;
        numTilesX: number;
        numTilesY: number;
        rowIndex: number;
        startFrame: MinMaxGradient;
        useRandomRow: boolean;
        uvChannelMask: number;
    }
}
declare module "Loader/otherPlan/dataType/exC2DComponent" {
    export class exC2DComponent {
        static classType: typeof exC2DComponent;
        cmop: string;
    }
}
declare module "Loader/otherPlan/dataType/Prefab2D" {
    import { AssetBundleFileInfo } from "Loader/otherPlan/dataType/AssetBundleFileInfo";
    import { exC2DComponent } from "Loader/otherPlan/dataType/exC2DComponent";
    export class Prefab2D extends AssetBundleFileInfo {
        static classType: typeof Prefab2D;
        className: string;
        prefab: string;
        layer: number;
        tag: string;
        tranName: string;
        isStatic: boolean;
        children: Prefab2D[];
        width: number;
        height: number;
        pivot: m4m.math.vector2;
        _visible: boolean;
        localTranslate: m4m.math.vector2;
        localScale: m4m.math.vector2;
        localRotate: number;
        isMask: boolean;
        layoutState: number;
        layoutPercentState: number;
        layoutValueMap: numberdic;
        insid: number;
        components: exC2DComponent[];
    }
    class numberdic {
        static classType: typeof numberdic;
        n1: number;
        n2: number;
        n4: number;
        n8: number;
        n16: number;
        n32: number;
    }
    export class Border {
        static classType: typeof Border;
        l: number;
        t: number;
        r: number;
        b: number;
    }
}
declare module "Loader/otherPlan/dataType/f14EffectSystem" {
    import { AssetBundleFileInfo } from "Loader/otherPlan/dataType/AssetBundleFileInfo";
    export class f14EffectSystem extends AssetBundleFileInfo {
        static classType: typeof f14EffectSystem;
        className: string;
        Name: string;
        lifeTime: number;
        beloop: boolean;
        layers: layer[];
    }
    class layer {
        static classType: typeof layer;
        Name: string;
        type: string;
        singlemeshdata: Singlemeshdata;
        frames: frame[];
    }
    class Singlemeshdata {
        static classType: typeof Singlemeshdata;
        mesh: string;
        material: string;
        position: string;
        scale: string;
        euler: string;
        color: string;
        tex_ST: string;
        enableTexAnimation: boolean;
        uvType: string;
        uSpeed: number;
        vSpeed: number;
        row: number;
        column: number;
        count: number;
        beBillboard: boolean;
        bindAxis: string;
    }
    class frame {
        static classType: typeof frame;
        frameindex: number;
        vec3Atts: att[];
        vec4Atts: att[];
        colorAtts: att[];
    }
    class att {
        static classType: typeof att;
        name: string;
        value: string;
    }
}
declare module "PSDUI/UiDataManager" {
    export class UiDataManager {
        private static uiLabelBinders;
        /**清除所有Label绑定 */
        static clearAllBindLabels(): void;
        /**
         * 清除指定绑定名下所有Label绑定
         * @param bindName 绑定名
         */
        static clearBindLabels(bindName: string): void;
        /**
         * 将已有的绑定信息加入Label绑定列表
         * @param binder 绑定信息
         */
        static addBindLabl(binder: labelBinder): any;
        /**
         * 添加一个新的Label绑定
         * @param bindName 绑定变量名
         * @param bindlabel 绑定的label组件
         * @param bindText 绑定的文字结构（文字中 {0} 作为标识，{0} 会替换为被绑定的数据，如果没有 {0} 则会将被绑定的数据添加到最后，如果不指定就全部替换为被绑定的数据）
         * @returns 绑定信息
         */
        static bindLabelData(bindName: string, bindlabel: m4m.framework.label, bindText?: string): labelBinder;
        private static needUnBindLabelList;
        /**
         * 修改Label信息
         * @param bindName 绑定变量名
         * @param text 传入信息
         */
        static changeLabelData(bindName: string, text: string): void;
        /**
         * 清除一个Label绑定
         * @param binder 绑定信息
         */
        static unBindLabelDataByBinder(binder: labelBinder): void;
        /**
         * 清除一个Label绑定
         * @param bindName 绑定变量名
         */
        static unBindLabelData(bindName: string, bindlabel: m4m.framework.label): void;
        private static uiTranBinders;
        /**清除所有Tran绑定 */
        static clearAllBindTrans(): void;
        /**
         * 清除指定绑定名下所有Tran绑定
         * @param bindName 绑定名
         */
        static clearBindTrans(bindName: string): void;
        /**
         * 将已有的绑定信息加入Tran绑定列表
         * @param binder 绑定信息
         */
        static addBindTrans(binder: tran2DBinder): any;
        /**
         * 添加一个新的Tran绑定
         * @param bindName 绑定变量名
         * @param bindTran 绑定的trans组件
         * @returns 绑定信息
         */
        static bindTransData(bindName: string, bindTran: m4m.framework.transform2D): tran2DBinder;
        private static needUnBindTransList;
        /**
         * 修改Tran信息
         * @param bindName 绑定变量名
         * @param isVisible 是否显示
         */
        static changeTransData(bindName: string, isVisible: boolean): void;
        /**
         * 清除一个Tran绑定
         * @param binder 绑定信息
         */
        static unBindTransDataByBinder(binder: tran2DBinder): void;
        /**
         * 清除一个Trans绑定
         * @param bindName 绑定变量名
         */
        static unBindTransData(bindName: string, bindTran: m4m.framework.transform2D): void;
        private static functionBinders;
        /**清除所有Function绑定 */
        static clearAllBindFunction(): void;
        /**
         * 清除指定绑定名下所有Function绑定
         * @param bindName 绑定名
         */
        static clearBindFunction(bindName: string): void;
        /**
         * 将已有的绑定信息加入Function绑定列表
         * @param binder 绑定信息
         */
        static addBindFunction(binder: FunctionBinder): any;
        /**
         * 添加一个新的Function绑定
         * @param bindName 绑定变量名
         * @param fun function
         * @returns 绑定信息
         */
        static bindFunctionData(bindName: string, fun: Function): FunctionBinder;
        private static needUnBindFunctionList;
        /**
         * 修改Function信息
         * @param bindName 绑定变量名
         * @param data
         */
        static changeFunctionData(bindName: string, data: any): void;
        /**
         * 清除一个Function绑定
         * @param binder 绑定信息
         */
        static unBindFunctionDataByBinder(binder: FunctionBinder): void;
        /**
         * 清除一个Function绑定
         * @param bindName 绑定变量名
         */
        static unBindFunctionData(bindName: string, fun: Function): void;
    }
    export class labelBinder {
        linkName: string;
        linkText: string;
        linkLabel: m4m.framework.label;
    }
    export class tran2DBinder {
        linkName: string;
        linkTran: m4m.framework.transform2D;
    }
    export class FunctionBinder {
        linkName: string;
        linkFun: Function;
    }
}
declare module "PSDUI/newLoadTools" {
    export class newLoadTools {
        static urlCaseDic: {
            [url: string]: number;
        };
        static retryTime: number;
        static retryCount: number;
        /**
         *
         * @param url 加载路径
         * @param fun 加载结果回调函数
         * @param onprocess 加载进度
         * @param loadedFun 正常加载完成后回调
         */
        static xhrLoad(url: string, fun: (ContentData: any, _err: Error, isloadFail?: boolean) => void, onprocess: (curLength: number, totalLength: number) => void, responseType: XMLHttpRequestResponseType, loadedFun: (req: XMLHttpRequest) => void): void;
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 加载text资源
         * @param url 加载路径
         * @param fun 加载结果回调函数
         * @param onprocess 加载进度
         * @version m4m-m4m 1.0
         */
        static loadJson(url: string, fun: (_txt: string, _err: Error, isloadFail?: boolean) => void, onprocess?: (curLength: number, totalLength: number) => void): void;
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 加载arraybuffer资源
         * @param url 加载路径
         * @param fun 加载结果回调函数
         * @param onprocess 加载进度
         */
        static loadArrayBuffer(url: string, fun: (_bin: ArrayBuffer, _err: Error, isloadFail?: boolean) => void, onprocess?: (curLength: number, totalLength: number) => void): void;
    }
}
declare module "PSDUI/newLoader" {
    import { cMap } from "Data/Map";
    import { LoadType } from "PSDUI/newLoaderManager";
    export class newLoader {
        static _loadJson(url: string, fun: (_txt: string, _err: Error, isloadFail?: boolean) => void, onprocess?: (curLength: number, totalLength: number) => void): void;
        static _loadImg(url: string, cb: (img: any, _err: any) => void): void;
        id: number;
        endFunction: Function;
        loaderEvents: CallBackData[];
        url: string;
        priority: number;
        timeoutCount: number;
        timeout: number;
        userCount: number;
        progress: number;
        bytesLoaded: number;
        bytesTotal: number;
        timer: cMap<number>;
        fileCount: number;
        fileLoadedCount: number;
        loaderType: LoadType;
        bin: any;
        constructor();
        private _progressCallBack;
        private removeList;
        load(): any;
        dispose(): void;
        addProgressCallBack(value: Function): void;
        addCallBack(callBack: Function, obj: any): void;
        removeCallBack(callBack: Function): void;
    }
    class CallBackData {
        callback: Function;
        data: any;
        dispose(): void;
    }
}
declare module "PSDUI/newLoaderManager" {
    import { newLoader } from "PSDUI/newLoader";
    import { cMap } from "Data/Map";
    export enum ResLoadType {
        NONE = 0,
        SCENE = 1
    }
    export enum LoadType {
        ARRAYBUFFER = 0,
        JSON = 1,
        IMAGE = 2
    }
    export class newLoaderManager {
        static get Instance(): newLoaderManager;
        static loaderCount: number;
        loaders: cMap<newLoader>;
        currentLoaders: newLoader[];
        waitLoaders: newLoader[];
        constructor();
        private static instance;
        private index;
        private loadFailBackList;
        load(url: string, onLoadFinished: Function, data?: any, loadType?: LoadType): newLoader;
        startLoader(): void;
        loaderEnd(loader: newLoader): void;
        addLoader(loader: newLoader): void;
        removeLoader(url: string): void;
        addFail(loader: newLoader): void;
        private getNextLoader;
        private failBackFun;
    }
}
declare module "PSDUI/combinNewLoader" {
    import { newLoader } from "PSDUI/newLoader";
    enum LoadType {
        ARRAYBUFFER = 0,
        JSON = 1,
        IMAGE = 2
    }
    export class combinNewLoader {
        fileCount: number;
        fileLoadedCount: number;
        sucessProgress: number;
        progress: number;
        private list;
        private loadedFile;
        private loadCallBack;
        private progressCallback;
        add(url: string, callback: Function, type?: LoadType): void;
        loaderEnd(loader: newLoader, file: any): void;
        start(callback?: Function): void;
        LoadProgress(progress: number, fileLoadedCount: number, fileCount: number, bytesLoaded: number, bytesTotal: number): void;
    }
}
declare module "PSDUI/newUiBase" {
    import { labelBinder, tran2DBinder } from "PSDUI/UiDataManager";
    import { uiLayerType } from "PSDUI/UiManager";
    export class newUiBase {
        static signArr: string[];
        static pages: newUiBase[];
        static downlayerPages: newUiBase[];
        static baselayerPages: newUiBase[];
        static midlayerPages: newUiBase[];
        static highlayerPages: newUiBase[];
        static poplayerPages: newUiBase[];
        uiName: string;
        isShow: boolean;
        isInited: boolean;
        linkList: labelBinder[];
        tranLinkList: tran2DBinder[];
        transform: m4m.framework.transform2D;
        /**其他面板show 时 不隐藏 */
        notHideOnOtherShow: boolean;
        /**打开时不影响其他uiPage */
        noAffected: boolean;
        uiLayer: uiLayerType;
        /**当前UI是否会被记录 (用于返回上一步打开) */
        isLogUi: boolean;
        /** 当前UI是否会影响场景玩家操作 */
        influenceSceneAction: boolean;
        /**隐藏UI事件 */
        onHide: () => any;
        /**打开UI事件 */
        onShow: () => any;
        /**销毁UI事件 */
        onDispose: () => any;
        /**初始化UI事件 */
        onInite: () => any;
        private static needHidePageList;
        onInit(): void;
        show(): void;
        hide(): void;
        openLastUI(): string;
        getLastUI(): string;
        dispose(): void;
        private init;
        private static hideLayerAll;
        private getParent;
        private pushToLayer;
        private outLayer;
        private unbind;
        private bind;
    }
}
declare module "Tools/consTool" {
    /** system 编译模式 ， 类对象扫描 收集工具 */
    export class consTool {
        static init(): void;
        /** 标准 systemJs 使用 */
        private static scanAllUsercode;
        /** 小青 版systemJs 使用 */
        private static scan_new;
    }
}
declare module "PSDUI/UiManager" {
    import { metaUIManager } from "UIBase/metaUIManager";
    import { newUiBase } from "PSDUI/newUiBase";
    class UiManagerEventer extends m4m.AEvent {
    }
    /**
     * UI 管理类 （type2）
     */
    export class UiManager extends metaUIManager {
        /** 创建UI 事件 */
        static readonly ON_CREATE_UI = "onCreateUI";
        /** UI显示（show）事件 */
        static readonly ON_SHOW_UI = "onShowUI";
        /** UI隐藏（hide）事件 */
        static readonly ON_HIDE_UI = "onHideUI";
        static startLoadCallBack: Function;
        static endLoadCallBack: Function;
        static dontDisposeUIList: string[];
        private static scene;
        private static nowLoadingMap;
        private static uiMap;
        private static viewName;
        private static jsonList;
        private static _eventer;
        /** uiManager 事件 控制对象 */
        static get eventer(): UiManagerEventer;
        static hideLayerAll(layer: uiLayerType): void;
        static hideAllUi(without?: string): void;
        protected static uiRoot: m4m.framework.transform2D;
        static getUiRootTest(): m4m.framework.transform2D;
        protected static isInited: boolean;
        protected static uiLogList: string[];
        protected static logLimit: number;
        protected static logUiNow: boolean;
        protected static logUi(UIName: string): void;
        static openLastUI(uiName: string, isOpenUI?: boolean): string;
        /**
         * 获取UI当前 初始化 状态
         * @param uiClassName UI名字
         * @returns UI当前是否已经初始化
         */
        static isUiInited(uiClassName: string): boolean;
        /**
         * 获取UI当前显示状态
         * @param uiClassName UI名字
         * @returns UI当前是否显示
         */
        static isUiShow(uiClassName: string): boolean;
        /**
         * 加载UI
         * @param uiClassName UI名字
         * @param coverLayer 覆盖 UI 放置到的层级设定
         * @param notHideOnOtherShow 其他UI打开时，自己不会被隐藏
         * @param oninit 初始化方法
         */
        static InitUi(uiClassName: string, oninit?: () => void): void;
        /**
         * 显示UI
         * @param uiClassName UI名字
         * @param coverLayer 覆盖 UI 放置到的层级设定
         * @param notHideOnOtherShow 其他UI打开时，自己不会被隐藏
         * @param oninit 初始化方法
         */
        static showUi(uiClassName: string, oninit?: () => void, needCallBack?: boolean): void;
        /**
         * 隐藏UI
         * @param uiClassName UI名字
         */
        static hideUi(uiClassName: string): void;
        /**
        * 销毁UI
        * @param uiClassName UI类名字
        */
        static disposeUi(uiClassName: string): void;
        /**
        * 隐藏时 销毁UI 通用 直接在UI hide时会被调用
        * @param uiClassName UI类名字
        */
        static OnHideDisposeUi(uiClassName: string): void;
        /**
         * 获取UI对象
         * @param uiClass UI类 对象
         * @param isShowUi 是否显示UI
         * @param callBack 获取UI后回调
         * @param oninit 初始化方法
         * @param coverLayer 覆盖 UI 放置到的层级设定
         * @param notHideOnOtherShow 其他UI打开时，自己不会被隐藏
         */
        static getUi<T extends newUiBase>(uiClassName: string, isShowUi: boolean, callBack: (uiObj: T) => void, oninit: () => void): void;
        static init(uiWidth: number, uiHeight: number, screenMatchRate: number, uiPrefabPath: string, atlasPath: string): void;
        private static setCreatUi;
        private static creatUi;
        private static referenceComps;
        private static setCompsToTran2D;
        private static makeTran;
        private static makeAComp2D;
        private static referenceComp;
    }
    export enum uiLayerType {
        downlayer = -1,
        baselayer = 0,
        midlayer = 1,
        highlayer = 2,
        poplayer = 3
    }
}
declare module "RPC/RpcServerCall" {
    export class RpcServerCall {
        static uid: string;
        static errorState: boolean;
        static OnError: (e: any) => void;
        static Init(): void;
        static CallScript(path: any, method: any, ...params: any[]): Promise<any>;
        static CallScriptRetCls<T>(ctor: any, path: string, method: string, ...params: any[]): Promise<T>;
        static CallScriptHttp(path: any, method: any, ...params: any[]): Promise<any>;
        static CallUserScriptHttp(uid: any, path: any, method: any, ...params: any[]): Promise<any>;
    }
}
declare module "RPC/RPCManager" {
    export interface IRPCCallRsult {
        IsSuccess: boolean;
        message: string;
        result: any;
    }
    /**
     * 同步对象装饰器
     * 实现此装饰器的对象会附加 sync[从服务器同步到本地],save[保存到服务器] 这两个方法
     * @param constructor
     */
    export function SyncObject(constructor: any): void;
    export class RPCManager {
        static Init(): void;
        static sock: WebSocket;
        static pidIndex: number;
        static syncPidIndex: number;
        /**
         * 调用RPC超时时间
         */
        static timeOut: number;
        static httpApi: string;
        static callMap: {
            [pid: number]: {
                cleanID: number;
                resolve(value?: any): void;
                reject(reason?: any): void;
            };
        };
        static syncMap: {
            [pid: number]: {
                cleanID: number;
                obj: any;
                resolve(value?: any): void;
                reject(reason?: any): void;
            };
        };
        static ptlHandles: {
            [ptplNum: number]: Function;
        };
        static serverCallMap: {
            [key: string]: Function;
        };
        static RegHandle(key: string, func: Function): void;
        static Send<T>(method: string, ...params: any[]): Promise<T>;
        static SendHttp<T>(method: string, ...params: any[]): Promise<T>;
        static SendHttpSimple(url: string, method: string, params?: any): Promise<any>;
        static Filter(e: any): boolean;
        private static RPCSCallHandle;
        private static RPCCallResultHandle;
        private static SyncResultHandle;
        private static SaveResultHandle;
        private static ListCountHandle;
        private static ListHandle;
        /**
         * 请求和服务器同步数据
         * @param obj 需要同步的对象
         * @param fields 需要同步的字段
         */
        static SyncObject(obj: any, fields: string[]): Promise<void>;
        static SyncObjectWS(obj: any, fields: string[]): Promise<void>;
        static SyncObjectHttp(obj: any, fields: string[]): Promise<void>;
        /**
         * 保存数据到服务器
         * @param obj 需要保存的对象
         * @param fields 需要保存的字段
         */
        static SaveObject(obj: any, fields: string[]): Promise<void>;
        static SaveObjectWS(obj: any, fields: string[]): Promise<void>;
        static SaveObjectHttp(obj: any, fields: string[]): Promise<void>;
        /**
        * 获取数据数量
        */
        static GetlistCount(name: string): Promise<number>;
        static GetlistCountWS(name: string): Promise<number>;
        static GetlistCountHttp(name: string): Promise<number>;
        /**
        * 获取列表数据
        * @param offset 从什么位置获取 默认值:0
        * @param count 指定需要保存的字段 例如["name","desc"]
        */
        static Getlist(ctor: any, offset?: number, count?: number): Promise<any>;
        static GetlistWS(ctor: any, offset?: number, count?: number): Promise<unknown>;
        static GetlistHttp<T>(ctor: any, offset?: number, count?: number): Promise<T[]>;
    }
}
declare module "RPC/RPCApi" {
    /**
    * RPC输入输出类
    */
    export class RPCMethods {
        /**
        * 调用脚本方法 c->s
        * @param scriptPath
        * @param method
        * @param args
        * @returns any
        */
        static CallScript_websocket(scriptPath: string, method: string, args: any[]): Promise<any>;
        /**
        * 调用脚本 c->s
        * @param scriptPath
        * @param method
        * @param args
        * @returns any
        */
        static CallScript_http(scriptPath: string, method: string, args: any[]): Promise<any>;
        /**
        * 用户脚本 c->s
        * @param uid
        * @param scriptPath
        * @param method
        * @param args
        * @returns any
        */
        static CallUserScript_http(uid: string, scriptPath: string, method: string, args: any[]): Promise<any>;
        /**
        * 用户变量 c->s
        * @param uid
        * @param varname
        * @returns any
        */
        static GetUserVar_http(uid: string, varname: string): Promise<any>;
        static Init(): void;
    }
}
declare module "Scripts/CameraFollowCtr" {
    import { ISpCustomComp, ISpGameObject, ISpTransform } from "Tools/engineParallel/spInterface";
    export class CameraFollowCtr implements ISpCustomComp {
        protected _target: ISpTransform;
        protected _helpPointTarget: ISpTransform;
        protected _lookAtPoint: m4m.math.vector3;
        protected _targetOffset: m4m.math.vector3;
        protected _distance: number;
        minPanAngle: number;
        maxPanAngle: number;
        minTileAngle: number;
        maxTileAngle: number;
        get distance(): number;
        set distance(v: number);
        protected _panAngle: number;
        /** 平移角度 */
        get panAngle(): number;
        set panAngle(v: number);
        protected _tiltAngle: number;
        protected _tiltRadian: number;
        /** 倾斜角 */
        get tiltAngle(): number;
        set tiltAngle(v: number);
        protected _lookDir: m4m.math.vector3;
        protected _pause: boolean;
        enabled: boolean;
        gameObject: ISpGameObject;
        onPlay(): void;
        remove(): void;
        start(): void;
        /**
         * 设置 相机的观察目标点
         * @param position 观察目标点
         */
        setTargetPoint(position: m4m.math.vector3): void;
        /**
         * 获取 实际跟随目标点
         * @param outPos 获取的目标点
         */
        getRealLookPoint(outPos: m4m.math.vector3): void;
        /**
         * 设置 相机的观察目标
         * @param target 观察目标
         */
        setTarget(target: ISpTransform): void;
        /**
         * 设置 相机的观察目标的偏移量
         * @param x 坐标x
         * @param y 坐标y
         * @param z 坐标z
         */
        setTargetOffset(x: number, y: number, z: number): void;
        /**
         *  暂停跟随运动
         * @param value
         */
        pause(value: boolean): void;
        update(delta: number): void;
        /**
         * 计算一步相机的跟随。
         */
        step(): void;
        /**
         * 计算 目标点指向相机的 方向
         * @param out 返回的方向
         */
        calCamZDir(out: m4m.math.vector3): void;
        protected calCameraDisAndLook(): void;
        protected calCamDis(): void;
        protected DoLookAtPoint(): void;
        protected calCameraPos(): void;
    }
}
declare module "Time/CDManage" {
    import { CDData } from "Time/CDData";
    export class CDManage {
        static get Instance(): CDManage;
        currentSkillID: number;
        pingtimeStart: number;
        timeQuality: number;
        constructor();
        private static instance;
        private _serverTime;
        private _initGameTime;
        private cdData;
        remainTime(futureTime: number): number;
        serverTime(): number;
        serverSecondsTime(): number;
        setServerTime(v: number): void;
        getTimer(): number;
        startCDTime(cdID: number, time: number, cdTime1?: number): void;
        Update(): void;
        isCDing(cdID: number): boolean;
        stopCD(id: number): void;
        getCDdata(cdID: number): CDData;
    }
}
declare module "Time/CDData" {
    import { Dictionary } from "Data/Dictionary";
    export class CDData {
        showLog: boolean;
        list: Dictionary;
        cdID: number;
        startTime: number;
        endTime: number;
        cdTime: number;
        cdUpdate(): void;
        GetCDPercentage(): number;
    }
}
declare module "Time/FrameTimer" {
    export class FrameTimer {
        static get Instance(): FrameTimer;
        private static init;
        private static _instance;
        private nodeDic;
        private removeList;
        /** 暂停计时 */
        stop(timeId: number): void;
        /** 计时一次
         * time 等待时间
         * DoFun delat 帧间隔时间 、isEnd 是否是结束 、tick 间隔滴答（loop 模式才有）
         */
        once(endTime: number, DoFun: (delat: number, isEnd: boolean, tick: boolean) => any): number;
        /** 计时一次
         * time 循环时间间隔
         * DoFun delat 帧间隔时间 、isEnd 是否是结束 、tick 间隔滴答（loop 模式才有）
         */
        loop(tickTime: number, DoFun: (delat: number, isEnd: boolean, tick: boolean) => any): number;
        private update;
    }
}
declare module "Tools/DebugLineTool2d" {
    /** 调试 线条绘制工具 */
    export class DebugLineTool2d {
        static init(rootNode: m4m.framework.transform2D): void;
        /**
         * 绘制线段
         * @param start 起始点
         * @param end 结束点
         * @param thickness 线段宽度
         * @param colorId 线段颜色[0:红 , 1:橙  ,2:黄 ,3:绿 ,4:青 ,5:蓝 ,6:紫 ,7:白,8:黑 ,9:灰]
         * @param alpha 透明值 0 - 1
         */
        static drawLine(start: m4m.math.Ivec2, end: m4m.math.Ivec2, thickness?: number, colorId?: number, alpha?: number): void;
        /**
         * 绘制几何图形 通过 所有点
         * @param points 路径点
         * @param thickness 线段宽度
         * @param colorId 线段颜色[0:红 , 1:橙  ,2:黄 ,3:绿 ,4:青 ,5:蓝 ,6:紫 ,7:白,8:黑 ,9:灰]
         * @param isSeal 是否封闭
         * @param alpha 透明值 0 - 1
         */
        static drawPoints(points: m4m.math.Ivec2[], thickness?: number, colorId?: number, alpha?: number, needClose?: boolean): void;
        /**
         * 绘制圆形
         * @param pos 圆中心点
         * @param radius 圆半径
         * @param thickness 线段宽度
         * @param colorId 线段颜色[0:红 , 1:橙  ,2:黄 ,3:绿 ,4:青 ,5:蓝 ,6:紫 ,7:白,8:黑 ,9:灰]
         * @param alpha 透明值 0 - 1
         * @param sidesNum 边的数量
         */
        static drawCircle(pos: m4m.math.Ivec2, radius: number, thickness?: number, colorId?: number, alpha?: number, sidesNum?: number): void;
        private static setPointCircle;
        /**
         * 绘制矩形
         * @param x 位置x
         * @param y 位置x
         * @param w 宽度
         * @param h 高度
         * @param thickness  线段宽度
         * @param colorId 线段颜色[0:红 , 1:橙  ,2:黄 ,3:绿 ,4:青 ,5:蓝 ,6:紫 ,7:白,8:黑 ,9:灰]
         * @param alpha 透明值 0 - 1
         */
        static drawRect(x: number, y: number, w: number, h: number, thickness?: number, colorId?: number, alpha?: number): void;
        static update(): void;
        static remove(): void;
        static colors: m4m.math.color[];
        private static readonly right;
        private static readonly toAngle;
        private static readonly toRad;
        private static inited;
        private static lineRoot;
        private static lineQueue;
        private static currIndex;
        private static template;
    }
}
declare module "Tools/DebugTextTool2d" {
    /**
     * 调试 文本绘制工具
     */
    export class DebugTextTool2d {
        private static textRoot;
        private static textQueue;
        private static currIndex;
        private static template;
        private static inited;
        static init(rootNode: m4m.framework.transform2D): void;
        /**
         * 绘制文本
         * @param centerPos 中心点位置
         * @param text 文本内容
         * @param fontSize 字体大小
         * @param colorId 线段颜色[0:红 , 1:橙  ,2:黄 ,3:绿 ,4:青 ,5:蓝 ,6:紫 ,7:白,8:黑 ,9:灰]
         * @param alpha 透明值 0 - 1
         */
        static drawText(centerPos: m4m.math.Ivec2, text: string, fontSize?: number, colorId?: number, alpha?: number): void;
        private static colorEqual;
        static update(): void;
    }
}
declare module "Tools/TaskManager" {
    /**
     * 任务函数主体
     * @param cb  任务完成回调
     */
    export type TaskFun = (cb: Function) => void;
    /**
     * 任务 管理器
     * 单个任务 ： Function(cb):void;
     */
    export class TaskManager {
        /**
         * 创建串行任务
         * @param tasks 任务函数(多参数)
         */
        static serial(...tasks: TaskFun[]): TaskFun;
        /**
         * 创建串行任务
         * @param tasks 任务函数队列
         */
        static serialArray(tasks: TaskFun[]): TaskFun;
        /**
         * 创建并行任务
         * @param tasks 任务函数(多参数)
         */
        static parallel(...tasks: TaskFun[]): TaskFun;
        /**
         * 创建并行任务
         * @param tasks 任务函数队列
         */
        static parallelArray(tasks: TaskFun[]): TaskFun;
    }
}
declare module "Tools/GuideMgr" {
    /**
     * 引导功能 管理器
     * 使用 1. init()  2.guideRun(id)
     */
    export class GuideMgr {
        /** 需要打印 步骤信息 */
        static DebugPrint: boolean;
        /** 引导 类型 */
        private static typeStepFunsMap;
        /** excel 配置的 action 函数map  */
        private static actFunMap;
        /**  */
        private static tempClassNameStepFunsMap;
        /** 当前激活的单元实例队列 */
        private static activeGuides;
        /** 当前 单元 */
        private static currGuide;
        /** 引导配置的 类对象 */
        private static GuideBaseClassObj;
        /**
         * <装饰 类 对象>
         * 绑定 当前类到指定 GuideTypeID ，该类 绑定bindStep 的静态函数，归为该引导。
         * 使用方式 ：@GuideMgr.bindType([引导ID]])
         * @param _guideID 引导类型的ID
         */
        static bindType(_guideID: number): (constructor: any) => void;
        /**
         * <装饰 函数 对象>
         * 绑定 引导单步的执行函数 (被标记的函数 必须是一个 static (cb:Function)=>void )
         * 使用方式 ：@GuideMgr.bindStep([步骤号])
         * @param stepID 执行步ID （标记第几步执行 ，ID 从1 开始计数）
         */
        static bindStep(stepID: number): (target: any, propertyKey: string, descriptor: PropertyDescriptor) => void;
        /**
         * <装饰 函数 对象>
         * 绑定 引导Action 函数
         * 使用方式 ： @GuideMgr.bindActFun
         */
        static bindActFun(target: any, propertyKey: string, descriptor: PropertyDescriptor): void;
        static init(GuideBaseClassObj: any): void;
        /**
         * 开始跑 引导 ，返回一个 Promise
         * @param GuideID 引导的ID
         * @returns Promise,完成时则 引导完成。
         */
        static guideRun(GuideID: number): Promise<unknown>;
        private static excelParse;
        private static nextGuide;
        private static guideEnd;
    }
}
declare module "Tools/IconUtil" {
    export class IconUtil {
        static uiSahderCacheTag: string;
        static defuiShaderName: string;
        static defMaSkUIShaderName: string;
        static greyUIShaderName: string;
        /** 图片灰白  裁剪版本 */
        static greyMaskUIShaderName: string;
        /** 文本彩色流光 shader */
        static labelMulColorShader: string;
        static defuiFontShaderName: string;
        private static cacheUIMat;
        private static cacheUICSahderName;
        /** 清理 */
        static clear(): void;
        /**
         * 改变 ui节点树下所有 img的shader
         * @param _uiTreeRoot ui节点树 根节点
         * @param uiShaderName shader  名
         * @param needCache 是否缓存老的 材质
         */
        static changeImgShaderByTree(_uiTreeRoot: m4m.framework.transform2D, uiShaderName: string, needCache?: boolean): void;
        /**
         * 恢复 ui节点树下所有 之前有缓存的老 材质
         * @param _uiTreeRoot ui节点树 根节点
         */
        static recoverImgShaderByTree(_uiTreeRoot: m4m.framework.transform2D): void;
        private static EachTransformImgTree;
        static setIconGrayedShader(r: m4m.framework.IRectRenderer): void;
        static setIconOriginShader(r: m4m.framework.IRectRenderer): void;
        static setColorWordsLabelShader(r: m4m.framework.IRectRenderer): void;
        static setCommonLabelShader(r: m4m.framework.IRectRenderer): void;
    }
}
declare module "Tools/KeyFramePlayTool" {
    /** 关键帧数据 */
    type kfData = [number, number];
    /**  关键帧 回调函数，会在生命周期内 每帧回调一次 */
    type kfCallBack = (/** 值 */ value: number, /** 是否结束 */ isEnd: boolean) => any;
    /**
     * 关键帧 播放工具
     */
    export class KeyFramePlayTool {
        private static _playIDCount;
        private static _playIdMap;
        /**
         * 播放线性关键帧
         * @param keyFrameData 关键帧数据数组 (kfData : [时间点,数值])
         * @param callback 回调函数
         * @returns 播放ID
         */
        static playLinear(keyFrameData: kfData[], callback: kfCallBack): number;
        /**
         * 停止播放
         * @param playId 播放ID
         */
        static stop(playId: number): void;
        private static test;
    }
}
declare module "Tools/Over3dModelMgr" {
    import { ISpTransform } from "Tools/engineParallel/spInterface";
    /** UI之上 3D 渲染 管理类 */
    export class Over3dModelMgr {
        private static readonly helpV2;
        private static readonly cachLayerTag;
        private static readonly hasCachLayerTag;
        private static _canvas;
        private static asp;
        private static camSize;
        private static inited;
        private static tryInit;
        /**
         * 获取3d坐标通过UI坐标
         * @param UIPos UI世界坐标
         * @param outPos3d  返回的 3d空间世界坐标
         */
        static get3dPos(UIPos: m4m.math.vector2, outPos3d: m4m.math.vector3): void;
        /**
         * 将模型 渲染到UI上
         * @param tran 3d 模型对象
         */
        static setModelToUI(tran: ISpTransform): void;
        /**
         * 将模型 从UI渲染到上恢复
         * @param tran 3d 模型对象
         */
        static recoveryModel(tran: ISpTransform): void;
        private static changeLayerGUI;
        private static resetLayerGUI;
    }
}
declare module "Tools/ScreenshotMgr" {
    /**
     * 截屏管理器
     */
    export class ScreenshotMgr {
        private static camPostObj;
        private static texReader;
        private static canvas2d;
        private static ctx2d;
        private static currW;
        private static currH;
        private static currData;
        private static lastfixRot;
        private static PictureWidth;
        private static PictureHeight;
        private static PictureScale;
        static init(): void;
        /** 截取屏幕 */
        static Screenshot(withOutUI?: boolean): void;
        /** 保存称为base64 数据 */
        static SaveToBase64(): string;
        static SaveToBuffer(): Int32Array;
        /**
         * 裁剪截取的图片数据
         * @param x 屏幕空间坐标x
         * @param y 屏幕空间坐标y
         * @param w 屏幕空间 宽度
         * @param h 屏幕空间 高度
         */
        static Cutting(x: number, y: number, w: number, h: number): void;
        private static makeTexReader;
        /** Y翻转纹理 */
        private static flipY;
        private static fixRotAngle;
        private static refreshGlRenderTarget;
    }
}
declare module "Tools/bztool" {
    export class BezierCurveTool {
        private static readonly helpV2;
        private static readonly helpV2v1;
        private static readonly helpV2v2;
        private static readonly helpV2v3;
        private static readonly helpV2v4;
        private static readonly helpV2v5;
        private static cupV2;
        /**
         * 评估值
         * @param kfs 所有的关键帧对象
         * @param _time normal 时间 （0 - 1）
         */
        static evaluate(kfs: m4m.framework.keyFrame[], _time: number): number;
        /**
         * 计算 曲线的值
         * @param kfL 左边帧对象
         * @param kfR 右边帧对象
         * @param playTime 时间值
         */
        static calcValue(kfL: m4m.framework.keyFrame, kfR: m4m.framework.keyFrame, playTime: number): number;
        private static converCalc;
        private static calcCurve;
        private static CurveEquation;
    }
}
declare module "Tools/fontMgr" {
    export class FontMgr {
        static get Instance(): FontMgr;
        get realheight(): number;
        constructor();
        private static FONT_CANVAS;
        private static FONT_CANVAS_TEMP;
        private static collectChars;
        private static _instance;
        private fontImageData;
        private fontContext;
        private fontcontexttemp;
        private textureSize;
        private letterSpacing;
        private fontSize;
        private haveString;
        private defFontResName;
        private _font;
        private imgWidth;
        private imgHeight;
        /** 刷新字体纹理 是否使用unit8array  */
        private useBufferRefresh;
        private isIosBol;
        private adding;
        private cTIdx;
        private xAddvance;
        private yAddvance;
        /**
         * name
         */
        init(useBufferRefresh: boolean, isIosBol: any): void;
        /**
         * 添加字符到字体
         * @param str
         */
        checkAddText(str: string): void;
        private createCanvas;
        private makeTempContext;
        private makeFontCanvasImgData;
        private update;
        private onTryExpandTexts;
        private refCanvas2d;
        private createTextrue;
        /** 尝试拓展文字到font */
        private tryExpandText;
        private adddNewChar;
    }
}
declare module "Tools/htmlCode" {
    export class htmlCode {
        static runCode(): void;
    }
}
declare module "Tools/materialchanger" {
    /**
     *  模型 材质shader切换器
     *  来回切换各种材质
     */
    export class materialchanger {
        private static get assetMgr();
        /**
         * 模型 材质shader切换器
         * @param ignoreIRenders 排除的渲染组件
         */
        constructor(ignoreIRenders?: string[]);
        private static _assetMgr;
        private static changeMatTag;
        private limitIRenderNameMap;
        /**
         * 获取 matSetting
         * @param tran 渲染模型对象
         * @param matConfig matSetting对象
         */
        getSetting(tran: m4m.framework.transform, matConfig: IMatConfig): IMatSetting;
        /**
         * 改变材质
         * @param tran 渲染模型对象
         * @param matConfig matSetting对象
         * @param toOrig 是否是设置成源初材质
         */
        changeMat(tran: m4m.framework.transform, matConfig: IMatConfig, toOrig: boolean): void;
        /**
         * 设置材质 数值通过参数对象
         * @param mat 材质对象
         * @param valObj 设置参数
         */
        setMatValue(mat: m4m.framework.material, valObj: matParameter): void;
        private getShaderFullName;
        private matSetTo;
        private parameterToClone;
    }
    type matParameter = {
        [pName: string]: number | m4m.math.vector4;
    };
    interface IMaterials {
        materials: m4m.framework.material[];
    }
    interface IMatConfigVal {
        parameterVal: matParameter;
        mats: m4m.framework.material[];
        hasMatsRenders: IMaterials[];
    }
    interface IMatSetting {
        currChangedShaderName: string;
        configMap: {
            [key: string]: IMatConfigVal;
        };
    }
    interface IMatConfig {
        shaderName: string;
        parameter: matParameter;
    }
}
declare module "Tools/physics2dExpandsTool" {
    import { ReuseArray } from "Data/ReuseArray";
    interface IRaycastResult {
        hited: boolean;
        hitPoint: m4m.math.Ivec2;
        hitedBody: any;
    }
    /**
     * 2d 物理拓展 工具
     */
    export class physics2dExpandsTool {
        static get Bounds(): any;
        static get SAT(): any;
        static get Bodies(): any;
        static get Vertices(): any;
        static get Body(): any;
        static get Axes(): any;
        private static testCircleIntersect;
        /**
         * 设置 2d 物理物体 碰撞 开 或 关
         * @param pBody 2d 物理物体实例
         * @param enable
         */
        static SetPhyCollision(pBody: m4m.framework.I2DPhysicsBody, enable: boolean): void;
        private static cloneFilter;
        /**
         * 查询 2d物理物体是否与指定点发生了碰撞
         * @param phyBody 2d物理对象
         * @param point 2d的点
         * @param isExact 是否高精度检测 （粗进度只检测bounds）
         */
        static queryPoint(phyBody: m4m.framework.I2DPhysicsBody, point: m4m.math.Ivec2, isExact?: boolean): boolean;
        /**
         * 查询 所有的bodie 通过指定的圆形区域内
         * @param pos 圆形位置
         * @param radius 圆半径
         * @param outlist 输出bodie ID 列表
         * @param layerMask 挑选的层级
         */
        static queryCircle(pos: m4m.math.Ivec2, radius: number, outlist: ReuseArray<number>, layerMask?: number): void;
        private static fastBoundVSCircle;
        private static gridFilter;
        private static debugDrawBounds;
        private static debugDrawBoundsList;
        private static debugDrawGrid;
        /** 获取bodies 通过指定圆 */
        private static gridFilterBycircle;
        /** 获取bodies 通过指定body的边界 */
        private static gridFilterByBodyBound;
        private static gridGetRegionByCir;
        private static gridGetRegion;
        private static setGridRegion;
        /** 检测 点 是否被 bounds 包含  */
        private static boundsContains;
        /**
         * Returns a list of collisions between `body` and `bodies`.
         * @method collides
         * @param {body} body
         * @param {body[]} bodies
         * @return {object[]} list of collisions
         */
        static collides(body: any, bodies: any, collisions: ReuseArray<any>): void;
        static get rayHelp_rectBody(): m4m.framework.Ibody;
        /**
         * 投射一束射线检测与bodies 的碰撞结果 ，返回rayhitResult 对象
         * @param bodies 检测的对象组
         * @param rayPoint 射线的发射点
         * @param rayDir 射线的方向
         * @param rayLen 射线的长度
         * @param layerMask 挑选的层级
         * @param useCacheRayResult 返回结果是否使用共享rayResult对象
         */
        static queryRay(bodies: any[], rayPoint: m4m.math.vector2, rayDir: m4m.math.vector2, rayLen: number, layerMask?: number, useCacheRayResult?: boolean): IRaycastResult;
        private static setRectangleBody;
        /**
         * 光线投射检测与墙面的碰撞 ， 碰到返回true
         * @param wallA 墙a点
         * @param wallB 墙b点
         * @param rayPos 射线起点
         * @param rayDir 射线方向
         * @param rayLen 射线长度
         * @param outHitPoint 返回的碰撞点
         */
        private static raycast2Wall;
        private static exampleRaytest;
        /** 绘制debug 开关 */
        static Draw2dDebug: boolean;
        static drawBound: boolean;
        static drawbucketGird: boolean;
        private static _Bounds;
        private static _SAT;
        private static _Bodies;
        private static _Vertices;
        private static _Body;
        private static _Axes;
        private static readonly disbleFilter;
        private static readonly PhyCollisionTag;
        private static helpRegion;
        private static cupBodies;
        private static rayHelpV2;
        private static rayHelpV2v1;
        private static rayHelpV2v3;
        private static rayHelpResult;
        private static _rayHelpRectBody;
        private static helpVelocity;
        private static helpCentre;
        private static HelpRayVertices;
    }
}
declare module "Tools/viewDragTool" {
    /** 拖拽查看场景物体工具 */
    export class viewDragTool {
        static get instance(): viewDragTool;
        static dispose(): void;
        /** 能被拖拽 layermask */
        get dragLayerMask(): number;
        set dragLayerMask(v: number);
        /** 框选的 透明值  */
        get selectSphereAlpha(): number;
        set selectSphereAlpha(a: number);
        onPicked: (tran: m4m.framework.transform) => {};
        private static _instance;
        private static readonly helpV2;
        private static readonly helpV3;
        private static readonly helpV3v1;
        private _dragLayerMask;
        private _selectSphereAlpha;
        private _app;
        private _inputMgr;
        private _scene;
        private _assetMgr;
        private _lastPickedTran;
        private selectModel;
        private canDragMove;
        private startScreenPos;
        private startTranPos;
        private startPlaneHitPos;
        private planeNormal;
        private outInfo;
        init(): void;
        dispose(): void;
        private _pointUp;
        private _pointmove;
        private getHitPointByPlane;
        private _pointDown;
        private cansoleSelecting;
        private rightDown;
        private leftDown;
        private tryToPick;
        private pickedTrans;
        private setShperePos;
        private setShpereScele;
        private pickedSelectModel;
    }
}
declare module "Tools/PBR/PBREnvSettings" {
    /** PBR 环境设置 */
    export class PBREnvSettings {
        /** 天空盒资源名 */
        skyBox: string;
        /** 曝光强度强度 */
        exposure: number;
        /** pbr是否使用间接环境光照图 */
        pbrUseEnvMap: boolean;
    }
}
declare module "Tools/PBR/PBREnvMgr" {
    import { PBREnvSettings } from "Tools/PBR/PBREnvSettings";
    /**
     * PBR 环境 管理器
     */
    export class PBREnvMgr {
        private static _isZipTex;
        private static _skyboxShader;
        private static _skyBoxTexPath;
        private static _currEnv;
        private static _skyBox;
        private static _lights;
        private static _enableSkyBox;
        private static _SpecEnvMap;
        private static _DiffEnvMap;
        /** 间接照明 镜面反射环境图（IBL） */
        static get SpecEnvMap(): m4m.framework.texture;
        /** 间接照明 漫反射环境图（IBL） */
        static get DiffEnvMap(): m4m.framework.texture;
        /** 曝光度 >= 0 */
        static get Exposure(): number;
        /** pbr是否使用间接环境光照图 */
        static get PBRUseEnvMap(): boolean;
        /** 天空盒 */
        private static get skyBox();
        /** 当前的环境设置 */
        static get currEnv(): PBREnvSettings;
        /** 天空盒shader */
        static get skyboxShader(): string;
        static set skyboxShader(val: string);
        /** 是否开启天空盒子 */
        static get enableSkyBox(): boolean;
        static set enableSkyBox(val: boolean);
        /**
         * 初始化
         * @param skyBoxPath 天空盒路径
         */
        static init(skyBoxPath: string): void;
        /**
         * 设置PBR环境
         * @param env 环境设置实例
         */
        static setEnv(env: PBREnvSettings): Promise<void>;
        /**
         * 尝试添加 unity拓展灯光
         * @param _gltf gltf资源对象
         */
        static tryAddExtLight(_gltf: m4m.framework.gltf): void;
        private static clearLights;
        private static loadTexRes;
        private static setSkyBox;
        private static refreshSkyBoxTex;
    }
}
declare module "Tools/PBR/PBRMgr" {
    /** PBR 管理类 */
    export class PBRMgr {
        static readonly carePbrShaderMap: {
            [k: string]: boolean;
        };
        /**
         * 设置 pbr 节点的环境贴图
         * @param r 渲染组件
         * @param useEvnMap 是否使用间接环境光照
         * @returns
         */
        static attachEnv(r: m4m.framework.IRenderer, useEvnMap?: boolean): void;
        /**
         * 设置 全部场景pbr节点的环境贴图
         */
        static ckAttachEnvAll(node: m4m.framework.transform): void;
    }
}
declare module "UIBase/touchPad" {
    /**
     * UI 触控板组件
     * 有效区域为当前transform2d 的实际矩形区域
     * 模拟连续的滑动信息输出（类似于 笔记本电脑 上的触摸板鼠标输入设备）
     */
    export class touchPad extends m4m.framework.behaviour2d {
        /**
         * 输入值改变时，回调函数
         * 需要用户对接该函数对象
         */
        onValueChange: (x: any, y: any) => any;
        /**
         * 点下时 回调函数
         */
        onPointDown: (x: any, y: any) => any;
        /**
         * 释放点下时 回调函数
         */
        onPointUp: (x: any, y: any) => any;
        private static readonly helpV2;
        private hasPointDown;
        private startPoint;
        private lastPoint;
        onPointEvent(canvas: m4m.framework.canvas, ev: m4m.framework.PointEvent, oncap: boolean): void;
    }
}
declare module "UIBase/uiMgr" {
    import { metaUIManager } from "UIBase/metaUIManager";
    export class uiMgr extends metaUIManager {
        /** 给 子域分享画布 使用 */
        static shareCanvasImg: m4m.framework.rawImage2D;
        /** 全屏尺寸 img容器 */
        static scFullImg: m4m.framework.rawImage2D;
        /** 头像尺寸 img容器  */
        static scIconImg: m4m.framework.rawImage2D;
        /** 上层相机的 overLay , UI 上模型模式使用*/
        static topOverlay: m4m.framework.overlay2D;
        protected static uiRoot: m4m.framework.transform2D;
        static init(uiWidth: number, uiHeight: number, screenMatchRate: number, uiPrefabPath: string, atlasPath: string): void;
    }
}
declare module "UIBase/uiPage" {
    /** 面板逻辑管理对象接口 */
    export interface IPageBase {
        handle: IpageHandle;
    }
    /** 面板handle对象接口 */
    export interface IpageHandle {
        transform: m4m.framework.transform2D;
        onHide(): any;
        show(): any;
        hide(): any;
        remove(): any;
    }
    /** 加载uipage工具类 */
    class LoadTool {
        private static atlasEndMap;
        private static priorityAtlas;
        static loadAtlas(atlas: string[]): Promise<void>;
        static removeAtlasByName(atlas: string[]): void;
        private static priorityPagePfb;
        static loadPrefeb(prefabName: string): Promise<void>;
    }
    /** uiPage基础类 */
    export abstract class PageBase implements IPageBase {
        /** UI prefab 的资源路径 */
        static get UIPath(): string;
        /** 图集 的资源路径 */
        static get atlasPath(): string;
        /**
         * 初始化设置
         * @param UIPath UI prefab 的资源路径
         * @param atlasPath 图集 的资源路径
         */
        static init(UIPath: string, atlasPath: string): void;
        static hasInstance(subClassName: string): boolean;
        protected static instanceMap: {
            [subClassName: string]: PageBase;
        };
        protected static get instance(): PageBase;
        /** 显示 */
        static Show(): void;
        /** 隐藏 */
        static Hide(): void;
        /** 釋放清理資源 和 handle*/
        static Destory(): void;
        static Init(): void;
        /** 注册UI事件（中函数中注册各子类UI接收事件） */
        static regUIEvent(): void;
        static get loadState(): number;
        /** 0:未加载 、1：加载中 、 2：加载完毕 */
        protected resLoadState: number;
        /**
         * 添加执行任务
         * @param taskFun 任务方法
         * @param taskArg 任务参数对象 arguments
        */
        static addTask(taskFunName: string, taskArg?: any): void;
        /** uipage 加载工具类 */
        static loadTool: typeof LoadTool;
        static onShowAct: (pageObj: PageBase) => any;
        static onHideAct: (pageObj: PageBase) => any;
        static onDestoryAct: (pageObj: PageBase) => any;
        /** ui prefab handle */
        abstract handle: IpageHandle;
        /** handle的类型 */
        abstract handleType: any;
        /** 依赖的UI prefab 资源名 */
        abstract dependentPrefabName: string;
        /** 依赖的UI 图集 资源名列表 */
        abstract dependentAtlasNames: string[];
        private static _UIPath;
        private static _atlasPath;
        private taskQueue;
        /** 加载完毕后 on 初始化结束 ，page实例对象、handle 构建 完毕 */
        protected oninited(): void; /** on开始加载 */
        protected onStartLoad(): void;
        private Init;
        private show;
        private hide;
        private destory;
        private loadRes;
        private mountComp;
        private executeTask;
    }
    /**全屏 面板handle 基组件类 */
    export abstract class uiPage extends m4m.framework.behaviour2d implements IpageHandle {
        private static hideAll;
        /** page队列 */
        static pages: uiPage[];
        uiLayer: number;
        notHideOnOtherShow: boolean;
        onHide: () => any;
        onShow: () => any;
        onDispose: () => any;
        private inited;
        /** 显示UI页面  */
        show(): void;
        /** 隐藏UI页面 */
        hide(): void;
        remove(): void;
        private init;
        private getParent;
    }
    /**pop 面板handle 基组件类 */
    export abstract class uiPop extends m4m.framework.behaviour2d implements IpageHandle {
        onHide: () => any;
        onShow: () => any;
        onDispose: () => any;
        private inited;
        show(): void;
        hide(): void;
        remove(): void;
        private init;
    }
}
declare module "UIBase/uiPolygon" {
    export class uiPolygon implements m4m.framework.IRectRenderer {
        transform: m4m.framework.transform2D;
        color: m4m.math.color;
        private static readonly defUIShader;
        private static readonly defMaskUIShader;
        private static readonly helpV2;
        private static readonly helpV2v1;
        private polygonData;
        private datar;
        private minX;
        private maxX;
        private minY;
        private maxY;
        private _darwRect;
        private _cacheMaskV4;
        private _CustomShaderName;
        /**
         * @private
         * ui默认材质
         */
        private _uimat;
        private get uimat();
        /**
         * 添加 多边形的点
         * @param localPos 坐标（本地坐标空间为基坐标系）
         */
        addPoint(localPos: m4m.math.vector2): void;
        /**
         * 清理 所有的点
         */
        clearPoint(): void;
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 设置rander Shader名字
         * @version m4m 1.0
         */
        setShaderByName(shaderName: string): void;
        render(canvas: m4m.framework.canvas): void;
        updateTran(): void;
        getMaterial(): m4m.framework.material;
        getDrawBounds(): m4m.math.rect;
        onPlay(): void;
        start(): void;
        update(delta: number): void;
        remove(): void;
        /** 计算drawRect */
        private calcDrawRect;
    }
}
declare module "UIBase/uiRenderLeaper" {
    /** UI层级渲染 跳跃器  (用来实现 覆盖在模型上的UI)*/
    export class uiRenderLeaper extends m4m.framework.behaviour2d {
        /** 跳跃 层级 */
        leapLayer: number;
        private readonly leapRenderTag;
        private readonly leapedTag;
        /**跃迁显示 状态 */
        private _isLeap;
        onPlay(): void;
        update(delta: number): void;
        /**
         * 切换跳跃显示设置
         * @param isLeap 是否跃迁显示
         */
        swLeapDisplay(isLeap: boolean): void;
        remove(): void;
        private onFrontBefRender;
        private onLeapRender;
        private renderRecursion;
        private FrontUpdateTran;
        private moveRenderer;
    }
}
declare module "animation/AnimationController" {
    import { IDispose, ISpAnimPlayerHandle } from "Tools/engineParallel/spInterface";
    /**
    {
        "states":{
            "show":{"clipName":"" , "speed":1 , "normalizeTime":1 , "mirror":false },
            "showidle":{"clipName":"showidle" , "speed":1 , "normalizeTime":1 , "mirror":false },
            "dead":{"clipName":"dead" , "speed":1 , "normalizeTime":1 , "mirror":false },
            "idle":{"clipName":"idle" , "speed":1 , "normalizeTime":1 , "mirror":false },
        },
        "transitions":[
            {"from":"__entry__","to":"idle"},
            {"from":"__anyState__","to":"show"},
            {"from":"__anyState__","to":"showidle"},
            {"from":"__anyState__","to":"dead"},
            {"from":"__anyState__","to":"idle"},
            {"from":"show","to":"showidle"},
            {"from":"hit1","to":"idle"},
        ]
    }
    
     */
    class AnimStatePlayEvent {
        stateName: string;
    }
    class EventTypes {
        /** 状态开始播放 */
        "onStatePlay": AnimStatePlayEvent;
        /** 状态播放结束 */
        "onStatePlayEnd": AnimStatePlayEvent;
    }
    /**
     * 动画控制 状态机
     */
    export class AnimationController extends m4m.AEvent implements IDispose {
        /** 动画片段 后缀 */
        private static ANYSTATE;
        private static ENTRY;
        private static EXIT;
        private _animPlayer;
        /** 任何状态 */
        private anyState;
        /** 进入状态 */
        private entry;
        /** 退出状态 */
        private exit;
        /** 状态map */
        private stateMap;
        private currentState;
        private playEvent;
        /** 动画播放器 */
        get animPlayer(): ISpAnimPlayerHandle;
        dispose(): void;
        /** 初始化设置 */
        init(animPlayer: ISpAnimPlayerHandle, stateConf: object): void;
        /**
         * 获取 指定动画状态 的播放时长
         * @param stateName 动画状态名
         */
        getStateTimeLength(stateName: string): number;
        /**
         * 获取 当前在播放的状态名字
         */
        getCurrentStateName(): string;
        /**
         * 播放 动画（指定的动画状态名）
         * @param stateName 动画状态名
         */
        play(stateName: string): void;
        /**
         * 停止播放 动画
         */
        stop(): void;
        /**
         * 添加事件监听
         * @param eventType
         * @param listener
         * @param thisArg
         */
        On<K extends keyof EventTypes>(eventType: K, listener: (ev: EventTypes[K]) => any, thisArg: any): void;
        /**
         * 添加一次性事件监听(指定 state 对象)
         * @param eventType 事件类型
         * @param stateName 触发的state名
         * @param listener 监听触发函数
         * @param thisArg this对象
         */
        OnStateOnce<K extends keyof EventTypes>(eventType: K, stateName: string, listener: (ev: EventTypes[K]) => any, thisArg: any): void;
        /**
         * 移除事件监听
         * @param eventType
         * @param listener
         * @param thisArg
         */
        RemoveListener<K extends keyof EventTypes>(eventType: K, listener: Function, thisArg: any): void;
        /**
         * 派发事件
         * @param eventType
         * @param ev
         */
        Emit<K extends keyof EventTypes>(eventType: K, ev: EventTypes[K]): void;
        private _playByTransition;
        private _playNext;
        /** 播放结束 */
        private _onPlayEnd;
        /** 创建 过渡 */
        private makeTransition;
        /** 添加到 map */
        private addToMap;
    }
}
declare module "audio/H5AudioHandle" {
    import { IAudioHandle } from "audio/AudioMgr";
    /**
     * html5 环境 音频handle
     */
    export class H5AudioHandle implements IAudioHandle {
        urlBasePath: string;
        private static readonly ON_LOAD_BUFFER;
        private _eventer;
        private audioContextMap;
        private audioBufferMap;
        private _pauseMap;
        private _startTimeMap;
        private onEndedCallBackFun;
        constructor();
        onEnded(fun: Function): void;
        clearAudioBuffer(resName: string): void;
        loadAudioBuffer(resName: string, fun: (buf: AudioBuffer, _err: Error) => void): void;
        forEach(fn: (resName: string) => void): void;
        addAudio(resName: string): boolean;
        removeAudio(resName: string): void;
        getVolume(resName: string): number;
        setVolume(resName: string, volume: number): void;
        play(resName: string, isloop?: boolean, volume?: number): void;
        stop(resName: string): void;
        seek(resName: string, position: number): void;
        pause(resName: string): void;
        ispaused(resName: string): boolean;
        private disposeAudioChannel;
        private regAudioPlayEnd;
    }
}
declare module "audio/WXAudioHandle" {
    import { IAudioHandle } from "audio/AudioMgr";
    /**
     * 微信 声音handle
     */
    export class WXAudioHandle implements IAudioHandle {
        urlBasePath: string;
        private audioContextMap;
        private onEndedCallBackFun;
        onEnded(fun: Function): void;
        removeAudio(resName: string): void;
        forEach(fn: (resName: string) => void): void;
        addAudio(resName: string): boolean;
        getVolume(resName: string): number;
        setVolume(resName: string, volume: number): void;
        play(resName: string, isloop?: boolean, volume?: number): void;
        seek(resName: string, position: number): void;
        stop(resName: string): void;
        pause(resName: string): void;
        ispaused(resName: string): boolean;
    }
}
declare module "audio/AudioMgr" {
    /** 声音handle 接口 */
    export interface IAudioHandle {
        /** 资源基础路径 */
        urlBasePath: string;
        /** 遍历所有 已经加载的音效 */
        forEach(fn: (resName: string) => void): any;
        /** 添加音效 */
        addAudio(resName: string): any;
        /** 移除 已经加载的音效*/
        removeAudio(resName: string): any;
        /** 获取音量 */
        getVolume(resName: string): number;
        /**设置单个音量 */
        setVolume(resName: string, volume: number): any;
        /** 播放指定音源 */
        play(resName: string, isloop?: boolean, volume?: number): any;
        /** 停止播放 */
        stop(resName: string): any;
        /**
         * 跳到指定进度位置
         * @param resName
         * @param position 单位化（0-1）的进度位置
         */
        seek(resName: string, position: number): any;
        /**暂停 某个声音 */
        pause(resName: string): any;
        /**是否暂停或 播完了 */
        ispaused(resName: string): boolean;
        /**监听音频自然播放至结束的事件*/
        onEnded(fun: Function): any;
    }
    export class AudioMgr {
        private static _recordVolumeMap;
        /** 音频的基础路径 */
        private static _urlBasePath;
        private static _isMute;
        /** 是否静音 */
        static get IsMute(): boolean;
        /** 音频 handle对象 */
        private static audioHandle;
        /**
         * 初始化
         * @param urlBasePath 音频的基础路径
         */
        static init(urlBasePath: string): void;
        /**
         * 静音操作
         * @param isMute 是否静音（true 静音 ，false 恢复之前播放音量）
         */
        static setMute(isMute: boolean): void;
        static setSpecialVolume(volume: number, audioResList: string[], bgm: boolean): void;
        static setVolume(resName: string, volume: number): void;
        /** 播放指定音源 */
        static Play(resName: string, isloop?: boolean, volume?: number): void;
        /** 停止播放 */
        static Stop(resName: string): void;
        /** 停播全部 */
        static stopAll(): void;
        /** 跳到指定进度位置 */
        static Seek(resName: string, position: number): void;
        /** 暂停播放 */
        static pause(resName: string): void;
        /**是否暂停或 播完了 */
        static ispaused(resName: string): boolean;
        /** 删除销毁 音频 */
        static removeAudio(resName: string): void;
        /** 监听音频自然播放至结束的事件 */
        static onEnded(fun: Function): void;
    }
}
