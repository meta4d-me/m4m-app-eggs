"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var m4m;
(function (m4m) {
    var version = /** @class */ (function () {
        function version() {
        }
        version.VERSION = "0.0.2";
        return version;
    }());
    m4m.version = version;
})(m4m || (m4m = {}));
//主要的入口
var m4m;
//主要的入口
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @private
         */
        var NotifyType;
        (function (NotifyType) {
            NotifyType[NotifyType["AddChild"] = 0] = "AddChild";
            NotifyType[NotifyType["RemoveChild"] = 1] = "RemoveChild";
            NotifyType[NotifyType["ChangeVisible"] = 2] = "ChangeVisible";
            NotifyType[NotifyType["AddCamera"] = 3] = "AddCamera";
            NotifyType[NotifyType["AddCanvasRender"] = 4] = "AddCanvasRender";
        })(NotifyType = framework.NotifyType || (framework.NotifyType = {}));
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 设定画布的渲染大小，选择长或者宽作为标准锁定画布大小进行渲染。横屏选择FixedWidthType，竖屏选择FixedHeightType。目的是锁定屏幕大小，防止分辨率过高导致渲染压力过大
         * @version m4m 1.0
         */
        var CanvasFixedType;
        (function (CanvasFixedType) {
            /** 随着窗口自由适应 */
            CanvasFixedType[CanvasFixedType["Free"] = 0] = "Free";
            /** 固定宽度 */
            CanvasFixedType[CanvasFixedType["FixedWidthType"] = 1] = "FixedWidthType";
            /** 固定高度 */
            CanvasFixedType[CanvasFixedType["FixedHeightType"] = 2] = "FixedHeightType";
        })(CanvasFixedType = framework.CanvasFixedType || (framework.CanvasFixedType = {}));
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 引擎的主入口
         * @version m4m 1.0
         */
        var application = /** @class */ (function () {
            function application() {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 全局宏定义
                 * @version m4m 1.0
                 */
                this.globalMacros = [];
                this.limitFrame = true;
                // private version: string = "v0.0.1";
                // private build: string = "b000077";
                this._tar = -1;
                this._standDeltaTime = -1;
                this.canvasFixedType = CanvasFixedType.Free;
                this._scaleFromPandding = 1;
                this._frameID = 0;
                this.beStepNumber = 0;
                this.pretimer = 0;
                /**
                 * @private
                 */
                this.isFrustumCulling = true;
                //用户控制层代码，逻辑非常简单，就是给用户一个全局代码插入的机会，update不受场景切换的影响
                this._userCode = [];
                this._userCodeNew = [];
                this._editorCode = [];
                this._editorCodeNew = [];
                // private _bePlay: boolean = false;
                /**
                 * @private
                 */
                this.be2dstate = false;
                this.curcameraindex = -1;
                /**
                 * 运行开关
                 */
                this.bePlay = false;
                // public get bePlay()
                // {
                //     return this._bePlay;
                // }
                // /**
                //  * @private
                //  */
                // public set bePlay(value: boolean)
                // {
                //     this._bePlay = value;
                // }
                this._bePause = false;
                this._beStepForward = false;
                this._beRendering = true;
                /** 旋转角度 OrientationMode.AUTO */
                this.orientation = framework.OrientationMode.AUTO; //
                this.shouldRotate = false; //需要旋转
                this.lastWidth = 0;
                this.lastHeight = 0;
                this.OffOrientationUpdate = false; //关闭更新
            }
            Object.defineProperty(application.prototype, "width", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 绘制区域宽度 像素单位
                 * @version m4m 1.0
                 */
                get: function () {
                    return this.webgl.canvas.width;
                    // return this.webgl.canvas.getBoundingClientRect().width;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(application.prototype, "height", {
                // /**
                //  * @public
                //  * @language zh_CN
                //  * @classdesc
                //  * 绘制区域高度 像素单位
                //  * @version m4m 1.0
                //  */
                get: function () {
                    return this.webgl.canvas.height;
                    // return this.webgl.canvas.getBoundingClientRect().height;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(application.prototype, "timeScale", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 获取timescale
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._timeScale;
                },
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 设置timescale
                 * @version m4m 1.0
                 */
                set: function (val) {
                    this._timeScale = val;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(application.prototype, "targetFrame", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 获取当前固定帧数
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._tar;
                },
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 设置固定帧数 不设置即为不限制帧数
                 * @version m4m 1.0
                 */
                set: function (val) {
                    if (val == 0)
                        val = -1;
                    this._tar = val;
                    this._standDeltaTime = 1 / this._tar;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(application.prototype, "canvasFixHeight", {
                set: function (val) {
                    this._fixHeight = val;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(application.prototype, "canvasFixWidth", {
                set: function (val) {
                    this._fixWidth = val;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(application.prototype, "canvasClientWidth", {
                get: function () {
                    return this._canvasClientWidth;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(application.prototype, "canvasClientHeight", {
                get: function () {
                    return this._canvasClientHeight;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(application.prototype, "scaleFromPandding", {
                get: function () { return this._scaleFromPandding; },
                enumerable: false,
                configurable: true
            });
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 引擎的启动方法
             * @param div 绘制区域的dom
             * @version m4m 1.0
             */
            application.prototype.start = function (div, type, val, webglDebug, opt_attribs) {
                // var metas = document.getElementsByName("viewport") as NodeListOf<HTMLMetaElement>;
                // var meta: HTMLMetaElement;
                // if (!metas || metas.length < 1)
                // {
                //     meta = document.createElement("meta") as HTMLMetaElement;
                //     meta.name = "viewport";
                //     document.head.appendChild(meta);
                // }
                // else
                //     meta = metas[0];
                // meta.content = "width=device-width, height=device-height, user-scalable=no, initial-scale=1, minimum-scale=0.5, maximum-scale=0.5";
                if (type === void 0) { type = CanvasFixedType.Free; }
                if (val === void 0) { val = 1200; }
                if (webglDebug === void 0) { webglDebug = false; }
                if (opt_attribs === void 0) { opt_attribs = null; }
                if (div == null) {
                    console.error("root div does Null at application start ");
                    return;
                }
                div.style.overflow = "hidden";
                div.style.position = "absolute";
                div.style.width = "100%";
                div.style.height = "100%";
                this.outcontainer = div;
                var rotateDiv = document.createElement("div");
                rotateDiv.className = "full";
                rotateDiv.style.overflow = "hidden";
                rotateDiv.style.position = "absolute";
                rotateDiv.style.width = "100%";
                rotateDiv.style.height = "100%";
                this.container = rotateDiv;
                div.appendChild(rotateDiv);
                var canvas = document.createElement("canvas");
                if (canvas == null) {
                    console.error("Failed to create canvas at the application.start()");
                    throw Error("Failed to create canvas at the application.start()");
                }
                canvas.className = "full";
                canvas.style.position = "absolute";
                canvas.style.width = "100%";
                canvas.style.height = "100%";
                canvas.style.backgroundColor = "#1e1e1e";
                canvas.setAttribute("tabindex", "1");
                rotateDiv.appendChild(canvas);
                //this.updateOrientationMode();
                //init webgl;
                // this.webgl = <WebGL2RenderingContext>canvas.getContext('webgl') ||
                //     <WebGL2RenderingContext>canvas.getContext("experimental-webgl");
                this.startForCanvas(canvas, type, val, webglDebug);
                //this.showDrawCall();
            };
            application.prototype.startForCanvas = function (canvas, type, val, webglDebug, opt_attribs) {
                if (type === void 0) { type = CanvasFixedType.Free; }
                if (val === void 0) { val = 1200; }
                if (webglDebug === void 0) { webglDebug = false; }
                if (opt_attribs === void 0) { opt_attribs = null; }
                console.log("engine version: " + m4m.version.VERSION);
                this.ccWidth = this.ccWidth == undefined ? canvas.clientWidth : this.ccWidth;
                this.ccHeight = this.ccHeight == undefined ? canvas.clientHeight : this.ccHeight;
                this._timeScale = 1;
                framework.sceneMgr.app = this;
                var tempWebGlUtil = new framework.WebGLUtils();
                this.webgl = tempWebGlUtil.setupWebGL(canvas, opt_attribs);
                // console.error(" i am ---tempWebGlUtil-" + webglDebug);
                if (this.webgl == null) {
                    console.error("Failed to get webgl at the application.start()");
                    throw Error("Failed to get webgl at the application.start()");
                }
                // 扩展
                new framework.GLExtension(this.webgl);
                switch (type) {
                    case CanvasFixedType.FixedWidthType:
                        this.canvasFixWidth = val;
                        break;
                    case CanvasFixedType.FixedHeightType:
                        this.canvasFixHeight = val;
                        break;
                }
                // let devicePixelRatio = window.devicePixelRatio || 1;
                this.canvasFixedType = type;
                // // if (this.outcontainer)
                // {
                //     switch (type)
                //     {
                //         case CanvasFixedType.Free:
                //             this.screenAdaptiveType = "宽高度自适应(宽高都不固定,真实像素宽高)";
                //             canvas.width = this.ccWidth*devicePixelRatio;
                //             canvas.height = this.ccHeight*devicePixelRatio;
                //             this._scaleFromPandding = 1;
                //             break;
                //         case CanvasFixedType.FixedWidthType:
                //             this.canvasFixWidth = val;
                //             this.screenAdaptiveType = "宽度自适应(宽度固定,一般横屏使用)";
                //             canvas.width = this._fixWidth*devicePixelRatio;
                //             canvas.height = canvas.width * this.ccHeight / this.ccWidth;
                //             //this._scaleFromPandding = this.ccHeight / this.webgl.canvas.height;
                //             this._scaleFromPandding = this.ccHeight / this.webgl.canvas.height;
                //             break;
                //         case CanvasFixedType.FixedHeightType:
                //             this.canvasFixHeight = val;
                //             this.screenAdaptiveType = "高度自适应(高度固定，一般竖屏使用)";
                //             canvas.height = this._fixHeight*devicePixelRatio;
                //             canvas.width = canvas.height * this._fixHeight / this.ccHeight;
                //             this._scaleFromPandding = this.ccHeight / this.webgl.canvas.height;
                //             break;
                //     }
                // }
                this.setScreenAsp();
                // this._canvasClientWidth = canvas.width; //this.webgl.canvas.clientWidth;
                // this._canvasClientHeight = canvas.height;//this.webgl.canvas.clientHeight;
                this._canvasClientWidth = this.ccWidth; //this.webgl.canvas.clientWidth;
                this._canvasClientHeight = this.ccHeight; //this.webgl.canvas.clientHeight;
                m4m.render.webglkit.initConst(this.webgl);
                this.initRender();
                this.initAssetMgr();
                this.initInputMgr();
                this.initScene();
                this.beginTimer = this.lastTimer = this.pretimer = Date.now() / 1000;
                this.loop();
                m4m.io.referenceInfo.regDefaultType();
                var initovercallback = window["initovercallback"];
                if (initovercallback != null) {
                    initovercallback(this);
                }
                //debug
                if (webglDebug) {
                    var tempWebGLDebugUtils = new framework.WebGLDebugUtils();
                    this.webgl = tempWebGLDebugUtils.makeDebugContext(this.webgl);
                    console.error(" i am ---webglDebug-");
                }
            };
            application.prototype.markNotify = function (trans, type) {
                // this.doNotify(trans, type);
            };
            application.prototype.doNotify = function (trans, type) {
                if (trans == null)
                    return;
                if (!this.checkFilter(trans))
                    return;
                if (this.notify)
                    this.notify.notify(trans, type);
                if (trans.children != null) {
                    for (var index in trans.children) {
                        this.doNotify(trans.children[index], type);
                    }
                }
            };
            /**
             * @private
             * @param trans
             */
            application.prototype.checkFilter = function (trans) {
                if (trans instanceof m4m.framework.transform) {
                    if (trans.gameObject.hideFlags & m4m.framework.HideFlags.HideInHierarchy) {
                        return false;
                    }
                }
                if (trans instanceof m4m.framework.transform2D) {
                    if (trans.hideFlags & m4m.framework.HideFlags.HideInHierarchy) {
                        return false;
                    }
                }
                return true;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 显示性能参数面板
             * @version m4m 1.0
             */
            application.prototype.showFps = function () {
                if (!this.container)
                    return;
                if (this.stats == null) {
                    this.stats = new Stats.Stats(this);
                    this.stats.container.style.position = 'absolute'; //绝对坐标
                    this.stats.container.style.left = '0px'; // (0,0)px,左上角
                    this.stats.container.style.top = '0px';
                    this.container.appendChild(this.stats.container);
                }
                else {
                    this.container.appendChild(this.stats.container);
                }
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 关闭性能参数面板
             * @param div 绘制区域的dom
             * @version m4m 1.0
             */
            application.prototype.closeFps = function () {
                if (this.stats != null) {
                    this.container.removeChild(this.stats.container);
                }
            };
            application.prototype.showDrawCall = function () {
                framework.DrawCallInfo.inc.showDrawcallInfo();
            };
            application.prototype.closeDrawCall = function () {
                framework.DrawCallInfo.inc.closeDrawCallInfo();
            };
            Object.defineProperty(application.prototype, "frameID", {
                get: function () { return this._frameID; },
                enumerable: false,
                configurable: true
            });
            ;
            //delta 单位秒
            application.prototype.update = function (delta) {
                this._frameID++;
                //if (this.outcontainer.clientWidth != this._canvasClientWidth || this.outcontainer.clientHeight != this._canvasClientHeight)
                {
                    this.updateOrientationMode();
                }
                this.updateScreenAsp();
                if (this.bePlay) {
                    if (this.bePause) {
                        if (this.beStepForward && this.beStepNumber > 0) {
                            this.beStepNumber--;
                            this.updateUserCode(delta);
                        }
                    }
                    else {
                        if (this._inputmgr)
                            this._inputmgr.update(delta);
                        this.updateUserCode(delta);
                    }
                }
                if (this.updateEditorCode)
                    this.updateEditorCode(delta);
                if (this._scene != null) {
                    this._scene.update(delta);
                }
            };
            application.prototype.updateScreenAsp = function () {
                if (!this.outcontainer)
                    return;
                if (this.webgl && this.webgl.canvas) {
                    var canvas = this.webgl.canvas;
                    this.ccWidth = canvas.clientWidth != null ? canvas.clientWidth : this.ccWidth;
                    this.ccHeight = canvas.clientHeight != null ? canvas.clientHeight : this.ccHeight;
                }
                if (this.ccWidth != this._canvasClientWidth || this.ccHeight != this._canvasClientHeight) {
                    this._canvasClientWidth = this.ccWidth;
                    this._canvasClientHeight = this.ccHeight;
                    this.setScreenAsp();
                    // if (this.canvasFixedType == CanvasFixedType.Free)
                    // {
                    //     this.webgl.canvas.width = this.ccWidth;
                    //     this.webgl.canvas.height = this.ccHeight;
                    //     this._scaleFromPandding = 1;
                    // }
                    // else if (this.canvasFixedType == CanvasFixedType.FixedWidthType)
                    // {
                    //     this.webgl.canvas.width = this._fixWidth;
                    //     this.webgl.canvas.height = this._fixWidth * this.ccHeight / this.ccWidth;
                    //     this._scaleFromPandding = this.ccHeight / this.webgl.canvas.height;
                    // } else if (this.canvasFixedType == CanvasFixedType.FixedHeightType)
                    // {
                    //     this.webgl.canvas.height = this._fixHeight;
                    //     this.webgl.canvas.width = this.ccWidth * this._fixHeight / this.ccHeight;
                    //     this._scaleFromPandding = this.ccHeight / this.webgl.canvas.height;
                    // }
                    // console.log("_fixWidth:" + this._fixWidth + "   _fixHeight:" + this._fixHeight);
                    // console.log("canvas resize.   width:" + this.webgl.canvas.width + "   height:" + this.webgl.canvas.height);
                    // console.log("canvas resize.   clientWidth:" + this.webgl.canvas.clientWidth + "   clientHeight:" + this.webgl.canvas.clientHeight);
                }
            };
            //设置屏幕的 ASP
            application.prototype.setScreenAsp = function () {
                if (!this.webgl || !this.webgl.canvas)
                    return;
                var canvas = this.webgl.canvas;
                var devicePixelRatio = window.devicePixelRatio || 1;
                var type = this.canvasFixedType;
                switch (type) {
                    case CanvasFixedType.Free:
                        this.screenAdaptiveType = "宽高度自适应(宽高都不固定,真实像素宽高)";
                        canvas.width = this.ccWidth * devicePixelRatio;
                        canvas.height = this.ccHeight * devicePixelRatio;
                        this._scaleFromPandding = 1;
                        break;
                    case CanvasFixedType.FixedWidthType:
                        this.screenAdaptiveType = "宽度自适应(宽度固定,一般横屏使用)";
                        canvas.width = this._fixWidth * devicePixelRatio;
                        canvas.height = canvas.width * this.ccHeight / this.ccWidth;
                        //this._scaleFromPandding = this.ccHeight / this.webgl.canvas.height;
                        this._scaleFromPandding = this.ccHeight * devicePixelRatio / this.webgl.canvas.height;
                        break;
                    case CanvasFixedType.FixedHeightType:
                        this.screenAdaptiveType = "高度自适应(高度固定，一般竖屏使用)";
                        canvas.height = this._fixHeight * devicePixelRatio;
                        canvas.width = this.ccWidth * canvas.height / this.ccHeight;
                        this._scaleFromPandding = this.ccHeight * devicePixelRatio / this.webgl.canvas.height;
                        break;
                }
            };
            /**
             * @private
             */
            application.prototype.getUserUpdateTimer = function () {
                return this.usercodetime;
            };
            /**
             * @private
             */
            application.prototype.getTotalTime = function () {
                return this.totalTime;
            };
            Object.defineProperty(application.prototype, "deltaTime", {
                /**
                 * @private
                 */
                get: function () {
                    return this._deltaTime * this._timeScale;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * @private
             */
            application.prototype.getUpdateTimer = function () {
                return this.updateTimer;
            };
            application.prototype.loop = function () {
                var now = Date.now() / 1000;
                this._deltaTime = now - this.lastTimer;
                this.totalTime = now - this.beginTimer;
                this.updateTimer = now - this.pretimer;
                if (this._deltaTime < this._standDeltaTime) {
                    var _this_1 = this;
                    var del = this._standDeltaTime - this._deltaTime;
                    setTimeout(function () {
                        var _now = Date.now() / 1000;
                        _this_1.lastTimer = _now;
                        _this_1.pretimer = _now;
                        _this_1.update(_this_1._standDeltaTime);
                        if (_this_1.stats != null)
                            _this_1.stats.update();
                        _this_1.loop();
                    }, del * 1000);
                }
                else {
                    this.update(this.deltaTime);
                    if (this.stats != null)
                        this.stats.update();
                    this.lastTimer = now;
                    this.pretimer = now;
                    if (this.limitFrame) {
                        requestAnimationFrame(this.loop.bind(this));
                    }
                    else {
                        setTimeout(this.loop.bind(this), 1);
                    }
                }
            };
            application.prototype.initScene = function () {
                if (this._scene == null) {
                    this._scene = new framework.scene(this);
                    framework.sceneMgr.scene = this._scene;
                }
            };
            application.prototype.initRender = function () {
                framework.uniformSetter.initAutouniform();
                m4m.render.shaderUniform.webgl = this.webgl;
                m4m.render.shaderUniform.initApplyUnifmFunc();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取场景实例
             * @version m4m 1.0
             */
            application.prototype.getScene = function () {
                return this._scene;
            };
            application.prototype.initAssetMgr = function () {
                if (this._assetmgr == null) {
                    framework.assetMgr.Instance = this._assetmgr = new framework.assetMgr(this);
                    this._assetmgr.initDefAsset();
                }
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取资源管理器实例
             * @version m4m 1.0
             */
            application.prototype.getAssetMgr = function () {
                return this._assetmgr;
            };
            application.prototype.initInputMgr = function () {
                if (this._inputmgr == null) {
                    this._inputmgr = new framework.inputMgr(this);
                }
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取输入管理器实例
             * @version m4m 1.0
             */
            application.prototype.getInputMgr = function () {
                return this._inputmgr;
            };
            Object.defineProperty(application.prototype, "bePause", {
                /**
                 * @private
                 */
                get: function () {
                    return this._bePause;
                },
                /**
                 * @private
                 */
                set: function (value) {
                    this._bePause = value;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(application.prototype, "beStepForward", {
                /**
                 * @private
                 */
                get: function () {
                    return this._beStepForward;
                },
                /**
                 * @private
                 */
                set: function (value) {
                    this._beStepForward = value;
                },
                enumerable: false,
                configurable: true
            });
            application.prototype.updateUserCode = function (delta) {
                //add new code;
                while (this._userCodeNew.length > 0) {
                    var c = this._userCodeNew.pop(); //this._userCodeNew[i];
                    if (c.isClosed() == false) {
                        c.onStart(this);
                        this._userCode.push(c);
                    }
                }
                for (var i = 0, len = this._userCode.length; i < len; ++i) {
                    c = this._userCode[i];
                    if (c.isClosed() == false && c.onUpdate) {
                        c.onUpdate(delta);
                    }
                    else {
                        this._userCode.splice(i, 1);
                    }
                }
                /*
                for (var i = this._userCodeNew.length - 1; i >= 0; i--)
                {
                    var c = this._userCodeNew[i];
                    if (c.isClosed() == false)
                    {
                        c.onStart(this);
                        this._userCode.push(c);
                        this._userCodeNew.splice(i, 1);
                    }
                }
                // this._userCodeNew.length = 0;
    
                //update logic
                var closeindex = -1;
                for (var i = 0; i < this._userCode.length; i++)
                {
                    var c = this._userCode[i];
                    if (c.isClosed() == false)
                    {
                        c.onUpdate(delta);
                    }
                    else if (closeindex < 0)
                    {
                        closeindex = i;
                    }
                }
    
                //remove closed
                if (closeindex >= 0)
                {
                    this._userCode.splice(closeindex, 1);
                }
                */
            };
            application.prototype.updateEditorCode = function (delta) {
                for (var i = this._editorCodeNew.length - 1; i >= 0; i--) {
                    var c = this._editorCodeNew[i];
                    if (c.isClosed() == false) {
                        c.onStart(this);
                        this._editorCode.push(c);
                        this._editorCodeNew.splice(i, 1);
                    }
                }
                var closeindex = -1;
                for (var i = this._editorCode.length - 1; i >= 0; i--) {
                    var c = this._editorCode[i];
                    if (c.isClosed()) {
                        this._editorCode.splice(i, 1);
                    }
                    else {
                        c.onUpdate(delta);
                    }
                }
            };
            Object.defineProperty(application.prototype, "beRendering", {
                /**
                 * 渲染开关
                 */
                get: function () { return this._beRendering; },
                set: function (val) { this._beRendering = val; },
                enumerable: false,
                configurable: true
            });
            ;
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 直接添加usercode实例
             * @param program usercode实例
             * @version m4m 1.0
             */
            application.prototype.addUserCodeDirect = function (program) {
                if (program.onUpdate.toString().length < 35)
                    program.onUpdate = undefined;
                this._userCodeNew.push(program);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 根据classname添加usercode
             * @param classname usercode类名
             * @version m4m 1.0
             */
            application.prototype.addUserCode = function (classname) {
                //反射创建实例的方法
                var prototype = m4m.reflect.getPrototype(classname);
                if (prototype != null) {
                    var code = m4m.reflect.createInstance(prototype, { "usercode": "1" });
                    this.addUserCodeDirect(code);
                }
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 根据classname添加editorcode
             * @param classname editorcode类名
             * @version m4m 1.0
             */
            application.prototype.addEditorCode = function (classname) {
                //反射创建实例的方法
                var prototype = m4m.reflect.getPrototype(classname);
                if (prototype != null) {
                    var code = m4m.reflect.createInstance(prototype, { "editorcode": "1" });
                    this.addEditorCodeDirect(code);
                }
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 直接添加editorcode实例
             * @param program editorcode实例
             * @version m4m 1.0
             */
            application.prototype.addEditorCodeDirect = function (program) {
                this._editorCodeNew.push(program);
            };
            application.prototype.updateOrientationMode = function () {
                if (this.OffOrientationUpdate || !this.outcontainer)
                    return;
                var screenRect = this.outcontainer.getBoundingClientRect();
                this.shouldRotate = false;
                if (this.orientation != framework.OrientationMode.AUTO) {
                    this.shouldRotate =
                        (this.orientation == framework.OrientationMode.LANDSCAPE || this.orientation == framework.OrientationMode.LANDSCAPE_FLIPPED) && screenRect.height > screenRect.width ||
                            this.orientation == framework.OrientationMode.PORTRAIT && screenRect.width > screenRect.height;
                }
                var screenWidth = this.shouldRotate ? screenRect.height : screenRect.width;
                var screenHeight = this.shouldRotate ? screenRect.width : screenRect.height;
                if (this.lastWidth == screenWidth && this.lastHeight == screenHeight)
                    return; //不再重复
                this.refreshOrientationMode(screenRect, screenWidth, screenHeight);
                // this.lastWidth = screenWidth;
                // this.lastHeight = screenHeight;
                // // if (this.width !== screenWidth) {
                // //     this.width = screenWidth;
                // // }
                // // if (this.height !== screenHeight) {
                // //     this.height = screenHeight;
                // // }
                // if (this.container) {
                //     this.container.style[getPrefixStyleName("transformOrigin")] = "0% 0% 0px";
                //     this.container.style.width = screenWidth + "px";
                //     this.container.style.height = screenHeight + "px";
                //     let rotation = 0;
                //     if (this.shouldRotate) {
                //         if (this.orientation == OrientationMode.LANDSCAPE) {//
                //             rotation = 90;
                //             this.container.style.top = (screenRect.height - screenWidth) / 2 + "px";
                //             this.container.style.left = (screenRect.width + screenHeight) / 2 + "px";
                //         }
                //         else {
                //             rotation = -90;
                //             this.container.style.top = (screenRect.height + screenWidth) / 2 + "px";
                //             this.container.style.left = (screenRect.width - screenHeight) / 2 + "px";
                //         }
                //     }
                //     else {
                //         this.container.style.top = (screenRect.height - screenHeight) / 2 + "px";
                //         this.container.style.left = (screenRect.width - screenWidth) / 2 + "px";
                //     }
                //     let transform = `rotate(${rotation}deg)`;
                //     this.container.style[getPrefixStyleName("transform")] = transform;
                // }
            };
            /**
             * 刷新 一次,视窗朝向数据。
             * @param rect 视窗矩形区域
             * @param screenWidth 视窗宽度
             * @param screenHeight 视窗高度
             */
            application.prototype.refreshOrientationMode = function (rect, screenWidth, screenHeight) {
                var screenRect = rect == null ? this.outcontainer.getBoundingClientRect() : rect;
                this.shouldRotate = false;
                if (this.orientation != framework.OrientationMode.AUTO) {
                    this.shouldRotate =
                        (this.orientation == framework.OrientationMode.LANDSCAPE || this.orientation == framework.OrientationMode.LANDSCAPE_FLIPPED) && screenRect.height > screenRect.width ||
                            this.orientation == framework.OrientationMode.PORTRAIT && screenRect.width > screenRect.height;
                }
                if (!screenWidth) {
                    screenWidth = this.shouldRotate ? screenRect.height : screenRect.width;
                }
                if (!screenHeight) {
                    screenHeight = this.shouldRotate ? screenRect.width : screenRect.height;
                }
                this.lastWidth = screenWidth;
                this.lastHeight = screenHeight;
                // if (this.width !== screenWidth) {
                //     this.width = screenWidth;
                // }
                // if (this.height !== screenHeight) {
                //     this.height = screenHeight;
                // }
                if (this.container) {
                    this.container.style[getPrefixStyleName("transformOrigin")] = "0% 0% 0px";
                    this.container.style.width = screenWidth + "px";
                    this.container.style.height = screenHeight + "px";
                    var rotation = 0;
                    if (this.shouldRotate) {
                        if (this.orientation == framework.OrientationMode.LANDSCAPE) { //
                            rotation = 90;
                            this.container.style.top = (screenRect.height - screenWidth) / 2 + "px";
                            this.container.style.left = (screenRect.width + screenHeight) / 2 + "px";
                        }
                        else {
                            rotation = -90;
                            this.container.style.top = (screenRect.height + screenWidth) / 2 + "px";
                            this.container.style.left = (screenRect.width - screenHeight) / 2 + "px";
                        }
                    }
                    else {
                        this.container.style.top = (screenRect.height - screenHeight) / 2 + "px";
                        this.container.style.left = (screenRect.width - screenWidth) / 2 + "px";
                    }
                    var transform_1 = "rotate(".concat(rotation, "deg)");
                    this.container.style[getPrefixStyleName("transform")] = transform_1;
                }
            };
            return application;
        }());
        framework.application = application;
        framework.OrientationMode = {
            /**
             * 适配屏幕
             */
            AUTO: "auto",
            /**
             * 默认竖屏
             */
            PORTRAIT: "portrait",
            /**
             * 默认横屏，舞台顺时针旋转90度
             */
            LANDSCAPE: "landscape",
            /**
             * 默认横屏，舞台逆时针旋转90度
             */
            LANDSCAPE_FLIPPED: "landscapeFlipped"
        };
        /**
         * @private
         */
        var currentPrefix = null;
        /**
         * @private
         */
        function getPrefixStyleName(name, element) {
            var header = "";
            if (element != null) {
                header = getPrefix(name, element);
            }
            else {
                if (currentPrefix == null) {
                    var tempStyle = document.createElement('div').style;
                    currentPrefix = getPrefix("transform", tempStyle);
                }
                header = currentPrefix;
            }
            if (header == "") {
                return name;
            }
            return header + name.charAt(0).toUpperCase() + name.substring(1, name.length);
        }
        framework.getPrefixStyleName = getPrefixStyleName;
        /**
         * @private
         */
        function getPrefix(name, element) {
            if (name in element) {
                return "";
            }
            name = name.charAt(0).toUpperCase() + name.substring(1, name.length);
            var transArr = ["webkit", "ms", "Moz", "O"];
            for (var i = 0; i < transArr.length; i++) {
                var tempStyle = transArr[i] + name;
                if (tempStyle in element) {
                    return transArr[i];
                }
            }
            return "";
        }
        framework.getPrefix = getPrefix;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var DeviceInfo = /** @class */ (function () {
            function DeviceInfo() {
            }
            DeviceInfo.getExtension = function () {
                // this.debuginfo= sceneMgr.app.webgl.getExtension('WEBGL_debug_renderer_info');
                this.debuginfo = framework.sceneMgr.app.webgl.extensions.WEBGL_debug_renderer_info;
                if (this.debuginfo == null) {
                    console.warn("extension(WEBGL_debug_renderer_info) not support!");
                }
            };
            Object.defineProperty(DeviceInfo, "GraphDevice", {
                /**
                 * GPU类型
                 */
                get: function () {
                    if (this.debuginfo == null) {
                        this.getExtension();
                    }
                    if (this.debuginfo) {
                        var device = framework.sceneMgr.app.webgl.getParameter(this.debuginfo.UNMASKED_RENDERER_WEBGL);
                        return device;
                    }
                    else {
                        return "unknown";
                    }
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(DeviceInfo, "CanvasWidth", {
                /**
                 * canvas 宽度
                 */
                get: function () {
                    if (framework.sceneMgr.app) {
                        return framework.sceneMgr.app.webgl.canvas.width;
                    }
                    else {
                        return null;
                    }
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(DeviceInfo, "CanvasHeight", {
                /**
                 * canvas 高度
                 */
                get: function () {
                    if (framework.sceneMgr.app) {
                        return framework.sceneMgr.app.webgl.canvas.height;
                    }
                    else {
                        return null;
                    }
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(DeviceInfo, "ScreenAdaptiveType", {
                /**
                 * 屏幕自适应方式
                 */
                get: function () {
                    if (framework.sceneMgr.app) {
                        return framework.sceneMgr.app.screenAdaptiveType;
                    }
                    else {
                        return "unknown";
                    }
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(DeviceInfo, "ScreenWidth", {
                /**
                 * 屏幕宽度
                 */
                get: function () {
                    return window.screen.width * (window.devicePixelRatio || 1);
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(DeviceInfo, "ScreenHeight", {
                /**
                 * 屏幕高度
                 */
                get: function () {
                    return window.screen.height * (window.devicePixelRatio || 1);
                },
                enumerable: false,
                configurable: true
            });
            return DeviceInfo;
        }());
        framework.DeviceInfo = DeviceInfo;
        var DrawCallEnum;
        (function (DrawCallEnum) {
            DrawCallEnum[DrawCallEnum["UI"] = 0] = "UI";
            DrawCallEnum[DrawCallEnum["SKinrender"] = 1] = "SKinrender";
            DrawCallEnum[DrawCallEnum["Meshrender"] = 2] = "Meshrender";
            DrawCallEnum[DrawCallEnum["EffectSystem"] = 3] = "EffectSystem";
        })(DrawCallEnum = framework.DrawCallEnum || (framework.DrawCallEnum = {}));
        var DrawCallInfo = /** @class */ (function () {
            function DrawCallInfo() {
                this.data = [];
                this.currentState = DrawCallEnum.Meshrender;
            }
            Object.defineProperty(DrawCallInfo, "inc", {
                get: function () {
                    if (this._inc == null) {
                        this._inc = new DrawCallInfo();
                    }
                    return this._inc;
                },
                enumerable: false,
                configurable: true
            });
            DrawCallInfo.prototype.reset = function () {
                this.data[DrawCallEnum.UI] = 0;
                this.data[DrawCallEnum.SKinrender] = 0;
                this.data[DrawCallEnum.Meshrender] = 0;
                this.data[DrawCallEnum.EffectSystem] = 0;
            };
            DrawCallInfo.prototype.add = function () {
                this.data[this.currentState] += 1;
            };
            DrawCallInfo.prototype.initShowPlane = function () {
                var div = document.createElement("div");
                this.rootdiv = div;
                framework.sceneMgr.app.container.appendChild(div);
                div.style.display = "inline-block";
                div.style.background = "#00000085";
                div.style.position = "absolute";
                div.style.left = "100px";
                div.style.top = "0px";
                div.style.height = "60px";
                div.style.width = "170px";
                var li1 = document.createElement("li");
                li1.textContent = "SkinMeshDrawcall: ";
                this.SKinrenderDraw = li1;
                var li3 = document.createElement("li");
                li3.textContent = "MeshrenderDrawcall: ";
                this.MeshrenderDraw = li3;
                var li2 = document.createElement("li");
                li2.textContent = "EffectrenderDrawcall: ";
                this.EffectrenderDraw = li2;
                var li4 = document.createElement("li");
                li4.textContent = "UIrenderDrawcall: ";
                this.UIrenderDraw = li4;
                var list = [li1, li3, li2, li4];
                for (var i = 0; i < list.length; i++) {
                    var li = list[i];
                    li.style.fontSize = "10px";
                    li.style.color = "Aqua";
                    li.style.height = "12px";
                    li.style.width = "170px";
                    li.style.left = "0px";
                    div.appendChild(li);
                }
            };
            DrawCallInfo.prototype.showPerFrame = function () {
                this.MeshrenderDraw.textContent = "MeshrenderDrawcall: " + this.data[DrawCallEnum.Meshrender];
                this.SKinrenderDraw.textContent = "SkinMeshDrawcall: " + this.data[DrawCallEnum.SKinrender];
                this.EffectrenderDraw.textContent = "EffectrenderDrawcall: " + this.data[DrawCallEnum.EffectSystem];
                this.UIrenderDraw.textContent = "UIrenderDrawcall: " + this.data[DrawCallEnum.UI];
            };
            DrawCallInfo.prototype.showDrawcallInfo = function () {
                if (this.SKinrenderDraw == null) {
                    this.initShowPlane();
                }
                DrawCallInfo.BeActived = true;
                this.rootdiv.style.visibility = "visible";
            };
            DrawCallInfo.prototype.closeDrawCallInfo = function () {
                DrawCallInfo.BeActived = false;
                this.rootdiv.style.visibility = "hidden";
            };
            DrawCallInfo.BeActived = false;
            return DrawCallInfo;
        }());
        framework.DrawCallInfo = DrawCallInfo;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        //错误搜集类
        var error = /** @class */ (function () {
            function error() {
            }
            error.push = function (err) {
                console.error(err.stack);
                if (this.openQueue && this.onError)
                    this.onError(err);
            };
            error.openQueue = true;
            return error;
        }());
        framework.error = error;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @private
         */
        var sceneMgr = /** @class */ (function () {
            function sceneMgr() {
            }
            Object.defineProperty(sceneMgr, "ins", {
                get: function () {
                    if (sceneMgr._ins == null)
                        sceneMgr._ins = new sceneMgr();
                    return sceneMgr._ins;
                },
                enumerable: false,
                configurable: true
            });
            return sceneMgr;
        }());
        framework.sceneMgr = sceneMgr;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var Stats;
(function (Stats_1) {
    /**
     * @author mrdoob / http://mrdoob.com/
     * @modify lights translate -> typescript
     */
    /**
     * @private
     */
    var Stats = /** @class */ (function () {
        function Stats(app) {
            var _this = this;
            this.mode = 0;
            this.app = app;
            this.container = document.createElement('div');
            this.container.style.cssText = 'position:fixed;top:0;left:0;cursor:pointer;opacity:0.7;z-index:1';
            this.container.addEventListener('click', function (event) {
                event.preventDefault();
                _this.showPanel(++_this.mode % _this.container.children.length);
            }, false);
            //
            this.beginTime = (performance || Date).now(), this.prevTime = this.beginTime, this.frames = 0;
            this.fpsPanel = this.addPanel(new Panel('FPS', '#0ff', '#002'));
            this.msPanel = this.addPanel(new Panel('MS', '#0f0', '#020'));
            this.ratePanel = this.addPanel(new Panel('%', '#0f0', '#020'));
            this.userratePanel = this.addPanel(new Panel('%', '#0f0', '#020'));
            if (window && window.performance && window.performance["memory"]) {
                this.memPanel = this.addPanel(new Panel('MB', '#f08', '#201'));
            }
            this.showPanel(0);
        }
        Stats.prototype.update = function () {
            this.beginTime = this.end();
        };
        Stats.prototype.showPanel = function (id) {
            for (var i = 0; i < this.container.children.length; i++) {
                this.container.children[i]["style"].display = i === id ? 'block' : 'none';
            }
            this.mode = id;
        };
        Stats.prototype.addPanel = function (panel) {
            this.container.appendChild(panel.canvas);
            return panel;
        };
        Stats.prototype.begin = function () {
            this.beginTime = (performance || Date).now();
        };
        Stats.prototype.end = function () {
            this.frames++;
            var time = (performance || Date).now();
            this.msPanel.update(time - this.beginTime, 200);
            if (time > this.prevTime + 1000) {
                var fps = (this.frames * 1000) / (time - this.prevTime);
                this.fpsPanel.update(fps, 100);
                this.ratePanel.update(this.app.getUpdateTimer() * this.frames / 10, 100);
                this.userratePanel.update(this.app.getUserUpdateTimer() * this.frames / 10, 100);
                this.prevTime = time;
                this.frames = 0;
                if (this.memPanel) {
                    var memory = performance["memory"];
                    this.memPanel.update(memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576);
                }
            }
            return time;
        };
        return Stats;
    }());
    Stats_1.Stats = Stats;
    /**
     * @private
     */
    var Panel = /** @class */ (function () {
        function Panel(name, fg, bg) {
            this.name = name;
            this.fg = fg;
            this.bg = bg;
            this.min = Infinity;
            this.max = 0;
            this.PR = Math.round(window.devicePixelRatio || 1);
            this.WIDTH = 80 * this.PR;
            this.HEIGHT = 48 * this.PR;
            this.TEXT_X = 3 * this.PR;
            this.TEXT_Y = 2 * this.PR;
            this.GRAPH_X = 3 * this.PR;
            this.GRAPH_Y = 15 * this.PR;
            this.GRAPH_WIDTH = 74 * this.PR, this.GRAPH_HEIGHT = 30 * this.PR;
            this.canvas = document.createElement('canvas');
            this.canvas.width = this.WIDTH;
            this.canvas.height = this.HEIGHT;
            this.canvas.style.cssText = 'width:80px;height:48px';
            this.context = this.canvas.getContext('2d');
            this.context.font = 'bold ' + (9 * this.PR) + 'px Helvetica,Arial,sans-serif';
            this.context.textBaseline = 'top';
            this.context.fillStyle = bg;
            this.context.fillRect(0, 0, this.WIDTH, this.HEIGHT);
            this.context.fillStyle = fg;
            this.context.fillText(name, this.TEXT_X, this.TEXT_Y);
            this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT);
            this.context.fillStyle = bg;
            this.context.globalAlpha = 0.9;
            this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT);
        }
        Panel.prototype.update = function (value, maxValue) {
            this.min = Math.min(this.min, value);
            this.max = Math.max(this.max, value);
            this.context.fillStyle = this.bg;
            this.context.globalAlpha = 1;
            this.context.fillRect(0, 0, this.WIDTH, this.GRAPH_Y);
            this.context.fillStyle = this.fg;
            this.context.fillText(Math.round(value) + ' ' + this.name + ' (' + Math.round(this.min) + '-' + Math.round(this.max) + ')', this.TEXT_X, this.TEXT_Y);
            this.context.drawImage(this.canvas, this.GRAPH_X + this.PR, this.GRAPH_Y, this.GRAPH_WIDTH - this.PR, this.GRAPH_HEIGHT, this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH - this.PR, this.GRAPH_HEIGHT);
            this.context.fillRect(this.GRAPH_X + this.GRAPH_WIDTH - this.PR, this.GRAPH_Y, this.PR, this.GRAPH_HEIGHT);
            this.context.fillStyle = this.bg;
            this.context.globalAlpha = 0.9;
            this.context.fillRect(this.GRAPH_X + this.GRAPH_WIDTH - this.PR, this.GRAPH_Y, this.PR, Math.round((1 - (value / maxValue)) * this.GRAPH_HEIGHT));
        };
        return Panel;
    }());
})(Stats || (Stats = {}));
///// <reference path="../../lib/Reflect.d.ts"/>
var m4m;
///// <reference path="../../lib/Reflect.d.ts"/>
(function (m4m) {
    m4m.m4m_reflect_root = {};
    var reflect;
    (function (reflect) {
        function isComp(type) {
            return m4m.m4m_reflect_root.__gdmeta__[type] &&
                m4m.m4m_reflect_root.__gdmeta__[type].__gdmeta__ &&
                m4m.m4m_reflect_root.__gdmeta__[type].__gdmeta__.class.custom.nodecomp;
        }
        reflect.isComp = isComp;
        /**
         * @private
         */
        function regType(constructorObj, customInfo) {
            var target = constructorObj.prototype;
            if (target["__gdmeta__"] == undefined)
                target["__gdmeta__"] = {};
            if (target["__gdmeta__"]["class"] == undefined)
                target["__gdmeta__"]["class"] = {};
            var name = target["constructor"]["name"];
            if (name == null) //this is for ie
             {
                var fs = target["constructor"].toString();
                var i = fs.indexOf("(");
                name = fs.substring(9, i);
            }
            var classname = constructorObj["ClassName"];
            name = classname ? classname : name;
            target["__gdmeta__"]["class"]["typename"] = name;
            //注册全局类型标记
            if (m4m.m4m_reflect_root["__gdmeta__"] == null)
                m4m.m4m_reflect_root["__gdmeta__"] = {};
            m4m.m4m_reflect_root["__gdmeta__"][name] = target;
            //fill custom info
            if (target["__gdmeta__"]["class"]["custom"] == null)
                target["__gdmeta__"]["class"]["custom"] = {};
            if (customInfo != null) {
                for (var key in customInfo) {
                    target["__gdmeta__"]["class"]["custom"][key] = customInfo[key];
                }
            }
        }
        /**
         * @private
         */
        function regFunc(target, funcname, customInfo) {
            //fill type
            if (target["__gdmeta__"] == undefined)
                target["__gdmeta__"] = {};
            if (target["__gdmeta__"][funcname] == null)
                target["__gdmeta__"][funcname] = {};
            target["__gdmeta__"][funcname]["type"] = "function";
            //fill meta
            // var tp = Reflect.getMetadata("design:paramtypes", target, funcname);
            // var tr = Reflect.getMetadata("design:returntype", target, funcname);
            // target["__gdmeta__"][funcname]["paramtypes"] = [];
            // for (var i in tp) {
            //     target["__gdmeta__"][funcname]["paramtypes"][i] = tp[i]["name"];
            // }
            // target["__gdmeta__"][funcname]["returntype"] = tr == null ? null : tr["name"];
            //fill custom info
            if (target["__gdmeta__"][funcname]["custom"] == null)
                target["__gdmeta__"][funcname]["custom"] = {};
            if (customInfo != null) {
                for (var key in customInfo) {
                    target["__gdmeta__"][funcname]["custom"][key] = customInfo[key];
                }
            }
        }
        /**
         * @private
         */
        function regField(target, fieldName, customInfo) {
            //fill type
            if (target["__gdmeta__"] == undefined)
                target["__gdmeta__"] = {};
            if (target["__gdmeta__"][fieldName] == null)
                target["__gdmeta__"][fieldName] = {};
            target["__gdmeta__"][fieldName]["type"] = "field";
            //fill meta 
            // var t = Reflect.getMetadata("design:type", target, fieldName);
            // if (t == null)//ie.反射这套sb 机制 ，居然和ie不兼容
            // {
            //     target["__gdmeta__"][fieldName]["valuetype"] = null;
            // }
            // else
            // {
            //     target["__gdmeta__"][fieldName]["valuetype"] = t["name"];
            // }
            //fill custom info
            if (target["__gdmeta__"][fieldName]["custom"] == null)
                target["__gdmeta__"][fieldName]["custom"] = {};
            if (customInfo != null) {
                for (var key in customInfo) {
                    target["__gdmeta__"][fieldName]["custom"][key] = customInfo[key];
                }
            }
        }
        /**
         * @private
         */
        function getPrototypes() {
            return m4m.m4m_reflect_root["__gdmeta__"];
        }
        reflect.getPrototypes = getPrototypes;
        /**
         * @private
         */
        function getPrototype(name) {
            return m4m.m4m_reflect_root["__gdmeta__"][name];
        }
        reflect.getPrototype = getPrototype;
        /**
         * @private
         */
        function createInstance(prototype, matchTag) {
            // var type = getProtoTypes()[name];
            // if (type[name] == null)
            //     return null;
            if (matchTag == null) {
                var ctor = prototype.constructor;
                return new ctor();
            }
            else {
                var info = prototype["__gdmeta__"]["class"]["custom"];
                for (var key in matchTag) {
                    if (info[key] != matchTag[key]) {
                        console.warn("createInstance:" + name + ". tag do not match.");
                        return null;
                    }
                }
                var ctor = prototype.constructor;
                return new ctor();
            }
        }
        reflect.createInstance = createInstance;
        /**
         * @private
         */
        function getClassName(prototype) {
            var info = prototype["__gdmeta__"]["class"]["typename"];
            return info;
        }
        reflect.getClassName = getClassName;
        /**
         * @private
         */
        function getClassTag(prototype, tag) {
            var info = prototype["__gdmeta__"]["class"]["custom"];
            return info[tag];
        }
        reflect.getClassTag = getClassTag;
        /**
         * @private
         */
        function getMeta(prototype) {
            var meta = prototype.__gdmeta__;
            return meta;
        }
        reflect.getMeta = getMeta;
        /**
         * @private
         */
        function attr_Class(constructorObj) {
            regType(constructorObj, null);
        }
        reflect.attr_Class = attr_Class;
        /**
         * @private
         */
        function attr_Func(customInfo) {
            if (customInfo === void 0) { customInfo = null; }
            return function (target, propertyKey, value) {
                regFunc(target, propertyKey, customInfo);
            };
        }
        reflect.attr_Func = attr_Func;
        /**
         * @private
         */
        function attr_Field(customInfo) {
            if (customInfo === void 0) { customInfo = null; }
            return function (target, propertyKey) {
                regField(target, propertyKey, customInfo);
            };
        }
        reflect.attr_Field = attr_Field;
        /**
         * @private
         */
        function userCode(constructorObj) {
            regType(constructorObj, { "usercode": "1" });
        }
        reflect.userCode = userCode;
        /**
         * @private
         */
        function editorCode(constructorObj) {
            regType(constructorObj, { "editorcode": "1" });
        }
        reflect.editorCode = editorCode;
        /**
         * @private
         */
        function selfClone(constructorObj) {
            regType(constructorObj, { "selfclone": "1" });
        }
        reflect.selfClone = selfClone;
        /**
         * @private
         */
        function nodeComponent(constructorObj) {
            regType(constructorObj, { "nodecomp": "1" });
        }
        reflect.nodeComponent = nodeComponent;
        /**
         * @private
         */
        function nodeComponentInspector(constructorObj) {
            regType(constructorObj, { "nodecomp_inspector": "1" });
        }
        reflect.nodeComponentInspector = nodeComponentInspector;
        /**
         * @private
         */
        function nodeRender(constructorObj) {
            regType(constructorObj, { "renderer": "1" });
        }
        reflect.nodeRender = nodeRender;
        /**
         * @private
         */
        function nodeCamera(constructorObj) {
            regType(constructorObj, { "camera": "1" });
        }
        reflect.nodeCamera = nodeCamera;
        /**
         * @private
         */
        function nodeLight(constructorObj) {
            regType(constructorObj, { "light": "1" });
        }
        reflect.nodeLight = nodeLight;
        /**
         * @private
         */
        function nodeBoxCollider(constructorObj) {
            regType(constructorObj, { "boxcollider": "1" });
        }
        reflect.nodeBoxCollider = nodeBoxCollider;
        /**
         * @private
         */
        function nodeBoxCollider2d(constructorObj) {
            regType(constructorObj, { "boxcollider2d": "1" });
        }
        reflect.nodeBoxCollider2d = nodeBoxCollider2d;
        /**
         * @private
         */
        function node2DPhysicsBody(constructorObj) {
            regType(constructorObj, { "node2dphysicsbody": "1" });
        }
        reflect.node2DPhysicsBody = node2DPhysicsBody;
        /**
         * @private
         */
        function nodeSphereCollider(constructorObj) {
            regType(constructorObj, { "spherecollider": "1" });
        }
        reflect.nodeSphereCollider = nodeSphereCollider;
        /**
         * @private
         */
        function nodeEffectBatcher(constructorObj) {
            regType(constructorObj, { "effectbatcher": "1" });
        }
        reflect.nodeEffectBatcher = nodeEffectBatcher;
        /**
         * @private
         */
        function nodeMeshCollider(constructorObj) {
            regType(constructorObj, { "meshcollider": "1" });
        }
        reflect.nodeMeshCollider = nodeMeshCollider;
        /**
         * @private
         */
        function nodeCanvasRendererCollider(constructorObj) {
            regType(constructorObj, { "canvasRenderer": "1" });
        }
        reflect.nodeCanvasRendererCollider = nodeCanvasRendererCollider;
        /**
         * @private
         */
        function node2DComponent(constructorObj) {
            regType(constructorObj, { "2dcomp": "1" });
        }
        reflect.node2DComponent = node2DComponent;
        /**
         * @private
         */
        function pluginMenuItem(constructorObj) {
            regType(constructorObj, { "plugin_menuitem": "1" });
        }
        reflect.pluginMenuItem = pluginMenuItem;
        /**
         * @private
         */
        function pluginWindow(constructorObj) {
            regType(constructorObj, { "plugin_window": "1" });
        }
        reflect.pluginWindow = pluginWindow;
        /**
         * @private
         */
        function pluginExt(constructorObj) {
            regType(constructorObj, { "plugin_ext": "1" });
        }
        reflect.pluginExt = pluginExt;
        /**
         * @private
         */
        function compValue(integer, defvalue, min, max) {
            if (integer === void 0) { integer = false; }
            if (defvalue === void 0) { defvalue = 0; }
            if (min === void 0) { min = Number.MIN_VALUE; }
            if (max === void 0) { max = Number.MAX_VALUE; }
            return function (target, propertyKey) {
                regField(target, propertyKey, {
                    "compValue": "1",
                    "integer": integer ? "1" : "0",
                    "defvalue": defvalue.toString(),
                    "min": min.toString(),
                    "max": max.toString(),
                });
            };
        }
        reflect.compValue = compValue;
        /**
         * @private
         */
        function compCall(customInfo) {
            if (customInfo === void 0) { customInfo = null; }
            return function (target, propertyKey, value) {
                regFunc(target, propertyKey, { "compcall": "1" });
                regFunc(target, propertyKey, customInfo);
            };
        }
        reflect.compCall = compCall;
        /**
         * @private
         */
        function SerializeType(constructorObj) {
            regType(constructorObj, { "SerializeType": "1" });
        }
        reflect.SerializeType = SerializeType;
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * Field
         * @version m4m 1.0
         * @param valueType 值类型
         * @param defaultValue 默认值
         * @param referenceType valueType 为 reference类型时 的具体类型
         */
        function Field(valueType, defaultValue, referenceType) {
            if (defaultValue === void 0) { defaultValue = undefined; }
            if (referenceType === void 0) { referenceType = undefined; }
            return function (target, propertyKey) {
                regField(target, propertyKey, {
                    "SerializeField": true,
                    "valueType": valueType
                });
                if (defaultValue == undefined) {
                }
                else {
                    regField(target, propertyKey, {
                        "defaultValue": defaultValue
                    });
                }
                if (valueType == "reference" && referenceType != undefined) {
                    regField(target, propertyKey, {
                        "referenceType": referenceType
                    });
                }
            };
        }
        reflect.Field = Field;
        /**
         * Field的引用类型(修饰后，改字段将在 Inspector 中暴露 , 该函数是Field() 的封装 )
         * @param referenceType reference指定类型 支持:"transform"、"transform2D"、@reflect.node2DComponent、@reflect.nodeComponent
         * @param defaultValue 默认值
         */
        function FieldRef(referenceType, defaultValue) {
            if (defaultValue === void 0) { defaultValue = undefined; }
            return function (target, propertyKey) {
                regField(target, propertyKey, {
                    "SerializeField": true,
                    "valueType": "reference",
                    "referenceType": referenceType
                });
                if (defaultValue != null) {
                    regField(target, propertyKey, {
                        "defaultValue": defaultValue
                    });
                }
            };
        }
        reflect.FieldRef = FieldRef;
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 属性面板提示修饰
         * @version m4m 1.0
         */
        function UIComment(comment) {
            return function (target, propertyKey) {
                regField(target, propertyKey, {
                    "UIComment": comment
                });
            };
        }
        reflect.UIComment = UIComment;
        /**
         * @private
         */
        var FieldUIStyle;
        (function (FieldUIStyle) {
            FieldUIStyle[FieldUIStyle["None"] = 0] = "None";
            FieldUIStyle[FieldUIStyle["RangeFloat"] = 1] = "RangeFloat";
            FieldUIStyle[FieldUIStyle["MultiLineString"] = 2] = "MultiLineString";
            FieldUIStyle[FieldUIStyle["Enum"] = 3] = "Enum"; //序列化的时候枚举获取不到具体类型。先占坑
        })(FieldUIStyle = reflect.FieldUIStyle || (reflect.FieldUIStyle = {}));
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 属性面板显示方式修饰
         * @version m4m 1.0
         */
        function UIStyle(style, min, max, defvalue) {
            return function (target, propertyKey) {
                regField(target, propertyKey, {
                    "FieldUIStyle": style,
                    "min": min ? min : null,
                    "max": max ? max : null,
                    "defvalue": defvalue ? defvalue : null
                });
            };
        }
        reflect.UIStyle = UIStyle;
    })(reflect = m4m.reflect || (m4m.reflect = {}));
})(m4m || (m4m = {}));
/// <reference path="../io/reflect.ts" />
var m4m;
/// <reference path="../io/reflect.ts" />
(function (m4m) {
    var math;
    (function (math) {
        ;
        ;
        ;
        var _ubyte = new Uint8Array(1);
        var _byte = new Int8Array(1);
        var _int16 = new Int16Array(1);
        var _int32 = new Int32Array(1);
        var _uint16 = new Uint16Array(1);
        var _uint32 = new Uint32Array(1);
        var _float32 = new Float32Array(1);
        var _float64 = new Float64Array(1);
        function UByte(v) {
            if (v === void 0) { v = 0; }
            if (typeof (v) == "string")
                v = Number(v);
            _ubyte[0] = v;
            return _ubyte[0];
        }
        math.UByte = UByte;
        function Byte(v) {
            if (v === void 0) { v = 0; }
            if (typeof (v) == "string")
                v = Number(v);
            _byte[0] = v;
            return _byte[0];
        }
        math.Byte = Byte;
        function Int16(v) {
            if (v === void 0) { v = 0; }
            if (typeof (v) == "string")
                v = Number(v);
            _int16[0] = v;
            return _int16[0];
        }
        math.Int16 = Int16;
        function Int32(v) {
            if (v === void 0) { v = 0; }
            if (typeof (v) == "string")
                v = Number(v);
            _int32[0] = v;
            return _int32[0];
        }
        math.Int32 = Int32;
        function UInt16(v) {
            if (v === void 0) { v = 0; }
            if (typeof (v) == "string")
                v = Number(v);
            _uint16[0] = v;
            return _uint16[0];
        }
        math.UInt16 = UInt16;
        function UInt32(v) {
            if (v === void 0) { v = 0; }
            if (typeof (v) == "string")
                v = Number(v);
            _uint32[0] = v;
            return _uint32[0];
        }
        math.UInt32 = UInt32;
        function Float(v) {
            if (v === void 0) { v = 0; }
            if (typeof (v) == "string")
                v = Number(v);
            _float32[0] = v;
            return _float32[0];
        }
        math.Float = Float;
        function Double(v) {
            if (v === void 0) { v = 0; }
            if (typeof (v) == "string")
                v = Number(v);
            _float64[0] = v;
            return _float64[0];
        }
        math.Double = Double;
        /**
         * @private
         */
        var vector2 = /** @class */ (function () {
            function vector2(x, y) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                this.x = x;
                this.y = y;
            }
            vector2.ClassName = "vector2";
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], vector2.prototype, "x", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], vector2.prototype, "y", void 0);
            vector2 = __decorate([
                m4m.reflect.SerializeType,
                __metadata("design:paramtypes", [Number, Number])
            ], vector2);
            return vector2;
        }());
        math.vector2 = vector2;
        /**
         * @private
         */
        var rect = /** @class */ (function () {
            // public rawData = new Float32Array(4);
            function rect(x, y, w, h) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (w === void 0) { w = 0; }
                if (h === void 0) { h = 0; }
                // this.rawData[0] = x;
                // this.rawData[1] = y;
                // this.rawData[2] = w;
                // this.rawData[3] = h;
                this.x = x;
                this.y = y;
                this.w = w;
                this.h = h;
            }
            // get h(): float
            // {
            //     return this.rawData[3];
            // };
            // set h(h: float)
            // {
            //     this.rawData[3] = h;
            // }
            rect.prototype.toString = function () {
                return "".concat(this.x, ",").concat(this.y, ",").concat(this.w, ",").concat(this.h);
            };
            rect.ClassName = "rect";
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], rect.prototype, "x", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], rect.prototype, "y", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], rect.prototype, "w", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], rect.prototype, "h", void 0);
            rect = __decorate([
                m4m.reflect.SerializeType,
                __metadata("design:paramtypes", [Number, Number, Number, Number])
            ], rect);
            return rect;
        }());
        math.rect = rect;
        /**
         * @private
         */
        var border = /** @class */ (function () {
            // public rawData = new Float32Array(4);
            function border(l, t, r, b) {
                if (l === void 0) { l = 0; }
                if (t === void 0) { t = 0; }
                if (r === void 0) { r = 0; }
                if (b === void 0) { b = 0; }
                // this.rawData[0] = l;
                // this.rawData[1] = t;
                // this.rawData[2] = r;
                // this.rawData[3] = b;
                this.l = l;
                this.t = t;
                this.r = r;
                this.b = b;
            }
            // get b(): float
            // {
            //     return this.rawData[3];
            // };
            // set b(b: float)
            // {
            //     this.rawData[3] = b;
            // }
            border.prototype.toString = function () {
                return "".concat(this.r, ",").concat(this.t, ",").concat(this.r, ",").concat(this.b);
            };
            border.ClassName = "border";
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], border.prototype, "l", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], border.prototype, "t", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], border.prototype, "r", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], border.prototype, "b", void 0);
            border = __decorate([
                m4m.reflect.SerializeType,
                __metadata("design:paramtypes", [Number, Number, Number, Number])
            ], border);
            return border;
        }());
        math.border = border;
        /**
         * @private
         */
        var color = /** @class */ (function () {
            // public rawData = new Float32Array(4);
            function color(r, g, b, a) {
                if (r === void 0) { r = 1; }
                if (g === void 0) { g = 1; }
                if (b === void 0) { b = 1; }
                if (a === void 0) { a = 1; }
                // this.rawData[0] = r;
                // this.rawData[1] = g;
                // this.rawData[2] = b;
                // this.rawData[3] = a;
                this.r = r;
                this.g = g;
                this.b = b;
                this.a = a;
            }
            // get a(): float
            // {
            //     return this.rawData[3];
            // };
            // set a(a: float)
            // {
            //     this.rawData[3] = a;
            // }
            color.prototype.toString = function () {
                return "".concat(this.r, ",").concat(this.g, ",").concat(this.b, ",").concat(this.a);
            };
            color.ClassName = "color";
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], color.prototype, "r", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], color.prototype, "g", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], color.prototype, "b", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], color.prototype, "a", void 0);
            color = __decorate([
                m4m.reflect.SerializeType,
                __metadata("design:paramtypes", [Number, Number, Number, Number])
            ], color);
            return color;
        }());
        math.color = color;
        /**
         * @private
         */
        var vector3 = /** @class */ (function () {
            function vector3(x, y, z) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (z === void 0) { z = 0; }
                this.x = x;
                this.y = y;
                this.z = z;
            }
            // get z(): float
            // {
            //     return this.rawData[2];
            // };
            // set z(z: float)
            // {
            //     this.rawData[2] = z;
            // }
            vector3.prototype.toString = function () {
                // return `${this.rawData[0]},${this.rawData[1]},${this.rawData[2]}`;
                return "".concat(this.x, ",").concat(this.y, ",").concat(this.z);
            };
            vector3.ClassName = "vector3";
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], vector3.prototype, "x", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], vector3.prototype, "y", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], vector3.prototype, "z", void 0);
            vector3 = __decorate([
                m4m.reflect.SerializeType,
                __metadata("design:paramtypes", [Number, Number, Number])
            ], vector3);
            return vector3;
        }());
        math.vector3 = vector3;
        /**
         * @private
         */
        var vector4 = /** @class */ (function () {
            // public rawData = new Float32Array(4);
            function vector4(x, y, z, w) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (z === void 0) { z = 0; }
                if (w === void 0) { w = 0; }
                // this.rawData[0] = x;
                // this.rawData[1] = y;
                // this.rawData[2] = z;
                // this.rawData[3] = w;
                this.x = x;
                this.y = y;
                this.z = z;
                this.w = w;
            }
            // get w(): float
            // {
            //     return this.rawData[3];
            // };
            // set w(w: float)
            // {
            //     this.rawData[3] = w;
            // }
            vector4.prototype.toString = function () {
                return "".concat(this.x, ",").concat(this.y, ",").concat(this.z, ",").concat(this.w);
            };
            vector4.ClassName = "vector4";
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], vector4.prototype, "x", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], vector4.prototype, "y", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], vector4.prototype, "z", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], vector4.prototype, "w", void 0);
            vector4 = __decorate([
                m4m.reflect.SerializeType,
                __metadata("design:paramtypes", [Number, Number, Number, Number])
            ], vector4);
            return vector4;
        }());
        math.vector4 = vector4;
        /**
         * @private
         */
        var quaternion = /** @class */ (function () {
            // public rawData = new Float32Array(4);
            function quaternion(x, y, z, w) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (z === void 0) { z = 0; }
                if (w === void 0) { w = 1; }
                // this.rawData[0] = x;
                // this.rawData[1] = y;
                // this.rawData[2] = z;
                // this.rawData[3] = w;
                this.x = x;
                this.y = y;
                this.z = z;
                this.w = w;
            }
            // get w(): float
            // {
            //     return this.rawData[3];
            // };
            // set w(w: float)
            // {
            //     this.rawData[3] = w;
            // }
            quaternion.prototype.toString = function () {
                // return `${this.rawData[0]},${this.rawData[1]},${this.rawData[2]},${this.rawData[3]}`;
                return "".concat(this.x, ",").concat(this.y, ",").concat(this.z, ",").concat(this.w);
            };
            quaternion.ClassName = "quaternion";
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], quaternion.prototype, "x", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], quaternion.prototype, "y", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], quaternion.prototype, "z", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], quaternion.prototype, "w", void 0);
            quaternion = __decorate([
                m4m.reflect.SerializeType,
                __metadata("design:paramtypes", [Number, Number, Number, Number])
            ], quaternion);
            return quaternion;
        }());
        math.quaternion = quaternion;
        /**
         * @private
         */
        var matrix = /** @class */ (function () {
            // public rawData: Float32Array;
            function matrix(datas) {
                if (datas === void 0) { datas = null; }
                // if (datas)
                // {
                //     this.rawData = datas;
                // }
                // else
                //     this.rawData = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
                if (datas) {
                    this.rawData = datas;
                }
                else
                    this.rawData = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
            }
            matrix.prototype.toString = function () {
                return "[" + this.rawData[0] + "," + this.rawData[1] + "," + this.rawData[2] + "," + this.rawData[3] + "],"
                    + "[" + this.rawData[4] + "," + this.rawData[5] + "," + this.rawData[6] + "," + this.rawData[7] + "],"
                    + "[" + this.rawData[8] + "," + this.rawData[9] + "," + this.rawData[10] + "," + this.rawData[11] + "],"
                    + "[" + this.rawData[12] + "," + this.rawData[13] + "," + this.rawData[14] + "," + this.rawData[15] + "]";
            };
            matrix.ClassName = "matrix";
            return matrix;
        }());
        math.matrix = matrix;
        /**
         * @private
         */
        var matrix3x2 = /** @class */ (function () {
            function matrix3x2(datas) {
                if (datas === void 0) { datas = null; }
                // if (datas)
                // {
                //     this.rawData = datas;
                // }
                // else
                //     this.rawData = new Float32Array([1, 0, 0, 1, 0, 0]);
                if (datas) {
                    this.rawData = datas;
                }
                else
                    this.rawData = [1, 0, 0, 1, 0, 0];
            }
            matrix3x2.prototype.toString = function () {
                return "[" + this.rawData[0] + "," + this.rawData[1] + "," + this.rawData[2] + "],"
                    + "[" + this.rawData[3] + "," + this.rawData[4] + "," + this.rawData[5] + "]";
            };
            return matrix3x2;
        }());
        math.matrix3x2 = matrix3x2;
        /**
         * 动态延长 Array
         */
        var ExtenArray = /** @class */ (function () {
            /**
             * 动态延长 Array
             * @param bufferType buffer类型
             * @param initSize 初始array 长度
             */
            function ExtenArray(bufferType, initSize) {
                if (initSize === void 0) { initSize = 32; }
                this.bufferType = bufferType;
                this._buoy = -1;
                this._length = initSize;
                // this._buffer = new T(initSize);
                this._buffer = new bufferType(initSize);
            }
            Object.defineProperty(ExtenArray.prototype, "buffer", {
                /** 定长数组 */
                get: function () { return this._buffer; },
                enumerable: false,
                configurable: true
            });
            ;
            Object.defineProperty(ExtenArray.prototype, "count", {
                /** 已经使用到数量 */
                get: function () { return this._buoy + 1; },
                set: function (val) {
                    if (val < 0)
                        val = 0;
                    if (val > this._length) {
                        var needSize = Math.ceil(val / this._length) * this._length;
                        this.exlength(needSize);
                    }
                    this._buoy = val - 1;
                },
                enumerable: false,
                configurable: true
            });
            ;
            ;
            /** push添加到array */
            ExtenArray.prototype.push = function (num) {
                this._buoy++;
                if (this._buoy >= this._length) {
                    this.exlength();
                }
                this._buffer[this._buoy] = num;
            };
            ExtenArray.prototype.exlength = function (mult) {
                if (mult === void 0) { mult = 2; }
                var _nlength = this._length * mult;
                var _buffer = this._buffer;
                // let _nbuffer = new T(_nlength);
                var _nbuffer = new this.bufferType(_nlength);
                for (var i = 0, len = this._length; i < len; i++) {
                    _nbuffer[i] = _buffer[i];
                }
                this._buffer = _nbuffer;
                this._length = _nlength;
            };
            /** 对象清理 */
            ExtenArray.prototype.dispose = function () {
                this._buffer = null;
            };
            return ExtenArray;
        }());
        math.ExtenArray = ExtenArray;
        /**
         * 复用数组 ，用于频繁重复创建数组容器的场景(减少GC消耗)
         */
        var ReuseArray = /** @class */ (function () {
            function ReuseArray() {
                this.arr = [];
                this.buoy = -1;
            }
            /** 获取 Array 对象 */
            ReuseArray.prototype.getArray = function () {
                return this.arr;
            };
            Object.defineProperty(ReuseArray.prototype, "length", {
                /** 获取当前长度 */
                get: function () { return this.buoy + 1; },
                set: function (val) { this.buoy = val - 1; },
                enumerable: false,
                configurable: true
            });
            ;
            ;
            ReuseArray.prototype.push = function (val) {
                this.buoy++;
                this.arr[this.buoy] = val;
            };
            /** 获取指定索引的值 */
            ReuseArray.prototype.get = function (index) {
                if (index > this.buoy)
                    return null;
                return this.arr[index];
            };
            /** 数组所有值置为null  */
            ReuseArray.prototype.clear = function () {
                var len = this.arr.length;
                for (var i = 0; i < len; i++) {
                    if (this.arr[i] == null && i >= this.buoy)
                        break;
                    this.arr[i] = null;
                }
                this.buoy = -1;
            };
            return ReuseArray;
        }());
        math.ReuseArray = ReuseArray;
        // //表示一个变换
        // export class transform
        // {
        //     rot: quaternion = new quaternion();
        //     tran: vector3 = new vector3();
        //     scale: vector3 = new vector3(1, 1, 1);
        // }
        // //表示一个不含缩放的变换
        // export class TransformWithoutScale
        // {
        //     rot: quaternion = new quaternion();
        //     tran: vector3 = new vector3();
        // }
        function vec4FormJson(json, vec4) {
            json = json.replace("(", "");
            json = json.replace(")", "");
            var arr = json.split(",");
            vec4.x = Number(arr[0]);
            vec4.y = Number(arr[1]);
            vec4.z = Number(arr[2]);
            vec4.w = Number(arr[3]);
        }
        math.vec4FormJson = vec4FormJson;
        function vec3FormJson(json, vec3) {
            json = json.replace("(", "");
            json = json.replace(")", "");
            var arr = json.split(",");
            vec3.x = Number(arr[0]);
            vec3.y = Number(arr[1]);
            vec3.z = Number(arr[2]);
        }
        math.vec3FormJson = vec3FormJson;
        function vec2FormJson(json, vec2) {
            json = json.replace("(", "");
            json = json.replace(")", "");
            var arr = json.split(",");
            vec2.x = Number(arr[0]);
            vec2.y = Number(arr[1]);
        }
        math.vec2FormJson = vec2FormJson;
        function colorFormJson(json, _color) {
            json = json.replace("RGBA(", "");
            json = json.replace(")", "");
            var arr = json.split(",");
            _color.r = Number(arr[0]);
            _color.g = Number(arr[1]);
            _color.b = Number(arr[2]);
            _color.a = Number(arr[3]);
        }
        math.colorFormJson = colorFormJson;
    })(math = m4m.math || (m4m.math = {}));
})(m4m || (m4m = {}));
/// <reference path="../../io/reflect.ts" />
/// <reference path="../../render/struct.ts" />
var m4m;
/// <reference path="../../io/reflect.ts" />
/// <reference path="../../render/struct.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 2d批处理类
         * @version m4m 1.0
         */
        var batcher2D = /** @class */ (function () {
            function batcher2D() {
                this.vboCount = 0;
                this.eboCount = 0;
            }
            /**
             * @private
             */
            batcher2D.prototype.initBuffer = function (webgl, vf, drawMode) {
                this.mesh = new m4m.render.glMesh();
                this.mesh.initBuffer(webgl, vf, 128, m4m.render.MeshTypeEnum.Dynamic);
                this.dataForVbo = new Float32Array(128);
                this.drawMode = drawMode;
                if (drawMode == m4m.render.DrawModeEnum.EboLine || drawMode == m4m.render.DrawModeEnum.EboTri) {
                    this.mesh.addIndex(webgl, 128);
                    this.dataForEbo = new Uint16Array(128);
                }
                this.mesh.initVAO();
            };
            /**
             * @private
             */
            batcher2D.prototype.begin = function (webgl, pass) {
                // if (mat == this.curmaterial) return;
                //这明显是个bug,pass即使一样，也可能要重绘
                if (this.vboCount > 0)
                    this.end(webgl);
                this.curPass = pass;
                this.vboCount = 0; //不清理会缓存
            };
            /**
             * @private
             */
            batcher2D.prototype.push = function (webgl, vbodata, ebodata) {
                if (this.vboCount + vbodata.length > batcher2D.limitCount
                    ||
                        (ebodata != null && this.eboCount + ebodata.length > batcher2D.limitCount)) {
                    this.end(webgl);
                    this.dataForVbo;
                }
                if (this.vboCount + vbodata.length > this.dataForVbo.length) {
                    var narr = new Float32Array(this.dataForVbo.length * 2);
                    for (var i = 0; i < this.dataForVbo.length; i++) {
                        narr[i] = this.dataForVbo[i];
                    }
                    this.dataForVbo = narr;
                    this.mesh.resetVboSize(webgl, this.dataForVbo.length);
                }
                for (var i = 0; i < vbodata.length; i++) {
                    this.dataForVbo[this.vboCount + i] = vbodata[i];
                }
                this.vboCount += vbodata.length;
                if (this.drawMode == m4m.render.DrawModeEnum.VboLine || this.drawMode == m4m.render.DrawModeEnum.VboTri)
                    return;
                if (ebodata != null) {
                    if (this.eboCount + ebodata.length > this.dataForEbo.length) {
                        var narr = new Uint16Array(this.dataForEbo.length * 2);
                        for (var i = 0; i < this.dataForEbo.length; i++) {
                            narr[i] = this.dataForEbo[i];
                        }
                        this.dataForEbo = narr;
                        this.mesh.resetEboSize(webgl, 0, this.dataForEbo.length);
                    }
                    for (var i = 0; i < ebodata.length; i++) {
                        this.dataForEbo[this.eboCount + i] = ebodata[i];
                    }
                    this.eboCount += ebodata.length;
                }
            };
            /**
             * @private
             */
            batcher2D.prototype.end = function (webgl) {
                if (this.vboCount == 0)
                    return;
                this.mesh.uploadVertexData(webgl, this.dataForVbo);
                if (this.eboCount > 0) {
                    this.mesh.uploadIndexData(webgl, 0, this.dataForEbo);
                }
                var vertexcount = (this.vboCount / (this.mesh.vertexByteSize / 4)) | 0;
                this.curPass.use(webgl);
                //顶点状态绑定
                // this.mesh.bind(webgl, this.curPass.program, (this.drawMode == render.DrawModeEnum.EboLine || this.drawMode == render.DrawModeEnum.EboTri) ? 0 : -1);
                this.mesh.onVAO();
                //绘制call
                framework.DrawCallInfo.inc.add();
                if (this.drawMode == m4m.render.DrawModeEnum.EboLine) {
                    this.mesh.drawElementLines(webgl, 0, this.eboCount);
                }
                else if (this.drawMode == m4m.render.DrawModeEnum.EboTri) {
                    this.mesh.drawElementTris(webgl, 0, this.eboCount);
                }
                else if (this.drawMode == m4m.render.DrawModeEnum.VboLine) {
                    this.mesh.drawArrayLines(webgl, 0, vertexcount);
                }
                else if (this.drawMode == m4m.render.DrawModeEnum.VboTri) {
                    this.mesh.drawArrayTris(webgl, 0, vertexcount);
                }
                this.vboCount = 0;
                this.eboCount = 0;
                //顶点状态解绑
                this.mesh.offVAO();
            };
            //buffer 最大限制
            batcher2D.limitCount = 2048 * 64;
            return batcher2D;
        }());
        framework.batcher2D = batcher2D;
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 2d节点的容器类
         * @version m4m 1.0
         */
        var canvas = /** @class */ (function () {
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 构造函数
             * @version m4m 1.0
             */
            function canvas() {
                this._peCareListBuoy = -1;
                this._pointEventCareList = [];
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 用于区分当前容器是在overlay(2D)还是canvasrenderer(3D)下
                 * @version m4m 1.0
                 */
                this.is2dUI = true;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * UI绘制使用深度排序规则
                 * (可以降低drawcall , 但是会一定程度增加CPU计算量,视情况使用)
                 * @version m4m 1.0
                 */
                this.isDrawByDepth = false;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 *  强行lable置顶渲染（用于优化Drawcall）
                 * @version m4m 1.0
                 */
                this.isForceLabelTopRender = false;
                /**
                 * 启用UI事件
                 */
                this.enableUIEvent = true;
                /** 启用 剔除超出可视范围的渲染节点  */
                this.enableOutsideRenderClip = true;
                this.pointDown = false;
                this.pointEvent = new framework.PointEvent();
                this.pointX = 0;
                this.pointY = 0;
                this.lastWidth = 0;
                this.lastHeight = 0;
                this.lastMultiTouch = false;
                this._insIdFrameMap = {};
                this.lastMaskSta = -1;
                this.rendererDic = {}; //渲染对象字典容器
                this.depthList = [];
                this.sortedList = [];
                this.canvasBounds = new m4m.math.rect(); //canvas 全局边框矩形
                this.qt_maxObjNum = 5; //四叉树节点最大的对象数量
                this.qt_maxlevel = 6; //四叉树最大的深度
                this.helpMap = {};
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 画布使用的像素宽度
                 * @version m4m 1.0
                 */
                this.pixelWidth = 640;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 画布使用的像素高度
                 * @version m4m 1.0
                 */
                this.pixelHeight = 480;
                this.rootNode = new framework.transform2D();
                this.rootNode.canvas = this;
            }
            canvas_1 = canvas;
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 添加2d节点
             * @param node 要添加的2d节点实例
             * @version m4m 1.0
             */
            canvas.prototype.addChild = function (node) {
                this.rootNode.addChild(node);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 移除2d节点
             * @param node 要移除的2d节点实例
             * @version m4m 1.0
             */
            canvas.prototype.removeChild = function (node) {
                this.rootNode.removeChild(node);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取所有孩子节点
             * @version m4m 1.0
             */
            canvas.prototype.getChildren = function () {
                return this.rootNode.children;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取孩子节点的数量
             * @version m4m 1.0
             */
            canvas.prototype.getChildCount = function () {
                if (this.rootNode.children == null)
                    return 0;
                return this.rootNode.children.length;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取指定的孩子节点
             * @param index 位置索引
             * @version m4m 1.0
             */
            canvas.prototype.getChild = function (index) {
                return this.rootNode.children[index];
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 更新
             * @param delta 两次update的间隔时间
             * @param touch 是否接收到事件
             * @param XOnModelSpace 模型空间下的x偏移
             * @param YOnModelSpace 模型空间下的y偏移
             * @param multiTouch 是否多点中
             * @version m4m 1.0
             */
            canvas.prototype.update = function (delta, touch, XOnModelSpace, YOnModelSpace, multiTouch) {
                if (multiTouch === void 0) { multiTouch = false; }
                this.rootSizeAdjust();
                this.burstPointEvent(touch, XOnModelSpace, YOnModelSpace, multiTouch);
                this.updateNodeTree(delta);
            };
            /**
             * 根节点 尺寸 调整
             */
            canvas.prototype.rootSizeAdjust = function () {
                //canvas 的空间是左上角(-asp,1)-(asp,-1),和屏幕空间一致
                //右下角是 1*asp，1
                //这里有点状况，不应该乘以
                var rootnode = this.rootNode;
                // var asp = this.pixelWidth / this.pixelHeight;
                var dirtyScale = false;
                if (rootnode.dirty) {
                    rootnode.localRotate = rootnode.pivot.x = rootnode.pivot.y = 0;
                    rootnode.localTranslate.y = 1;
                    rootnode.localTranslate.x = -1;
                    dirtyScale = true;
                }
                if (this.pixelWidth != this.lastWidth || this.pixelHeight != this.lastHeight) {
                    this.lastWidth = rootnode.width = this.pixelWidth;
                    this.lastHeight = rootnode.height = this.pixelHeight;
                    dirtyScale = true;
                }
                if (dirtyScale) {
                    rootnode.localScale.x = 2 / this.pixelWidth;
                    rootnode.localScale.y = -2 / this.pixelHeight;
                    rootnode.markDirty();
                }
            };
            /** 刷新节点树 */
            canvas.prototype.updateNodeTree = function (delta) {
                if (this.onPreUpdate)
                    this.onPreUpdate(delta);
                //upadte
                this.rootNode.updateTran(false);
                //rootnode.update(delta);
                if (this.scene.app.bePlay) {
                    this._peCareListBuoy = -1;
                    this.objupdate(this.rootNode, delta);
                }
                if (this.onLateUpdate)
                    this.onLateUpdate(delta);
            };
            /**
             * 触发 point 事件流
             * @param touch 是否有点
             * @param XOnModelSpace 坐标x
             * @param YOnModelSpace 坐标y
             * @param multiTouch 多点
             */
            canvas.prototype.burstPointEvent = function (touch, XOnModelSpace, YOnModelSpace, multiTouch) {
                if (multiTouch === void 0) { multiTouch = false; }
                if (!this.enableUIEvent)
                    return;
                //重置event
                this.pointEvent.eated = false;
                var tv2 = canvas_1.help_v2;
                tv2.x = this.pointEvent.x = XOnModelSpace;
                tv2.y = this.pointEvent.y = YOnModelSpace;
                this.pointEvent.selected = null;
                this.clipPosToCanvasPos(tv2, tv2);
                this.pointEvent.c_x = tv2.x;
                this.pointEvent.c_y = tv2.y;
                var skip = false;
                if (!this.pointDown && !touch && !multiTouch && !this.lastMultiTouch) //nothing
                 {
                    skip = true;
                }
                else if (this.pointDown == false && touch == true) //pointdown
                 {
                    this.pointEvent.type = m4m.event.PointEventEnum.PointDown;
                }
                else if (this.pointDown == true && touch == true) //pointhold
                 {
                    this.pointEvent.type = m4m.event.PointEventEnum.PointHold;
                    // if (this.pointX == this.pointEvent.x && this.pointY == this.pointEvent.y)
                    // {
                    //     // console.log("skip event");
                    //     skip = true;
                    // }
                }
                else if (this.pointDown == true && touch == false) //pointup
                 {
                    this.pointEvent.type = m4m.event.PointEventEnum.PointUp;
                }
                //事件走的是flash U型圈
                if (!skip) {
                    if (this.scene.app.bePlay) {
                        // rootnode.onCapturePointEvent(this, this.pointEvent);
                        // rootnode.onPointEvent(this, this.pointEvent);
                        //优化
                        // this.capturePointFlow();  //多余 flow
                        this.popPointFlow();
                    }
                    this.pointDown = touch;
                    this.pointX = this.pointEvent.x;
                    this.pointY = this.pointEvent.y;
                }
                // m4m.poolv2_del(tv2);
                this.lastMultiTouch = multiTouch;
            };
            //捕获阶段流
            canvas.prototype.capturePointFlow = function () {
                //event 捕捉阶段，自上而下
                var list = this._pointEventCareList;
                var buoy = this._peCareListBuoy;
                var ev = this.pointEvent;
                var Eated = false;
                while (buoy >= 0) {
                    var idx = this._peCareListBuoy - buoy;
                    var node = framework.transform2D.getTransform2DById(list[idx]);
                    if (node.components) {
                        for (var i = 0; i <= node.components.length; i++) {
                            if (ev.eated == false) {
                                var comp = node.components[i];
                                if (comp && comp.init && framework.instanceOfI2DPointListener(comp.comp)) {
                                    comp.comp.onPointEvent(canvas_1, ev, true);
                                    Eated = ev.eated;
                                    if (ev.eated)
                                        break;
                                }
                            }
                        }
                    }
                    buoy--;
                    if (Eated)
                        break;
                }
            };
            //冒泡阶段流
            canvas.prototype.popPointFlow = function () {
                var list = this._pointEventCareList;
                var buoy = this._peCareListBuoy;
                var ev = this.pointEvent;
                var Eated = false;
                while (buoy >= 0) {
                    var node = framework.transform2D.getTransform2DById(list[buoy]);
                    if (node && node.components) {
                        for (var i = 0; i <= node.components.length; i++) {
                            if (ev.eated == false) {
                                var comp = node.components[i];
                                if (comp && comp.init && framework.instanceOfI2DPointListener(comp.comp)) {
                                    comp.comp.onPointEvent(canvas_1, ev, false);
                                    Eated = ev.eated;
                                    if (ev.eated)
                                        break;
                                }
                            }
                        }
                    }
                    buoy--;
                    if (Eated)
                        break;
                }
            };
            canvas.prototype.objupdate = function (node, delta) {
                if (!node || !node.visible)
                    return;
                var app = this.scene.app;
                var currFrameID = app.frameID;
                node.init(this.scene.app.bePlay); //组件还未初始化的初始化
                var compLen = node.components.length;
                if (compLen > 0) {
                    for (var i = 0; i < compLen; i++) {
                        if (!node.components[i])
                            continue; //能在有对象在update环节dispose
                        var c = node.components[i];
                        if (!c)
                            continue;
                        var comp = c.comp;
                        if (framework.StringUtil.ENABLED in c.comp && !c.comp[framework.StringUtil.ENABLED])
                            continue;
                        if (!c.OnPlayed) {
                            c.comp.onPlay();
                            c.OnPlayed = true;
                        }
                        if (comp.update)
                            comp.update(delta);
                        if (framework.instanceOfI2DPointListener(comp)) { //判断是否为
                            var insId = node.insId.getInsID();
                            //insID 去重
                            if (this._insIdFrameMap[insId] != currFrameID) {
                                this._insIdFrameMap[insId] = currFrameID;
                                this._peCareListBuoy++;
                                var plist = this._pointEventCareList;
                                var pBuoy = this._peCareListBuoy;
                                if (plist.length <= pBuoy) {
                                    plist.push(insId);
                                }
                                else {
                                    plist[pBuoy] = insId;
                                }
                                plist[pBuoy];
                            }
                        }
                    }
                }
                if (node.children != null) {
                    var chiLen = node.children.length;
                    for (var i = 0; i < chiLen; i++) {
                        this.objupdate(node.children[i], delta);
                    }
                }
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 渲染
             * @param context 渲染上下文
             * @param assetmgr 资源管理类的实例
             * @version m4m 1.0
             */
            canvas.prototype.render = function (context, assetmgr) {
                framework.DrawCallInfo.inc.currentState = framework.DrawCallEnum.UI;
                this.context = context;
                this.assetmgr = assetmgr;
                // context.updateModel(this.gameObject.transform);
                this.lastMat = null;
                // if (canvasRenderer.defmat == null)
                // {
                //     canvasRenderer.defmat = new material();
                //     canvasRenderer.defmat.setShader(assetmgr.getShader("shader/defui"));
                // }
                if (this.batcher == null) {
                    this.webgl = context.webgl;
                    this.batcher = new batcher2D();
                    var vf = m4m.render.VertexFormatMask.Position | m4m.render.VertexFormatMask.Color | m4m.render.VertexFormatMask.UV0 | m4m.render.VertexFormatMask.ColorEX;
                    this.batcher.initBuffer(context.webgl, vf, m4m.render.DrawModeEnum.VboTri);
                }
                //this.pushDrawData(canvas.defmat, this.vbod);
                if (this.beforeRender != null)
                    this.beforeRender();
                //begin
                if (!this.isDrawByDepth) {
                    this.drawScene(this.rootNode, context, assetmgr);
                    if (this.isForceLabelTopRender) {
                        this.renderTopLabels();
                        canvas_1.helpLabelArr.length = 0;
                    }
                }
                else {
                    this.drawSceneByDepth(this.rootNode, context, assetmgr);
                }
                this.batcher.end(context.webgl);
                if (this.afterRender != null)
                    this.afterRender();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 提交原始数据</p>
             * 所有的2d渲染组件将数据提交到这里</p>
             * 最后由批处理完成绘制
             * @param mat 材质
             * @param data 2d渲染组件的顶点数据
             * @version m4m 1.0
             */
            canvas.prototype.pushRawData = function (mat, data) {
                if (mat != this.lastMat) {
                    this.lastMat = mat;
                    this.batcher.end(this.webgl);
                    var pass = this.lastMat.getShader().passes["base"][0];
                    //有一些自动参数要传进去
                    //mat.setMatrix("glstate_matrix_mvp", this.context.matrixModelViewProject);
                    //mat.uploadUniform(pass);
                    // //mvp 信号
                    pass.use(this.webgl);
                    mat.uploadUnifoms(pass, this.context);
                    // this.batcher.begin(context.webgl, pass);
                    // this.batcher.push(context.webgl, this.vbod, null);
                    // this.batcher.end(context.webgl);
                    this.batcher.begin(this.webgl, pass);
                }
                else {
                    var msta = mat.statedMapUniforms["MaskState"];
                    var mr = mat.statedMapUniforms["_maskRect"];
                    if (msta != null && msta.value != null && mr != null && mr.value != null) {
                        var rect = mr.value;
                        if (this.lastMaskV4 == null)
                            this.lastMaskV4 = new m4m.math.vector4();
                        if (msta.value != this.lastMaskSta || this.lastMaskV4.x != rect.x || this.lastMaskV4.y != rect.y || this.lastMaskV4.z != rect.z || this.lastMaskV4.w != rect.w) {
                            this.lastMaskSta = msta.value;
                            m4m.math.vec4Clone(rect, this.lastMaskV4);
                            this.batcher.end(this.webgl);
                            var pass = this.lastMat.getShader().passes["base"][0];
                            //mat.uploadUniform(pass);
                            mat.uploadUnifoms(pass, this.context);
                        }
                    }
                }
                this.batcher.push(this.webgl, data, null);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 绘制2d节点
             * @param node 要绘制的2d节点
             * @param context 渲染上下文
             * @param assetmgr 资源管理类的实例
             * @version m4m 1.0
             */
            canvas.prototype.drawScene = function (node, context, assetmgr) {
                //context.updateModel(this.gameObject.transform);
                if (!node.visible)
                    return;
                var r = node.renderer;
                if (r != null && (!this.enableOutsideRenderClip || !this.ckViewOutside(node))) { //视窗剔除
                    //渲染
                    if (!this.isForceLabelTopRender || !("isLabel" in r)) {
                        r.render(this);
                    }
                    else {
                        canvas_1.helpLabelArr.push(r);
                    }
                }
                if (node.children != null) {
                    for (var i = 0; i < node.children.length; i++) {
                        this.drawScene(node.children[i], context, assetmgr);
                    }
                }
            };
            /**
             * 检查是在可视区域外
             * @param node 节点
             */
            canvas.prototype.ckViewOutside = function (node) {
                var canvasRect = canvas_1.help_rect_CanvasV;
                m4m.math.rectSet(canvasRect, 0, 0, this.pixelWidth, this.pixelHeight);
                // let nodeRect = node.getDrawBounds();
                var nodeRect = node.aabbRect;
                var isInside = m4m.math.rectOverlap(canvasRect, nodeRect);
                return !isInside;
            };
            canvas.prototype.renderTopLabels = function () {
                var len = canvas_1.helpLabelArr.length;
                if (len < 1)
                    return;
                var arr = canvas_1.helpLabelArr;
                for (var i = 0; i < len; i++) {
                    arr.get(i).render(this);
                }
            };
            /** 按深度层 合批渲染 */
            canvas.prototype.drawSceneByDepth = function (node, context, assetmgr) {
                var _this = this;
                //更新 canvasBounds
                this.canvasBounds.w = this.pixelWidth;
                this.canvasBounds.h = this.pixelHeight;
                if (!this.depthQTree)
                    this.depthQTree = new framework.quadTree(this.canvasBounds, this.qt_maxObjNum, this.qt_maxlevel);
                this.depthQTree.clear();
                //所有Renderer 计算 深度
                this.flowCount = 0;
                //test 
                this.collectToDepthL(node);
                //按队列顺序 逐各渲染
                this.sortDepthList();
                this.sortedList.forEach(function (rnode) {
                    if (rnode)
                        rnode.render(_this);
                });
                this.depthList.length = this.sortedList.length = 0;
            };
            /** 排序Depth列表 */
            canvas.prototype.sortDepthList = function () {
                var _this = this;
                var len = this.depthList.length;
                var lastGuid = -1;
                var idList = [];
                var _loop_1 = function (i) {
                    idList.length = 0;
                    //逐层按相同材质连续排序 
                    //不同层首尾连接规则 1.队列头部 放置 和上一层同材质类型 2.尾部放置 数量最多的类型 
                    var arr = this_1.depthList[i];
                    var tempM = {};
                    arr.forEach(function (rn, idx) {
                        if (rn && rn.getMaterial()) {
                            var guid = rn.getMaterial().getGUID();
                            if (!_this.helpMap[guid])
                                _this.helpMap[guid] = [];
                            _this.helpMap[guid].push(rn);
                            if (!tempM[guid]) {
                                idList.push(guid);
                                tempM[guid] = true;
                            }
                        }
                    });
                    //排序  1.队列头部 放置 和上一层同材质类型 2.尾部放置 数量最多的类型 
                    //1.队列头部 放置 和上一层同材质类型
                    if (lastGuid != -1 && this_1.helpMap[lastGuid] && this_1.helpMap[lastGuid].length > 0) {
                        var sidx = idList.indexOf(lastGuid);
                        if (sidx != -1)
                            idList.splice(sidx, 1);
                        idList.unshift(lastGuid);
                    }
                    //2.尾部放置 数量最多的类型
                    var tempLastLen = 0;
                    var endGuid = -1;
                    for (var key in this_1.helpMap) {
                        var temparr = this_1.helpMap[key];
                        if (temparr && temparr.length > tempLastLen) {
                            endGuid = Number(key);
                            tempLastLen = temparr.length;
                        }
                    }
                    //尾部 ,优先 头部规则
                    if (lastGuid != endGuid && endGuid != -1 && !isNaN(endGuid)) {
                        var sidx = idList.indexOf(endGuid);
                        if (sidx != -1)
                            idList.splice(sidx, 1);
                        idList.push(endGuid);
                    }
                    idList.forEach(function (id) {
                        var rArr = _this.helpMap[id];
                        if (rArr && rArr.length > 0) {
                            rArr.forEach(function (rn) {
                                if (rn)
                                    _this.sortedList.push(rn);
                            });
                        }
                    });
                    if (idList.length > 0) {
                        lastGuid = idList[idList.length - 1];
                    }
                    //清理map
                    for (var key in this_1.helpMap) {
                        var temparr = this_1.helpMap[key];
                        if (temparr)
                            temparr.length = 0;
                    }
                };
                var this_1 = this;
                for (var i = 0; i < len; i++) {
                    _loop_1(i);
                }
                this.helpMap = {};
            };
            /**收集到深度列表 */
            canvas.prototype.collectToDepthL = function (node) {
                if (!node.visible)
                    return;
                if (node.renderer) {
                    var bounds = node.renderer.getDrawBounds();
                    bounds[canvas_1.flowIndexTag] = this.flowCount;
                    this.rendererDic[this.flowCount] = node.renderer; //引用 存入字典
                    this.checkBottomUI(node.renderer);
                    this.flowCount++;
                }
                if (node.children) {
                    for (var i = 0; i < node.children.length; i++) {
                        this.collectToDepthL(node.children[i]);
                    }
                }
            };
            /**
             * 检查BottomUI
             */
            canvas.prototype.checkBottomUI = function (rd) {
                //检测 bottomUI  (逐当前 depthList 层检测 rect 碰撞 ，优化工具 四叉树 )
                //无 ，depth = 0
                //有 ，depth = bottomUI.depth + 1 
                var tempCup = [];
                var myr = rd.getDrawBounds();
                this.depthQTree.retrieve(myr, tempCup);
                var lastIdx = -1;
                //确定 深度
                while (tempCup.length > 0) {
                    var temp = tempCup.pop();
                    if (m4m.math.rectCollided(temp, myr)) {
                        if (temp[canvas_1.flowIndexTag] > lastIdx) {
                            lastIdx = temp[canvas_1.flowIndexTag];
                            if (temp[canvas_1.flowIndexTag] == (myr[canvas_1.flowIndexTag] - 1))
                                break; //相邻的bottomUI ，其他不用找了
                        }
                    }
                }
                var depth = 0;
                if (lastIdx != -1) {
                    var wrd = this.rendererDic[lastIdx];
                    depth = wrd[canvas_1.depthTag] + 1;
                }
                rd[canvas_1.depthTag] = depth;
                //填入 到四叉树 
                this.depthQTree.insert(myr);
                if (!this.depthList[depth])
                    this.depthList[depth] = [];
                this.depthList[depth].push(rd);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取canvas的根节点
             * @version m4m 1.0
             */
            canvas.prototype.getRoot = function () {
                if (this.rootNode == null) {
                    this.rootNode = new framework.transform2D();
                    this.rootNode.canvas = this;
                    this.scene.app.markNotify(this.rootNode, framework.NotifyType.AddChild);
                }
                return this.rootNode;
            };
            /**
             * [过时接口,完全弃用]
             * @version m4m 1.0
             */
            canvas.prototype.ModelPosToCanvasPos = function (clipPos, outCanvasPos) {
                this.clipPosToCanvasPos(clipPos, outCanvasPos);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 裁剪空间坐标 转到 canvas 坐标
             * @param clipPos 屏幕空间坐标
             * @param outCanvasPos canvas 坐标
             * @version m4m 1.0
             */
            canvas.prototype.clipPosToCanvasPos = function (clipPos, outCanvasPos) {
                if (clipPos == null || outCanvasPos == null)
                    return;
                var scalx = 1 - (clipPos.x - 1) * -0.5;
                var scaly = (clipPos.y - 1) * -0.5;
                outCanvasPos.x = scalx * this.pixelWidth;
                outCanvasPos.y = scaly * this.pixelHeight;
            };
            /**
             * [过时接口,完全弃用]
             * @version m4m 1.0
             */
            canvas.prototype.CanvasPosToModelPos = function (canvasPos, outClipPos) {
                this.canvasPosToClipPos(canvasPos, outClipPos);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * canvas坐标 转到 裁剪空间坐标
             * @param canvasPos canvas坐标
             * @param outClipPos model空间坐标
             * @version m4m 1.0
             */
            canvas.prototype.canvasPosToClipPos = function (canvasPos, outClipPos) {
                if (!canvasPos || !outClipPos)
                    return;
                var scalx = canvasPos.x / this.pixelWidth;
                var scaly = canvasPos.y / this.pixelHeight;
                outClipPos.x = scalx * 2 - 1;
                outClipPos.y = 1 - scaly * 2;
            };
            var canvas_1;
            canvas.ClassName = "canvas";
            canvas.help_v2 = new m4m.math.vector2();
            canvas.help_rect_CanvasV = new m4m.math.rect();
            canvas.helpLabelArr = new m4m.math.ReuseArray();
            //深度渲染层列表
            canvas.depthTag = "__depthTag__";
            canvas.flowIndexTag = "__flowIndexTag__";
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], canvas.prototype, "pixelWidth", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], canvas.prototype, "pixelHeight", void 0);
            __decorate([
                m4m.reflect.Field("transform2D"),
                __metadata("design:type", framework.transform2D)
            ], canvas.prototype, "rootNode", void 0);
            canvas = canvas_1 = __decorate([
                m4m.reflect.SerializeType,
                __metadata("design:paramtypes", [])
            ], canvas);
            return canvas;
        }());
        framework.canvas = canvas;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../io/reflect.ts" />
var m4m;
/// <reference path="../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 3DUI的容器类</p>
         * 3d组件</p>
         * 与overlay(2DUI)相对应。
         * @version m4m 1.0
         */
        var canvasRenderer = /** @class */ (function () {
            /**
             * @private
             */
            function canvasRenderer() {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * layer类型
                 * @version m4m 1.0
                 */
                this.layer = framework.RenderLayerEnum.Common;
                /**
                 * @private
                 */
                this.queue = 0;
                this.m_lastAsp = -1;
                this.cupTans2ds = [];
                this.canvas = new framework.canvas();
                this.canvas.is2dUI = false;
            }
            Object.defineProperty(canvasRenderer.prototype, "renderLayer", {
                //renderLayer: CullingMask = CullingMask.default;
                get: function () { return this.gameObject.layer; },
                set: function (layer) {
                    this.gameObject.layer = layer;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(canvasRenderer.prototype, "dontFrustumCulling", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 不受视锥剔除
                 * @version m4m 1.0
                 */
                get: function () {
                    if (this.gameObject) {
                        return (this.gameObject.hideFlags & framework.HideFlags.DontFrustumCulling) != 0;
                    }
                    else {
                        return false;
                    }
                },
                set: function (val) {
                    if (this.gameObject) {
                        if (val)
                            this.gameObject.hideFlags |= framework.HideFlags.DontFrustumCulling;
                        else
                            this.gameObject.hideFlags ^= framework.HideFlags.DontFrustumCulling;
                    }
                },
                enumerable: false,
                configurable: true
            });
            /**
             * @private
             */
            canvasRenderer.prototype.getBound = function () {
                return null;
            };
            /**
             * @private
             */
            canvasRenderer.prototype.intersectsTransform = function (tran) {
                return false;
            };
            /**
             * @private
             */
            canvasRenderer.prototype.start = function () {
                this.canvas.scene = this.gameObject.getScene();
                this.canvas.parentTrans = this.gameObject.transform;
                this.inputmgr = this.gameObject.getScene().app.getInputMgr();
            };
            canvasRenderer.prototype.onPlay = function () {
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 添加2d子节点
             * @version m4m 1.0
             */
            canvasRenderer.prototype.addChild = function (node) {
                this.canvas.addChild(node);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 移除2d子节点
             * @version m4m 1.0
             */
            canvasRenderer.prototype.removeChild = function (node) {
                this.canvas.removeChild(node);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取所有2d子节点
             * @version m4m 1.0
             */
            canvasRenderer.prototype.getChildren = function () {
                return this.canvas.getChildren();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取2d子节点的数量
             * @version m4m 1.0
             */
            canvasRenderer.prototype.getChildCount = function () {
                return this.canvas.getChildCount();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取2d子节点
             * @param index 索引
             * @version m4m 1.0
             */
            canvasRenderer.prototype.getChild = function (index) {
                return this.canvas.getChild(index);
            };
            /**
             * @private
             */
            canvasRenderer.prototype.update = function (delta) {
                var asp = this.canvas.pixelWidth / this.canvas.pixelHeight;
                if (asp != this.m_lastAsp) {
                    this.gameObject.transform.localScale.x = this.gameObject.transform.localScale.y * asp;
                    this.gameObject.transform.localScale = this.gameObject.transform.localScale;
                    this.m_lastAsp = asp;
                }
                if (this.cameraTouch != null) //需要用户代码 或者在编辑器里面绑定使用哪个camera（即设置此变量）,否则不会主动响应事件否则不会主动响应事件
                 {
                    var scene_1 = this.gameObject.getScene();
                    var tempv2 = m4m.math.pool.new_vector2(this.inputmgr.point.x, this.inputmgr.point.y);
                    var ray_1 = this.cameraTouch.creatRayByScreen(tempv2, scene_1.app);
                    var outModel = m4m.math.pool.new_vector2();
                    var bool = this.pickModelPos(ray_1, outModel);
                    if (bool) {
                        this.canvas.update(delta, this.inputmgr.point.touch, outModel.x, outModel.y);
                    }
                    else {
                        this.canvas.update(delta, false, 0, 0);
                    }
                    m4m.math.pool.delete_vector2(tempv2);
                    m4m.math.pool.delete_vector2(outModel);
                }
                else {
                    this.canvas.update(delta, false, 0, 0);
                }
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 射线碰撞 获取 Model坐标点
             * @param ray 射线
             * @param outModel Pos out获取到的Model坐标
             * @version m4m 1.0
             */
            canvasRenderer.prototype.pickModelPos = function (ray, outModelPos) {
                var result = false;
                if (!ray || !outModelPos)
                    return result;
                var scene = this.gameObject.getScene();
                var tempInfo = m4m.math.pool.new_pickInfo();
                var bool = ray.intersectPlaneTransform(this.gameObject.transform, tempInfo);
                if (bool && tempInfo.pickedtran == this.gameObject.transform) //pick 到自己
                 {
                    var mat = this.gameObject.transform.getWorldMatrix();
                    var matinv = m4m.math.pool.new_matrix();
                    m4m.math.matrixInverse(mat, matinv);
                    var outv = m4m.math.pool.new_vector3();
                    m4m.math.matrixTransformVector3(tempInfo.hitposition, matinv, outv);
                    outModelPos.x = outv.x;
                    outModelPos.y = outv.y;
                    result = true;
                    m4m.math.pool.delete_matrix(matinv);
                    m4m.math.pool.delete_vector3(outv);
                }
                return result;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 射线拣选 全部 transform2D
             * @param ray 射线
             * @version m4m 1.0
             */
            canvasRenderer.prototype.pickAll2d = function (ray) {
                var result;
                var outv = m4m.math.pool.new_vector2();
                var bool = this.pickModelPos(ray, outv);
                if (bool) {
                    result = [];
                    this.dopick2d(outv, this.canvas.getRoot(), result, true);
                }
                m4m.math.pool.delete_vector2(outv);
                return result;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 射线拣选transform2D
             * @param ray 射线
             * @version m4m 1.0
             */
            canvasRenderer.prototype.pick2d = function (ray) {
                var result;
                var outv = m4m.math.pool.new_vector2();
                var bool = this.pickModelPos(ray, outv);
                if (bool) {
                    var temparr = [];
                    this.dopick2d(outv, this.canvas.getRoot(), temparr);
                    if (temparr && temparr[0])
                        result = temparr[0];
                }
                m4m.math.pool.delete_vector2(outv);
                return result;
            };
            /**
             * Model坐标来拣选transform2D (从下至上递归)
             */
            canvasRenderer.prototype.dopick2d = function (ModelPos, tran, outPicks, isAll) {
                if (isAll === void 0) { isAll = false; }
                if (!ModelPos || !tran || !outPicks)
                    return;
                if (tran.children && tran.children.length > 0) {
                    for (var i = tran.children.length - 1; i >= 0; i--) {
                        this.dopick2d(ModelPos, tran.children[i], outPicks, isAll);
                    }
                }
                if (tran.ContainsCanvasPoint(ModelPos)) {
                    outPicks.push(tran);
                    if (!isAll)
                        return;
                }
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 屏幕空间坐标 转到 canvas坐标
             * @version m4m 1.0
             */
            canvasRenderer.prototype.calScreenPosToCanvasPos = function (camera, screenPos, outCanvasPos) {
                if (!camera || !screenPos || !outCanvasPos)
                    return;
                var ray = camera.creatRayByScreen(screenPos, this.gameObject.getScene().app);
                var ModelPos = m4m.math.pool.new_vector2();
                this.pickModelPos(ray, ModelPos);
                this.canvas.clipPosToCanvasPos(ModelPos, outCanvasPos);
                m4m.math.pool.delete_vector2(ModelPos);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * canvas坐标 转到 世界空间坐标
             * @param from Transform2D世界坐标
             * @param out 返回结果v2
             * @version m4m 1.0
             */
            canvasRenderer.prototype.calCanvasPosToWorldPos = function (from, out) {
                if (!this.canvas || !from || !out)
                    return;
                var ModelPos = m4m.math.pool.new_vector3();
                ModelPos.x = (from.x / this.canvas.pixelWidth) * 2 - 1;
                ModelPos.y = (from.y / this.canvas.pixelHeight) * -2 + 1;
                var m_mtx = this.gameObject.transform.getWorldMatrix();
                m4m.math.matrixTransformVector3(ModelPos, m_mtx, out);
                out.z = this.gameObject.transform.getWorldTranslate().z;
                m4m.math.pool.delete_vector3(ModelPos);
            };
            /**
             * @private
             */
            canvasRenderer.prototype.render = function (context, assetmgr, camera) {
                // if (!(camera.CullingMask & this.renderLayer)) return;
                context.updateModel(this.gameObject.transform);
                this.canvas.render(context, assetmgr);
            };
            /**
             * @private
             */
            canvasRenderer.prototype.remove = function () {
            };
            /**
             * @private
             */
            canvasRenderer.prototype.clone = function () {
            };
            canvasRenderer.ClassName = "canvasRenderer";
            __decorate([
                m4m.reflect.Field("boolean"),
                __metadata("design:type", Boolean),
                __metadata("design:paramtypes", [Boolean])
            ], canvasRenderer.prototype, "dontFrustumCulling", null);
            __decorate([
                m4m.reflect.Field("canvas"),
                __metadata("design:type", framework.canvas)
            ], canvasRenderer.prototype, "canvas", void 0);
            canvasRenderer = __decorate([
                m4m.reflect.nodeRender,
                m4m.reflect.nodeComponent,
                m4m.reflect.nodeCanvasRendererCollider,
                __metadata("design:paramtypes", [])
            ], canvasRenderer);
            return canvasRenderer;
        }());
        framework.canvasRenderer = canvasRenderer;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../io/reflect.ts" />
var m4m;
/// <reference path="../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * UI 缩放模式
         */
        var UIScaleMode;
        (function (UIScaleMode) {
            /** 固定像素尺寸*/
            UIScaleMode[UIScaleMode["CONSTANT_PIXEL_SIZE"] = 0] = "CONSTANT_PIXEL_SIZE";
            /**参考屏幕尺寸比例缩放*/
            UIScaleMode[UIScaleMode["SCALE_WITH_SCREEN_SIZE"] = 1] = "SCALE_WITH_SCREEN_SIZE";
        })(UIScaleMode = framework.UIScaleMode || (framework.UIScaleMode = {}));
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 2DUI的容器类，与canvasrender(3DUI)相对应。
         * @version m4m 1.0
         */
        var overlay2D = /** @class */ (function () {
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 构造函数
             * @version m4m 1.0
             */
            function overlay2D() {
                this._hasListenerEvent = false;
                this._disposed = false;
                /**
                 * @private
                 * @language zh_CN
                 * @classdesc
                 * 是否初始化完成，在执行完start之后设置为true
                 * @version m4m 1.0
                 */
                this.init = false;
                // /**
                //  * @public
                //  * @language zh_CN
                //  * @classdesc
                //  * 是否自适应
                //  * @version m4m 1.0
                //  */
                // @m4m.reflect.Field("boolean")
                // autoAsp: boolean = true;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 屏幕宽高匹配模式 (range 0-1  =0:固定宽  =1:固定高)
                 * @version m4m 1.0
                 */
                this.screenMatchRate = 0;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 屏幕匹配参考宽度
                 * @version m4m 1.0
                 */
                this.matchReference_width = 800;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 屏幕匹配参考高度
                 * @version m4m 1.0
                 */
                this.matchReference_height = 600;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 缩放模式
                 *
                 * 配合参数 ：
                 * matchReference_height
                 * matchReference_width
                 * screenMatchRate
                 * @version m4m 1.0
                 */
                this.scaleMode = UIScaleMode.CONSTANT_PIXEL_SIZE;
                /**
                * @public
                * @language zh_CN
                * @classdesc
                * 渲染排序
                * @version m4m 1.0
                */
                this.sortOrder = 0;
                // private readonly viewPixelrect = new math.rect();
                this.helpv2 = new m4m.math.vector2();
                this.helpv2_1 = new m4m.math.vector2();
                this.lastVPRect = new m4m.math.rect();
                this.lastScreenMR = 0;
                this.lastMR_width = 0;
                this.lastMR_height = 0;
                this.canvas = new framework.canvas();
                framework.sceneMgr.app.markNotify(this.canvas.getRoot(), framework.NotifyType.AddChild);
            }
            overlay2D_1 = overlay2D;
            Object.defineProperty(overlay2D.prototype, "disposed", {
                get: function () { return this._disposed; },
                enumerable: false,
                configurable: true
            });
            ;
            overlay2D.prototype.dispose = function () {
                this.unRegEvents();
                this._disposed = true;
            };
            /**
             * @private
             */
            overlay2D.prototype.start = function (camera) {
                if (camera == this.camera)
                    return;
                this.camera = camera;
                this.app = camera.gameObject.getScene().app;
                camera.calcViewPortPixel(this.app);
                this.canvas.scene = camera.gameObject.getScene();
                this.inputmgr = camera.gameObject.getScene().app.getInputMgr();
                if (overlay2D_1.pointEventDirectMode) {
                    this.regEvnets();
                }
            };
            overlay2D.prototype.regEvnets = function () {
                this._hasListenerEvent = true;
                var ipt = m4m.framework.sceneMgr.app.getInputMgr();
                ipt.addHTMLElementListener("touchstart", this.refreshAndPointEvent, this);
                ipt.addHTMLElementListener("touchmove", this.refreshAndPointEvent, this);
                ipt.addHTMLElementListener("touchend", this.refreshAndPointEvent, this);
                ipt.addHTMLElementListener("touchcancel", this.refreshAndPointEvent, this);
                ipt.addHTMLElementListener("mousedown", this.refreshAndPointEvent, this);
                ipt.addHTMLElementListener("mousemove", this.refreshAndPointEvent, this);
                ipt.addHTMLElementListener("mouseup", this.refreshAndPointEvent, this);
            };
            overlay2D.prototype.unRegEvents = function () {
                if (!this._hasListenerEvent)
                    return;
                var ipt = m4m.framework.sceneMgr.app.getInputMgr();
                ipt.removeHTMLElementListener("touchstart", this.refreshAndPointEvent, this);
                ipt.removeHTMLElementListener("touchmove", this.refreshAndPointEvent, this);
                ipt.removeHTMLElementListener("touchend", this.refreshAndPointEvent, this);
                ipt.removeHTMLElementListener("touchcancel", this.refreshAndPointEvent, this);
                ipt.removeHTMLElementListener("mousedown", this.refreshAndPointEvent, this);
                ipt.removeHTMLElementListener("mousemove", this.refreshAndPointEvent, this);
                ipt.removeHTMLElementListener("mouseup", this.refreshAndPointEvent, this);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 添加2d子节点
             * @param node 2d节点实例
             * @version m4m 1.0
             */
            overlay2D.prototype.addChild = function (node) {
                this.canvas.addChild(node);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 移除2d子节点
             * @param node 2d节点实例
             * @version m4m 1.0
             */
            overlay2D.prototype.removeChild = function (node) {
                this.canvas.removeChild(node);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取所有的2d子节点
             * @version m4m 1.0
             */
            overlay2D.prototype.getChildren = function () {
                return this.canvas.getChildren();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取2d子节点的数量
             * @version m4m 1.0
             */
            overlay2D.prototype.getChildCount = function () {
                return this.canvas.getChildCount();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取2d子节点
             * @param index 索引
             * @version m4m 1.0
             */
            overlay2D.prototype.getChild = function (index) {
                return this.canvas.getChild(index);
            };
            /**
             * @private
             */
            overlay2D.prototype.render = function (context, assetmgr, camera) {
                if (!this.canvas.getRoot().visible || !this.camera)
                    return;
                // if (!(camera.CullingMask & this.renderLayer)) return;
                // if (this.autoAsp)
                // {
                //     let vp = new m4m.math.rect();
                //     this.camera.calcViewPortPixel(assetmgr.app, vp);
                //     let aspcam = vp.w / vp.h;
                //     let aspc = this.canvas.pixelWidth / this.canvas.pixelHeight;
                //     if (aspc != aspcam)
                //     {
                //         this.canvas.pixelWidth = this.canvas.pixelHeight * aspcam;
                //         this.canvas.getRoot().markDirty();
                //     }
                // }
                context.updateOverlay();
                this.canvas.render(context, assetmgr);
            };
            /**
             * @private
             */
            overlay2D.prototype.update = function (delta) {
                //layout update
                this.ckScaleMode();
                this.canvas.rootSizeAdjust();
                if (!this._hasListenerEvent) {
                    this.onPointEvent();
                }
                this.canvas.updateNodeTree(delta);
            };
            /** 刷新ui point数据并触发 事件 */
            overlay2D.prototype.refreshAndPointEvent = function () {
                this.inputmgr.pointCk();
                this.onPointEvent();
            };
            /** ui point 事件 */
            overlay2D.prototype.onPointEvent = function () {
                //用屏幕空间坐标系丢给canvas
                var _p = this.inputmgr.point;
                this.helpv2.x = _p.x;
                this.helpv2.y = _p.y;
                var sPos = this.helpv2;
                var mPos = this.helpv2_1;
                this.calScreenPosToClipPos(sPos, mPos);
                this.canvas.burstPointEvent(_p.touch, mPos.x, mPos.y, _p.multiTouch);
            };
            //检查缩放模式 改变
            overlay2D.prototype.ckScaleMode = function () {
                if (!this.canvas.getRoot().visible || !this.camera)
                    return;
                // this.camera.calcViewPortPixel(this.app, this.viewPixelrect);
                // m4m.math.rectClone(this.camera.currViewPixelRect ,this.viewPixelrect);
                var currVPR = this.camera.currViewPixelRect;
                var dirty = false;
                if (m4m.math.rectEqul(this.lastVPRect, currVPR)) {
                    switch (this.scaleMode) {
                        case UIScaleMode.CONSTANT_PIXEL_SIZE:
                            break;
                        case UIScaleMode.SCALE_WITH_SCREEN_SIZE:
                            if (this.lastScreenMR != this.screenMatchRate || this.lastMR_width != this.matchReference_width || this.lastMR_height != this.matchReference_height) {
                                dirty = true;
                            }
                            break;
                    }
                }
                else {
                    //rect 不等 需要重刷
                    dirty = true;
                }
                if (!dirty)
                    return;
                var _w = 0;
                var _h = 0;
                m4m.math.rectClone(currVPR, this.lastVPRect);
                this.lastScreenMR = this.screenMatchRate;
                this.lastMR_width = this.matchReference_width;
                this.lastMR_height = this.matchReference_height;
                //计算w h
                switch (this.scaleMode) {
                    case UIScaleMode.CONSTANT_PIXEL_SIZE:
                        _w = currVPR.w;
                        _h = currVPR.h;
                        break;
                    case UIScaleMode.SCALE_WITH_SCREEN_SIZE:
                        var match = this.screenMatchRate < 0 ? 0 : this.screenMatchRate;
                        match = match > 1 ? 1 : match;
                        var asp = currVPR.w / currVPR.h;
                        _w = m4m.math.numberLerp(this.matchReference_width, this.matchReference_height * asp, match);
                        _h = m4m.math.numberLerp(this.matchReference_height, this.matchReference_width / asp, 1 - match);
                        break;
                }
                //赋值
                this.canvas.pixelWidth = _w;
                this.canvas.pixelHeight = _h;
                this.canvas.getRoot().markDirty();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 投射拣选检测
             * @param mx x偏移
             * @param my y偏移
             * @version m4m 1.0
             */
            overlay2D.prototype.pick2d = function (mx, my, tolerance) {
                if (tolerance === void 0) { tolerance = 0; }
                if (this.camera == null)
                    return null;
                var root = this.canvas.getRoot();
                this.helpv2.x = mx;
                this.helpv2.y = my;
                var sPos = this.helpv2;
                var mPos = this.helpv2_1;
                this.calScreenPosToClipPos(sPos, mPos);
                var trans = this.dopick2d(mPos, root, tolerance);
                return trans;
            };
            /**
             * @private
             */
            overlay2D.prototype.dopick2d = function (clipPos, tran, tolerance) {
                if (tolerance === void 0) { tolerance = 0; }
                if (tran.components != null) {
                    for (var i = tran.components.length - 1; i >= 0; i--) {
                        var comp = tran.components[i];
                        if (comp != null)
                            //if (comp.init && comp.comp.transform.ContainsCanvasPoint(outv,tolerance))
                            if (comp.comp.transform.ContainsCanvasPoint(clipPos, tolerance)) {
                                return comp.comp.transform;
                            }
                    }
                }
                if (tran.children != null) {
                    for (var i = tran.children.length - 1; i >= 0; i--) {
                        var tran2 = this.dopick2d(clipPos, tran.children[i], tolerance);
                        if (tran2 != null)
                            return tran2;
                    }
                }
                return null;
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 屏幕空间坐标 转到 canvas坐标
            * @version m4m 1.0
            */
            overlay2D.prototype.calScreenPosToCanvasPos = function (screenPos, outCanvasPos) {
                if (!this.camera || !this.canvas)
                    return;
                var mPos = this.helpv2;
                this.calScreenPosToClipPos(screenPos, mPos);
                // var mat: m4m.math.matrix3x2 = m4m.math.pool.new_matrix3x2();
                // m4m.math.matrix3x2Clone(this.canvas.getRoot().getWorldMatrix(), mat);
                // m4m.math.matrix3x2Inverse(mat, mat);
                // m4m.math.matrix3x2TransformVector2(mat, mPos, outCanvasPos);
                // m4m.math.pool.delete_matrix3x2(mat);
                this.canvas.clipPosToCanvasPos(mPos, outCanvasPos);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * canvas坐标 转到 屏幕空间坐标
             * @param canvasPos canvas坐标
             * @param outScreenPos 输出的屏幕空间坐标
             * @version m4m 1.0
             */
            overlay2D.prototype.calCanvasPosToScreenPos = function (canvasPos, outScreenPos) {
                if (!this.camera || !this.canvas)
                    return;
                var clipPos = this.helpv2;
                this.canvas.canvasPosToClipPos(canvasPos, clipPos);
                this.calClipPosToScreenPos(clipPos, outScreenPos);
            };
            /**
             * [过时接口,完全弃用]
             * @version m4m 1.0
             */
            overlay2D.prototype.calScreenPosToModelPos = function (screenPos, outClipPos) {
                this.calScreenPosToClipPos(screenPos, outClipPos);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 屏幕空间坐标 转到 裁剪空间坐标
             * @version m4m 1.0
             * @param screenPos
             * @param outClipPos
             */
            overlay2D.prototype.calScreenPosToClipPos = function (screenPos, outClipPos) {
                if (!screenPos || !outClipPos || !this.camera)
                    return;
                // this.camera.calcViewPortPixel(this.app, currVPR);
                var currVPR = this.camera.currViewPixelRect;
                var rect = this.camera.viewport;
                var real_x = screenPos.x - rect.x * this.app.width;
                var real_y = screenPos.y - rect.y * this.app.height;
                outClipPos.x = (real_x / currVPR.w) * 2 - 1;
                outClipPos.y = (real_y / currVPR.h) * -2 + 1;
            };
            /**
             * [过时接口,完全弃用]
             * @version m4m 1.0
             */
            overlay2D.prototype.calModelPosToScreenPos = function (clipPos, outScreenPos) {
                this.calClipPosToScreenPos(clipPos, outScreenPos);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * Model坐标 转到 屏幕空间坐标
             * @param clipPos 裁剪空间坐标
             * @param outScreenPos 输出的屏幕空间坐标
             * @version m4m 1.0
             */
            overlay2D.prototype.calClipPosToScreenPos = function (clipPos, outScreenPos) {
                if (!clipPos || !outScreenPos || !this.camera)
                    return;
                var currVPR = this.camera.currViewPixelRect;
                // this.camera.calcViewPortPixel(this.app, currVPR);
                var rect = this.camera.viewport;
                var real_x = currVPR.w * (clipPos.x + 1) * 0.5;
                var real_y = currVPR.h * (clipPos.y - 1) * -0.5;
                outScreenPos.x = real_x + rect.x * this.app.width;
                outScreenPos.y = real_y + rect.y * this.app.height;
            };
            var overlay2D_1;
            overlay2D.ClassName = "overlay2D";
            /** point事件 直接模式（默认True,在dom输入原生帧直接触发） */
            overlay2D.pointEventDirectMode = true;
            __decorate([
                m4m.reflect.Field("canvas"),
                __metadata("design:type", framework.canvas)
            ], overlay2D.prototype, "canvas", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], overlay2D.prototype, "screenMatchRate", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Object)
            ], overlay2D.prototype, "matchReference_width", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Object)
            ], overlay2D.prototype, "matchReference_height", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], overlay2D.prototype, "scaleMode", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], overlay2D.prototype, "sortOrder", void 0);
            overlay2D = overlay2D_1 = __decorate([
                m4m.reflect.SerializeType,
                __metadata("design:paramtypes", [])
            ], overlay2D);
            return overlay2D;
        }());
        framework.overlay2D = overlay2D;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../io/reflect.ts" />
/// <reference path="../../render/struct.ts" />
var m4m;
/// <reference path="../../io/reflect.ts" />
/// <reference path="../../render/struct.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * UI布局选项
         * @version m4m 1.0
         */
        var layoutOption;
        (function (layoutOption) {
            layoutOption[layoutOption["LEFT"] = 1] = "LEFT";
            layoutOption[layoutOption["TOP"] = 2] = "TOP";
            layoutOption[layoutOption["RIGHT"] = 4] = "RIGHT";
            layoutOption[layoutOption["BOTTOM"] = 8] = "BOTTOM";
            layoutOption[layoutOption["H_CENTER"] = 16] = "H_CENTER";
            layoutOption[layoutOption["V_CENTER"] = 32] = "V_CENTER";
        })(layoutOption = framework.layoutOption || (framework.layoutOption = {}));
        /**
         * 实例对象是 I2DPointListener
         * @param object
         */
        function instanceOfI2DPointListener(object) {
            return "onPointEvent" in object;
        }
        framework.instanceOfI2DPointListener = instanceOfI2DPointListener;
        // /**
        //  * @public
        //  * @language zh_CN
        //  * @classdesc
        //  * 2d组件的接口
        //  * @version m4m 1.0
        //  */
        // export interface I2DComponent {
        //     onPlay();
        //     start();
        //     update(delta: number);
        //     transform: transform2D;
        //     remove();
        // }
        // /**
        //  * @public
        //  * @language zh_CN
        //  * @classdesc
        //  * 2d碰撞器接口
        //  * @version m4m 1.0
        //  */
        // export interface ICollider2d {
        //     transform: transform2D;
        //     getBound(): obb2d;
        //     intersectsTransform(tran: transform2D): boolean;
        // }
        // /**
        //  * @public
        //  * @language zh_CN
        //  * @classdesc
        //  * 2D渲染组件的接口
        //  * @version m4m 1.0
        //  */
        // export interface IRectRenderer extends I2DComponent {
        //     render(canvas: canvas);
        //     //刷新顶点信息
        //     updateTran();
        //     //获取渲染材质
        //     getMaterial():m4m.framework.material;
        //     //获取渲染边界(合并渲染深度排序会使用到)
        //     getDrawBounds():m4m.math.rect;
        // }
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 2D组件实例接口
         * @version m4m 1.0
         */
        var C2DComponent = /** @class */ (function () {
            function C2DComponent(comp, init) {
                if (init === void 0) { init = false; }
                this.OnPlayed = false;
                this.comp = comp;
                this.init = init;
            }
            C2DComponent.ClassName = "C2DComponent";
            __decorate([
                m4m.reflect.Field("I2DComponent"),
                __metadata("design:type", Object)
            ], C2DComponent.prototype, "comp", void 0);
            C2DComponent = __decorate([
                m4m.reflect.SerializeType,
                __metadata("design:paramtypes", [Object, Boolean])
            ], C2DComponent);
            return C2DComponent;
        }());
        framework.C2DComponent = C2DComponent;
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 2d的节点类<p/>
         * 相当于3d的tranform和gameobject的合集<p/>
         * 自身包含父子关系和组件
         * @version m4m 1.0
         */
        var transform2D = /** @class */ (function () {
            function transform2D() {
                /**
                * @public
                * @language zh_CN
                * @classdesc
                * 当前节点依赖的prefab路径，如果不依赖，则为空
                * @version m4m 1.0
                */
                this.prefab = "";
                /**
                 * 启用 UI 布局功能
                 */
                this.enableUILayout = true;
                /**
                 * 启用 UI 矩形遮罩裁剪显示 功能
                 */
                this.enableUIMaskRect = true;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 对象layer (取值范围0~31)
                 * @version m4m 1.0
                 */
                this.layer = framework.cullingmaskutil.maskTolayer(framework.CullingMask.default); //物件有一个layer 取值范围0~31，各种功能都可以用layer mask 去过滤作用范围
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 对象字符标签
                 * @version m4m 1.0
                 */
                this.tag = framework.StringUtil.builtinTag_Untagged;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 当前2d节点的名字
                 * @version m4m 1.0
                 */
                this.name = "noname";
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 对象是静态
                 * @version m4m 1.0
                 */
                this.isStatic = false;
                this._children = [];
                // private _children: transform[] = [];
                // /**
                //  * @public
                //  * @language zh_CN
                //  * @classdesc
                //  * 子物体列表
                //  * @version m4m 1.0
                //  */
                // @m4m.reflect.Field("transform[]")
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 当前2d节点的宽
                 * @version m4m 1.0
                 */
                this.width = 0; //2d位置
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 当前2d节点的高
                 * @version m4m 1.0
                 */
                this.height = 0;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 当前2d节点的中心点位置
                 * @version m4m 1.0
                 */
                this.pivot = new m4m.math.vector2(0, 0);
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 当前2d节点的hideFlag，用来控制2d节点各种形态下的显示隐藏
                 * @version m4m 1.0
                 */
                this.hideFlags = framework.HideFlags.None;
                this._visible = true;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 当前节点的唯一id
                 * @version m4m 1.0
                 */
                this.insId = new framework.insID();
                this.dirty = true; //自己是否需要更新
                this.dirtyChild = true; //子层是否需要更新
                this.dirtyWorldDecompose = false;
                this.dirtyAABB = false; //AABB 标记脏
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 当前2d节点的位置
                 * @version m4m 1.0
                 */
                this.localTranslate = new m4m.math.vector2(0, 0);
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 当前2d节点的缩放
                 * @version m4m 1.0
                 */
                this.localScale = new m4m.math.vector2(1, 1);
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 当前2d节点的旋转
                 * @version m4m 1.0
                 */
                this.localRotate = 0; //旋转
                this._maskrectId = "";
                this._isMask = false;
                this._aabbRect = new m4m.math.rect();
                this._parentIsMask = false;
                this.localMatrix = new m4m.math.matrix3x2; //2d矩阵
                //这个是如果爹改了就要跟着算的
                this.worldMatrix = new m4m.math.matrix3x2();
                this.canvasWorldMatrix = new m4m.math.matrix3x2();
                this.worldRotate = new m4m.math.angelref();
                this.worldTranslate = new m4m.math.vector2(0, 0);
                this.worldScale = new m4m.math.vector2(1, 1);
                this._beDispose = false; //是否被释放了
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 当前节点的所有组件
                 * @version m4m 1.0
                 */
                this.components = [];
                this.componentTypes = {};
                this.componentsInit = [];
                // /**
                //  * @public
                //  * @language zh_CN
                //  * @classdesc
                //  * 当前节点的渲染组件，一个节点同时只能存在一个渲染组件
                //  * @version m4m 1.0
                //  */
                // onPointEvent(canvas: canvas, ev: PointEvent) {
                //     //event 上升阶段,上升阶段事件会被吞掉
                //     if (this.children != null) {
                //         for (var i = this.children.length - 1; i >= 0; i--) {
                //             if (ev.eated == false) {
                //                 var c = this.children[i];
                //                 if (c != null && c.visible)
                //                     c.onPointEvent(canvas, ev);
                //                 // if (ev.eated)
                //                 // {//事件刚刚被吃掉，
                //                 //     //这时是否要做点什么？
                //                 // }
                //             }
                //         }
                //     }
                //     if (ev.eated == false && this.components != null) {
                //         for (var i = this.components.length - 1; i >= 0; i--) {
                //             var comp = this.components[i];
                //             if (comp != null)
                //                 if (comp.init && instanceOfI2DPointListener(comp.comp) ) {
                //                     (comp.comp as any).onPointEvent(canvas, ev, false);
                //                 }
                //         }
                //     }
                // }
                this.optionArr = [layoutOption.LEFT, layoutOption.TOP, layoutOption.RIGHT, layoutOption.BOTTOM, layoutOption.H_CENTER, layoutOption.V_CENTER];
                this._layoutState = 0;
                this.layoutValueMap = {}; // map structure {layoutOption : value}
                this._layoutPercentState = 0; //百分比模式
                this.layoutDirty = false;
                this.lastWidth = 0;
                this.lastHeight = 0;
                this.lastParentWidth = 0;
                this.lastParentHeight = 0;
                this.lastParentPivot = new m4m.math.vector2(0, 0);
                this.lastPivot = new m4m.math.vector2(0, 0);
            }
            transform2D_1 = transform2D;
            /**
             * 获取transform2D 通过 insID
             * @param id transform2D
             */
            transform2D.getTransform2DById = function (insID) {
                return this._transform2DMap[insID];
            };
            Object.defineProperty(transform2D.prototype, "canvas", {
                get: function () {
                    if (this._canvas == null) {
                        if (this._parent == null)
                            return null;
                        return this._parent.canvas;
                    }
                    return this._canvas;
                },
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 当前2d节点所属的canvas
                 * @version m4m 1.0
                 */
                set: function (val) {
                    if (!val)
                        return;
                    this._canvas = val;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(transform2D.prototype, "parent", {
                get: function () {
                    return this._parent;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(transform2D.prototype, "children", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 当前2d节点的孩子节点
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._children;
                },
                set: function (children) {
                    this._children = children;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(transform2D.prototype, "visibleInScene", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 当前2d节点在场景中是否可见</p>
                 * 如果其父节点不可见，其同样不可见
                 * @version m4m 1.0
                 */
                get: function () {
                    var obj = this;
                    while (obj.visible) {
                        obj = obj._parent;
                    }
                    return obj.visible;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(transform2D.prototype, "visible", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 当前2d节点的隐藏状态
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._visible;
                },
                set: function (val) {
                    if (val != this._visible) {
                        this._visible = val;
                        framework.sceneMgr.app.markNotify(this, framework.NotifyType.ChangeVisible);
                    }
                },
                enumerable: false,
                configurable: true
            });
            ;
            Object.defineProperty(transform2D.prototype, "transform", {
                /**
                 * @private
                 * @language zh_CN
                 * @classdesc
                 * 获取自身
                 * @version m4m 1.0
                 */
                get: function () {
                    return this;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(transform2D.prototype, "maskRectId", {
                /** 裁剪遮罩矩形 ID */
                get: function () { return this._maskrectId; },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(transform2D.prototype, "maskRect", {
                /** 裁剪遮罩矩形 */
                get: function () {
                    if (this._temp_maskRect == null)
                        this._temp_maskRect = new m4m.math.rect();
                    if (this._maskRect != null) {
                        this._temp_maskRect.x = this._maskRect.x;
                        this._temp_maskRect.y = this._maskRect.y;
                        this._temp_maskRect.w = this._maskRect.w;
                        this._temp_maskRect.h = this._maskRect.h;
                    }
                    return this._temp_maskRect;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(transform2D.prototype, "isMask", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 当前节点是否是mask
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._isMask;
                },
                set: function (b) {
                    this._isMask = b;
                    this.markDirty();
                    if (this._parent != null)
                        this.updateTran(true);
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(transform2D.prototype, "aabbRect", {
                /** aabb 矩形 */
                get: function () {
                    if (this._temp_aabbRect == null)
                        this._temp_aabbRect = new m4m.math.rect();
                    if (this._aabbRect != null) {
                        m4m.math.rectClone(this._aabbRect, this._temp_aabbRect);
                    }
                    if (this.dirtyAABB) {
                        this.calcAABB(this.worldMatrix);
                        this.dirtyAABB = false;
                    }
                    return this._temp_aabbRect;
                },
                enumerable: false,
                configurable: true
            });
            transform2D.prototype.updateMaskRect = function () {
                var rect_x;
                var rect_y;
                var rect_w;
                var rect_h;
                var ParentRect;
                if (this._parent != null) {
                    this._parentIsMask = this._parent.isMask || this._parent.parentIsMask;
                    ParentRect = this._parent.maskRect;
                }
                else
                    this._parentIsMask = false;
                if (this.isMask || this.parentIsMask) {
                    this._maskrectId = "";
                    if (this.parentIsMask) {
                        this._maskrectId = this._parent._maskrectId;
                    }
                    if (this.isMask) {
                        this._maskrectId += "_".concat(this.insId.getInsID());
                        //计算 maskrect
                        var wPos = this.getWorldTranslate();
                        var wW = this.canvas.pixelWidth;
                        var wH = this.canvas.pixelHeight;
                        rect_x = wPos.x / wW;
                        rect_y = wPos.y / wH;
                        rect_w = this.width / wW;
                        rect_h = this.height / wH;
                        if (this.parentIsMask && ParentRect != null) {
                            //计算 rect  ∩  parentRect
                            var min_x = Math.max(rect_x, ParentRect.x);
                            var min_y = Math.max(rect_y, ParentRect.y);
                            var max_x = Math.min(rect_x + rect_w, ParentRect.x + ParentRect.w);
                            var max_y = Math.min(rect_y + rect_h, ParentRect.y + ParentRect.h);
                            rect_x = min_x;
                            rect_y = min_y;
                            rect_w = max_x - min_x;
                            rect_h = max_y - min_y;
                        }
                    }
                    else if (ParentRect != null) {
                        rect_x = ParentRect.x;
                        rect_y = ParentRect.y;
                        rect_w = ParentRect.w;
                        rect_h = ParentRect.h;
                    }
                    if (this._maskRect == null)
                        this._maskRect = new m4m.math.rect();
                    if (this._maskRect.x != rect_x || this._maskRect.x != rect_y || this._maskRect.x != rect_w || this._maskRect.x != rect_h) {
                        this._maskRect.x = rect_x;
                        this._maskRect.y = rect_y;
                        this._maskRect.w = rect_w;
                        this._maskRect.h = rect_h;
                    }
                }
            };
            Object.defineProperty(transform2D.prototype, "parentIsMask", {
                get: function () {
                    return this._parentIsMask;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 为当前2d节点添加子节点
             * @param node 要添加的子节点
             * @version m4m 1.0
             */
            transform2D.prototype.addChild = function (node) {
                // if (node.parent != null) {
                //     node.parent.removeChild(node);
                // }
                // if (this.children == null)
                //     this.children = [];
                // this.children.push(node);
                // node.parent = this;
                // node.canvas = this.canvas;
                // sceneMgr.app.markNotify(node, NotifyType.AddChild);
                // this.markDirty();
                this.addChildAt(node, this._children.length);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 为当前2d节点添加子节点,并插入到指定位置
             * @param node 要添加的子节点
             * @param index 要插入到的位置
             * @version m4m 1.0
             */
            transform2D.prototype.addChildAt = function (node, index) {
                if (index < 0 || !node) {
                    return;
                }
                if (node._parent != null) {
                    node._parent.removeChild(node);
                }
                if (this._children == null)
                    this._children = [];
                this._children.splice(index, 0, node);
                node.canvas = this.canvas;
                node._parent = this;
                transform2D_1._transform2DMap[node.insId.getInsID()] = node;
                framework.sceneMgr.app.markNotify(node, framework.NotifyType.AddChild);
                this.markDirty();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 为当前2d节点移除子节点
             * @param 要移除的子节点
             * @version m4m 1.0
             */
            transform2D.prototype.removeChild = function (node) {
                if (!node) {
                    console.warn("target is null");
                    return;
                }
                if (node._parent != this || this._children == null) {
                    console.warn("not my child.");
                    return;
                }
                var i = this._children.indexOf(node);
                if (i < 0)
                    return;
                this._children.splice(i, 1);
                node._parent = null;
                delete transform2D_1._transform2DMap[node.insId.getInsID()];
                framework.sceneMgr.app.markNotify(node, framework.NotifyType.RemoveChild);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 为当前2d节点移除所有子节点
             * @version m4m 1.0
             */
            transform2D.prototype.removeAllChild = function (needDispose) {
                if (needDispose === void 0) { needDispose = false; }
                while (this._children.length > 0) {
                    if (needDispose)
                        this._children[0].dispose();
                    else
                        this.removeChild(this._children[0]);
                }
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 标记自身脏了
             * @version m4m 1.0
             */
            transform2D.prototype.markDirty = function () {
                this.dirty = true;
                var p = this._parent;
                while (p != null) {
                    p.dirtyChild = true;
                    p = p._parent;
                }
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 用脏机制来检查自身和子节点。更新位置、缩放、旋转等信息
             * @param parentChange 父节点是否发生变化
             * @version m4m 1.0
             */
            transform2D.prototype.updateTran = function (parentChange) {
                //无刷
                if (this.dirtyChild == false && this.dirty == false && parentChange == false)
                    return;
                if (this.dirty) {
                    m4m.math.matrix3x2MakeTransformRTS(this.localTranslate, this.localScale, this.localRotate, this.localMatrix);
                }
                if (this.dirty || parentChange) {
                    if (this.enableUILayout) {
                        this.refreshLayout();
                    }
                    if (this.parent == null) {
                        m4m.math.matrix3x2Clone(this.localMatrix, this.worldMatrix);
                    }
                    else {
                        m4m.math.matrix3x2Multiply(this.parent.worldMatrix, this.localMatrix, this.worldMatrix);
                    }
                    this.dirtyWorldDecompose = true;
                    if (this.enableUIMaskRect) {
                        this.updateMaskRect();
                    }
                    if (this.renderer != null) {
                        this.renderer.updateTran();
                    }
                }
                //aabb
                this.dirtyAABB = true;
                if (this._children != null) {
                    for (var i = 0, l = this._children.length; i < l; i++) {
                        this._children[i].updateTran(parentChange || this.dirty);
                    }
                }
                this.dirty = false;
                this.dirtyChild = false;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 更新整个节点结构
             * @version m4m 1.0
             */
            transform2D.prototype.updateWorldTran = function () {
                //parent 找到顶，第一个dirty的
                var p = this._parent;
                var dirtylist = [];
                dirtylist.push(this);
                while (p != null) {
                    if (p.dirty)
                        dirtylist.push(p);
                    p = p._parent;
                }
                var top = dirtylist.pop();
                top.updateTran(false);
            };
            //计算AABB 包围盒
            transform2D.prototype.calcAABB = function (wMtx) {
                var w = this.width;
                var h = this.height;
                var px = this.pivot.x;
                var py = this.pivot.y;
                var osX = px * w;
                var osY = py * h;
                var p0 = transform2D_1.help_v2;
                var p1 = transform2D_1.help_v2_1;
                var p2 = transform2D_1.help_v2_2;
                var p3 = transform2D_1.help_v2_3;
                m4m.math.vec2Set(p0, -osX, -osY);
                m4m.math.vec2Set(p1, w - osX, -osY);
                m4m.math.vec2Set(p2, w - osX, h - osY);
                m4m.math.vec2Set(p3, -osX, h - osY);
                m4m.math.matrix3x2TransformVector2(wMtx, p0, p0);
                m4m.math.matrix3x2TransformVector2(wMtx, p1, p1);
                m4m.math.matrix3x2TransformVector2(wMtx, p2, p2);
                m4m.math.matrix3x2TransformVector2(wMtx, p3, p3);
                if (this.canvas) {
                    this.canvas.clipPosToCanvasPos(p0, p0);
                    this.canvas.clipPosToCanvasPos(p1, p1);
                    this.canvas.clipPosToCanvasPos(p2, p2);
                    this.canvas.clipPosToCanvasPos(p3, p3);
                }
                var min = p0;
                var max = p1;
                m4m.math.vec2Set(min, Math.min(p0.x, p1.x, p2.x, p3.x), Math.min(p0.y, p1.y, p2.y, p3.y));
                m4m.math.vec2Set(max, Math.max(p0.x, p1.x, p2.x, p3.x), Math.max(p0.y, p1.y, p2.y, p3.y));
                m4m.math.rectSet(this._aabbRect, min.x, min.y, max.x - min.x, max.y - min.y);
            };
            //计算 to canvasMtx 矩阵
            transform2D.prototype.CalcReCanvasMtx = function (out) {
                if (!out)
                    return;
                // let tsca = m4m.math.pool.new_vector2();
                // let ttran = m4m.math.pool.new_vector2();
                var tsca = transform2D_1.help_v2;
                var ttran = transform2D_1.help_v2_1;
                tsca.x = this.canvas.pixelWidth / 2;
                tsca.y = -this.canvas.pixelHeight / 2;
                ttran.x = this.canvas.pixelWidth / 2;
                ttran.y = this.canvas.pixelHeight / 2;
                m4m.math.matrix3x2MakeTransformRTS(ttran, tsca, 0, out);
            };
            /**
             * @private
             * 转换并拆解canvas坐标空间 RTS
             */
            transform2D.prototype.decomposeWorldMatrix = function () {
                if (this.dirtyWorldDecompose) {
                    // let reCanvasMtx = m4m.math.pool.new_matrix3x2();
                    var reCanvasMtx = transform2D_1.help_mtx;
                    // let tsca = m4m.math.pool.new_vector2();
                    // let ttran = m4m.math.pool.new_vector2();
                    // tsca.x = this.canvas.pixelWidth/2;
                    // tsca.y = - this.canvas.pixelHeight/2;
                    // ttran.x = this.canvas.pixelWidth/2;
                    // ttran.y = this.canvas.pixelHeight/2;
                    // math.matrix3x2MakeTransformRTS(ttran,tsca,0,reCanvsMtx);
                    this.CalcReCanvasMtx(reCanvasMtx);
                    m4m.math.matrix3x2Multiply(reCanvasMtx, this.worldMatrix, this.canvasWorldMatrix);
                    m4m.math.matrix3x2Decompose(this.canvasWorldMatrix, this.worldScale, this.worldRotate, this.worldTranslate);
                    // math.pool.delete_vector2(tsca);
                    // math.pool.delete_vector2(ttran);
                    // math.pool.delete_matrix3x2(reCanvasMtx);
                    this.dirtyWorldDecompose = false;
                }
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取当前节点的相对于canvas的位置
             * @version m4m 1.0
             */
            transform2D.prototype.getWorldTranslate = function () {
                this.decomposeWorldMatrix();
                return this.worldTranslate;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取当前节点的相对于canvas的缩放
             * @version m4m 1.0
             */
            transform2D.prototype.getWorldScale = function () {
                this.decomposeWorldMatrix();
                return this.worldScale;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取当前节点的相对于canvas的旋转
             * @version m4m 1.0
             */
            transform2D.prototype.getWorldRotate = function () {
                this.decomposeWorldMatrix();
                return this.worldRotate;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取当前节点的本地变换矩阵
             * @version m4m 1.0
             */
            transform2D.prototype.getLocalMatrix = function () {
                return this.localMatrix;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取当前节点的世界变换矩阵
             * @version m4m 1.0
             */
            transform2D.prototype.getWorldMatrix = function () {
                return this.worldMatrix;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取当前节点的Canvas_世界_变换矩阵
             * @version m4m 1.0
             */
            transform2D.prototype.getCanvasWorldMatrix = function () {
                this.decomposeWorldMatrix();
                return this.canvasWorldMatrix;
            };
            transform2D.getTransInfoInCanvas = function (trans, out) {
                // var rotscale = m4m.math.pool.new_vector2();
                // let inversemat = m4m.math.pool.new_matrix3x2();
                // let mattoRoot = m4m.math.pool.new_matrix3x2();
                // var rotPos = m4m.math.pool.new_vector2();
                var mat = trans.getWorldMatrix();
                var rotmat = trans.canvas.getRoot().getWorldMatrix();
                var inversemat = transform2D_1.help_mtx;
                m4m.math.matrix3x2Inverse(rotmat, inversemat);
                var mattoRoot = transform2D_1.help_mtx_1;
                m4m.math.matrix3x2Multiply(inversemat, mat, mattoRoot);
                var rotscale = transform2D_1.help_v2;
                var rotRot = new m4m.math.angelref();
                var rotPos = transform2D_1.help_v2_1;
                m4m.math.matrix3x2Decompose(mattoRoot, rotscale, rotRot, rotPos);
                m4m.math.vec2Clone(trans.pivot, out.pivot);
                m4m.math.vec2Clone(rotPos, out.pivotPos);
                out.rot = rotRot.v;
                out.width = trans.width * rotscale.x;
                out.height = trans.height * rotscale.y;
                // m4m.math.pool.delete_matrix3x2(inversemat);
                // m4m.math.pool.delete_matrix3x2(mattoRoot);
                // m4m.math.pool.delete_vector2(rotscale);
                // m4m.math.pool.delete_vector2(rotPos);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 设置当前节点的相对于canvas的位置
             * @param pos 相对于canvas的位置
             * @version m4m 1.0
             */
            transform2D.prototype.setWorldPosition = function (pos) {
                // var dir = math.pool.new_vector2();
                // var pworld = math.pool.new_matrix3x2();
                // let matinv = math.pool.new_matrix3x2();
                // let dirinv = math.pool.new_vector2();
                this.dirty = true;
                this.updateWorldTran();
                var thispos = this.getWorldTranslate();
                var dir = transform2D_1.help_v2;
                dir.x = pos.x - thispos.x;
                dir.y = pos.y - thispos.y;
                var pworld = transform2D_1.help_mtx;
                if (this._parent != null) {
                    m4m.math.matrix3x2Clone(this._parent.worldMatrix, pworld);
                }
                else {
                    m4m.math.matrix3x2MakeIdentity(pworld);
                }
                var matinv = transform2D_1.help_mtx_1;
                m4m.math.matrix3x2Inverse(pworld, matinv);
                var dirinv = transform2D_1.help_v2_1;
                m4m.math.matrix3x2TransformNormal(matinv, dir, dirinv);
                this.localTranslate.x += dirinv.x;
                this.localTranslate.y += dirinv.y;
                // math.pool.delete_matrix3x2(matinv);
                // math.pool.delete_vector2(dir);
                // math.pool.delete_vector2(dirinv);
            };
            Object.defineProperty(transform2D.prototype, "beDispose", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 获取当前transform是否被释放掉了
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._beDispose;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 释放当前节点，包括其子节点
             * @version m4m 1.0
             */
            transform2D.prototype.dispose = function () {
                if (this._parent)
                    this._parent.removeChild(this);
                this._dispose();
            };
            transform2D.prototype._dispose = function () {
                if (this._beDispose)
                    return;
                if (this._children) {
                    for (var k in this._children) {
                        this._children[k]._dispose();
                    }
                    this.removeAllChild();
                }
                this.removeAllComponents();
                this._beDispose = true;
                if (this.onDispose)
                    this.onDispose();
            };
            // private componentplayed :C2DComponent[]=[];
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 组件的初始化
             * @version m4m 1.0
             */
            transform2D.prototype.init = function (bePlay) {
                if (bePlay === void 0) { bePlay = false; }
                var comps = this.componentsInit;
                if (comps.length <= 0)
                    return;
                while (comps.length > 0) { //这里不要再改回 for循环 , 当组件init 时添加其他组件时，会造成问题
                    var c = comps.shift();
                    c.comp.start();
                    c.init = true;
                    if (bePlay) {
                        if ((framework.StringUtil.ENABLED in c.comp) && !c.comp[framework.StringUtil.ENABLED])
                            continue; //组件enable影响
                        c.comp.onPlay();
                        c.OnPlayed = true;
                    }
                }
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 为当前节点添加一个组件
             * @param type 组件名称
             * @version m4m 1.0
             */
            transform2D.prototype.addComponent = function (type) {
                var pp = m4m.reflect.getPrototype(type);
                if (!pp)
                    throw new Error("get null of ".concat(type, " to getPrototype"));
                var comp = m4m.reflect.createInstance(pp, { "2dcomp": "1" });
                return this.addComponentDirect(comp);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 为当前节点添加组件
             * @param comp 2d组件实例
             * @version m4m 1.0
             */
            transform2D.prototype.addComponentDirect = function (comp) {
                if (!comp) {
                    console.error("this component is null");
                    return;
                }
                if (comp.transform != null) {
                    console.error("this components has added to a  gameObject");
                    return;
                }
                comp.transform = this;
                var typeStr = framework.getClassName(comp);
                if (this.componentTypes[typeStr]) {
                    console.error(this.name + "   已经有一个" + typeStr + "的组件了，不能俩");
                    return;
                }
                if (this.components == null)
                    this.components = [];
                var _comp = new C2DComponent(comp, false);
                this.components.push(_comp);
                this.componentsInit.push(_comp);
                if (m4m.reflect.getClassTag(comp["__proto__"], "renderer") == "1") { //这货是个渲染器
                    if (this.renderer == null) {
                        this.renderer = comp;
                        // console.warn("add renderer:" + this.name);
                    }
                    else {
                        console.error("已经有一个渲染器的组件了，不能俩");
                        return;
                    }
                }
                if (m4m.reflect.getClassTag(comp["__proto__"], "boxcollider2d") == "1") { //这货是个boxcollider2d
                    if (this.collider == null) {
                        this.collider = comp;
                    }
                    else {
                        console.error("已经有一个碰撞组件了，不能俩");
                        return;
                    }
                }
                if (m4m.reflect.getClassTag(comp["__proto__"], "node2dphysicsbody") == "1") { //这货是个node2dphysicsbody
                    if (this.physicsBody == null) {
                        this.physicsBody = comp;
                    }
                    else {
                        console.error("已经有一个碰撞组件了，不能俩");
                        return;
                    }
                }
                if (framework.functionIsEmpty(comp.update))
                    comp.update = undefined; //update空转
                this.componentTypes[typeStr] = true;
                return comp;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 移除当前节点下的组件
             * @param comp 2d组件实例
             * @version m4m 1.0
             */
            transform2D.prototype.removeComponent = function (comp) {
                if (!comp)
                    return;
                // let typeName =  reflect.getClassName(comp); //组件继承时remove fial
                var typeName = framework.getClassName(comp);
                if (!this.componentTypes[typeName])
                    return;
                delete this.componentTypes[typeName];
                for (var i = 0; i < this.components.length; i++) {
                    if (this.components[i].comp == comp) {
                        this.clearOfCompRemove(this.components[i]);
                        this.components.splice(i, 1);
                        break;
                    }
                }
            };
            transform2D.prototype.clearOfCompRemove = function (cComp) {
                var comp = cComp.comp;
                if (cComp.init) {
                    comp.remove();
                }
                else {
                    var i = this.componentsInit.indexOf(cComp);
                    if (i != -1)
                        this.componentsInit.splice(i, 1);
                }
                if (comp == this.renderer)
                    this.renderer = null;
                if (comp == this.collider)
                    this.collider = null;
                if (comp == this.physicsBody)
                    this.physicsBody = null;
                comp.transform = null;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 移除当前节点下的组件
             * @param type 2d组件名称
             * @version m4m 1.0
             */
            transform2D.prototype.removeComponentByTypeName = function (type) {
                if (!this.componentTypes[type])
                    return;
                delete this.componentTypes[type];
                var comps = this.components;
                var len = comps.length;
                for (var i = 0; i < len; i++) {
                    // if (reflect.getClassName(this.components[i].comp) == type) {
                    if (framework.getClassName(comps[i].comp) == type) {
                        this.clearOfCompRemove(comps[i]);
                        var p = comps.splice(i, 1);
                        return p[0];
                    }
                }
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 移除当前节点下的所有组件
             * @param type 2d组件名称
             * @version m4m 1.0
             */
            transform2D.prototype.removeAllComponents = function () {
                this.componentsInit.length = 0;
                var len = this.components.length;
                for (var i = 0; i < len; i++) {
                    this.components[i].comp.remove();
                    this.components[i].comp.transform = null;
                }
                if (this.renderer)
                    this.renderer = null;
                if (this.collider)
                    this.collider = null;
                if (this.physicsBody)
                    this.physicsBody = null;
                this.components.length = 0;
                this.componentTypes = {};
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取当前节点的指定组件实例
             * @param type 2d组件的名字
             * @version m4m 1.0
             */
            transform2D.prototype.getComponent = function (type) {
                for (var i = 0; i < this.components.length; i++) {
                    var comp = this.components[i].comp;
                    var cname = framework.getClassName(comp);
                    // var cname = m4m.reflect.getClassName(this.components[i].comp["__proto__"]);
                    if (cname == type) {
                        return comp;
                    }
                }
                return null;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取当前节点身上所有的组件
             * @version m4m 1.0
             */
            transform2D.prototype.getComponents = function () {
                var components = [];
                for (var i = 0; i < this.components.length; i++) {
                    components.push(this.components[i].comp);
                }
                return components;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取当前节点下所有的特定组件
             * @param type 组件名称
             * @version m4m 1.0
             */
            transform2D.prototype.getComponentsInChildren = function (type) {
                var components = [];
                this.getNodeCompoents(this, type, components);
                return components;
            };
            /**
             * @private
             * 之前给编辑器开的接口
             * @param node
             * @param _type
             * @param comps
             */
            transform2D.prototype.getNodeCompoents = function (node, _type, comps) {
                var len = node.components.length;
                for (var i = 0; i < len; i++) {
                    var comp = node.components[i].comp;
                    var cname = framework.getClassName(comp);
                    // var cname = m4m.reflect.getClassName(node.components[i].comp["__proto__"]);
                    if (cname == _type) {
                        comps.push(comp);
                    }
                }
                if (node._children != null) {
                    var len_1 = node._children.length;
                    for (var j = 0; j < len_1; j++) {
                        this.getNodeCompoents(node._children[j], _type, comps);
                    }
                }
            };
            /**
             * 获取当前节点下及子节点第一个能找到的组件
             * @param type 组件名称
             */
            transform2D.prototype.getFirstComponentInChildren = function (type) {
                return this.getNodeFirstComponent(this, type);
            };
            /**
             * 获取节点的第一个组件
             * @param node
             * @param type
             */
            transform2D.prototype.getNodeFirstComponent = function (node, type) {
                var len = node.components.length;
                for (var i = 0; i < len; i++) {
                    var comp = node.components[i].comp;
                    var cname = framework.getClassName(comp);
                    // var cname = m4m.reflect.getClassName(node.components[i].comp["__proto__"]);
                    if (cname == type) {
                        return comp;
                    }
                }
                if (node._children != null) {
                    var len_1 = node._children.length;
                    for (var j = 0; j < len_1; j++) {
                        var result = node.getNodeFirstComponent(node._children[j], type);
                        if (result)
                            return result;
                    }
                }
            };
            // /**
            //  * @public
            //  * @language zh_CN
            //  * @classdesc
            //  * 捕获事件
            //  * @param canvas canvas实例
            //  * @param ev 事件对象
            //  * @version m4m 1.0
            //  */
            // onCapturePointEvent(canvas: canvas, ev: PointEvent) {
            //     //event 捕捉阶段，正向
            //     if (this.components != null) {
            //         for (var i = 0; i <= this.components.length; i++) {
            //             if (ev.eated == false) {
            //                 var comp = this.components[i];
            //                 if (comp != null)
            //                     if (comp.init && instanceOfI2DPointListener(comp.comp) ) {
            //                         (comp.comp as any).onPointEvent(canvas, ev, true);
            //                     }
            //             }
            //         }
            //     }
            //     if (ev.eated == false) {
            //         if (this.children != null) {
            //             for (var i = 0; i <= this.children.length; i++) {
            //                 var c = this.children[i];
            //                 if (c != null && c.visible)
            //                     c.onCapturePointEvent(canvas, ev);
            //             }
            //         }
            //     }
            // }
            // ContainsPoint(p: math.vector2): boolean
            // {
            //     var p2 = new math.vector2();
            //     p2.x = p.x + this.pivot.x * this.width;
            //     p2.y = p.y + this.pivot.y * this.height;
            //     return p2.x >= 0 && p2.y >= 0 && p2.x < this.width && p2.y < this.height;
            // }
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 检测以canvas为参考的位置，是否在节点的范围内
             * @param ModelPos 模型空间位置
             * @version m4m 1.0
             */
            transform2D.prototype.ContainsCanvasPoint = function (ModelPos, tolerance) {
                if (tolerance === void 0) { tolerance = 0; }
                var result = false;
                var mworld = this.getWorldMatrix();
                // var mout = math.pool.new_matrix3x2();
                var mout = transform2D_1.help_mtx;
                m4m.math.matrix3x2Inverse(mworld, mout);
                // var p2 = math.pool.new_vector2();
                var p2 = transform2D_1.help_v2;
                m4m.math.matrix3x2TransformVector2(mout, ModelPos, p2); //世界坐标 右乘 逆转worldMatrix 得到 ModelPos
                p2.x += this.pivot.x * this.width;
                p2.y += this.pivot.y * this.height;
                result = p2.x + tolerance >= 0 && p2.y + tolerance >= 0 && p2.x < this.width + tolerance && p2.y < this.height + tolerance;
                // math.pool.delete_matrix3x2(mout);
                // math.pool.delete_vector2(p2);
                return result;
            };
            Object.defineProperty(transform2D.prototype, "layoutState", {
                get: function () {
                    return this._layoutState;
                },
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 布局状态
                 * @version m4m 1.0
                 */
                set: function (state) {
                    if (isNaN(state) || state == undefined)
                        return;
                    if (state != this._layoutState) {
                        this.layoutDirty = true;
                        this.markDirty();
                        this._layoutState = state;
                    }
                },
                enumerable: false,
                configurable: true
            });
            //private layoutValueMap : number[] = [];   // map structure {layoutOption : value}
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 布局设定值
             * @version m4m 1.0
             */
            transform2D.prototype.setLayoutValue = function (option, value) {
                if (isNaN(option) || isNaN(value) || option == undefined || value == undefined)
                    return;
                if (this.layoutValueMap[option] == undefined || value != this.layoutValueMap[option]) {
                    this.layoutDirty = true;
                    this.markDirty();
                    this.layoutValueMap[option] = value;
                }
            };
            transform2D.prototype.getLayoutValue = function (option) {
                if (this.layoutValueMap[option] == undefined)
                    this.layoutValueMap[option] = 0;
                return this.layoutValueMap[option];
            };
            Object.defineProperty(transform2D.prototype, "layoutPercentState", {
                get: function () {
                    return this._layoutPercentState;
                },
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 布局百分比模式状态
                 * @version m4m 1.0
                 */
                set: function (state) {
                    if (isNaN(state) || state == undefined)
                        return;
                    if (state != this._layoutPercentState) {
                        this.layoutDirty = true;
                        this.markDirty();
                        this._layoutPercentState = state;
                    }
                },
                enumerable: false,
                configurable: true
            });
            transform2D.prototype.refreshLayout = function () {
                var parent = this._parent;
                if (!parent)
                    return;
                if (this.width != this.lastWidth || this.height != this.lastHeight || parent.width != this.lastParentWidth || parent.height != this.lastParentHeight || parent.pivot.x != this.lastParentPivot.x
                    || parent.pivot.y != this.lastParentPivot.y || this.pivot.x != this.lastPivot.x || this.pivot.y != this.lastPivot.y)
                    this.layoutDirty = true;
                if (!this.layoutDirty)
                    return;
                var state = this._layoutState | this._layoutPercentState;
                if (state != 0) {
                    if (state & layoutOption.LEFT) {
                        if (state & layoutOption.RIGHT) {
                            this.width = parent.width - this.getLayCoordinateValue(layoutOption.LEFT) - this.getLayCoordinateValue(layoutOption.RIGHT);
                        }
                        this.localTranslate.x = this.getLayCoordinateValue(layoutOption.LEFT) - parent.pivot.x * parent.width + this.pivot.x * this.width;
                    }
                    else if (state & layoutOption.RIGHT) {
                        this.localTranslate.x = parent.width - this.width - this.getLayCoordinateValue(layoutOption.RIGHT) - parent.pivot.x * parent.width + this.pivot.x * this.width;
                    }
                    if (state & layoutOption.H_CENTER) {
                        this.localTranslate.x = (parent.width - this.width) / 2 + this.getLayCoordinateValue(layoutOption.H_CENTER) - parent.pivot.x * parent.width + this.pivot.x * this.width;
                    }
                    if (state & layoutOption.TOP) {
                        if (state & layoutOption.BOTTOM) {
                            this.height = parent.height - this.getLayCoordinateValue(layoutOption.TOP) - this.getLayCoordinateValue(layoutOption.BOTTOM);
                        }
                        this.localTranslate.y = this.getLayCoordinateValue(layoutOption.TOP) - parent.pivot.y * parent.height + this.pivot.y * this.height;
                    }
                    else if (state & layoutOption.BOTTOM) {
                        this.localTranslate.y = parent.height - this.height - this.getLayCoordinateValue(layoutOption.BOTTOM) - parent.pivot.y * parent.height + this.pivot.y * this.height;
                    }
                    if (state & layoutOption.V_CENTER) {
                        this.localTranslate.y = (parent.height - this.height) / 2 + this.getLayCoordinateValue(layoutOption.V_CENTER) - parent.pivot.y * parent.height + this.pivot.y * this.height;
                    }
                    //布局调整 后刷新 matrix
                    m4m.math.matrix3x2MakeTransformRTS(this.localTranslate, this.localScale, this.localRotate, this.localMatrix);
                }
                this.layoutDirty = false;
                this.lastParentWidth = parent.width;
                this.lastParentHeight = parent.height;
                this.lastWidth = this.width;
                this.lastHeight = this.height;
                this.lastParentPivot.x = parent.pivot.x;
                this.lastParentPivot.y = parent.pivot.y;
                this.lastPivot.x = this.pivot.x;
                this.lastPivot.y = this.pivot.y;
            };
            /** 获取Layout 的坐标系值 */
            transform2D.prototype.getLayCoordinateValue = function (option) {
                if (this.layoutValueMap[option] == undefined)
                    this.layoutValueMap[option] = 0;
                var value = 0;
                if (this._layoutPercentState & option) {
                    if (this._parent) {
                        switch (option) {
                            case layoutOption.LEFT:
                            case layoutOption.H_CENTER:
                            case layoutOption.RIGHT:
                                value = this._parent.width * this.layoutValueMap[option] / 100;
                                break;
                            case layoutOption.TOP:
                            case layoutOption.V_CENTER:
                            case layoutOption.BOTTOM:
                                value = this._parent.height * this.layoutValueMap[option] / 100;
                                break;
                        }
                    }
                }
                else {
                    value = this.layoutValueMap[option];
                }
                return value;
            };
            /** 设置Layout 的坐标系值 */
            transform2D.prototype.setLayCoordinateValue = function (option, value) {
                if (isNaN(option) || isNaN(value) || option == undefined || value == undefined)
                    return;
                var _v = value;
                if (this._layoutPercentState & option) {
                    if (this._parent) {
                        switch (option) {
                            case layoutOption.LEFT:
                            case layoutOption.H_CENTER:
                            case layoutOption.RIGHT:
                                _v = value / this._parent.width * 100;
                                break;
                            case layoutOption.TOP:
                            case layoutOption.V_CENTER:
                            case layoutOption.BOTTOM:
                                _v = value / this._parent.height * 100;
                                break;
                        }
                    }
                }
                //save value
                if (this.layoutValueMap[option] == undefined || _v != this.layoutValueMap[option]) {
                    this.layoutDirty = true;
                    this.markDirty();
                    this.layoutValueMap[option] = _v;
                }
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 设置兄弟姐妹序列索引
             * @version m4m 1.0
             */
            transform2D.prototype.setSiblingIndex = function (siblingIndex) {
                var p = this._parent;
                if (!p || !p._children || siblingIndex >= p._children.length || isNaN(siblingIndex) || siblingIndex < 0)
                    return;
                var currIdx = p._children.indexOf(this);
                if (currIdx == -1 || currIdx == siblingIndex)
                    return;
                p._children.splice(currIdx, 1);
                var useidx = siblingIndex > currIdx ? siblingIndex - 1 : siblingIndex;
                p._children.splice(useidx, 0, this); //insert to target pos
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取兄弟姐妹序列索引
             * @version m4m 1.0
             */
            transform2D.prototype.getSiblingIndex = function () {
                var p = this._parent;
                if (!p || !p._children)
                    return -1;
                if (p._children.length < 1)
                    return 0;
                return p._children.indexOf(this);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取当前transform2D的克隆
             * @version m4m 1.0
             */
            transform2D.prototype.clone = function () {
                return m4m.io.cloneObj(this);
            };
            /**
             * 设置 节点的本地位置（会处理layout选项）
             * @param pos
             */
            transform2D.prototype.setLocalPosition = function (pos) {
                var state = this._layoutState | this._layoutPercentState;
                var lPos = this.localTranslate;
                var x = pos.x;
                var y = pos.y;
                var parent = this.parent;
                if (state == 0 || !parent) {
                    if (lPos.x != x || lPos.y != y)
                        this.markDirty();
                    lPos.x = x;
                    lPos.y = y;
                }
                //layout 模式处理
                if (!parent)
                    return;
                //x
                if (state & layoutOption.LEFT) {
                    var l = x;
                    if (state & layoutOption.RIGHT) {
                        var r = -x;
                        this.setLayCoordinateValue(layoutOption.RIGHT, r);
                    }
                    this.setLayCoordinateValue(layoutOption.LEFT, l);
                }
                else if (state & layoutOption.RIGHT) {
                    this.setLayCoordinateValue(layoutOption.RIGHT, -x);
                }
                if (state & layoutOption.H_CENTER) {
                    var difHalf = (parent.width - this.width) / 2;
                    this.setLayCoordinateValue(layoutOption.H_CENTER, x - difHalf);
                }
                //y
                if (state & layoutOption.TOP) {
                    var t = y;
                    if (state & layoutOption.BOTTOM) {
                        var b = -y;
                        this.setLayCoordinateValue(layoutOption.BOTTOM, b);
                    }
                    this.setLayCoordinateValue(layoutOption.TOP, t);
                }
                else if (state & layoutOption.BOTTOM) {
                    this.setLayCoordinateValue(layoutOption.BOTTOM, -y);
                }
                if (state & layoutOption.V_CENTER) {
                    var difHalf = (parent.height - this.height) / 2;
                    this.setLayCoordinateValue(layoutOption.V_CENTER, y - difHalf);
                }
            };
            var transform2D_1;
            transform2D.ClassName = "transform2D";
            transform2D.help_v2 = new m4m.math.vector2();
            transform2D.help_v2_1 = new m4m.math.vector2();
            transform2D.help_v2_2 = new m4m.math.vector2();
            transform2D.help_v2_3 = new m4m.math.vector2();
            transform2D.help_mtx = new m4m.math.matrix3x2();
            transform2D.help_mtx_1 = new m4m.math.matrix3x2();
            //insID : transform2D 收集 map
            transform2D._transform2DMap = {};
            __decorate([
                m4m.reflect.Field("string"),
                __metadata("design:type", String)
            ], transform2D.prototype, "prefab", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                m4m.reflect.UIStyle("enum"),
                __metadata("design:type", Number)
            ], transform2D.prototype, "layer", void 0);
            __decorate([
                m4m.reflect.Field("string"),
                __metadata("design:type", String)
            ], transform2D.prototype, "tag", void 0);
            __decorate([
                m4m.reflect.Field("string"),
                __metadata("design:type", String)
            ], transform2D.prototype, "name", void 0);
            __decorate([
                m4m.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], transform2D.prototype, "isStatic", void 0);
            __decorate([
                m4m.reflect.Field("transform2D[]"),
                __metadata("design:type", Array),
                __metadata("design:paramtypes", [Array])
            ], transform2D.prototype, "children", null);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], transform2D.prototype, "width", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], transform2D.prototype, "height", void 0);
            __decorate([
                m4m.reflect.Field("vector2"),
                __metadata("design:type", m4m.math.vector2)
            ], transform2D.prototype, "pivot", void 0);
            __decorate([
                m4m.reflect.Field("boolean"),
                __metadata("design:type", Object)
            ], transform2D.prototype, "_visible", void 0);
            __decorate([
                m4m.reflect.Field("vector2"),
                __metadata("design:type", m4m.math.vector2)
            ], transform2D.prototype, "localTranslate", void 0);
            __decorate([
                m4m.reflect.Field("vector2"),
                __metadata("design:type", m4m.math.vector2)
            ], transform2D.prototype, "localScale", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], transform2D.prototype, "localRotate", void 0);
            __decorate([
                m4m.reflect.Field("boolean"),
                __metadata("design:type", Boolean),
                __metadata("design:paramtypes", [Boolean])
            ], transform2D.prototype, "isMask", null);
            __decorate([
                m4m.reflect.Field("C2DComponent[]"),
                __metadata("design:type", Array)
            ], transform2D.prototype, "components", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], transform2D.prototype, "layoutState", null);
            __decorate([
                m4m.reflect.Field("numberdic"),
                __metadata("design:type", Object)
            ], transform2D.prototype, "layoutValueMap", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], transform2D.prototype, "layoutPercentState", null);
            transform2D = transform2D_1 = __decorate([
                m4m.reflect.SerializeType
            ], transform2D);
            return transform2D;
        }());
        framework.transform2D = transform2D;
        var t2dInfo = /** @class */ (function () {
            function t2dInfo() {
                this.pivot = new m4m.math.vector2();
                this.pivotPos = new m4m.math.vector2();
            }
            t2dInfo.getCenter = function (info, outCenter) {
                outCenter.x = info.pivotPos.x + info.width * (0.5 - info.pivot.x) * Math.cos(info.rot) - info.height * (0.5 - info.pivot.y) * Math.sin(info.rot);
                outCenter.y = info.pivotPos.y - info.width * (0.5 - info.pivot.x) * Math.sin(info.rot) + info.height * (0.5 - info.pivot.y) * Math.cos(info.rot);
            };
            return t2dInfo;
        }());
        framework.t2dInfo = t2dInfo;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../../io/reflect.ts" />
var m4m;
/// <reference path="../../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        var behaviour2d = /** @class */ (function () {
            function behaviour2d() {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 组件启用
                 * @version m4m 1.0
                 */
                // @reflect.Field("boolean")  //有问题 ，待处理组件继承后 开启
                this.enabled = true;
            }
            /** 初始化使用 */
            behaviour2d.prototype.start = function () {
            };
            /** 初始化使用  在start 之后*/
            behaviour2d.prototype.onPlay = function () {
            };
            /** 每帧调用一次 */
            behaviour2d.prototype.update = function (delta) {
            };
            behaviour2d.prototype.remove = function () {
            };
            return behaviour2d;
        }());
        framework.behaviour2d = behaviour2d;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../../io/reflect.ts" />
var m4m;
/// <reference path="../../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
        * @public
        * @language zh_CN
        * @classdesc
        * 2d矩形碰撞盒
        * @version m4m 1.0
        */
        var boxcollider2d = /** @class */ (function () {
            function boxcollider2d() {
            }
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 获取obb2d
            * @version m4m 1.0
            */
            boxcollider2d.prototype.getBound = function () {
                return this._obb;
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 检测碰撞
            * @version m4m 1.0
            */
            boxcollider2d.prototype.intersectsTransform = function (tran) {
                if (tran == null)
                    return false;
                if (this._obb == null || tran.collider.getBound() == null)
                    return false;
                var _obb = tran.collider.getBound();
                return this._obb.intersects(_obb);
            };
            /**
           * @private
           * @language zh_CN
           * @classdesc
           * 构建碰撞盒
           * @version m4m 1.0
           */
            boxcollider2d.prototype.build = function () {
                var t = this.transform;
                this._obb = new framework.obb2d();
                this._obb.buildByCenterSize(t.getWorldTranslate(), t.width, t.height);
                this.refreshTofullOver();
            };
            /**
            * @private
            * @language zh_CN
            * @classdesc
            * 刷新成碰撞框完全覆盖transform
            * @version m4m 1.0
            */
            boxcollider2d.prototype.refreshTofullOver = function () {
                if (!this._obb || !this._obb.size || !this._obb.offset)
                    return;
                var t = this.transform;
                this._obb.size.x = t.width;
                this._obb.size.y = t.height;
                this._obb.offset.x = (0.5 - t.pivot.x) * this._obb.size.x;
                this._obb.offset.y = (0.5 - t.pivot.y) * this._obb.size.y;
            };
            boxcollider2d.prototype.start = function () {
                this.build();
            };
            boxcollider2d.prototype.onPlay = function () {
            };
            boxcollider2d.prototype.update = function (delta) {
                if (this._obb) {
                    this._obb.update(this.transform.getCanvasWorldMatrix());
                }
            };
            boxcollider2d.prototype.remove = function () {
                if (this._obb)
                    this._obb.dispose();
                this._obb = null;
            };
            boxcollider2d.ClassName = "boxcollider2d";
            boxcollider2d = __decorate([
                m4m.reflect.node2DComponent,
                m4m.reflect.nodeBoxCollider2d
            ], boxcollider2d);
            return boxcollider2d;
        }());
        framework.boxcollider2d = boxcollider2d;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../../io/reflect.ts" />
var m4m;
/// <reference path="../../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 按钮变换类型
         * @version m4m 1.0
         */
        var TransitionType;
        (function (TransitionType) {
            TransitionType[TransitionType["None"] = 0] = "None";
            TransitionType[TransitionType["ColorTint"] = 1] = "ColorTint";
            TransitionType[TransitionType["SpriteSwap"] = 2] = "SpriteSwap";
        })(TransitionType = framework.TransitionType || (framework.TransitionType = {}));
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 2d按钮组件
         * @version m4m 1.0
         */
        var button = /** @class */ (function () {
            function button() {
                this._transition = TransitionType.ColorTint;
                this._origianlSpriteName = "";
                this._pressedSpriteName = "";
                this._normalColor = new m4m.math.color(1, 1, 1, 1);
                this._pressedColor = new m4m.math.color(0.5, 0.5, 0.5, 1);
                this._fadeDuration = 0.1;
                this.downPointV2 = new m4m.math.vector2();
                this.isMovedLimit = false; //point 移动范围是否超出限制值
                this.movedLimit = 0.02; //point 移动范围限制值
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 点击事件
                 * @version m4m 1.0
                 */
                //onClick: UIEvent = new UIEvent();
                this.UIEventer = new m4m.event.UIEvent();
                this._downInThis = false;
                this._dragOut = false;
            }
            button_1 = button;
            Object.defineProperty(button.prototype, "transition", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 按钮变换类型
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._transition;
                },
                set: function (transition) {
                    this._transition = transition;
                    if (this._targetImage != null) {
                        if (transition == TransitionType.ColorTint) {
                            this._targetImage.color = this.normalColor;
                        }
                        else {
                            this._targetImage.color = this._originalColor;
                        }
                    }
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(button.prototype, "targetImage", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 默认显示图像
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._targetImage;
                },
                set: function (graphic) {
                    if (this._targetImage != null) {
                        this._targetImage.color = this._originalColor;
                    }
                    if (graphic != null) {
                        this._originalColor = graphic.color;
                        this._originalSprite = graphic.sprite;
                        if (graphic.sprite)
                            this._origianlSpriteName = graphic.sprite.getName();
                        if (this._transition == TransitionType.ColorTint) {
                            graphic.color = this.normalColor;
                        }
                    }
                    else {
                        this._originalColor = null;
                        this._originalSprite = null;
                    }
                    this._targetImage = graphic;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(button.prototype, "pressedGraphic", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 按下时要显示的sprite
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._pressedSprite;
                },
                set: function (sprite) {
                    this._pressedSprite = sprite;
                    if (sprite != null) {
                        this._pressedSpriteName = sprite.getName();
                    }
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(button.prototype, "normalColor", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 正常的显示颜色
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._normalColor;
                },
                set: function (color) {
                    this._normalColor = color;
                    if (this._targetImage != null && this.transition == TransitionType.ColorTint) {
                        this._targetImage.color = color;
                    }
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(button.prototype, "pressedColor", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 按下后的颜色
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._pressedColor;
                },
                set: function (color) {
                    this._pressedColor = color;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(button.prototype, "fadeDuration", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 颜色淡出持续时间
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._fadeDuration;
                },
                set: function (duration) {
                    this._fadeDuration = duration;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * @private
             */
            button.prototype.start = function () {
            };
            button.prototype.onPlay = function () {
            };
            /**
             * @private
             */
            button.prototype.update = function (delta) {
                // math.colorLerp();
            };
            /**
             * @private
             */
            button.prototype.remove = function () {
                this._targetImage = null;
                this.transform = null;
                this._normalColor = null;
                this._originalColor = null;
                this._pressedColor = null;
                if (this.pressedGraphic)
                    this.pressedGraphic.unuse();
            };
            /**
             * @private
             */
            button.prototype.onPointEvent = function (canvas, ev, oncap) {
                //oncap==true 是捕获阶段，一般的行为，只在pop阶段处理
                if (oncap == false) {
                    var tv2 = m4m.poolv2();
                    tv2.x = ev.x;
                    tv2.y = ev.y;
                    var b = this.transform.ContainsCanvasPoint(tv2);
                    if (b) {
                        if (ev.type == m4m.event.PointEventEnum.PointDown) {
                            this._downInThis = true;
                            this.showPress();
                            var pd = m4m.event.UIEventEnum.PointerDown;
                            if (this.UIEventer.listenerCount(m4m.event.UIEventEnum[pd]) > 0) {
                                ev.eated = true;
                                this.UIEventer.EmitEnum(pd, ev);
                                if (button_1.enablePathDispatch && button_1.onPath) {
                                    button_1.onPath("".concat(this.caclePath(), ":[").concat(m4m.event.UIEventEnum[pd], "]"));
                                }
                            }
                            this.downPointV2.x = ev.x;
                            this.downPointV2.y = ev.y;
                            this.isMovedLimit = false;
                        }
                        else if (ev.type == m4m.event.PointEventEnum.PointHold && this._downInThis) {
                            if (this._dragOut == true) {
                                this._dragOut = false;
                                this.showPress();
                            }
                            if (!this.isMovedLimit) {
                                this.isMovedLimit = m4m.math.vec2Distance(tv2, this.downPointV2) > this.movedLimit;
                            }
                        }
                        else if (ev.type == m4m.event.PointEventEnum.PointUp && this._downInThis) {
                            this._downInThis = false;
                            this.showNormal();
                            var pu = m4m.event.UIEventEnum.PointerUp;
                            if (this.UIEventer.listenerCount(m4m.event.UIEventEnum[pu]) > 0) {
                                ev.eated = true;
                                this.UIEventer.EmitEnum(pu, ev);
                                if (button_1.enablePathDispatch && button_1.onPath) {
                                    button_1.onPath("".concat(this.caclePath(), ":[").concat(m4m.event.UIEventEnum[pu], "]"));
                                }
                            }
                            //this.onClick.excute();
                            var pc = m4m.event.UIEventEnum.PointerClick;
                            if (!this.isMovedLimit && this.UIEventer.listenerCount(m4m.event.UIEventEnum[pc]) > 0) {
                                ev.eated = true;
                                this.UIEventer.EmitEnum(pc, ev);
                                if (button_1.enablePathDispatch && button_1.onPath) {
                                    button_1.onPath("".concat(this.caclePath(), ":[").concat(m4m.event.UIEventEnum[pc], "]"));
                                }
                            }
                        }
                    }
                    else {
                        if (ev.type == m4m.event.PointEventEnum.PointUp) { //在区域外抬起
                            this._downInThis = false;
                        }
                        else if (ev.type == m4m.event.PointEventEnum.PointHold && this._downInThis) {
                            if (this._dragOut == false) {
                                this._dragOut = true;
                                this.showNormal();
                            }
                        }
                    }
                    m4m.poolv2_del(tv2);
                }
            };
            /**
            * 添加UI事件监听者
            * @param eventEnum 事件类型
            * @param func 事件触发回调方法 (Warn: 不要使用 func.bind() , 它会导致相等判断失败)
            * @param thisArg 回调方法执行者
            */
            button.prototype.addListener = function (eventEnum, func, thisArg) {
                this.UIEventer.OnEnum(eventEnum, func, thisArg);
            };
            /**
             * 移除事件监听者
             * @param event 事件类型
             * @param func 事件触发回调方法
             * @param thisArg 回调方法执行者
             */
            button.prototype.removeListener = function (eventEnum, func, thisArg) {
                this.UIEventer.RemoveListener(m4m.event.UIEventEnum[eventEnum], func, thisArg);
            };
            /**
             * @private
             */
            button.prototype.showNormal = function () {
                if (this.transition == TransitionType.ColorTint) {
                    this.changeColor(this._normalColor);
                }
                else if (this.transition == TransitionType.SpriteSwap) {
                    if (!this._originalSprite) {
                        this._originalSprite = this.tryGetSprite(this._origianlSpriteName);
                    }
                    this.changeSprite(this._originalSprite);
                }
            };
            /**
             * @private
             */
            button.prototype.showPress = function () {
                if (this.transition == TransitionType.None) {
                    return;
                }
                else if (this.transition == TransitionType.ColorTint) {
                    this.changeColor(this._pressedColor);
                }
                else if (this.transition == TransitionType.SpriteSwap) {
                    if (this._targetImage != null && this._targetImage.sprite != null && this._originalSprite == null) {
                        this._originalSprite = this._targetImage.sprite;
                    }
                    if (!this._pressedSprite) {
                        this._pressedSprite = this.tryGetSprite(this._pressedSpriteName);
                    }
                    this.changeSprite(this._pressedSprite);
                }
            };
            button.prototype.tryGetSprite = function (spriteName) {
                var temp = framework.assetMgr.mapNamed[spriteName];
                if (temp != null) {
                    var tsprite = this.transform.canvas.assetmgr.getAssetByName(spriteName);
                    if (tsprite)
                        return tsprite;
                }
            };
            /**
             * @private
             */
            button.prototype.changeColor = function (targetColor) {
                if (this._targetImage != null) {
                    this._targetImage.color = targetColor;
                    this._targetImage.transform.markDirty();
                }
            };
            /**
             * @private
             */
            button.prototype.changeSprite = function (sprite) {
                if (sprite == null)
                    return;
                if (this._targetImage != null) {
                    this._targetImage.sprite = sprite;
                    this._targetImage.transform.markDirty();
                }
            };
            /** 计算path */
            button.prototype.caclePath = function () {
                if (!this.transform)
                    return "";
                var result = this.transform.name;
                var currTran = this.transform;
                var parent = currTran.parent;
                while (parent) {
                    result = "".concat(parent.name, "|").concat(result);
                    currTran = parent;
                    parent = currTran.parent;
                }
                return result;
            };
            var button_1;
            button.ClassName = "button";
            /** 开启 交互时 路径派发 */
            button.enablePathDispatch = false;
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], button.prototype, "transition", null);
            __decorate([
                m4m.reflect.Field("string"),
                __metadata("design:type", String)
            ], button.prototype, "_origianlSpriteName", void 0);
            __decorate([
                m4m.reflect.Field("string"),
                __metadata("design:type", String)
            ], button.prototype, "_pressedSpriteName", void 0);
            __decorate([
                m4m.reflect.Field("reference", null, "image2D"),
                __metadata("design:type", framework.image2D),
                __metadata("design:paramtypes", [framework.image2D])
            ], button.prototype, "targetImage", null);
            __decorate([
                m4m.reflect.Field("color"),
                m4m.reflect.UIStyle("color"),
                __metadata("design:type", m4m.math.color),
                __metadata("design:paramtypes", [m4m.math.color])
            ], button.prototype, "normalColor", null);
            __decorate([
                m4m.reflect.Field("color"),
                m4m.reflect.UIStyle("color"),
                __metadata("design:type", m4m.math.color),
                __metadata("design:paramtypes", [m4m.math.color])
            ], button.prototype, "pressedColor", null);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], button.prototype, "fadeDuration", null);
            button = button_1 = __decorate([
                m4m.reflect.node2DComponent
            ], button);
            return button;
        }());
        framework.button = button;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../../io/reflect.ts" />
var m4m;
/// <reference path="../../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 2d图片组件
         * @version m4m 1.0
         */
        var image2D = /** @class */ (function () {
            /**
             * @private
             */
            function image2D() {
                this._unitLen = 13;
                //2d使用固定的顶点格式
                //pos[0,1,2]color[3,4,5,6]uv[7,8]color2[9,10,11,12] length=13
                this.datar = [
                    0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
                ];
                this.needRefreshImg = false;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 颜色
                 * @version m4m 1.0
                 */
                this.color = new m4m.math.color(1.0, 1.0, 1.0, 1.0);
                this._CustomShaderName = ""; //自定义UIshader
                this._imageType = ImageType.Simple;
                this._fillMethod = FillMethod.Horizontal;
                this._fillAmmount = 1;
                this._spriteName = "";
                this._imageBorder = new m4m.math.border();
                this.min_x = Number.MAX_VALUE;
                this.max_x = Number.MAX_VALUE * -1;
                this.min_y = Number.MAX_VALUE;
                this.max_y = Number.MAX_VALUE * -1;
                m4m.io.enumMgr.enumMap["ImageType"] = ImageType;
                m4m.io.enumMgr.enumMap["FillMethod"] = FillMethod;
            }
            image2D_1 = image2D;
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 设置rander Shader名字
             * @version m4m 1.0
             */
            image2D.prototype.setShaderByName = function (shaderName) {
                this._CustomShaderName = shaderName;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取rander 的材质
             * @version m4m 1.0
             */
            image2D.prototype.getMaterial = function () {
                if (!this._uimat) {
                    return this.uimat;
                }
                return this._uimat;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取渲染绘制矩形边界
             * @version m4m 1.0
             */
            image2D.prototype.getDrawBounds = function () {
                if (!this._darwRect) {
                    this._darwRect = new m4m.math.rect();
                    this.calcDrawRect();
                }
                return this._darwRect;
            };
            Object.defineProperty(image2D.prototype, "uimat", {
                get: function () {
                    var assetmgr = this.transform.canvas.assetmgr;
                    if (!assetmgr)
                        return this._uimat;
                    this.searchTexture();
                    if (this._sprite && this._sprite.texture) {
                        var pMask = this.transform.parentIsMask;
                        var mat = this._uimat;
                        var rectTag = "";
                        var uiTag = "_ui";
                        if (pMask) {
                            // let prect = this.transform.maskRect;
                            // rectTag = `mask(${prect.x}_${prect.y}_${prect.w}_${prect.h})`; //when parentIsMask,can't multiplexing material , can be multiplexing when parent equal
                            var rId = this.transform.maskRectId;
                            rectTag = "mask(".concat(rId, ")");
                        }
                        var useShaderName = this._CustomShaderName ? this._CustomShaderName : pMask ? image2D_1.defMaskUIShader : image2D_1.defUIShader;
                        var matName = useShaderName + this._sprite.texture.getName() + uiTag + rectTag;
                        if (!mat || mat.getName() != matName) {
                            if (mat)
                                mat.unuse();
                            mat = assetmgr.getAssetByName(matName);
                            if (mat)
                                mat.use();
                        }
                        if (!mat) {
                            mat = new framework.material(matName);
                            var sh = assetmgr.getShader(this._CustomShaderName);
                            sh = sh ? sh : assetmgr.getShader(pMask ? image2D_1.defMaskUIShader : image2D_1.defUIShader);
                            mat.setShader(sh);
                            mat.use();
                            this.needRefreshImg = true;
                        }
                        this._uimat = mat;
                    }
                    return this._uimat;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(image2D.prototype, "imageType", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 图片显示模式
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._imageType;
                },
                set: function (type) {
                    this._imageType = type;
                    this.prepareData();
                    if (this.transform != null)
                        this.transform.markDirty();
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(image2D.prototype, "fillMethod", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 图片填充方式
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._fillMethod;
                },
                set: function (method) {
                    this._fillMethod = method;
                    this.prepareData();
                    if (this.transform != null)
                        this.transform.markDirty();
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(image2D.prototype, "fillAmmount", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 填充率
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._fillAmmount;
                },
                set: function (ammount) {
                    this._fillAmmount = ammount;
                    if (this.transform != null)
                        this.transform.markDirty();
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(image2D.prototype, "sprite", {
                get: function () {
                    return this._sprite;
                },
                // /**
                //  * @public
                //  * @language zh_CN
                //  * @classdesc
                //  * 设置图片
                //  * @param texture 图片
                //  * @param border 切片信息
                //  * @param rect 显示范围
                //  * @version m4m 1.0
                //  */
                // setTexture(texture: texture, border?: math.border, rect?: math.rect)
                // {   //image 不应该有setTexture
                //     this.needRefreshImg = true;
                //     if(this.sprite)
                //     {
                //         this.sprite.unuse();
                //     }
                //     var _sprite = new sprite();
                //     _sprite.texture = texture;
                //     if (border != null)
                //         _sprite.border = border;
                //     else
                //         _sprite.border = new math.border(0, 0, 0, 0);
                //     if (rect != null)
                //         _sprite.rect = rect;
                //     else
                //         _sprite.rect = new math.rect(0, 0, texture.glTexture.width, texture.glTexture.height);
                //     this.sprite = _sprite;
                //     this.sprite.use();
                //     this.prepareData();
                //     if (this.transform != null){
                //         this.transform.markDirty();
                //         this.updateTran();
                //     }
                // }
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 精灵
                 * @version m4m 1.0
                 */
                set: function (sprite) {
                    if (sprite == this._sprite)
                        return;
                    if (this._sprite) {
                        this._sprite.unuse();
                    }
                    if (!this._sprite || !sprite || this._sprite.texture != sprite.texture) {
                        this.needRefreshImg = true;
                    }
                    this._sprite = sprite;
                    if (sprite) {
                        // this._imageBorder.l = sprite.border.l;
                        // this._imageBorder.t = sprite.border.t;
                        // this._imageBorder.r = sprite.border.r;
                        // this._imageBorder.b = sprite.border.b;
                        this._sprite.use();
                        this._spriteName = this._sprite.getName();
                        this.prepareData();
                        if (this.transform != null) {
                            this.transform.markDirty();
                            this.updateTran();
                        }
                    }
                    else {
                        this._spriteName = "";
                    }
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(image2D.prototype, "imageBorder", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 9宫格边距
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._imageBorder;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * @private
             */
            image2D.prototype.render = function (canvas) {
                var mat = this.uimat;
                if (!mat)
                    return;
                var img;
                if (this._sprite && this._sprite.texture) {
                    img = this._sprite.texture;
                }
                if (img) {
                    var needRMask = false;
                    if (this.needRefreshImg) {
                        mat.setTexture("_MainTex", img);
                        this.needRefreshImg = false;
                        needRMask = true;
                    }
                    if (this.transform.parentIsMask) {
                        if (!this._cacheMaskV4)
                            this._cacheMaskV4 = new m4m.math.vector4();
                        var rect = this.transform.maskRect;
                        if (this._cacheMaskV4.x != rect.x || this._cacheMaskV4.y != rect.y || this._cacheMaskV4.w != rect.w || this._cacheMaskV4.z != rect.h || needRMask) {
                            this._cacheMaskV4.x = rect.x;
                            this._cacheMaskV4.y = rect.y;
                            this._cacheMaskV4.z = rect.w;
                            this._cacheMaskV4.w = rect.h;
                            mat.setVector4("_maskRect", this._cacheMaskV4);
                        }
                    }
                    canvas.pushRawData(mat, this.datar);
                }
            };
            //资源管理器中寻找 指定的贴图资源
            image2D.prototype.searchTexture = function () {
                if (this._sprite)
                    return;
                var assetmgr = this.transform.canvas.assetmgr;
                var temp = framework.assetMgr.mapNamed[this._spriteName];
                var tspr;
                if (temp != null) {
                    tspr = assetmgr.getAssetByName(this._spriteName);
                }
                else {
                    if (assetmgr.mapDefaultSprite[this._spriteName]) //找默认资源
                        tspr = assetmgr.getDefaultSprite(this._spriteName);
                }
                if (tspr) {
                    this.sprite = tspr;
                    this.needRefreshImg = true;
                    return; //捕获到目标sprite后强制 下一帧渲染 （防止 transform树同步延迟 导致 右上角ghostShadow 问题）
                }
            };
            /**
             * @private
             */
            image2D.prototype.start = function () {
            };
            image2D.prototype.onPlay = function () {
            };
            /**
             * @private
             */
            image2D.prototype.update = function (delta) {
            };
            /**
             * @private
             */
            image2D.prototype.remove = function () {
                if (this._sprite)
                    this._sprite.unuse();
                if (this._uimat)
                    this._uimat.unuse();
                this.datar.length = 0;
                this.transform = null;
                this._imageBorder = null;
            };
            /**
             * @private
             * 根据显示方式来准备数据
             */
            image2D.prototype.prepareData = function () {
                if (this._sprite == null)
                    return;
                var urange = this._sprite.urange;
                var vrange = this._sprite.vrange;
                var ulen = urange.y - urange.x;
                var vlen = vrange.y - vrange.x;
                switch (this._imageType) {
                    case ImageType.Simple:
                        this.datar = [
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1
                        ];
                        break;
                    case ImageType.Sliced:
                        this.datar = [
                            //topleft
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            //top
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            //topright
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            //left
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            //center
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            //right
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            //bottomleft
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            //bottom
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                            //bottomright
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                        ];
                        break;
                    case ImageType.Tiled:
                        this.datar = [
                        //0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                        //0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                        //0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                        //0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                        //0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                        //0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1
                        ];
                        break;
                    case ImageType.Filled:
                        var halfu = urange.x + 0.5 * ulen;
                        var halfv = vrange.x + 0.5 * vlen;
                        switch (this._fillMethod) {
                            case FillMethod.Horizontal:
                            case FillMethod.Vertical:
                            case FillMethod.Radial_90:
                                this.datar = [
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1
                                ];
                                break;
                            case FillMethod.Radial_180:
                                this.datar = [
                                    //左半边
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                                    //右半边
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1
                                ];
                                break;
                            case FillMethod.Radial_360:
                                this.datar = [
                                    //左上
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, halfv, 1, 1, 1, 1,
                                    //右上
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, halfv, 1, 1, 1, 1,
                                    //左下
                                    0, 0, 0, 1, 1, 1, 1, urange.x, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.y, 1, 1, 1, 1,
                                    //右下
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, halfv, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1,
                                    0, 0, 0, 1, 1, 1, 1, halfu, vrange.y, 1, 1, 1, 1,
                                ];
                                break;
                        }
                        break;
                }
            };
            /**
             * @private
             */
            image2D.prototype.updateTran = function () {
                var m = this.transform.getWorldMatrix();
                var l = -this.transform.pivot.x * this.transform.width;
                var r = this.transform.width + l;
                var t = -this.transform.pivot.y * this.transform.height;
                var b = this.transform.height + t;
                var x0 = l * m.rawData[0] + t * m.rawData[2] + m.rawData[4];
                var y0 = l * m.rawData[1] + t * m.rawData[3] + m.rawData[5];
                var x1 = r * m.rawData[0] + t * m.rawData[2] + m.rawData[4];
                var y1 = r * m.rawData[1] + t * m.rawData[3] + m.rawData[5];
                var x2 = l * m.rawData[0] + b * m.rawData[2] + m.rawData[4];
                var y2 = l * m.rawData[1] + b * m.rawData[3] + m.rawData[5];
                var x3 = r * m.rawData[0] + b * m.rawData[2] + m.rawData[4];
                var y3 = r * m.rawData[1] + b * m.rawData[3] + m.rawData[5];
                if (this._sprite == null)
                    return;
                switch (this._imageType) {
                    case ImageType.Simple:
                        this.updateSimpleData(x0, y0, x1, y1, x2, y2, x3, y3);
                        break;
                    case ImageType.Sliced:
                        this.updateSlicedData(x0, y0, x1, y1, x2, y2, x3, y3);
                        break;
                    case ImageType.Tiled:
                        this.updateTiledData(x0, y0, x1, y1, x2, y2, x3, y3);
                        break;
                    case ImageType.Filled:
                        this.updateFilledData(x0, y0, x1, y1, x2, y2, x3, y3);
                        break;
                }
                //主color
                var vertexCount = this.datar.length / this._unitLen;
                for (var i = 0; i < vertexCount; i++) {
                    this.datar[i * this._unitLen + 3] = this.color.r;
                    this.datar[i * this._unitLen + 4] = this.color.g;
                    this.datar[i * this._unitLen + 5] = this.color.b;
                    this.datar[i * this._unitLen + 6] = this.color.a;
                }
                //drawRect 
                this.min_x = Math.min(x0, x1, x2, x3, this.min_x);
                this.min_y = Math.min(y0, y1, y2, y3, this.min_y);
                this.max_x = Math.max(x0, x1, x2, x3, this.max_x);
                this.max_y = Math.max(y0, y1, y2, y3, this.max_y);
                this.calcDrawRect();
            };
            /** 计算drawRect */
            image2D.prototype.calcDrawRect = function () {
                if (!this._darwRect)
                    return;
                //drawBounds (y 轴反向)
                var canvas = this.transform.canvas;
                if (!canvas)
                    return;
                var minPos = m4m.poolv2();
                minPos.x = this.min_x;
                minPos.y = this.max_y;
                canvas.clipPosToCanvasPos(minPos, minPos);
                var maxPos = m4m.poolv2();
                maxPos.x = this.max_x;
                maxPos.y = this.min_y;
                canvas.clipPosToCanvasPos(maxPos, maxPos);
                this._darwRect.x = minPos.x;
                this._darwRect.y = minPos.y;
                this._darwRect.w = maxPos.x - minPos.x;
                this._darwRect.h = maxPos.y - minPos.y;
                this.min_x = this.min_y = Number.MAX_VALUE;
                this.max_x = this.max_y = Number.MAX_VALUE * -1;
                m4m.poolv2_del(minPos);
                m4m.poolv2_del(maxPos);
            };
            /**
             * @private
             * 更新quad的顶点数据
             */
            image2D.prototype.updateQuadData = function (x0, y0, x1, y1, x2, y2, x3, y3, quadIndex, mirror) {
                if (quadIndex === void 0) { quadIndex = 0; }
                if (mirror === void 0) { mirror = false; }
                var _index = quadIndex * 6;
                if (!mirror) {
                    this.datar[(_index + 0) * this._unitLen] = x0;
                    this.datar[(_index + 0) * this._unitLen + 1] = y0;
                    this.datar[(_index + 1) * this._unitLen] = x1;
                    this.datar[(_index + 1) * this._unitLen + 1] = y1;
                    this.datar[(_index + 2) * this._unitLen] = x2;
                    this.datar[(_index + 2) * this._unitLen + 1] = y2;
                    this.datar[(_index + 3) * this._unitLen] = x2;
                    this.datar[(_index + 3) * this._unitLen + 1] = y2;
                    this.datar[(_index + 4) * this._unitLen] = x1;
                    this.datar[(_index + 4) * this._unitLen + 1] = y1;
                    this.datar[(_index + 5) * this._unitLen] = x3;
                    this.datar[(_index + 5) * this._unitLen + 1] = y3;
                }
                else {
                    this.datar[(_index + 0) * this._unitLen] = x0;
                    this.datar[(_index + 0) * this._unitLen + 1] = y0;
                    this.datar[(_index + 1) * this._unitLen] = x1;
                    this.datar[(_index + 1) * this._unitLen + 1] = y1;
                    this.datar[(_index + 2) * this._unitLen] = x3;
                    this.datar[(_index + 2) * this._unitLen + 1] = y3;
                    this.datar[(_index + 3) * this._unitLen] = x0;
                    this.datar[(_index + 3) * this._unitLen + 1] = y0;
                    this.datar[(_index + 4) * this._unitLen] = x3;
                    this.datar[(_index + 4) * this._unitLen + 1] = y3;
                    this.datar[(_index + 5) * this._unitLen] = x2;
                    this.datar[(_index + 5) * this._unitLen + 1] = y2;
                }
            };
            /**
             * @private
             * 更新常规数据
             */
            image2D.prototype.updateSimpleData = function (x0, y0, x1, y1, x2, y2, x3, y3) {
                this.updateQuadData(x0, y0, x1, y1, x2, y2, x3, y3);
            };
            /**
             * @private
             * 更新9宫数据
             */
            image2D.prototype.updateSlicedData = function (x0, y0, x1, y1, x2, y2, x3, y3) {
                var border = this._imageBorder;
                var rect = this._sprite.rect;
                //顶点
                var r1c1 = m4m.math.pool.new_vector2();
                var r1c4 = m4m.math.pool.new_vector2();
                var r4c1 = m4m.math.pool.new_vector2();
                var r4c4 = m4m.math.pool.new_vector2();
                var r1c2 = m4m.math.pool.new_vector2();
                var r1c3 = m4m.math.pool.new_vector2();
                var r2c1 = m4m.math.pool.new_vector2();
                var r3c1 = m4m.math.pool.new_vector2();
                var r2c2 = m4m.math.pool.new_vector2();
                var r2c3 = m4m.math.pool.new_vector2();
                var r2c4 = m4m.math.pool.new_vector2();
                var r3c2 = m4m.math.pool.new_vector2();
                var r3c3 = m4m.math.pool.new_vector2();
                var r3c4 = m4m.math.pool.new_vector2();
                var r4c2 = m4m.math.pool.new_vector2();
                var r4c3 = m4m.math.pool.new_vector2();
                //uv
                var r1c1_uv = m4m.math.pool.new_vector2();
                var r1c4_uv = m4m.math.pool.new_vector2();
                var r4c1_uv = m4m.math.pool.new_vector2();
                var r4c4_uv = m4m.math.pool.new_vector2();
                var r1c2_uv = m4m.math.pool.new_vector2();
                var r1c3_uv = m4m.math.pool.new_vector2();
                var r2c1_uv = m4m.math.pool.new_vector2();
                var r3c1_uv = m4m.math.pool.new_vector2();
                var r2c2_uv = m4m.math.pool.new_vector2();
                var r2c3_uv = m4m.math.pool.new_vector2();
                var r2c4_uv = m4m.math.pool.new_vector2();
                var r3c2_uv = m4m.math.pool.new_vector2();
                var r3c3_uv = m4m.math.pool.new_vector2();
                var r3c4_uv = m4m.math.pool.new_vector2();
                var r4c2_uv = m4m.math.pool.new_vector2();
                var r4c3_uv = m4m.math.pool.new_vector2();
                var help1 = m4m.math.pool.new_vector2();
                var help2 = m4m.math.pool.new_vector2();
                var help3 = m4m.math.pool.new_vector2();
                r1c1.x = x0;
                r1c1.y = y0;
                r1c4.x = x1;
                r1c4.y = y1;
                r4c1.x = x2;
                r4c1.y = y2;
                r4c4.x = x3;
                r4c4.y = y3;
                var width = m4m.math.vec2Distance(r1c1, r1c4);
                var height = m4m.math.vec2Distance(r1c1, r4c1);
                var urange = this._sprite.urange;
                var vrange = this._sprite.vrange;
                var l_vertex = (border.l) / this.transform.width;
                var r_vertex = (border.r) / this.transform.width;
                var t_vertex = (border.t) / this.transform.height;
                var b_vertex = (border.b) / this.transform.height;
                var l = (border.l) / rect.w * (urange.y - urange.x);
                var r = (border.r) / rect.w * (urange.y - urange.x);
                var t = (border.t) / rect.h * (vrange.y - vrange.x);
                var b = (border.b) / rect.h * (vrange.y - vrange.x);
                m4m.math.vec2Subtract(r1c4, r1c1, r1c2);
                m4m.math.vec2ScaleByNum(r1c2, l_vertex, r1c2);
                m4m.math.vec2Add(r1c2, r1c1, r1c2);
                m4m.math.vec2Subtract(r1c1, r1c4, r1c3);
                m4m.math.vec2ScaleByNum(r1c3, r_vertex, r1c3);
                m4m.math.vec2Add(r1c3, r1c4, r1c3);
                m4m.math.vec2Subtract(r4c1, r1c1, r2c1);
                m4m.math.vec2ScaleByNum(r2c1, t_vertex, r2c1);
                m4m.math.vec2Add(r2c1, r1c1, r2c1);
                m4m.math.vec2Subtract(r1c1, r4c1, r3c1);
                m4m.math.vec2ScaleByNum(r3c1, b_vertex, r3c1);
                m4m.math.vec2Add(r3c1, r4c1, r3c1);
                m4m.math.vec2Subtract(r1c2, r1c1, help1);
                m4m.math.vec2Subtract(r2c1, r1c1, help2);
                m4m.math.vec2Add(help1, help2, help3);
                m4m.math.vec2Add(help3, r1c1, r2c2);
                m4m.math.vec2Subtract(r1c3, r1c1, help1);
                m4m.math.vec2Subtract(r2c1, r1c1, help2);
                m4m.math.vec2Add(help1, help2, help3);
                m4m.math.vec2Add(help3, r1c1, r2c3);
                m4m.math.vec2Subtract(r1c4, r1c1, help1);
                m4m.math.vec2Subtract(r2c1, r1c1, help2);
                m4m.math.vec2Add(help1, help2, help3);
                m4m.math.vec2Add(help3, r1c1, r2c4);
                m4m.math.vec2Subtract(r1c2, r1c1, help1);
                m4m.math.vec2Subtract(r3c1, r1c1, help2);
                m4m.math.vec2Add(help1, help2, help3);
                m4m.math.vec2Add(help3, r1c1, r3c2);
                m4m.math.vec2Subtract(r1c3, r1c1, help1);
                m4m.math.vec2Subtract(r3c1, r1c1, help2);
                m4m.math.vec2Add(help1, help2, help3);
                m4m.math.vec2Add(help3, r1c1, r3c3);
                m4m.math.vec2Subtract(r1c4, r1c1, help1);
                m4m.math.vec2Subtract(r3c1, r1c1, help2);
                m4m.math.vec2Add(help1, help2, help3);
                m4m.math.vec2Add(help3, r1c1, r3c4);
                m4m.math.vec2Subtract(r1c2, r1c1, help1);
                m4m.math.vec2Subtract(r4c1, r1c1, help2);
                m4m.math.vec2Add(help1, help2, help3);
                m4m.math.vec2Add(help3, r1c1, r4c2);
                m4m.math.vec2Subtract(r1c3, r1c1, help1);
                m4m.math.vec2Subtract(r4c1, r1c1, help2);
                m4m.math.vec2Add(help1, help2, help3);
                m4m.math.vec2Add(help3, r1c1, r4c3);
                r1c1_uv.x = urange.x;
                r1c1_uv.y = vrange.x;
                r1c2_uv.x = l + urange.x;
                r1c2_uv.y = vrange.x;
                r1c3_uv.x = urange.y - r;
                r1c3_uv.y = vrange.x;
                r1c4_uv.x = urange.y;
                r1c4_uv.y = vrange.x;
                r2c1_uv.x = urange.x;
                r2c1_uv.y = t + vrange.x;
                r2c2_uv.x = l + urange.x;
                r2c2_uv.y = t + vrange.x;
                r2c3_uv.x = urange.y - r;
                r2c3_uv.y = t + vrange.x;
                r2c4_uv.x = urange.y;
                r2c4_uv.y = t + vrange.x;
                r3c1_uv.x = urange.x;
                r3c1_uv.y = vrange.y - b;
                r3c2_uv.x = l + urange.x;
                r3c2_uv.y = vrange.y - b;
                r3c3_uv.x = urange.y - r;
                r3c3_uv.y = vrange.y - b;
                r3c4_uv.x = urange.y;
                r3c4_uv.y = vrange.y - b;
                r4c1_uv.x = urange.x;
                r4c1_uv.y = vrange.y;
                r4c2_uv.x = l + urange.x;
                r4c2_uv.y = vrange.y;
                r4c3_uv.x = urange.y - r;
                r4c3_uv.y = vrange.y;
                r4c4_uv.x = urange.y;
                r4c4_uv.y = vrange.y;
                var vertexs = [r1c1, r1c2, r1c3, r1c4, r2c1, r2c2, r2c3, r2c4, r3c1, r3c2, r3c3, r3c4, r4c1, r4c2, r4c3, r4c4];
                var uvs = [r1c1_uv, r1c2_uv, r1c3_uv, r1c4_uv, r2c1_uv, r2c2_uv, r2c3_uv, r2c4_uv, r3c1_uv, r3c2_uv, r3c3_uv, r3c4_uv, r4c1_uv, r4c2_uv, r4c3_uv, r4c4_uv];
                var partVertexs;
                var partUVs;
                for (var i = 0; i < 9; i++) {
                    var r_1 = Math.floor(i / 3);
                    var c = i % 3;
                    //根据行列获取到9宫的当前部分的四个顶点和uv
                    partVertexs = [vertexs[0 + c + r_1 * 4], vertexs[1 + c + r_1 * 4], vertexs[4 + c + r_1 * 4], vertexs[5 + c + r_1 * 4]];
                    partUVs = [uvs[0 + c + r_1 * 4], uvs[1 + c + r_1 * 4], uvs[4 + c + r_1 * 4], uvs[5 + c + r_1 * 4]];
                    this.updateQuadData(partVertexs[0].x, partVertexs[0].y, partVertexs[1].x, partVertexs[1].y, partVertexs[2].x, partVertexs[2].y, partVertexs[3].x, partVertexs[3].y, i);
                    this.datar[(0 + i * 6) * this._unitLen + 7] = partUVs[0].x;
                    this.datar[(0 + i * 6) * this._unitLen + 8] = partUVs[0].y;
                    this.datar[(1 + i * 6) * this._unitLen + 7] = partUVs[1].x;
                    this.datar[(1 + i * 6) * this._unitLen + 8] = partUVs[1].y;
                    this.datar[(2 + i * 6) * this._unitLen + 7] = partUVs[2].x;
                    this.datar[(2 + i * 6) * this._unitLen + 8] = partUVs[2].y;
                    this.datar[(3 + i * 6) * this._unitLen + 7] = partUVs[2].x;
                    this.datar[(3 + i * 6) * this._unitLen + 8] = partUVs[2].y;
                    this.datar[(4 + i * 6) * this._unitLen + 7] = partUVs[1].x;
                    this.datar[(4 + i * 6) * this._unitLen + 8] = partUVs[1].y;
                    this.datar[(5 + i * 6) * this._unitLen + 7] = partUVs[3].x;
                    this.datar[(5 + i * 6) * this._unitLen + 8] = partUVs[3].y;
                    partVertexs.length = 0;
                    partUVs.length = 0;
                }
                m4m.math.pool.delete_vector2Array(vertexs);
                m4m.math.pool.delete_vector2Array(uvs);
                m4m.math.pool.delete_vector2Array([help1, help2, help3]);
            };
            /**
             * @private
             * 更新填充数据
             */
            image2D.prototype.updateFilledData = function (x0, y0, x1, y1, x2, y2, x3, y3) {
                var urange = this._sprite.urange;
                var vrange = this._sprite.vrange;
                var ulen = urange.y - urange.x;
                var vlen = vrange.y - vrange.x;
                var halfu = urange.x + 0.5 * ulen;
                var halfv = vrange.x + 0.5 * vlen;
                switch (this._fillMethod) {
                    case FillMethod.Horizontal:
                    case FillMethod.Vertical:
                    case FillMethod.Radial_90:
                        if (this._fillMethod == FillMethod.Horizontal) {
                            x1 = x1 - (1 - this.fillAmmount) * (x1 - x0);
                            y1 = y1 - (1 - this.fillAmmount) * (y1 - y0);
                            x3 = x3 - (1 - this.fillAmmount) * (x3 - x2);
                            y3 = y3 - (1 - this.fillAmmount) * (y3 - y2);
                            this.datar[1 * this._unitLen + 7] = urange.x + this.fillAmmount * ulen;
                            this.datar[4 * this._unitLen + 7] = urange.x + this.fillAmmount * ulen;
                            this.datar[5 * this._unitLen + 7] = urange.x + this.fillAmmount * ulen;
                        }
                        else if (this._fillMethod == FillMethod.Vertical) {
                            x0 = x0 - (1 - this.fillAmmount) * (x0 - x2);
                            y0 = y0 - (1 - this.fillAmmount) * (y0 - y2);
                            x1 = x1 - (1 - this.fillAmmount) * (x1 - x3);
                            y1 = y1 - (1 - this.fillAmmount) * (y1 - y3);
                            this.datar[0 * this._unitLen + 8] = (vrange.y - this.fillAmmount * vlen);
                            this.datar[1 * this._unitLen + 8] = (vrange.y - this.fillAmmount * vlen);
                            this.datar[4 * this._unitLen + 8] = (vrange.y - this.fillAmmount * vlen);
                        }
                        else if (this._fillMethod == FillMethod.Radial_90) {
                            if (this.fillAmmount >= 0.5) {
                                var _fillRate = 2 * (1 - this.fillAmmount);
                                x0 = x0 - _fillRate * (x0 - x1);
                                y0 = y0 - _fillRate * (y0 - y1);
                                this.datar[0 * this._unitLen + 7] = urange.x + _fillRate * ulen;
                                this.datar[1 * this._unitLen + 8] = vrange.x;
                                this.datar[4 * this._unitLen + 8] = vrange.x;
                            }
                            else {
                                var _fillRate = 2 * (0.5 - this.fillAmmount);
                                x1 = x1 - _fillRate * (x1 - x3);
                                y1 = y1 - _fillRate * (y1 - y3);
                                x0 = x1;
                                y0 = y1;
                                this.datar[0 * this._unitLen + 8] = vrange.x + _fillRate * vlen;
                                this.datar[1 * this._unitLen + 8] = vrange.x + _fillRate * vlen;
                                this.datar[4 * this._unitLen + 8] = vrange.x + _fillRate * vlen;
                            }
                        }
                        this.updateQuadData(x0, y0, x1, y1, x2, y2, x3, y3);
                        break;
                    case FillMethod.Radial_180:
                        var tx = (x0 + x1) / 2;
                        var ty = (y0 + y1) / 2;
                        var bx = (x2 + x3) / 2;
                        var by = (y2 + y3) / 2;
                        if (this.fillAmmount >= 0.75) {
                            var _fillRate = 4 * (1 - this.fillAmmount);
                            x2 = x2 - _fillRate * (x2 - x0);
                            y2 = y2 - _fillRate * (y2 - y0);
                            this.datar[5 * this._unitLen + 8] = vrange.y - _fillRate * vlen;
                            this.datar[0 * this._unitLen + 7] = urange.x;
                            this.datar[3 * this._unitLen + 7] = urange.x;
                            this.datar[6 * this._unitLen + 7] = halfu;
                            this.datar[7 * this._unitLen + 8] = vrange.x;
                            this.datar[10 * this._unitLen + 8] = vrange.x;
                        }
                        else if (this.fillAmmount >= 0.5) {
                            var _fillRate = 4 * (0.75 - this.fillAmmount);
                            x0 = x0 - _fillRate * (x0 - tx);
                            y0 = y0 - _fillRate * (y0 - ty);
                            x2 = x0;
                            y2 = y0;
                            this.datar[0 * this._unitLen + 7] = urange.x + 0.5 * ulen * _fillRate;
                            this.datar[3 * this._unitLen + 7] = urange.x + 0.5 * ulen * _fillRate;
                            this.datar[6 * this._unitLen + 7] = halfu;
                            this.datar[7 * this._unitLen + 8] = vrange.x;
                            this.datar[10 * this._unitLen + 8] = vrange.x;
                        }
                        else if (this.fillAmmount >= 0.25) {
                            var _fillRate = 4 * (0.5 - this.fillAmmount);
                            tx = tx - _fillRate * (tx - x1);
                            ty = ty - _fillRate * (ty - y1);
                            x0 = tx;
                            y0 = ty;
                            x2 = x0;
                            y2 = y0;
                            this.datar[6 * this._unitLen + 7] = halfu + 0.5 * ulen * _fillRate;
                            this.datar[7 * this._unitLen + 8] = vrange.x;
                            this.datar[10 * this._unitLen + 8] = vrange.x;
                        }
                        else {
                            var _fillRate = 4 * (0.25 - this.fillAmmount);
                            x1 = x1 - _fillRate * (x1 - x3);
                            y1 = y1 - _fillRate * (y1 - y3);
                            tx = x1;
                            ty = y1;
                            x0 = tx;
                            y0 = ty;
                            x2 = x0;
                            y2 = y0;
                            this.datar[7 * this._unitLen + 8] = vrange.x + _fillRate * vlen;
                            this.datar[10 * this._unitLen + 8] = vrange.x + _fillRate * vlen;
                        }
                        this.updateQuadData(x0, y0, tx, ty, x2, y2, bx, by, 0, true);
                        this.updateQuadData(tx, ty, x1, y1, bx, by, x3, y3, 1);
                        break;
                    case FillMethod.Radial_360:
                        var t_x = (x0 + x1) / 2;
                        var t_y = (y0 + y1) / 2;
                        var l_x = (x0 + x2) / 2;
                        var l_y = (y0 + y2) / 2;
                        var b_x = (x2 + x3) / 2;
                        var b_y = (y2 + y3) / 2;
                        var r_x = (x1 + x3) / 2;
                        var r_y = (y1 + y3) / 2;
                        var c_x = (l_x + r_x) / 2;
                        var c_y = (l_y + r_y) / 2;
                        var b_x1 = b_x;
                        var b_y1 = b_y;
                        if (this.fillAmmount >= 0.875) {
                            var _fillRate = 8 * (1 - this.fillAmmount);
                            b_x = b_x - _fillRate * (b_x - x2);
                            b_y = b_y - _fillRate * (b_y - y2);
                            this.datar[17 * this._unitLen + 7] = halfu - 0.5 * _fillRate * ulen;
                            this.datar[14 * this._unitLen + 8] = vrange.y;
                            this.datar[15 * this._unitLen + 8] = vrange.y;
                            this.datar[5 * this._unitLen + 8] = halfv;
                            this.datar[0 * this._unitLen + 7] = urange.x;
                            this.datar[3 * this._unitLen + 7] = urange.x;
                            this.datar[6 * this._unitLen + 7] = halfu;
                            this.datar[7 * this._unitLen + 8] = vrange.x;
                            this.datar[10 * this._unitLen + 8] = vrange.x;
                            this.datar[19 * this._unitLen + 8] = halfv;
                            this.datar[20 * this._unitLen + 7] = urange.y;
                            this.datar[22 * this._unitLen + 7] = urange.y;
                        }
                        else if (this.fillAmmount >= 0.75) {
                            var _fillRate = 8 * (0.875 - this.fillAmmount);
                            x2 = x2 - _fillRate * (x2 - l_x);
                            y2 = y2 - _fillRate * (y2 - l_y);
                            b_x = x2;
                            b_y = y2;
                            this.datar[14 * this._unitLen + 8] = vrange.y - 0.5 * _fillRate * vlen;
                            this.datar[15 * this._unitLen + 8] = vrange.y - 0.5 * _fillRate * vlen;
                            this.datar[5 * this._unitLen + 8] = halfv;
                            this.datar[0 * this._unitLen + 7] = urange.x;
                            this.datar[3 * this._unitLen + 7] = urange.x;
                            this.datar[6 * this._unitLen + 7] = halfu;
                            this.datar[7 * this._unitLen + 8] = vrange.x;
                            this.datar[10 * this._unitLen + 8] = vrange.x;
                            this.datar[19 * this._unitLen + 8] = halfv;
                            this.datar[20 * this._unitLen + 7] = urange.y;
                            this.datar[22 * this._unitLen + 7] = urange.y;
                        }
                        else if (this.fillAmmount >= 0.625) {
                            var _fillRate = 8 * (0.75 - this.fillAmmount);
                            l_x = l_x - _fillRate * (l_x - x0);
                            l_y = l_y - _fillRate * (l_y - y0);
                            x2 = l_x;
                            y2 = l_y;
                            b_x = x2;
                            b_y = y2;
                            this.datar[5 * this._unitLen + 8] = halfv - 0.5 * _fillRate * vlen;
                            this.datar[0 * this._unitLen + 7] = urange.x;
                            this.datar[3 * this._unitLen + 7] = urange.x;
                            this.datar[6 * this._unitLen + 7] = halfu;
                            this.datar[7 * this._unitLen + 8] = vrange.x;
                            this.datar[10 * this._unitLen + 8] = vrange.x;
                            this.datar[19 * this._unitLen + 8] = halfv;
                            this.datar[20 * this._unitLen + 7] = urange.y;
                            this.datar[22 * this._unitLen + 7] = urange.y;
                        }
                        else if (this.fillAmmount >= 0.5) {
                            var _fillRate = 8 * (0.625 - this.fillAmmount);
                            x0 = x0 - _fillRate * (x0 - t_x);
                            y0 = y0 - _fillRate * (y0 - t_y);
                            l_x = x0;
                            l_y = y0;
                            x2 = l_x;
                            y2 = l_y;
                            b_x = x2;
                            b_y = y2;
                            this.datar[0 * this._unitLen + 7] = urange.x + 0.5 * _fillRate * ulen;
                            this.datar[3 * this._unitLen + 7] = urange.x + 0.5 * _fillRate * ulen;
                            this.datar[6 * this._unitLen + 7] = halfu;
                            this.datar[7 * this._unitLen + 8] = vrange.x;
                            this.datar[10 * this._unitLen + 8] = vrange.x;
                            this.datar[19 * this._unitLen + 8] = halfv;
                            this.datar[20 * this._unitLen + 7] = urange.y;
                            this.datar[22 * this._unitLen + 7] = urange.y;
                        }
                        else if (this.fillAmmount >= 0.375) {
                            var _fillRate = 8 * (0.5 - this.fillAmmount);
                            t_x = t_x - _fillRate * (t_x - x1);
                            t_y = t_y - _fillRate * (t_y - y1);
                            x0 = t_x;
                            y0 = t_y;
                            l_x = x0;
                            l_y = y0;
                            x2 = l_x;
                            y2 = l_y;
                            b_x = x2;
                            b_y = y2;
                            this.datar[6 * this._unitLen + 7] = halfu + 0.5 * _fillRate * ulen;
                            this.datar[7 * this._unitLen + 8] = vrange.x;
                            this.datar[10 * this._unitLen + 8] = vrange.x;
                            this.datar[19 * this._unitLen + 8] = halfv;
                            this.datar[20 * this._unitLen + 7] = urange.y;
                            this.datar[22 * this._unitLen + 7] = urange.y;
                        }
                        else if (this.fillAmmount >= 0.25) {
                            var _fillRate = 8 * (0.375 - this.fillAmmount);
                            x1 = x1 - _fillRate * (x1 - r_x);
                            y1 = y1 - _fillRate * (y1 - r_y);
                            t_x = x1;
                            t_y = y1;
                            x0 = t_x;
                            y0 = t_y;
                            l_x = x0;
                            l_y = y0;
                            x2 = l_x;
                            y2 = l_y;
                            b_x = x2;
                            b_y = y2;
                            this.datar[7 * this._unitLen + 8] = vrange.x + 0.5 * _fillRate * vlen;
                            this.datar[10 * this._unitLen + 8] = vrange.x + 0.5 * _fillRate * vlen;
                            this.datar[19 * this._unitLen + 8] = halfv;
                            this.datar[20 * this._unitLen + 7] = urange.y;
                            this.datar[22 * this._unitLen + 7] = urange.y;
                        }
                        else if (this.fillAmmount >= 0.125) {
                            var _fillRate = 8 * (0.25 - this.fillAmmount);
                            r_x = r_x - _fillRate * (r_x - x3);
                            r_y = r_y - _fillRate * (r_y - y3);
                            x1 = r_x;
                            y1 = r_y;
                            t_x = x1;
                            t_y = y1;
                            x0 = t_x;
                            y0 = t_y;
                            l_x = x0;
                            l_y = y0;
                            x2 = l_x;
                            y2 = l_y;
                            b_x = x2;
                            b_y = y2;
                            this.datar[19 * this._unitLen + 8] = halfv + 0.5 * _fillRate * vlen;
                            this.datar[20 * this._unitLen + 7] = urange.y;
                            this.datar[22 * this._unitLen + 7] = urange.y;
                        }
                        else {
                            var _fillRate = 8 * (0.125 - this.fillAmmount);
                            x3 = x3 - _fillRate * (x3 - b_x);
                            y3 = y3 - _fillRate * (y3 - b_y);
                            r_x = x3;
                            r_y = y3;
                            x1 = r_x;
                            y1 = r_y;
                            t_x = x1;
                            t_y = y1;
                            x0 = t_x;
                            y0 = t_y;
                            l_x = x0;
                            l_y = y0;
                            x2 = l_x;
                            y2 = l_y;
                            b_x = x2;
                            b_y = y2;
                            this.datar[20 * this._unitLen + 7] = urange.y - 0.5 * _fillRate * ulen;
                            this.datar[22 * this._unitLen + 7] = urange.y - 0.5 * _fillRate * ulen;
                        }
                        this.updateQuadData(x0, y0, t_x, t_y, l_x, l_y, c_x, c_y, 0, true);
                        this.updateQuadData(t_x, t_y, x1, y1, c_x, c_y, r_x, r_y, 1);
                        this.updateQuadData(l_x, l_y, c_x, c_y, x2, y2, b_x, b_y, 2);
                        this.updateQuadData(c_x, c_y, r_x, r_y, b_x1, b_y1, x3, y3, 3, true);
                        break;
                }
            };
            /**
             * @private
             * 更新瓦片数据。这里只是没有border的瓦片。如果有border就要复杂很多
             */
            image2D.prototype.updateTiledData = function (x0, y0, x1, y1, x2, y2, x3, y3) {
                var rect = this._sprite.rect;
                var border = this._imageBorder;
                var urange = this._sprite.urange;
                var vrange = this._sprite.vrange;
                var ulen = urange.y - urange.x;
                var vlen = vrange.y - vrange.x;
                var xlen = x1 - x0;
                var ylen = y2 - y0;
                var _ul = this.transform.width / rect.w;
                var _vl = this.transform.height / rect.h;
                var inv_ul = 1 / _ul;
                var inv_vl = 1 / _vl;
                var dindex = 0;
                //创建完整的
                for (var i = 0; i < _vl - 1; i++) {
                    for (var j = 0; j < _ul - 1; j++) {
                        var tdata = [
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                            0, 0, 0, 1, 1, 1, 1, urange.y, vrange.y, 1, 1, 1, 1
                        ];
                        this.datar = this.datar.concat(tdata);
                        var tx0 = x0 + inv_ul * xlen * j;
                        var ty0 = y0 + inv_vl * ylen * i;
                        var tx1 = x0 + inv_ul * xlen * (j + 1);
                        var ty1 = y0 + inv_vl * ylen * i;
                        var tx2 = x0 + inv_ul * xlen * j;
                        var ty2 = y0 + inv_vl * ylen * (i + 1);
                        var tx3 = x0 + inv_ul * xlen * (j + 1);
                        var ty3 = y0 + inv_vl * ylen * (i + 1);
                        this.updateQuadData(tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, dindex);
                        dindex++;
                    }
                }
                //最后一行
                var intvl = Math.ceil(_vl) - 1;
                var tvl = _vl - Math.ceil(_vl) + 1;
                for (var j = 0; j < _ul - 1; j++) {
                    var tdata = [
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x + tvl * vlen, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x + tvl * vlen, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.y, vrange.x + tvl * vlen, 1, 1, 1, 1
                    ];
                    this.datar = this.datar.concat(tdata);
                    var tx0 = x0 + inv_ul * xlen * j;
                    var ty0 = y0 + inv_vl * ylen * intvl;
                    var tx1 = x0 + inv_ul * xlen * (j + 1);
                    var ty1 = y0 + inv_vl * ylen * intvl;
                    var tx2 = x0 + inv_ul * xlen * j;
                    var ty2 = y0 + inv_vl * ylen * (intvl + tvl);
                    var tx3 = x0 + inv_ul * xlen * (j + 1);
                    var ty3 = y0 + inv_vl * ylen * (intvl + tvl);
                    this.updateQuadData(tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, dindex);
                    dindex++;
                }
                //最后一列
                var intul = Math.ceil(_ul) - 1;
                var tul = _ul - Math.ceil(_ul) + 1;
                for (var i = 0; i < _vl - 1; i++) {
                    var tdata = [
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x + tul * ulen, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.y, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x + tul * ulen, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x + tul * ulen, vrange.y, 1, 1, 1, 1
                    ];
                    this.datar = this.datar.concat(tdata);
                    var tx0 = x0 + inv_ul * xlen * intul;
                    var ty0 = y0 + inv_vl * ylen * i;
                    var tx1 = x0 + inv_ul * xlen * (intul + tul);
                    var ty1 = y0 + inv_vl * ylen * i;
                    var tx2 = x0 + inv_ul * xlen * intul;
                    var ty2 = y0 + inv_vl * ylen * (i + 1);
                    var tx3 = x0 + inv_ul * xlen * (intul + tul);
                    var ty3 = y0 + inv_vl * ylen * (i + 1);
                    this.updateQuadData(tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, dindex);
                    dindex++;
                }
                //最后一个
                {
                    var tdata = [
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x + tul * ulen, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x + tvl * vlen, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x, vrange.x + tvl * vlen, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x + tul * ulen, vrange.x, 1, 1, 1, 1,
                        0, 0, 0, 1, 1, 1, 1, urange.x + tul * ulen, vrange.x + tvl * vlen, 1, 1, 1, 1
                    ];
                    this.datar = this.datar.concat(tdata);
                    var tx0 = x0 + inv_ul * xlen * intul;
                    var ty0 = y0 + inv_vl * ylen * intvl;
                    var tx1 = x0 + inv_ul * xlen * (intul + tul);
                    var ty1 = y0 + inv_vl * ylen * intvl;
                    var tx2 = x0 + inv_ul * xlen * intul;
                    var ty2 = y0 + inv_vl * ylen * (intvl + tvl);
                    var tx3 = x0 + inv_ul * xlen * (intul + tul);
                    var ty3 = y0 + inv_vl * ylen * (intvl + tvl);
                    this.updateQuadData(tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, dindex);
                    dindex++;
                }
            };
            var image2D_1;
            image2D.ClassName = "image2D";
            image2D.defUIShader = "shader/defui"; //非mask 使用shader
            image2D.defMaskUIShader = "shader/defmaskui"; //mask 使用shader
            __decorate([
                m4m.reflect.Field("color"),
                m4m.reflect.UIStyle("color"),
                __metadata("design:type", m4m.math.color)
            ], image2D.prototype, "color", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                m4m.reflect.UIStyle("enum"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], image2D.prototype, "imageType", null);
            __decorate([
                m4m.reflect.Field("number"),
                m4m.reflect.UIStyle("enum"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], image2D.prototype, "fillMethod", null);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], image2D.prototype, "fillAmmount", null);
            __decorate([
                m4m.reflect.Field("string"),
                __metadata("design:type", String)
            ], image2D.prototype, "_spriteName", void 0);
            __decorate([
                m4m.reflect.Field("border"),
                __metadata("design:type", Object)
            ], image2D.prototype, "_imageBorder", void 0);
            image2D = image2D_1 = __decorate([
                m4m.reflect.node2DComponent,
                m4m.reflect.nodeRender,
                __metadata("design:paramtypes", [])
            ], image2D);
            return image2D;
        }());
        framework.image2D = image2D;
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 贴图的显示方式
         * @version m4m 1.0
         */
        var ImageType;
        (function (ImageType) {
            ImageType[ImageType["Simple"] = 0] = "Simple";
            ImageType[ImageType["Sliced"] = 1] = "Sliced";
            ImageType[ImageType["Tiled"] = 2] = "Tiled";
            ImageType[ImageType["Filled"] = 3] = "Filled"; //填充
        })(ImageType = framework.ImageType || (framework.ImageType = {}));
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 更新瓦片数据。这里只是没有border的瓦片。如果有border就要复杂很多
         * @version m4m 1.0
         */
        var FillMethod;
        (function (FillMethod) {
            FillMethod[FillMethod["Horizontal"] = 0] = "Horizontal";
            FillMethod[FillMethod["Vertical"] = 1] = "Vertical";
            FillMethod[FillMethod["Radial_90"] = 2] = "Radial_90";
            FillMethod[FillMethod["Radial_180"] = 3] = "Radial_180";
            FillMethod[FillMethod["Radial_360"] = 4] = "Radial_360";
        })(FillMethod = framework.FillMethod || (framework.FillMethod = {}));
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../../io/reflect.ts" />
var m4m;
/// <reference path="../../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 2d文本输入框
         * @version m4m 1.0
         */
        var inputField = /** @class */ (function () {
            function inputField() {
                this.customRegexStr = "";
                this.beFocus = false;
                this._text = "";
                this._lastAddRTextFID = 0;
                this._inputStop = false;
                this._eventsHandle = {};
                this._charlimit = 0;
                this._lineType = lineType.SingleLine;
                this._contentType = contentType.None;
            }
            inputField_1 = inputField;
            Object.defineProperty(inputField.prototype, "frameImage", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 底框显示图像
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._frameImage;
                },
                set: function (frameImg) {
                    this._frameImage = frameImg;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(inputField.prototype, "selectionStart", {
                /** 选择区域的开始位置 */
                get: function () {
                    if (this.inputElement)
                        return this.inputElement.selectionStart;
                    return 0;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(inputField.prototype, "isFocus", {
                /** 输入框是否是聚焦的 */
                get: function () { return this.beFocus; },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(inputField.prototype, "selectionEnd", {
                /** 选择区域的结束位置 */
                get: function () {
                    if (this.inputElement)
                        return this.inputElement.selectionEnd;
                    return 0;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(inputField.prototype, "selectionDirection", {
                /** 选择区域的方向 ， forward ：从前往后 backward ：从后往前 */
                get: function () {
                    if (this.inputElement)
                        return this.inputElement.selectionDirection;
                    return "forward";
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(inputField.prototype, "text", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 文字内容
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._text;
                },
                set: function (val) {
                    if (val == this._text)
                        return;
                    val = val == null ? "" : val;
                    this._text = val;
                    if (this.inputElement)
                        this.inputElement.value = val;
                    if (this._textLable)
                        this._textLable.text = val;
                    if (this.beFocus) {
                        this.showEle();
                    }
                    else {
                        this.showLable();
                    }
                },
                enumerable: false,
                configurable: true
            });
            /**
             * 清除输入文本
             */
            inputField.prototype.clearText = function () {
                this._text = "";
                this.inputElement.value = this._text;
                this._textLable.text = this._text;
            };
            Object.defineProperty(inputField.prototype, "characterLimit", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 限制输入字符数
                 * @version m4m 1.0
                 */
                get: function () { return this._charlimit; },
                set: function (charlimit) {
                    this._charlimit = parseInt("".concat(charlimit));
                    this._charlimit = isNaN(this._charlimit) || this._charlimit < 0 ? 0 : this._charlimit;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(inputField.prototype, "LineType", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 文本行格式
                 * @version m4m 1.0
                 */
                get: function () { return this._lineType; },
                set: function (_lineType) {
                    if (this._lineType == _lineType)
                        return;
                    var newIsSin = _lineType == lineType.SingleLine;
                    var oldIsSin = this._lineType == lineType.SingleLine;
                    this._lineType = _lineType;
                    if (newIsSin != oldIsSin && this.inputElement) {
                        var oldVal = this.inputElement.value;
                        this.removeEle();
                        this.initEle();
                        this.inputElement.value = oldVal;
                    }
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(inputField.prototype, "ContentType", {
                /**
                * @public
                * @language zh_CN
                * @classdesc
                * 文本内容格式
                * @version m4m 1.0
                */
                get: function () { return this._contentType; },
                set: function (contentType) {
                    this._contentType = contentType;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(inputField.prototype, "TextLabel", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 输入内容label
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._textLable;
                },
                set: function (textLabel) {
                    if (textLabel == this._textLable)
                        return;
                    if (textLabel) {
                        textLabel.text = this._text;
                    }
                    this._textLable = textLabel;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(inputField.prototype, "PlaceholderLabel", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 输入内容label
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._placeholderLabel;
                },
                set: function (placeholderLabel) {
                    if (placeholderLabel == this._placeholderLabel)
                        return;
                    if (placeholderLabel.text == null || placeholderLabel.text == "")
                        placeholderLabel.text = "Enter Text...";
                    this._placeholderLabel = placeholderLabel;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * 刷新布局
             */
            inputField.prototype.layoutRefresh = function () {
                this.inputElmLayout();
                if (this._placeholderLabel) {
                    if (this._placeholderLabel.transform.width != this.transform.width)
                        this._placeholderLabel.transform.width = this.transform.width;
                    if (this._placeholderLabel.transform.height != this.transform.height)
                        this._placeholderLabel.transform.height = this.transform.height;
                }
                if (this._textLable) {
                    if (this._textLable.transform.width != this.transform.width)
                        this._textLable.transform.width = this.transform.width;
                    if (this._textLable.transform.height != this.transform.height)
                        this._textLable.transform.height = this.transform.height;
                    // //溢出模式设置
                    // let isSingleLine = this._lineType == lineType.SingleLine;
                    // this._textLable.verticalOverflow = !isSingleLine;
                    // this._textLable.horizontalOverflow = isSingleLine;
                }
            };
            /**设置 通用 样式 */
            inputField.prototype.setStyleEle = function (Ele) {
                Ele.style.outline = "medium";
                Ele.style.background = "transparent";
                Ele.style.border = "0";
                Ele.style.padding = "0";
                Ele.style.display = "none";
            };
            inputField.prototype.createInputEle = function () {
                this.inputElement = document.createElement("Input");
                var inpEle = this.inputElement;
                this.setStyleEle(inpEle);
                inpEle.type = "text";
                inpEle.style["-moz-appearance"] = 'textfield';
            };
            inputField.prototype.createTextAreaEle = function () {
                this.inputElement = document.createElement("textarea");
                var inpEle = this.inputElement;
                this.setStyleEle(inpEle);
                inpEle.style.resize = "none";
                inpEle.style.overflowY = 'scroll'; //Y 轴滚动条
                // inpEle.style.scrollbarGutter = "stable";
            };
            /** 初始化 html 元素 */
            inputField.prototype.initEle = function () {
                var _this = this;
                //ios fix thing
                this.ckIsMobile();
                //create Ele
                if (this._lineType == lineType.SingleLine) {
                    this.createInputEle();
                }
                else {
                    this.createTextAreaEle();
                }
                var inpEle = this.inputElement;
                //attchNode
                inpEle.tabIndex = 0;
                inpEle.value = this._text;
                // inpEle.autofocus = true;
                if (this.transform.canvas.scene) {
                    var htmlCanv = this.transform.canvas.scene.webgl.canvas;
                    if (htmlCanv)
                        htmlCanv.parentElement.appendChild(inpEle);
                }
                var eventsH = this._eventsHandle;
                //事件 handle 绑定函数
                eventsH.compositionstart = function (e) {
                    _this._inputStop = true;
                };
                eventsH.compositionend = function (e) {
                    _this._inputStop = false;
                    _this.textRefresh();
                };
                eventsH.blur = function (e) {
                    if (inputField_1._isMobile && _this._inputStop) {
                        if (eventsH.compositionend)
                            eventsH.compositionend();
                    }
                    _this.beFocus = false;
                    if (_this.onblur)
                        _this.onblur();
                };
                eventsH.focus = function (e) {
                    _this.beFocus = true;
                    if (_this.onfocus)
                        _this.onfocus();
                };
                eventsH.mouseout = function (e) {
                    if (_this.onmouseout)
                        _this.onmouseout();
                };
                eventsH.keydown = function (ev) {
                    if (_this._inputStop)
                        return;
                    if (ev.code == "Enter" || ev.keyCode == 13) {
                        var needSubmit = _this._lineType != lineType.MultiLine_NewLine;
                        if (ev.ctrlKey)
                            needSubmit = true; //ctr + Enter = 强制提交
                        if (needSubmit) {
                            // inpEle.blur();
                            _this.setFocus(false);
                            if (_this.onTextSubmit)
                                _this.onTextSubmit(_this._text);
                        }
                    }
                    // console.error(`code:${ev.code}`);
                };
                //reg all event
                for (var key in eventsH) {
                    var fun = eventsH[key];
                    inpEle.addEventListener(key, fun);
                }
                this.inputElmLayout();
            };
            inputField.prototype.updateEleStyle = function () {
                var inpEle = this.inputElement;
                if (!inpEle)
                    return;
                //
                if (this._textLable) {
                    var fontSize = this._textLable.fontsize / window.devicePixelRatio;
                    inpEle.style.fontSize = "".concat(fontSize, "px");
                    var cssColor = m4m.math.colorToCSS(this._textLable.color, false);
                    inpEle.style.color = cssColor;
                    // let _font = this._textLable.font;
                    // inpEle.style.fontFamily = 
                    switch (this._textLable.horizontalType) {
                        case framework.HorizontalType.Left:
                            inpEle.style.textAlign = "left";
                            break;
                        case framework.HorizontalType.Center:
                            inpEle.style.textAlign = "center";
                            break;
                        case framework.HorizontalType.Right:
                            inpEle.style.textAlign = "right";
                            break;
                    }
                }
                var placeholderStr = "Enter Text...";
                if (this._placeholderLabel)
                    placeholderStr = this._placeholderLabel.text;
                inpEle.placeholder = placeholderStr;
            };
            inputField.prototype.removeEle = function () {
                var inpEle = this.inputElement;
                if (!inpEle)
                    return;
                //unreg all event
                for (var key in this._eventsHandle) {
                    var fun = this._eventsHandle[key];
                    inpEle.removeEventListener(key, fun);
                }
                //remove
                inpEle.disabled = false;
                inpEle.value = "";
                inpEle.style.display = "none";
                if (inpEle.parentElement)
                    inpEle.parentElement.removeChild(inpEle);
                this.inputElement = null;
            };
            /**
             * @private
             */
            inputField.prototype.start = function () {
                this.initEle();
            };
            inputField.prototype.ckIsMobile = function () {
                if (inputField_1._isMobile == null) {
                    if (navigator && navigator.userAgent) {
                        var u = navigator.userAgent.toLowerCase();
                        inputField_1._isMobile = /mobile|iphone|ipad|android/.test(u);
                    }
                    else {
                        inputField_1._isMobile = false;
                    }
                }
            };
            inputField.prototype.onPlay = function () {
            };
            /**
            * @private
            * inputElement 位置、宽高刷新
            */
            inputField.prototype.inputElmLayout = function () {
                if (this.inputElement == null)
                    return;
                var pos = this.transform.getWorldTranslate();
                var cssStyle = this.inputElement.style;
                var p = this.transform.pivot;
                var w = this.transform.width;
                var h = this.transform.height;
                var realX = pos.x - p.x * w;
                var realY = pos.y - p.y * h;
                if (realX + "px" == cssStyle.left && realY + "px" == cssStyle.top && w + "px" == cssStyle.width && h + "px" == cssStyle.height)
                    return;
                var scalex = framework.sceneMgr.app.canvasClientWidth / this.transform.canvas.pixelWidth;
                var scaley = framework.sceneMgr.app.canvasClientHeight / this.transform.canvas.pixelHeight;
                cssStyle.position = "absolute";
                cssStyle.left = realX * scalex + "px";
                cssStyle.top = realY * scaley + "px";
                cssStyle.width = w * scalex + "px";
                cssStyle.height = h * scaley + "px";
            };
            /**
             * @private
             * 输入文本刷新
             */
            inputField.prototype.textRefresh = function () {
                if (this._inputStop || !this.inputElement)
                    return;
                var realMaxLen = this._charlimit;
                if (realMaxLen <= 0) {
                    realMaxLen = -1;
                }
                if (this.inputElement.maxLength != realMaxLen) {
                    //刷输入限制
                    this.inputElement.maxLength = realMaxLen;
                    return;
                }
                if (!this._textLable || !this._placeholderLabel || this._text == this.inputElement.value)
                    return;
                this._text = this.inputElement.value;
                if (this._contentType == contentType.Custom) {
                    if (this.customRegexStr != null && this.customRegexStr != "")
                        this._text = this._text.replace(this.customRegexStr, '');
                }
                else {
                    if (this._contentType == contentType.None) {
                    }
                    //英文字母，数字，汉字，下划线
                    else if ((this._contentType & contentType.Number) && (this._contentType & contentType.Word) && (this._contentType & contentType.ChineseCharacter) && (this._contentType & contentType.Underline)) {
                        this._text = this._text.replace(/^[\u4E00-\u9FA5a-zA-Z0-9_]{3,20}$/ig, '');
                    }
                    //英文字母，数字，下划线
                    else if ((this._contentType & contentType.Number) && (this._contentType & contentType.Word) && (this._contentType & contentType.Underline)) {
                        this._text = this._text.replace(/[^\w\.\/]/ig, '');
                    }
                    //数字，字符
                    else if ((this._contentType & contentType.Number) && (this._contentType & contentType.Word)) {
                        this._text = this._text.replace(/[^(A-Za-z0-9)]/ig, '');
                    }
                    //汉字，字符
                    else if ((this._contentType & contentType.ChineseCharacter) && (this._contentType & contentType.Word)) {
                        this._text = this._text.replace(/[^(A-Za-z\u4E00-\u9FA5)]/ig, '');
                    }
                    //数字
                    else if (this._contentType == contentType.Number) {
                        this._text = this._text.replace(/\D+/g, '');
                    }
                    //汉字
                    else if (this._contentType == contentType.ChineseCharacter) {
                        this._text = this._text.replace(/[^\u4E00-\u9FA5]/g, '');
                    }
                }
                //记录过滤 后的text
                this.inputElement.value = this._text;
                if (this._textLable) {
                    this._textLable.text = this._text;
                }
            };
            /**
             * @private
             */
            inputField.prototype.update = function (delta) {
                this.layoutRefresh();
                this.textRefresh();
            };
            /**
             * @private
             */
            inputField.prototype.remove = function () {
                if (this._textLable)
                    this._textLable.onAddRendererText = null;
                this._placeholderLabel = null;
                this._textLable = null;
                this.transform = null;
                this._frameImage = null;
                this.removeEle();
                this.onTextSubmit = null;
                this.onblur = null;
                this.onfocus = null;
                this.onmouseout = null;
            };
            /**
             * @private
             */
            inputField.prototype.onPointEvent = function (canvas, ev, oncap) {
                // if(this._isIos) return;
                if (oncap == false) {
                    if (ev.type != m4m.event.PointEventEnum.PointDown)
                        return;
                    var b = this.transform.ContainsCanvasPoint(new m4m.math.vector2(ev.x, ev.y));
                    this.setFocus(b);
                }
            };
            /**
             * 设置 输入聚焦状态
             * @param isFocus 是否聚焦
             */
            inputField.prototype.setFocus = function (isFocus) {
                if (isFocus) {
                    this.showEle();
                    if (!this.beFocus) {
                        this.inputElement.focus();
                    }
                }
                else {
                    if (this.beFocus)
                        this.inputElement.blur();
                    this.showLable();
                }
            };
            /** 显示 标签 */
            inputField.prototype.showLable = function () {
                if (this.inputElement)
                    this.inputElement.style.display = "none";
                if (this._textLable) {
                    this._textLable.transform.visible = false;
                    if (this._placeholderLabel)
                        this._placeholderLabel.transform.visible = false;
                    if (this._textLable.text != "") {
                        this._textLable.transform.visible = true;
                    }
                    else {
                        if (this._placeholderLabel)
                            this._placeholderLabel.transform.visible = true;
                    }
                }
            };
            /** 显示 html组件 */
            inputField.prototype.showEle = function () {
                //更新
                this.updateEleStyle();
                if (this.inputElement)
                    this.inputElement.style.display = ""; //显示html元素对象
                if (this._textLable)
                    this._textLable.transform.visible = false;
                if (this._placeholderLabel)
                    this._placeholderLabel.transform.visible = false;
            };
            var inputField_1;
            inputField.ClassName = "inputField";
            inputField.helpV2 = new m4m.math.vector2();
            __decorate([
                m4m.reflect.Field("reference", null, "image2D"),
                __metadata("design:type", framework.image2D),
                __metadata("design:paramtypes", [framework.image2D])
            ], inputField.prototype, "frameImage", null);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], inputField.prototype, "characterLimit", null);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], inputField.prototype, "LineType", null);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], inputField.prototype, "ContentType", null);
            __decorate([
                m4m.reflect.Field("reference", null, "label"),
                __metadata("design:type", framework.label),
                __metadata("design:paramtypes", [framework.label])
            ], inputField.prototype, "TextLabel", null);
            __decorate([
                m4m.reflect.Field("reference", null, "label"),
                __metadata("design:type", framework.label),
                __metadata("design:paramtypes", [framework.label])
            ], inputField.prototype, "PlaceholderLabel", null);
            inputField = inputField_1 = __decorate([
                m4m.reflect.node2DComponent
            ], inputField);
            return inputField;
        }());
        framework.inputField = inputField;
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 文本行显示方式
         * @version m4m 1.0
         */
        var lineType;
        (function (lineType) {
            /** 单行模式 */
            lineType[lineType["SingleLine"] = 0] = "SingleLine";
            /** 多行模式 */
            lineType[lineType["MultiLine"] = 1] = "MultiLine";
            /** 多行模式 (输入回车键换行处理)*/
            lineType[lineType["MultiLine_NewLine"] = 2] = "MultiLine_NewLine";
        })(lineType = framework.lineType || (framework.lineType = {}));
        /**
         * @language zh_CN
         * @classdesc
         * 文本内容类型
         * @version m4m 1.0
         */
        var contentType;
        (function (contentType) {
            contentType[contentType["None"] = 0] = "None";
            /** 数字*/
            contentType[contentType["Number"] = 1] = "Number";
            /** 字母 */
            contentType[contentType["Word"] = 2] = "Word";
            /** 下划线 */
            contentType[contentType["Underline"] = 4] = "Underline";
            /**中文字符 */
            contentType[contentType["ChineseCharacter"] = 8] = "ChineseCharacter";
            /**没有中文字符 */
            contentType[contentType["NoneChineseCharacter"] = 16] = "NoneChineseCharacter";
            /**邮件 */
            contentType[contentType["Email"] = 32] = "Email";
            /**密码 */
            contentType[contentType["PassWord"] = 64] = "PassWord";
            /** 自定义 */
            contentType[contentType["Custom"] = 128] = "Custom";
        })(contentType = framework.contentType || (framework.contentType = {}));
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../../io/reflect.ts" />
var m4m;
/// <reference path="../../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 2d文本组件
         * @version m4m 1.0
         */
        var label = /** @class */ (function () {
            function label() {
                /**字段 用于快速判断实例是否是label */
                this.isLabel = true;
                /** 有图片字符需要渲染 */
                this._hasImageChar = false;
                this._text = "";
                this.needRefreshFont = false;
                this.needRefreshAtlas = false;
                this._fontName = "defFont.font.json";
                this._fontsize = 14;
                this._linespace = 1;
                this._horizontalType = HorizontalType.Left;
                this._verticalType = VerticalType.Center;
                this._horizontalOverflow = false;
                this._verticalOverflow = false;
                this.lastStr = "";
                this.data_begin = new m4m.math.vector2(0, 0);
                this._lastBegin = new m4m.math.vector2(0, 0);
                /** 文本顶点数据 */
                this.datar = [];
                /** 字符图 顶点数据 */
                this.imgDatar = [];
                this._color = new m4m.math.color(1, 1, 1, 1);
                this._color2 = new m4m.math.color(0, 0, 0.5, 0.5);
                this._outlineWidth = 0.75;
                this._richText = false;
                this._imageTextAtlasName = "";
                /** 富文本 块列表 */
                this._richTextBlocks = [];
                /** 纯文本默认 块列表 */
                this._defTextBlocks = [{ text: "", opts: null }];
                /**富文本 脏标记  */
                this._drityRich = true;
                this._CustomShaderName = ""; //自定义UIshader
                this._dirtyData = true;
                this.min_x = Number.MAX_VALUE;
                this.max_x = Number.MAX_VALUE * -1;
                this.min_y = Number.MAX_VALUE;
                this.max_y = Number.MAX_VALUE * -1;
            }
            label_1 = label;
            Object.defineProperty(label.prototype, "text", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 文字内容
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._text;
                },
                set: function (text) {
                    text = text == null ? "" : text;
                    var hasChange = text != this._text;
                    this._text = text;
                    //设置缓存长度
                    // this.initdater(this._text.length);
                    this._dirtyData = true;
                    this._drityRich = hasChange;
                },
                enumerable: false,
                configurable: true
            });
            label.prototype.initdater = function (textLen, datar) {
                var size = 6 * 13;
                var cachelen = size * textLen;
                //少了补充
                while (datar.length < cachelen) { // {pos,color1,uv,color2}
                    datar.push(0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
                }
                //多了弹出
                while (datar.length > cachelen) {
                    // datar.pop();
                    datar.splice(datar.length - size, size);
                }
            };
            Object.defineProperty(label.prototype, "font", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 字体
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._font;
                },
                set: function (font) {
                    if (font == this._font)
                        return;
                    this.needRefreshFont = true;
                    if (this._font) {
                        this._font.unuse();
                    }
                    this._font = font;
                    if (font) {
                        this._font.use();
                        this._fontName = this._font.getName();
                    }
                    else {
                        this._fontName = "";
                    }
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(label.prototype, "fontsize", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 字体大小
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._fontsize;
                },
                set: function (size) {
                    if (this._fontsize == size)
                        return;
                    this._fontsize = size;
                    this._dirtyData = this._drityRich = true;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(label.prototype, "linespace", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 行高
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._linespace; //fontsize的倍数
                },
                set: function (val) {
                    if (this._linespace == val)
                        return;
                    this._linespace = val;
                    this._dirtyData = this._drityRich = true;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(label.prototype, "horizontalType", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 水平排列方式
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._horizontalType;
                },
                set: function (val) {
                    if (this._horizontalType == val)
                        return;
                    this._horizontalType = val;
                    this._dirtyData = this._drityRich = true;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(label.prototype, "verticalType", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 垂直排列方式
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._verticalType;
                },
                set: function (val) {
                    if (this._verticalType == val)
                        return;
                    this._verticalType = val;
                    this._dirtyData = this._drityRich = true;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(label.prototype, "horizontalOverflow", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 是否横向溢出
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._horizontalOverflow;
                },
                set: function (val) {
                    if (this._horizontalOverflow == val)
                        return;
                    this._horizontalOverflow = val;
                    this._dirtyData = this._drityRich = true;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(label.prototype, "verticalOverflow", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 是否竖向溢出
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._verticalOverflow;
                },
                set: function (val) {
                    if (this._verticalOverflow == val)
                        return;
                    this._verticalOverflow = val;
                    this._dirtyData = this._drityRich = true;
                },
                enumerable: false,
                configurable: true
            });
            /** 检查文字,是否需要 动态添加 */
            label.prototype.chackText = function (str) {
                var _font = this.font;
                if (!_font || !str || str == this.lastStr)
                    return;
                var missingStr = "";
                for (var i = 0, len = this._text.length; i < len; i++) {
                    var c = this._text.charAt(i);
                    if (_font.cmap[c])
                        continue;
                    missingStr += c;
                }
                if (label_1.onTryExpandTexts)
                    label_1.onTryExpandTexts(missingStr);
                this.lastStr = str;
            };
            /**
             * @private
             */
            label.prototype.updateData = function (_font) {
                if (label_1.onTryExpandTexts) {
                    this.chackText(this._text);
                } //检查 依赖文本(辅助 自动填充字体)
                //set data
                var b = this._defTextBlocks[0];
                b.text = this._text;
                this.setDataByBlock(_font, this._defTextBlocks);
            };
            // _updateData(_font: m4m.framework.font)
            // {
            //     if (label.onTryExpandTexts) { this.chackText(this._text); } //检查 依赖文本(辅助 自动填充字体)
            //     // this.dirtyData = false;
            //     //字符的 label尺寸 与 像素尺寸 的比值。
            //     let rate = this._fontsize / _font.pointSize;
            //     //矩阵信息
            //     let m = this.transform.getWorldMatrix();
            //     let m11 = m.rawData[0];
            //     let m12 = m.rawData[2];
            //     let m21 = m.rawData[1];
            //     let m22 = m.rawData[3];
            //     //顶点开始位置
            //     let bx = this.data_begin.x;
            //     let by = this.data_begin.y;
            //     //计算出排列数据
            //     let txadd = 0;                                  //字符x偏移量
            //     let tyadd = 0;                                  //字符y偏移量
            //     let lineEndIndexs: number[] = [];              //每行结束位置的索引列表
            //     let lineWidths: number[] = [];                 //每行字符宽度之和列表
            //     let contrast_w = this.horizontalOverflow ? Number.MAX_VALUE : this.transform.width;     //最大宽度限制
            //     let contrast_h = this.verticalOverflow ? Number.MAX_VALUE : this.transform.height;      //最大高度限制
            //     let lineHeight = this._fontsize * this.linespace;                                       //一行的高度
            //     let renderTextCount = 0;
            //     tyadd += lineHeight;
            //     let i = 0;
            //     for (let len = this._text.length; i < len; i++)
            //     {
            //         let c = this._text.charAt(i);
            //         let isNewline = c == `\n`; //换行符
            //         let cinfo = _font.cmap[c];
            //         if (!isNewline && cinfo == undefined) { continue; }
            //         let cWidth = cinfo ? cinfo.xAddvance * rate : 0;                 //字符的宽度
            //         //需要换行了
            //         if (isNewline || txadd + cWidth > contrast_w)
            //         {
            //             if (tyadd + lineHeight > contrast_h) { break; }             //高度超限制了
            //             lineEndIndexs.push(i);
            //             lineWidths.push(this.transform.width - txadd);
            //             txadd = 0;                                                  //文本x偏移置0
            //             tyadd += lineHeight;                                        //文本y偏移增加
            //         }
            //         if (cinfo)
            //         {
            //             txadd += cWidth;                                     //文本x偏移增加
            //             renderTextCount++;
            //         }
            //     }
            //     //最后的字符存入
            //     lineEndIndexs.push(i);
            //     lineWidths.push(this.transform.width - txadd);
            //     //文本渲染所占高度 和 transfrom节点高度的相差值
            //     let diffY = this.transform.height - tyadd;
            //     //相对transfrom X坐标的偏移
            //     let xadd = 0;
            //     //相对transfrom Y坐标的偏移
            //     let yadd = 0;
            //     if (this.verticalType == VerticalType.Center)               //垂直居中布局
            //     {
            //         yadd += diffY / 2;
            //     }
            //     else if (this.verticalType == VerticalType.Boom)            //垂直靠下布局
            //     {
            //         yadd += diffY;
            //     }
            //     //清理缓存
            //     this.initdater(renderTextCount, this.datar);
            //     i = 0;
            //     let rI = 0;
            //     for (let lineI = 0; lineI < lineEndIndexs.length; lineI++)
            //     {
            //         //一行
            //         xadd = 0;
            //         if (this.horizontalType == HorizontalType.Center)       //水平居中布局
            //         {
            //             xadd += lineWidths[lineI] / 2;
            //         }
            //         else if (this.horizontalType == HorizontalType.Right)   //水平靠右布局
            //         {
            //             xadd += lineWidths[lineI];
            //         }
            //         //遍历一行字符
            //         for (; i < lineEndIndexs[lineI]; i++)
            //         {
            //             let c = this._text.charAt(i);
            //             let cinfo = _font.cmap[c];
            //             if (cinfo == undefined) { continue; }
            //             var cx = xadd + cinfo.xOffset * rate;
            //             var cy = yadd - cinfo.yOffset * rate + _font.baseline * rate;
            //             var ch = rate * cinfo.ySize;
            //             var cw = rate * cinfo.xSize;
            //             xadd += cinfo.xAddvance * rate;
            //             var x1 = cx + cw;
            //             var y1 = cy;
            //             var x2 = cx;
            //             var y2 = cy + ch;
            //             var x3 = cx + cw;
            //             var y3 = cy + ch;
            //             //pos
            //             let _x0 = this.datar[rI * 6 * 13 + 0] = bx + cx * m11 + cy * m12;//x
            //             let _y0 = this.datar[rI * 6 * 13 + 1] = by + cx * m21 + cy * m22;//y
            //             let _x1 = this.datar[rI * 6 * 13 + 13 * 1 + 0] = bx + x1 * m11 + y1 * m12;//x
            //             let _y1 = this.datar[rI * 6 * 13 + 13 * 1 + 1] = by + x1 * m21 + y1 * m22;//y
            //             let _x2 = this.datar[rI * 6 * 13 + 13 * 2 + 0] = bx + x2 * m11 + y2 * m12;//x
            //             let _y2 = this.datar[rI * 6 * 13 + 13 * 2 + 1] = by + x2 * m21 + y2 * m22;//y
            //             this.datar[rI * 6 * 13 + 13 * 3 + 0] = bx + x2 * m11 + y2 * m12;//x
            //             this.datar[rI * 6 * 13 + 13 * 3 + 1] = by + x2 * m21 + y2 * m22;//y
            //             this.datar[rI * 6 * 13 + 13 * 4 + 0] = bx + x1 * m11 + y1 * m12;//x
            //             this.datar[rI * 6 * 13 + 13 * 4 + 1] = by + x1 * m21 + y1 * m22;//y
            //             let _x3 = this.datar[rI * 6 * 13 + 13 * 5 + 0] = bx + x3 * m11 + y3 * m12;//x
            //             let _y3 = this.datar[rI * 6 * 13 + 13 * 5 + 1] = by + x3 * m21 + y3 * m22;//y
            //             //uv
            //             var u0 = cinfo.x;
            //             var v0 = cinfo.y;
            //             var u1 = cinfo.x + cinfo.w;
            //             var v1 = cinfo.y;
            //             var u2 = cinfo.x;
            //             var v2 = cinfo.y + cinfo.h;
            //             var u3 = cinfo.x + cinfo.w;
            //             var v3 = cinfo.y + cinfo.h;
            //             this.datar[rI * 6 * 13 + 7] = u0;
            //             this.datar[rI * 6 * 13 + 8] = v0;
            //             this.datar[rI * 6 * 13 + 13 * 1 + 7] = u1;
            //             this.datar[rI * 6 * 13 + 13 * 1 + 8] = v1;
            //             this.datar[rI * 6 * 13 + 13 * 2 + 7] = u2;
            //             this.datar[rI * 6 * 13 + 13 * 2 + 8] = v2;
            //             this.datar[rI * 6 * 13 + 13 * 3 + 7] = u2;
            //             this.datar[rI * 6 * 13 + 13 * 3 + 8] = v2;
            //             this.datar[rI * 6 * 13 + 13 * 4 + 7] = u1;
            //             this.datar[rI * 6 * 13 + 13 * 4 + 8] = v1;
            //             this.datar[rI * 6 * 13 + 13 * 5 + 7] = u3;
            //             this.datar[rI * 6 * 13 + 13 * 5 + 8] = v3;
            //             //主color
            //             for (var j = 0; j < 6; j++)
            //             {
            //                 this.datar[rI * 6 * 13 + 13 * j + 3] = this.color.r;
            //                 this.datar[rI * 6 * 13 + 13 * j + 4] = this.color.g;
            //                 this.datar[rI * 6 * 13 + 13 * j + 5] = this.color.b;
            //                 this.datar[rI * 6 * 13 + 13 * j + 6] = this.color.a;
            //                 this.datar[rI * 6 * 13 + 13 * j + 9] = this.color2.r;
            //                 this.datar[rI * 6 * 13 + 13 * j + 10] = this.color2.g;
            //                 this.datar[rI * 6 * 13 + 13 * j + 11] = this.color2.b;
            //                 this.datar[rI * 6 * 13 + 13 * j + 12] = this.color2.a;
            //             }
            //             //drawRect 
            //             this.min_x = Math.min(_x0, _x1, _x2, _x3, this.min_x);
            //             this.min_y = Math.min(_y0, _y1, _y2, _y3, this.min_y);
            //             this.max_x = Math.max(_x0, _x1, _x2, _x3, this.max_x);
            //             this.max_y = Math.max(_y0, _y1, _y2, _y3, this.max_y);
            //             //有效渲染字符 索引递增
            //             rI++;
            //         }
            //         yadd += lineHeight;
            //     }
            //     //debug log
            //     // console.log(`lable text: 实际填充数 ：${rI} , 容器尺寸 ：${renderTextCount} \r text:${this._text}`);
            //     this.calcDrawRect();
            // }
            /** 更新数据 富文本 模式 */
            label.prototype.updateDataRich = function (_font) {
                //检查 依赖文本(辅助 自动填充字体)
                if (label_1.onTryExpandTexts) {
                    this.chackText(this._text);
                }
                //set data
                this.setDataByBlock(_font, this._richTextBlocks);
            };
            /**
             * 通过 block 设置数据
             * @param _font
             * @param blocks
             */
            label.prototype.setDataByBlock = function (_font, blocks) {
                //字符的 label尺寸 与 像素尺寸 的比值。
                var fontSize = this._fontsize;
                var rate = fontSize / _font.pointSize;
                var rBaseLine = _font.baseline * rate;
                var imgSize = fontSize * 0.8;
                var imgHalfGap = (fontSize - imgSize) / 2;
                var italicMoveX = fontSize * 0.3;
                //矩阵信息
                var m = this.transform.getWorldMatrix();
                var m11 = m.rawData[0];
                var m12 = m.rawData[2];
                var m21 = m.rawData[1];
                var m22 = m.rawData[3];
                //顶点开始位置
                var bx = this.data_begin.x;
                var by = this.data_begin.y;
                var atlas = this._imageTextAtlas;
                //计算出排列数据
                var txadd = 0; //字符x偏移量
                var tyadd = 0; //字符y偏移量
                var lineEndIndexs = []; //每行结束位置的索引列表
                var lineWidths = []; //每行字符宽度之和列表
                var contrast_w = this.horizontalOverflow ? Number.MAX_VALUE : this.transform.width; //最大宽度限制
                var contrast_h = this.verticalOverflow ? Number.MAX_VALUE : this.transform.height; //最大高度限制
                var lineHeight = fontSize * this.linespace; //一行的高度
                tyadd += lineHeight;
                var rI = 0;
                var imgCharCount = 0;
                var fullText = "";
                //筛选能渲染的数据,处理分行
                for (var i = 0, len = blocks.length; i < len; i++) {
                    var block = blocks[i];
                    var text = block.text;
                    var opts = block.opts;
                    if (text == null || text.length < 1)
                        continue;
                    //是否是 字符图
                    var hasImg = false;
                    var imgOpt = this.getImgOpt(opts);
                    if (atlas && imgOpt) {
                        //图集中是否能找到 该sprite
                        var sp = atlas.sprites[imgOpt.value];
                        hasImg = sp != null;
                    }
                    var forceBreak_1 = false;
                    //遍历字符串
                    for (var j = 0, len1 = text.length; j < len1; j++) {
                        var hasC = false;
                        var cWidth = 0;
                        var c = "";
                        var isNewline = false;
                        if (!hasImg) {
                            c = text.charAt(j);
                            isNewline = c == "\n"; //换行符
                            var cinfo = _font.cmap[c];
                            if (!isNewline && !cinfo) {
                                continue;
                            }
                            if (cinfo) {
                                cWidth = cinfo.xAddvance * rate; //字符的宽度
                                hasC = true;
                            }
                        }
                        else {
                            hasC = true;
                            cWidth = fontSize;
                            c = "*";
                        }
                        //需要换行了
                        if (isNewline || txadd + cWidth > contrast_w) {
                            if (tyadd + lineHeight > contrast_h) {
                                forceBreak_1 = true;
                                break;
                            } //高度超限制了
                            lineEndIndexs.push(rI);
                            lineWidths.push(this.transform.width - txadd);
                            txadd = 0; //文本x偏移置0
                            tyadd += lineHeight; //文本y偏移增加
                        }
                        if (hasC) {
                            txadd += cWidth; //文本x偏移增加
                            fullText += c;
                            rI++;
                            if (hasImg) {
                                imgCharCount++;
                            }
                        }
                        if (hasImg) {
                            break;
                        } //是图片跳出当前 block
                    }
                    if (forceBreak_1) {
                        break;
                    } //强制退出
                }
                //最后一行结尾的字符存入
                lineEndIndexs.push(rI);
                lineWidths.push(this.transform.width - txadd);
                //文本渲染所占高度 和 transfrom节点高度的相差值
                var diffY = this.transform.height - tyadd;
                var yOffset = 0;
                //垂直居中布局
                if (this.verticalType == VerticalType.Center) {
                    yOffset += diffY / 2;
                }
                //垂直靠下布局
                else if (this.verticalType == VerticalType.Boom) {
                    yOffset += diffY;
                }
                //相对transfrom X坐标的偏移
                var xadd = 0;
                //相对transfrom Y坐标的偏移
                var yadd = yOffset;
                //准备容器
                this.initdater(fullText.length - imgCharCount, this.datar);
                if (imgCharCount) {
                    this.initdater(imgCharCount, this.imgDatar); //字符图 数据容器
                }
                //
                this._hasImageChar = false;
                rI = 0;
                var textI = 0;
                var imgI = 0;
                var lineI = lineEndIndexs.shift();
                var lineWidth = lineWidths.shift();
                var forceBreak = false;
                var toNewLine = true;
                var lineCount = 0;
                //填充顶点数据
                for (var i = 0, len = blocks.length; i < len; i++) {
                    var block = blocks[i];
                    var text = block.text;
                    var opts = block.opts;
                    var optObj = label_1.helpOptObj;
                    this.getOptObj(opts, optObj);
                    //是图片字符
                    //color 选项
                    var color = optObj.color != null ? optObj.color : this.color;
                    var color2 = void 0;
                    if (optObj.color) {
                        color2 = label_1.helpColor;
                        m4m.math.colorClone(optObj.color, color2);
                        color2.a *= 0.5;
                    }
                    else {
                        color2 = this.color2;
                    }
                    //粗体
                    //斜体
                    var moveX = optObj.i ? italicMoveX : 0;
                    //下划线
                    //遍历字符串
                    for (var j = 0, len1 = text.length; j < len1; j++) {
                        if (lineI == null) {
                            forceBreak = true;
                            break;
                        }
                        if (rI >= lineI) {
                            lineI = lineEndIndexs.shift();
                            lineWidth = lineWidths.shift();
                            if (lineI == null || lineWidth == null) {
                                forceBreak = true;
                                break;
                            }
                            toNewLine = true;
                        }
                        if (toNewLine) {
                            //换行了
                            xadd = 0;
                            //水平居中布局
                            if (this.horizontalType == HorizontalType.Center) {
                                xadd += lineWidth / 2;
                            }
                            //水平靠右布局
                            else if (this.horizontalType == HorizontalType.Right) {
                                xadd += lineWidth;
                            }
                            //y 偏移值
                            yadd = yOffset + lineHeight * lineCount;
                            //行数增加
                            lineCount++;
                            toNewLine = false;
                        }
                        var hasImg = fullText[rI] == "*" && optObj.img;
                        var _I = 0;
                        var datar = void 0;
                        var c = void 0;
                        if (!hasImg) {
                            _I = textI;
                            c = text.charAt(j);
                            var cinfo = _font.cmap[c];
                            if (cinfo == undefined) {
                                continue;
                            }
                            //填充字符数据
                            datar = this.datar;
                            //pos
                            var ch = rate * cinfo.ySize;
                            var cw = rate * cinfo.xSize;
                            var x0 = xadd + cinfo.xOffset * rate;
                            var y0 = yadd - cinfo.yOffset * rate + rBaseLine;
                            //uv
                            var u0 = cinfo.x;
                            var v0 = cinfo.y;
                            var u1 = cinfo.x + cinfo.w;
                            var v1 = cinfo.y;
                            var u2 = cinfo.x;
                            var v2 = cinfo.y + cinfo.h;
                            var u3 = cinfo.x + cinfo.w;
                            var v3 = cinfo.y + cinfo.h;
                            //主color
                            for (var k = 0; k < 6; k++) {
                                datar[_I * 6 * 13 + 13 * k + 3] = color.r;
                                datar[_I * 6 * 13 + 13 * k + 4] = color.g;
                                datar[_I * 6 * 13 + 13 * k + 5] = color.b;
                                datar[_I * 6 * 13 + 13 * k + 6] = color.a;
                                datar[_I * 6 * 13 + 13 * k + 9] = color2.r;
                                datar[_I * 6 * 13 + 13 * k + 10] = color2.g;
                                datar[_I * 6 * 13 + 13 * k + 11] = color2.b;
                                datar[_I * 6 * 13 + 13 * k + 12] = color2.a;
                            }
                            //x 偏移增加
                            xadd += cinfo.xAddvance * rate;
                        }
                        else {
                            this._hasImageChar = true;
                            c = fullText[rI];
                            _I = imgI;
                            datar = this.imgDatar;
                            //填充字符图数据
                            var sp = atlas.sprites[optObj.img];
                            //pos
                            var ch = imgSize;
                            var cw = imgSize;
                            var x0 = xadd + imgHalfGap;
                            var y0 = yadd + imgHalfGap;
                            //uv
                            var urange = sp.urange;
                            var vrange = sp.vrange;
                            var u0 = urange.x;
                            var v0 = vrange.x;
                            var u1 = urange.y;
                            var v1 = vrange.x;
                            var u2 = urange.x;
                            var v2 = vrange.y;
                            var u3 = urange.y;
                            var v3 = vrange.y;
                            //主color
                            for (var k = 0; k < 6; k++) {
                                datar[_I * 6 * 13 + 13 * k + 3] = 1;
                                datar[_I * 6 * 13 + 13 * k + 4] = 1;
                                datar[_I * 6 * 13 + 13 * k + 5] = 1;
                                datar[_I * 6 * 13 + 13 * k + 6] = 1;
                            }
                            xadd += fontSize;
                        }
                        //填充数据
                        //pos
                        var x1 = x0 + cw;
                        var y1 = y0;
                        var x2 = x0;
                        var y2 = y0 + ch;
                        var x3 = x0 + cw;
                        var y3 = y0 + ch;
                        var _x0 = datar[_I * 6 * 13 + 0] = bx + (x0 + moveX) * m11 + y0 * m12; //x0
                        var _y0 = datar[_I * 6 * 13 + 1] = by + x0 * m21 + y0 * m22; //y0
                        var _x1 = datar[_I * 6 * 13 + 13 * 1 + 0] = bx + (x1 + moveX) * m11 + y1 * m12; //x1
                        var _y1 = datar[_I * 6 * 13 + 13 * 1 + 1] = by + x1 * m21 + y1 * m22; //y1
                        var _x2 = datar[_I * 6 * 13 + 13 * 2 + 0] = bx + x2 * m11 + y2 * m12; //x2
                        var _y2 = datar[_I * 6 * 13 + 13 * 2 + 1] = by + x2 * m21 + y2 * m22; //y2
                        datar[_I * 6 * 13 + 13 * 3 + 0] = _x2; //x
                        datar[_I * 6 * 13 + 13 * 3 + 1] = _y2; //y
                        datar[_I * 6 * 13 + 13 * 4 + 0] = _x1; //x
                        datar[_I * 6 * 13 + 13 * 4 + 1] = _y1; //y
                        var _x3 = datar[_I * 6 * 13 + 13 * 5 + 0] = bx + x3 * m11 + y3 * m12; //x3
                        var _y3 = datar[_I * 6 * 13 + 13 * 5 + 1] = by + x3 * m21 + y3 * m22; //y3
                        //uv
                        datar[_I * 6 * 13 + 7] = u0;
                        datar[_I * 6 * 13 + 8] = v0;
                        datar[_I * 6 * 13 + 13 * 1 + 7] = u1;
                        datar[_I * 6 * 13 + 13 * 1 + 8] = v1;
                        datar[_I * 6 * 13 + 13 * 2 + 7] = u2;
                        datar[_I * 6 * 13 + 13 * 2 + 8] = v2;
                        datar[_I * 6 * 13 + 13 * 3 + 7] = u2;
                        datar[_I * 6 * 13 + 13 * 3 + 8] = v2;
                        datar[_I * 6 * 13 + 13 * 4 + 7] = u1;
                        datar[_I * 6 * 13 + 13 * 4 + 8] = v1;
                        datar[_I * 6 * 13 + 13 * 5 + 7] = u3;
                        datar[_I * 6 * 13 + 13 * 5 + 8] = v3;
                        //drawRect 
                        this.min_x = Math.min(_x0, _x1, _x2, _x3, this.min_x);
                        this.min_y = Math.min(_y0, _y1, _y2, _y3, this.min_y);
                        this.max_x = Math.max(_x0, _x1, _x2, _x3, this.max_x);
                        this.max_y = Math.max(_y0, _y1, _y2, _y3, this.max_y);
                        //字符加入渲染队列
                        if (this.onAddRendererText)
                            this.onAddRendererText(x3, y3);
                        //有效渲染字符 索引递增
                        rI++;
                        if (!hasImg) {
                            textI++;
                        }
                        else {
                            imgI++;
                            break; //是图片字符 跳出该block
                        }
                    }
                    if (forceBreak)
                        break;
                }
                //debug log
                // console.log(`lable text: 实际填充数 ：${rI} , 容器尺寸 ：${fullText.length} \r text:${fullText}`);
                this.calcDrawRect();
            };
            /**获取 图片字符 选项 */
            label.prototype.getImgOpt = function (opts) {
                if (opts == null)
                    return;
                for (var i = 0, len = opts.length; i < len; i++) {
                    var val = opts[i];
                    if (val && val.getType() == RichOptType.Image)
                        return val;
                }
            };
            /** 获取富文本选项 对象 */
            label.prototype.getOptObj = function (opts, out) {
                out.i = false;
                out.b = false;
                out.u = false;
                if (out.color) {
                    m4m.math.pool.delete_color(out.color);
                    out.color = null;
                }
                out.img = "";
                if (!opts)
                    return;
                opts.forEach(function (val) {
                    if (val) {
                        switch (val.getType()) {
                            case RichOptType.Italic:
                                out.i = true;
                                break;
                            case RichOptType.Color:
                                var c = val.value;
                                out.color = m4m.math.pool.new_color(c.r, c.g, c.b, c.a);
                                break;
                            case RichOptType.Image:
                                out.img = val.value;
                                break;
                            case RichOptType.Bold:
                                out.b = true;
                                break;
                            case RichOptType.Underline:
                                out.u = true;
                                break;
                        }
                    }
                });
                return out;
            };
            Object.defineProperty(label.prototype, "color", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 填充颜色
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._color;
                },
                set: function (val) {
                    if (this._color != val) {
                        if (m4m.math.colorEqual(this._color, val))
                            return; //数值相同
                        m4m.math.colorClone(val, this._color);
                    }
                    this._dirtyData = this._drityRich = true;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(label.prototype, "color2", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 描边颜色
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._color2;
                },
                set: function (val) {
                    if (this._color2 != val) {
                        if (m4m.math.colorEqual(this._color2, val))
                            return; //数值相同
                        m4m.math.colorClone(val, this._color2);
                    }
                    this._dirtyData = this._drityRich = true;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(label.prototype, "outlineWidth", {
                /**
                 * 描边宽度
                 */
                get: function () {
                    return this._outlineWidth;
                },
                set: function (val) {
                    if (this._outlineWidth == val)
                        return;
                    this._outlineWidth = val;
                    this._dirtyData = this._drityRich = true;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(label.prototype, "richText", {
                /**
                 * 富文本模式 , 通过特定标签使用。
                 *
                 * 文字颜色             <color=#ffffffff>文本</color>       (已经支持);
                 * 文字斜体             \<i>文本\</i>                       (已经支持);
                 * 图片字符（表情）     [imgName]                           (已经支持);
                 * 文字加粗             \<b>文本\</b>                       (支持中);
                 * 文字加下划线         \<u>文本\</u>                       (支持中);
                 */
                get: function () { return this._richText; },
                set: function (val) { this._richText = val; },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(label.prototype, "imageTextAtlas", {
                /**
                 * 图像文字图集
                 * (例如 表情)
                 */
                get: function () { return this._imageTextAtlas; },
                set: function (val) {
                    if (val == this._imageTextAtlas)
                        return;
                    this._drityRich = true;
                    this._imageTextAtlas = val;
                    if (this._imageTextAtlas) {
                        this._imageTextAtlasName = this._imageTextAtlas.getName();
                    }
                    this.needRefreshAtlas = true;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 设置rander Shader名字
             * @version m4m 1.0
             */
            label.prototype.setShaderByName = function (shaderName) {
                this._CustomShaderName = shaderName;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取rander 的材质
             * @version m4m 1.0
             */
            label.prototype.getMaterial = function () {
                if (!this._uimat) {
                    return this.uimat;
                }
                return this._uimat;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取渲染绘制矩形边界
             * @version m4m 1.0
             */
            label.prototype.getDrawBounds = function () {
                if (!this._darwRect) {
                    this._darwRect = new m4m.math.rect();
                    this.calcDrawRect();
                }
                return this._darwRect;
            };
            /** 获取材质 通过 shaderName*/
            label.prototype.getMatByShader = function (oldMat, _tex, cShaderName, defMaskSh, defSh, newMatCB) {
                var transform = this.transform;
                var assetmgr = framework.sceneMgr.app.getAssetMgr();
                var pMask = transform.parentIsMask;
                var mat = oldMat;
                var rectTag = "";
                var uiTag = "_ui";
                if (pMask) {
                    //when parentIsMask,can't multiplexing material , can be multiplexing when parent equal
                    var rId = transform.maskRectId;
                    rectTag = "mask(".concat(rId, ")");
                }
                var useShaderName = cShaderName ? cShaderName : pMask ? defMaskSh : defSh;
                var matName = useShaderName + _tex.getName() + uiTag + rectTag;
                if (!mat || mat.getName() != matName) {
                    if (mat)
                        mat.unuse();
                    mat = assetmgr.getAssetByName(matName);
                    if (mat)
                        mat.use();
                }
                if (!mat) {
                    mat = new framework.material(matName);
                    var sh = assetmgr.getShader(cShaderName);
                    sh = sh ? sh : assetmgr.getShader(pMask ? defMaskSh : defSh);
                    mat.setShader(sh);
                    mat.use();
                    if (newMatCB)
                        newMatCB();
                    // this.needRefreshFont = true;
                }
                return mat;
            };
            Object.defineProperty(label.prototype, "uimat", {
                get: function () {
                    var _this = this;
                    var assetmgr = framework.sceneMgr.app.getAssetMgr();
                    if (!assetmgr)
                        return this._uimat;
                    this.searchTexture();
                    if (!this.font || !this.font.texture)
                        return this._uimat;
                    //获取材质
                    this._uimat = this.getMatByShader(this._uimat, this.font.texture, this._CustomShaderName, label_1.defMaskUIShader, label_1.defUIShader, function () {
                        //材质资源对象 刷新了
                        _this.needRefreshFont = true;
                    });
                    return this._uimat;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(label.prototype, "imgUIMat", {
                get: function () {
                    var _this = this;
                    var assetmgr = framework.sceneMgr.app.getAssetMgr();
                    if (!assetmgr)
                        return this._imgUIMat;
                    this.searchTextureAtlas();
                    if (!this._imageTextAtlas || !this._imageTextAtlas.texture)
                        return this._imgUIMat;
                    this._imgUIMat = this.getMatByShader(this._imgUIMat, this._imageTextAtlas.texture, "", label_1.defImgMaskUIShader, label_1.defImgUIShader, function () {
                        //材质资源对象 刷新了
                        _this.needRefreshAtlas = true;
                    });
                    return this._imgUIMat;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * @private
             */
            label.prototype.render = function (canvas) {
                var mat = this.uimat;
                if (!mat)
                    return;
                if (!this._font)
                    return;
                if (this._richText) {
                    if (this._drityRich) {
                        //富文本模式
                        this.parseRichText(this.text);
                        this.updateDataRich(this._font);
                        this._drityRich = false;
                    }
                }
                else if (this._dirtyData) {
                    this.updateData(this._font);
                    this._dirtyData = false;
                }
                var img;
                if (this._font) {
                    img = this._font.texture;
                }
                if (img) {
                    var forceRMask_1 = false;
                    if (this.needRefreshFont) {
                        mat.setTexture("_MainTex", img);
                        this.needRefreshFont = false;
                        forceRMask_1 = true;
                    }
                    if (this.transform.parentIsMask) {
                        //mask uniform 上传
                        this.setMaskData(mat, forceRMask_1);
                    }
                    else {
                        mat.setFloat("_outlineWidth", this.outlineWidth);
                    }
                    if (this.datar.length != 0)
                        canvas.pushRawData(mat, this.datar);
                }
                if (!this._hasImageChar || !this._richText || !this.imgDatar || this.imgDatar.length < 1)
                    return;
                //字符图绘制
                var imgMat = this.imgUIMat;
                if (!imgMat)
                    return;
                var _img;
                if (this._imageTextAtlas) {
                    _img = this._imageTextAtlas.texture;
                }
                if (!_img)
                    return;
                var forceRMask = false;
                if (this.needRefreshAtlas) {
                    imgMat.setTexture("_MainTex", _img);
                    this.needRefreshAtlas = false;
                    forceRMask = true;
                }
                if (this.transform.parentIsMask) {
                    //mask uniform 上传
                    this.setMaskData(imgMat, forceRMask);
                }
                //提交 字符图顶点数据
                if (this.imgDatar.length > 0) {
                    canvas.pushRawData(imgMat, this.imgDatar);
                }
            };
            label.prototype.setMaskData = function (mat, needRMask) {
                //mask uniform 上传
                if (this._cacheMaskV4 == null)
                    this._cacheMaskV4 = new m4m.math.vector4();
                var rect = this.transform.maskRect;
                if (this._cacheMaskV4.x != rect.x || this._cacheMaskV4.y != rect.y || this._cacheMaskV4.w != rect.w || this._cacheMaskV4.z != rect.h || needRMask) {
                    this._cacheMaskV4.x = rect.x;
                    this._cacheMaskV4.y = rect.y;
                    this._cacheMaskV4.z = rect.w;
                    this._cacheMaskV4.w = rect.h;
                    mat.setVector4("_maskRect", this._cacheMaskV4);
                }
            };
            //资源管理器中寻找 指定的贴图资源
            label.prototype.searchTexture = function () {
                //font  不存在，但有名字，在资源管理器中搜索
                if (!this._font && this._fontName) {
                    //字体
                    var assetmgr = framework.sceneMgr.app.getAssetMgr();
                    var resName = this._fontName;
                    var abname = resName.replace(".font.json", ".assetbundle.json");
                    var temp = assetmgr.getAssetByName(resName, abname);
                    if (!temp) {
                        resName = "".concat(this._fontName, ".font.json");
                        temp = assetmgr.getAssetByName(resName, abname);
                    }
                    if (temp != null) {
                        var tfont = assetmgr.getAssetByName(resName, abname);
                        if (tfont) {
                            this.font = tfont;
                            this.needRefreshFont = true;
                        }
                    }
                }
            };
            label.prototype.searchTextureAtlas = function () {
                //字符图集
                if (!this._imageTextAtlas && this._imageTextAtlasName) {
                    var assetmgr = framework.sceneMgr.app.getAssetMgr();
                    var atlasName = this._imageTextAtlasName;
                    var abname = atlasName.replace(".atlas.json", ".assetbundle.json");
                    var temp = assetmgr.getAssetByName(atlasName, abname);
                    if (temp) {
                        this.imageTextAtlas = temp;
                    }
                }
            };
            /**
             * @private
             */
            label.prototype.updateTran = function () {
                var m = this.transform.getWorldMatrix();
                var l = -this.transform.pivot.x * this.transform.width;
                var t = -this.transform.pivot.y * this.transform.height;
                var _b = this._lastBegin;
                var d_b = this.data_begin;
                d_b.x = l * m.rawData[0] + t * m.rawData[2] + m.rawData[4];
                d_b.y = l * m.rawData[1] + t * m.rawData[3] + m.rawData[5];
                //data_begin 有变化需要dirty
                if (!m4m.math.vec2Equal(_b, d_b, 0.00001)) {
                    this._dirtyData = true;
                    this._drityRich = true;
                }
                m4m.math.vec2Clone(d_b, _b);
            };
            /** 计算drawRect */
            label.prototype.calcDrawRect = function () {
                if (!this._darwRect)
                    return;
                //drawBounds (y 轴反向)
                var canvas = this.transform.canvas;
                if (!canvas)
                    return;
                var minPos = m4m.poolv2();
                minPos.x = this.min_x;
                minPos.y = this.max_y;
                canvas.clipPosToCanvasPos(minPos, minPos);
                var maxPos = m4m.poolv2();
                maxPos.x = this.max_x;
                maxPos.y = this.min_y;
                canvas.clipPosToCanvasPos(maxPos, maxPos);
                this._darwRect.x = minPos.x;
                this._darwRect.y = minPos.y;
                this._darwRect.w = maxPos.x - minPos.x;
                this._darwRect.h = maxPos.y - minPos.y;
                this.min_x = this.min_y = Number.MAX_VALUE;
                this.max_x = this.max_y = Number.MAX_VALUE * -1;
                m4m.poolv2_del(minPos);
                m4m.poolv2_del(maxPos);
            };
            /**
             * 解析 富文本
             * @param text
             */
            label.prototype.parseRichText = function (text) {
                //Color <color=#ffffffff></color>   文字颜色
                //Bold <b>text</b>                  文字加粗
                //Underline <u>text</u>             文字加下划线
                //Italic <u>text</u>                文字斜体
                //Image [imgName]                   图片字符（表情）
                //遍历字符串
                var len = text.length;
                var xmlStart = false;
                var imgStart = false;
                var strStack = [];
                var optStack = [];
                var blockDatas = this._richTextBlocks;
                blockDatas.length = 0;
                var atlas = this._imageTextAtlas;
                var genBlockFun = function () {
                    var str = strStack.shift();
                    //没有数据跳过
                    if (!str || str.length < 1)
                        return;
                    var opts = optStack.length > 0 ? optStack.concat() : null;
                    blockDatas.push({ text: str, opts: opts });
                };
                for (var i = 0; i < len; i++) {
                    var char = text[i];
                    if (char == "<") {
                        genBlockFun();
                        xmlStart = true;
                    }
                    else if (char == "[") {
                        genBlockFun();
                        imgStart = true;
                    }
                    if (strStack.length < 1)
                        strStack.push("");
                    strStack[strStack.length - 1] += char;
                    if (char == ">" && xmlStart) {
                        xmlStart = false;
                        // let xmlStr = strStack.pop();
                        var xmlStr = strStack[strStack.length - 1];
                        var isValid = false;
                        //判断 标签是开始 还是结束
                        if (xmlStr[1] == "/") {
                            var endOpt = optStack[optStack.length - 1];
                            if (endOpt) {
                                //选项确认有效
                                switch (xmlStr) {
                                    case "</color>":
                                        isValid = endOpt.getType() == RichOptType.Color;
                                        break;
                                    case "</i>":
                                        isValid = endOpt.getType() == RichOptType.Italic;
                                        break;
                                    case "</b>":
                                        isValid = endOpt.getType() == RichOptType.Bold;
                                        break;
                                    case "</u>":
                                        isValid = endOpt.getType() == RichOptType.Underline;
                                        break;
                                }
                            }
                            if (isValid) {
                                optStack.pop();
                            } //结束标记 弹栈
                        }
                        else {
                            //判断 标签类型
                            switch (xmlStr) {
                                case "<i>":
                                    isValid = true;
                                    optStack.push(new richOptItalic());
                                    break;
                                case "<b>":
                                    isValid = true;
                                    optStack.push(new richOptBold());
                                    break;
                                case "<u>":
                                    isValid = true;
                                    optStack.push(new richOptUnderline());
                                    break;
                                default:
                                    if (xmlStr.indexOf("color") == -1)
                                        continue;
                                    var _sIdx = xmlStr.indexOf("#");
                                    if (_sIdx == -1)
                                        continue;
                                    var colorVal = xmlStr.substring(_sIdx + 1, xmlStr.length - 1);
                                    var vLen = colorVal.length;
                                    if (vLen != 8 && vLen != 6)
                                        continue;
                                    var r = Number("0x".concat(colorVal.substring(0, 2)));
                                    var g = Number("0x".concat(colorVal.substring(2, 4)));
                                    var b = Number("0x".concat(colorVal.substring(4, 6)));
                                    var a = vLen == 6 ? this.color.a * 255 : Number("0x".concat(colorVal.substring(6, 8)));
                                    if (isNaN(r) || isNaN(g) || isNaN(b) || isNaN(a))
                                        continue;
                                    optStack.push(new richOptColor(new m4m.math.color(r / 255, g / 255, b / 255, a / 255)));
                                    isValid = true;
                                    break;
                            }
                        }
                        if (isValid) {
                            strStack.pop();
                        } //选项有效 弹栈
                    }
                    else if (char == "]" && imgStart) {
                        var str = strStack[strStack.length - 1];
                        var imgStr = str.substring(1, str.length - 1);
                        var isValid = atlas && atlas.sprites[imgStr]; //图集中是否能找到 该sprite
                        var imgOpt = new richOptImage(imgStr);
                        if (isValid) {
                            strStack.pop();
                            blockDatas.push({ text: str, opts: [imgOpt] });
                        }
                        imgStart = false;
                    }
                }
                //最后的数据
                while (strStack.length > 0) {
                    genBlockFun();
                }
            };
            /**
             * @private
             */
            label.prototype.start = function () {
            };
            label.prototype.onPlay = function () {
            };
            /**
             * @private
             */
            label.prototype.update = function (delta) {
            };
            /**
             * @private
             */
            label.prototype.remove = function () {
                if (this._font)
                    this._font.unuse();
                if (this._imageTextAtlas)
                    this._imageTextAtlas.unuse();
                if (this._uimat)
                    this._uimat.unuse();
                if (this._imgUIMat)
                    this._imgUIMat.unuse();
                this.datar.length = 0;
                this.imgDatar.length = 0;
                this._richTextBlocks.length = 0;
                this._defTextBlocks.length = 0;
                this.transform = null;
                this._cacheMaskV4 = null;
                this.onAddRendererText = null;
                this.data_begin = null;
                this._lastBegin = null;
            };
            var label_1;
            label.defUIShader = "shader/defuifont";
            label.defMaskUIShader = "shader/defmaskfont";
            label.defImgUIShader = "shader/defui";
            label.defImgMaskUIShader = "shader/defmaskui";
            label.helpOptObj = {};
            label.helpColor = new m4m.math.color();
            label.ClassName = "label";
            __decorate([
                m4m.reflect.Field("string"),
                __metadata("design:type", String),
                __metadata("design:paramtypes", [String])
            ], label.prototype, "text", null);
            __decorate([
                m4m.reflect.Field("string"),
                __metadata("design:type", Object)
            ], label.prototype, "_fontName", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], label.prototype, "fontsize", null);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], label.prototype, "linespace", null);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], label.prototype, "horizontalType", null);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], label.prototype, "verticalType", null);
            __decorate([
                m4m.reflect.Field("boolean"),
                __metadata("design:type", Boolean),
                __metadata("design:paramtypes", [Boolean])
            ], label.prototype, "horizontalOverflow", null);
            __decorate([
                m4m.reflect.Field("boolean"),
                __metadata("design:type", Boolean),
                __metadata("design:paramtypes", [Boolean])
            ], label.prototype, "verticalOverflow", null);
            __decorate([
                m4m.reflect.Field("color"),
                m4m.reflect.UIStyle("color"),
                __metadata("design:type", m4m.math.color),
                __metadata("design:paramtypes", [m4m.math.color])
            ], label.prototype, "color", null);
            __decorate([
                m4m.reflect.Field("color"),
                m4m.reflect.UIStyle("color"),
                __metadata("design:type", m4m.math.color),
                __metadata("design:paramtypes", [m4m.math.color])
            ], label.prototype, "color2", null);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], label.prototype, "outlineWidth", null);
            __decorate([
                m4m.reflect.Field("boolean"),
                __metadata("design:type", Boolean),
                __metadata("design:paramtypes", [Boolean])
            ], label.prototype, "richText", null);
            __decorate([
                m4m.reflect.Field("string"),
                __metadata("design:type", Object)
            ], label.prototype, "_imageTextAtlasName", void 0);
            label = label_1 = __decorate([
                m4m.reflect.node2DComponent,
                m4m.reflect.nodeRender
            ], label);
            return label;
        }());
        framework.label = label;
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 横向显示方式
         * @version m4m 1.0
         */
        var HorizontalType;
        (function (HorizontalType) {
            HorizontalType[HorizontalType["Center"] = 0] = "Center";
            HorizontalType[HorizontalType["Left"] = 1] = "Left";
            HorizontalType[HorizontalType["Right"] = 2] = "Right";
        })(HorizontalType = framework.HorizontalType || (framework.HorizontalType = {}));
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 纵向显示方式
         * @version m4m 1.0
         */
        var VerticalType;
        (function (VerticalType) {
            VerticalType[VerticalType["Center"] = 0] = "Center";
            VerticalType[VerticalType["Top"] = 1] = "Top";
            VerticalType[VerticalType["Boom"] = 2] = "Boom";
        })(VerticalType = framework.VerticalType || (framework.VerticalType = {}));
        /** 富文本类型 */
        var RichOptType;
        (function (RichOptType) {
            /** 颜色 */
            RichOptType[RichOptType["Color"] = 0] = "Color";
            /** 下划线 */
            RichOptType[RichOptType["Underline"] = 1] = "Underline";
            /** 字体加粗 */
            RichOptType[RichOptType["Bold"] = 2] = "Bold";
            /** 字体斜体 */
            RichOptType[RichOptType["Italic"] = 3] = "Italic";
            /** 图片 */
            RichOptType[RichOptType["Image"] = 4] = "Image";
        })(RichOptType || (RichOptType = {}));
        /**
         * 富文本选项 颜色
         */
        var richOptColor = /** @class */ (function () {
            function richOptColor(_c) {
                this.value = new m4m.math.color();
                m4m.math.colorClone(_c, this.value);
            }
            richOptColor.prototype.getType = function () { return RichOptType.Color; };
            return richOptColor;
        }());
        /**
         * 富文本选项 下划线
         */
        var richOptUnderline = /** @class */ (function () {
            function richOptUnderline() {
                this.value = true;
            }
            richOptUnderline.prototype.getType = function () { return RichOptType.Underline; };
            return richOptUnderline;
        }());
        /**
         * 富文本选项 加粗
         */
        var richOptBold = /** @class */ (function () {
            function richOptBold() {
                this.value = true;
            }
            richOptBold.prototype.getType = function () { return RichOptType.Bold; };
            return richOptBold;
        }());
        /**
         * 富文本选项 斜体
         */
        var richOptItalic = /** @class */ (function () {
            function richOptItalic() {
                this.value = true;
            }
            richOptItalic.prototype.getType = function () { return RichOptType.Italic; };
            return richOptItalic;
        }());
        /**
         * 富文本选项 文本图
         */
        var richOptImage = /** @class */ (function () {
            function richOptImage(imgSrc) {
                this.value = imgSrc;
            }
            richOptImage.prototype.getType = function () { return RichOptType.Image; };
            return richOptImage;
        }());
        ;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../../io/reflect.ts" />
var m4m;
/// <reference path="../../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 进度条
         * @version m4m 1.0
         */
        var progressbar = /** @class */ (function () {
            function progressbar() {
                this._value = 0.6;
            }
            Object.defineProperty(progressbar.prototype, "cutPanel", {
                /**
                 * 裁切容器
                 */
                get: function () {
                    return this._cutPanel;
                },
                set: function (trans) {
                    this._cutPanel = trans;
                    this.refreshBar();
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(progressbar.prototype, "barBg", {
                /**
                 * 进度条 背景图
                 */
                get: function () {
                    return this._barBg;
                },
                set: function (img) {
                    this._barBg = img;
                    this.refreshBar();
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(progressbar.prototype, "barOverImg", {
                /**
                 * 进度条 上层覆盖图
                 */
                get: function () {
                    return this._barOverImg;
                },
                set: function (img) {
                    this._barOverImg = img;
                    this.refreshBar();
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(progressbar.prototype, "value", {
                /**
                 * 进度值 0-1
                 */
                get: function () {
                    return this._value;
                },
                set: function (value) {
                    this._value = value < 0 ? 0 : value > 1 ? 1 : value;
                    if (!this._cutPanel || !this._barBg || !this._barBg.transform)
                        return;
                    this._cutPanel.width = this._value * this._barBg.transform.width;
                    this._cutPanel.markDirty();
                },
                enumerable: false,
                configurable: true
            });
            /**
             * @private
             */
            progressbar.prototype.start = function () {
            };
            progressbar.prototype.onPlay = function () {
            };
            /**
             * @private
             */
            progressbar.prototype.update = function (delta) {
                this.adjustOverImg();
            };
            progressbar.prototype.refreshBar = function () {
                this.adjustOverImg();
                this.value = this._value;
            };
            /** 调整overimg 宽高*/
            progressbar.prototype.adjustOverImg = function () {
                if (!this._barOverImg || !this._barBg)
                    return;
                var tbg = this._barBg.transform;
                var tover = this._barOverImg.transform;
                if (!tbg || !tover)
                    return;
                if (tbg.width != tover.width) {
                    tover.width = tbg.width;
                    tover.markDirty();
                }
            };
            /**
             * @private
             */
            progressbar.prototype.remove = function () {
                this._barBg = null;
                this._barOverImg = null;
                this._cutPanel = null;
            };
            progressbar.ClassName = "progressbar";
            __decorate([
                m4m.reflect.Field("reference", null, "transform2D"),
                __metadata("design:type", framework.transform2D),
                __metadata("design:paramtypes", [framework.transform2D])
            ], progressbar.prototype, "cutPanel", null);
            __decorate([
                m4m.reflect.Field("reference", null, "image2D"),
                __metadata("design:type", framework.image2D),
                __metadata("design:paramtypes", [framework.image2D])
            ], progressbar.prototype, "barBg", null);
            __decorate([
                m4m.reflect.Field("reference", null, "image2D"),
                __metadata("design:type", framework.image2D),
                __metadata("design:paramtypes", [framework.image2D])
            ], progressbar.prototype, "barOverImg", null);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], progressbar.prototype, "value", null);
            progressbar = __decorate([
                m4m.reflect.node2DComponent
            ], progressbar);
            return progressbar;
        }());
        framework.progressbar = progressbar;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../../io/reflect.ts" />
var m4m;
/// <reference path="../../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 2d图片组件</p>
         * 参照UGUI的思路，rawImage只拿整个图片来显示，不关心Sprite、九宫、填充等。这些统一都在iamge中处理
         * @version m4m 1.0
         */
        var rawImage2D = /** @class */ (function () {
            function rawImage2D() {
                this.datar = [
                    //3 pos  4 color  2 uv 4 color2
                    0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1,
                    0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
                ];
                this.needRefreshImg = false;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 颜色
                 * @version m4m 1.0
                 */
                this.color = new m4m.math.color(1.0, 1.0, 1.0, 1.0);
                this._CustomShaderName = ""; //自定义UIshader
                this.min_x = Number.MAX_VALUE;
                this.max_x = Number.MAX_VALUE * -1;
                this.min_y = Number.MAX_VALUE;
                this.max_y = Number.MAX_VALUE * -1;
            }
            rawImage2D_1 = rawImage2D;
            Object.defineProperty(rawImage2D.prototype, "image", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 图片
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._image;
                },
                set: function (_image) {
                    if (this._image == _image)
                        return;
                    this.needRefreshImg = true;
                    if (this._image) {
                        this._image.unuse();
                    }
                    this._image = _image;
                    if (_image) {
                        this._image.use();
                    }
                },
                enumerable: false,
                configurable: true
            });
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 设置rander Shader名字
             * @version m4m 1.0
             */
            rawImage2D.prototype.setShaderByName = function (shaderName) {
                this._CustomShaderName = shaderName;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取rander 的材质
             * @version m4m 1.0
             */
            rawImage2D.prototype.getMaterial = function () {
                if (!this._uimat) {
                    return this.uimat;
                }
                return this._uimat;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取渲染绘制矩形边界
             * @version m4m 1.0
             */
            rawImage2D.prototype.getDrawBounds = function () {
                if (!this._darwRect) {
                    this._darwRect = new m4m.math.rect();
                    this.calcDrawRect();
                }
                return this._darwRect;
            };
            Object.defineProperty(rawImage2D.prototype, "uimat", {
                get: function () {
                    if (this._image) {
                        var assetmgr = this.transform.canvas.assetmgr;
                        if (!assetmgr)
                            return this._uimat;
                        var pMask = this.transform.parentIsMask;
                        var mat = this._uimat;
                        var rectTag = "";
                        var uiTag = "_ui";
                        if (pMask) {
                            // let prect = this.transform.maskRect;
                            // rectTag = `mask(${prect.x}_${prect.y}_${prect.w}_${prect.h})`; //when parentIsMask,can't multiplexing material , can be multiplexing when parent equal
                            var rId = this.transform.maskRectId;
                            rectTag = "mask(".concat(rId, ")");
                        }
                        var useShaderName = this._CustomShaderName ? this._CustomShaderName : pMask ? rawImage2D_1.defMaskUIShader : rawImage2D_1.defUIShader;
                        var matName = useShaderName + this._image.getName() + uiTag + rectTag;
                        if (!mat || mat.getName() != matName) {
                            if (mat)
                                mat.unuse();
                            mat = assetmgr.getAssetByName(matName);
                            if (mat)
                                mat.use();
                        }
                        if (!mat) {
                            mat = new framework.material(matName);
                            var sh = assetmgr.getShader(this._CustomShaderName);
                            sh = sh ? sh : assetmgr.getShader(pMask ? rawImage2D_1.defMaskUIShader : rawImage2D_1.defUIShader);
                            mat.setShader(sh);
                            mat.use();
                            this.needRefreshImg = true;
                        }
                        this._uimat = mat;
                    }
                    return this._uimat;
                },
                enumerable: false,
                configurable: true
            });
            // /**
            //  * @private
            //  * ui默认材质
            //  */
            // _uimat: material;
            // private get uimat(){
            //     if (this.image != null ){
            //         let rectPostfix = this.transform.parentIsMask? `_(${this.transform.insId})`: ""; //when parentIsMask,can't multiplexing material
            //         let matName =this._image.getName() + "_uimask" + rectPostfix;
            //         let canvas = this.transform.canvas;
            //         if(!canvas.assetmgr) return;
            //         let mat = this._uimat;
            //         if(!mat || mat.getName() != matName){
            //             if(mat) mat.unuse(); 
            //             mat = canvas.assetmgr.getAssetByName(matName) as m4m.framework.material;
            //             if(mat) mat.use();
            //         }
            //         if(mat == null){
            //             mat = new material(matName);
            //             mat.setShader(canvas.assetmgr.getShader("shader/defmaskui"));
            //             mat.use();
            //         }
            //         mat.setFloat("MaskState", this.transform.parentIsMask? 1 : 0);
            //         this._uimat = mat;
            //     }
            //     return this._uimat;
            // }
            /**
             * @private
             */
            rawImage2D.prototype.render = function (canvas) {
                var mat = this.uimat;
                if (!mat)
                    return;
                var img = this.image;
                // if (img == null)
                // {
                //     var scene = this.transform.canvas.scene;
                //     img = scene.app.getAssetMgr().getDefaultTexture("grid");
                // }
                if (img != null) {
                    var needRMask = false;
                    if (this.needRefreshImg) {
                        mat.setTexture("_MainTex", img);
                        this.needRefreshImg = false;
                        needRMask = true;
                    }
                    if (this.transform.parentIsMask) {
                        if (this._cacheMaskV4 == null)
                            this._cacheMaskV4 = new m4m.math.vector4();
                        var rect = this.transform.maskRect;
                        if (this._cacheMaskV4.x != rect.x || this._cacheMaskV4.y != rect.y || this._cacheMaskV4.w != rect.w || this._cacheMaskV4.z != rect.h || needRMask) {
                            this._cacheMaskV4.x = rect.x;
                            this._cacheMaskV4.y = rect.y;
                            this._cacheMaskV4.z = rect.w;
                            this._cacheMaskV4.w = rect.h;
                            mat.setVector4("_maskRect", this._cacheMaskV4);
                        }
                    }
                    canvas.pushRawData(mat, this.datar);
                }
            };
            /**
             * @private
             */
            rawImage2D.prototype.updateTran = function () {
                var m = this.transform.getWorldMatrix();
                var l = -this.transform.pivot.x * this.transform.width;
                var r = this.transform.width + l;
                var t = -this.transform.pivot.y * this.transform.height;
                var b = this.transform.height + t;
                var x0 = l * m.rawData[0] + t * m.rawData[2] + m.rawData[4];
                var y0 = l * m.rawData[1] + t * m.rawData[3] + m.rawData[5];
                var x1 = r * m.rawData[0] + t * m.rawData[2] + m.rawData[4];
                var y1 = r * m.rawData[1] + t * m.rawData[3] + m.rawData[5];
                var x2 = l * m.rawData[0] + b * m.rawData[2] + m.rawData[4];
                var y2 = l * m.rawData[1] + b * m.rawData[3] + m.rawData[5];
                var x3 = r * m.rawData[0] + b * m.rawData[2] + m.rawData[4];
                var y3 = r * m.rawData[1] + b * m.rawData[3] + m.rawData[5];
                this.datar[0 * 13] = x0;
                this.datar[0 * 13 + 1] = y0;
                this.datar[1 * 13] = x1;
                this.datar[1 * 13 + 1] = y1;
                this.datar[2 * 13] = x2;
                this.datar[2 * 13 + 1] = y2;
                this.datar[3 * 13] = x2;
                this.datar[3 * 13 + 1] = y2;
                this.datar[4 * 13] = x1;
                this.datar[4 * 13 + 1] = y1;
                this.datar[5 * 13] = x3;
                this.datar[5 * 13 + 1] = y3;
                //主color
                for (var i = 0; i < 6; i++) {
                    this.datar[i * 13 + 3] = this.color.r;
                    this.datar[i * 13 + 4] = this.color.g;
                    this.datar[i * 13 + 5] = this.color.b;
                    this.datar[i * 13 + 6] = this.color.a;
                }
                //drawRect 
                this.min_x = Math.min(x0, x1, x2, x3, this.min_x);
                this.min_y = Math.min(y0, y1, y2, y3, this.min_y);
                this.max_x = Math.max(x0, x1, x2, x3, this.max_x);
                this.max_y = Math.max(y0, y1, y2, y3, this.max_y);
                this.calcDrawRect();
            };
            /** 计算drawRect */
            rawImage2D.prototype.calcDrawRect = function () {
                if (!this._darwRect)
                    return;
                //drawBounds (y 轴反向)
                var canvas = this.transform.canvas;
                if (!canvas)
                    return;
                var minPos = m4m.poolv2();
                minPos.x = this.min_x;
                minPos.y = this.max_y;
                canvas.clipPosToCanvasPos(minPos, minPos);
                var maxPos = m4m.poolv2();
                maxPos.x = this.max_x;
                maxPos.y = this.min_y;
                canvas.clipPosToCanvasPos(maxPos, maxPos);
                this._darwRect.x = minPos.x;
                this._darwRect.y = minPos.y;
                this._darwRect.w = maxPos.x - minPos.x;
                this._darwRect.h = maxPos.y - minPos.y;
                this.min_x = this.min_y = Number.MAX_VALUE;
                this.max_x = this.max_y = Number.MAX_VALUE * -1;
                m4m.poolv2_del(minPos);
                m4m.poolv2_del(maxPos);
            };
            /**
             * @private
             */
            rawImage2D.prototype.start = function () {
            };
            rawImage2D.prototype.onPlay = function () {
            };
            /**
             * @private
             */
            rawImage2D.prototype.update = function (delta) {
            };
            /**
             * @private
             */
            rawImage2D.prototype.remove = function () {
                if (this._image)
                    this._image.unuse();
                if (this._uimat)
                    this._uimat.unuse();
                this._image = null;
                this._cacheMaskV4 = null;
                this.transform = null;
                this.datar.length = 0;
            };
            var rawImage2D_1;
            rawImage2D.ClassName = "rawImage2D";
            rawImage2D.defUIShader = "shader/defui"; //非mask 使用shader
            rawImage2D.defMaskUIShader = "shader/defmaskui"; //mask 使用shader
            __decorate([
                m4m.reflect.Field("texture"),
                __metadata("design:type", framework.texture),
                __metadata("design:paramtypes", [framework.texture])
            ], rawImage2D.prototype, "image", null);
            __decorate([
                m4m.reflect.Field("color"),
                m4m.reflect.UIStyle("vector4"),
                __metadata("design:type", m4m.math.color)
            ], rawImage2D.prototype, "color", void 0);
            rawImage2D = rawImage2D_1 = __decorate([
                m4m.reflect.node2DComponent,
                m4m.reflect.nodeRender
            ], rawImage2D);
            return rawImage2D;
        }());
        framework.rawImage2D = rawImage2D;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../../io/reflect.ts" />
var m4m;
/// <reference path="../../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * 富文本版 lable
         * 支持表情字符，自定义样式段落
         */
        var richLabel = /** @class */ (function () {
            function richLabel() {
            }
            richLabel.prototype.render = function (canvas) {
                throw new Error("Method not implemented.");
            };
            richLabel.prototype.updateTran = function () {
                throw new Error("Method not implemented.");
            };
            richLabel.prototype.getMaterial = function () {
                throw new Error("Method not implemented.");
            };
            richLabel.prototype.getDrawBounds = function () {
                throw new Error("Method not implemented.");
            };
            richLabel.prototype.onPlay = function () {
                throw new Error("Method not implemented.");
            };
            richLabel.prototype.start = function () {
                throw new Error("Method not implemented.");
            };
            richLabel.prototype.update = function (delta) {
                throw new Error("Method not implemented.");
            };
            richLabel.prototype.remove = function () {
                throw new Error("Method not implemented.");
            };
            richLabel = __decorate([
                m4m.reflect.node2DComponent,
                m4m.reflect.nodeRender
            ], richLabel);
            return richLabel;
        }());
        framework.richLabel = richLabel;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../../io/reflect.ts" />
var m4m;
/// <reference path="../../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
        * @public
        * @language zh_CN
        * @classdesc
        * 矩形卷轴
        * @version m4m 1.0
        */
        var scrollRect = /** @class */ (function () {
            function scrollRect() {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 水平滑动开启
                 * @version m4m 1.0
                 */
                this.horizontal = true;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 垂直滑动开启
                 * @version m4m 1.0
                 */
                this.vertical = true;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 滑动惯性
                 * @version m4m 1.0
                 */
                this.inertia = true;
                /**
                * @public
                * @language zh_CN
                * @classdesc
                * 惯性减速率
                * @version m4m 1.0
                */
                this.decelerationRate = 0.135;
                //暂停滑动
                this.pauseSlide = false;
                this.isPointDown = false;
                this.lastPoint = new m4m.math.vector2();
                this.strPoint = new m4m.math.vector2();
                this.strPos = new m4m.math.vector2();
                this.collectNum = 3; //控制采集精度
                this.points = [];
                this.flyVelocity = new m4m.math.vector2(); //速度
                this.canfly = false;
                this.threshold = 0.01; //阈值
                this.cgTime = 0.2;
                this.cgCount = this.cgTime;
                this.lastfv = new m4m.math.vector2();
            }
            scrollRect_1 = scrollRect;
            Object.defineProperty(scrollRect.prototype, "content", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 输入内容label
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._content;
                },
                set: function (content) {
                    this._content = content;
                },
                enumerable: false,
                configurable: true
            });
            scrollRect.prototype.start = function () {
            };
            scrollRect.prototype.onPlay = function () {
            };
            scrollRect.prototype.update = function (delta) {
                this.flyingSlidr(delta);
            };
            scrollRect.prototype.onPointEvent = function (canvas, ev, oncap) {
                if (this.pauseSlide) {
                    this.isPointDown = false;
                    return;
                }
                //oncap==true 是捕获阶段，一般的行为，只在pop阶段处理
                if (oncap == false) {
                    var tv2 = scrollRect_1.helpv2;
                    tv2.x = ev.x;
                    tv2.y = ev.y;
                    var b = this.transform.ContainsCanvasPoint(tv2);
                    if (b) {
                        ev.eated = true;
                        if (this._content == null)
                            return;
                        if (!this.horizontal && !this.vertical)
                            return;
                        var temps = scrollRect_1.helpv2;
                        m4m.math.vec2Set(temps, ev.x, ev.y);
                        var tempc = scrollRect_1.helpv2_1;
                        this.transform.canvas.clipPosToCanvasPos(temps, tempc);
                        var sp = this.strPoint;
                        if (ev.type == m4m.event.PointEventEnum.PointDown) {
                            //点下
                            this.isPointDown = true;
                            sp.x = tempc.x;
                            sp.y = tempc.y;
                            m4m.math.vec2Clone(this._content.transform.localTranslate, this.strPos);
                            this.canfly = false;
                            if (this.onDownFun)
                                this.onDownFun(sp.x, sp.y);
                        }
                        if (ev.type == m4m.event.PointEventEnum.PointHold && this.isPointDown) {
                            //滑动中
                            var lp = this.lastPoint;
                            if (lp.x != tempc.x || lp.y != tempc.y) {
                                lp.x = tempc.x;
                                lp.y = tempc.y;
                                var addtransX = lp.x - sp.x;
                                var addtransY = lp.y - sp.y;
                                m4m.math.vec2Clone(this.strPos, this._content.localTranslate);
                                this.SlideTo(addtransX, addtransY);
                            }
                            if (this.inertia) {
                                this.collectPointing();
                            }
                        }
                    }
                }
                if (ev.type == m4m.event.PointEventEnum.PointUp) {
                    //滑动结束
                    this.isPointDown = false;
                    if (this.inertia) {
                        this.onInertiaSliderUp();
                    }
                    if (this.onUpFun)
                        this.onUpFun();
                }
            };
            //滑动一定距离
            scrollRect.prototype.SlideTo = function (addtransX, addtransY) {
                if (!this._content)
                    return;
                var ctrans = this._content.transform;
                var cpos = ctrans.localTranslate;
                var trans = this.transform;
                if (this.horizontal) {
                    cpos.x += addtransX;
                    if (cpos.x > 0 || ctrans.width <= trans.width)
                        cpos.x = 0;
                    if (ctrans.width > trans.width && cpos.x + ctrans.width < trans.width)
                        cpos.x = -1 * (ctrans.width - trans.width);
                }
                if (this.vertical) {
                    cpos.y += addtransY;
                    if (cpos.y > 0 || ctrans.height <= trans.height)
                        cpos.y = 0;
                    if (ctrans.height > trans.height && cpos.y + ctrans.height < trans.height)
                        cpos.y = -1 * (ctrans.height - trans.height);
                }
                ctrans.markDirty();
                if (this.onMoveFun)
                    this.onMoveFun(addtransX, addtransY);
            };
            //收集点数据
            scrollRect.prototype.collectPointing = function () {
                if (!this.isPointDown)
                    return;
                // let p = this.iptmgr.point;
                var p = this.lastPoint;
                if (this.points.length > this.collectNum) {
                    var v2 = this.points.shift();
                    m4m.math.pool.delete_vector2(v2);
                }
                var currpos = m4m.math.pool.new_vector2(p.x, p.y);
                this.points.push(currpos);
            };
            //点up
            scrollRect.prototype.onInertiaSliderUp = function () {
                if (this.points.length < 2) {
                    m4m.math.pool.delete_vector2Array(this.points);
                    return;
                }
                //计算缓动 滑行
                var fv = this.flyVelocity;
                fv.x = fv.y = 0;
                var len = this.points.length;
                var tv2 = scrollRect_1.helpv2;
                for (var i = 1; i < len; i++) {
                    var p_0 = this.points[i - 1];
                    var p_1 = this.points[i];
                    m4m.math.vec2Subtract(p_1, p_0, tv2);
                    m4m.math.vec2Add(tv2, fv, fv);
                }
                m4m.math.vec2Clone(this.flyVelocity, this.lastfv);
                m4m.math.pool.delete_vector2Array(this.points);
                this.canfly = true;
            };
            //惯性滑动
            scrollRect.prototype.flyingSlidr = function (delta) {
                if (!this.canfly || !this.inertia)
                    return;
                var fv = this.flyVelocity;
                this.cgCount += delta;
                if (this.cgCount >= this.cgTime) {
                    m4m.math.vec2Clone(fv, this.lastfv);
                    m4m.math.vec2ScaleByNum(fv, this.decelerationRate, fv);
                    this.cgCount = 0;
                }
                if (m4m.math.vec2Length(fv) < this.threshold) {
                    this.canfly = false;
                    this.cgCount = this.cgTime;
                }
                var tv2 = scrollRect_1.helpv2;
                m4m.math.vec2SLerp(this.lastfv, fv, this.cgCount / this.cgTime, tv2);
                this.SlideTo(tv2.x, tv2.y);
                if (this.canfly == false) //惯性滑动 结束
                 {
                    if (this.onSlideEndFun)
                        this.onSlideEndFun();
                }
            };
            scrollRect.prototype.remove = function () {
                this._content = null;
                this.transform = null;
            };
            var scrollRect_1;
            scrollRect.ClassName = "scrollRect";
            scrollRect.helpv2 = new m4m.math.vector2();
            scrollRect.helpv2_1 = new m4m.math.vector2();
            __decorate([
                m4m.reflect.Field("reference", null, "transform2D"),
                __metadata("design:type", framework.transform2D),
                __metadata("design:paramtypes", [framework.transform2D])
            ], scrollRect.prototype, "content", null);
            __decorate([
                m4m.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], scrollRect.prototype, "horizontal", void 0);
            __decorate([
                m4m.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], scrollRect.prototype, "vertical", void 0);
            __decorate([
                m4m.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], scrollRect.prototype, "inertia", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], scrollRect.prototype, "decelerationRate", void 0);
            scrollRect = scrollRect_1 = __decorate([
                m4m.reflect.node2DComponent
            ], scrollRect);
            return scrollRect;
        }());
        framework.scrollRect = scrollRect;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
        * @public
        * @language zh_CN
        * @classdesc
        * 滑动区域
        * @version m4m 1.0
        */
        var slideArea = /** @class */ (function () {
            function slideArea() {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 水平滑动开启
                 * @version m4m 1.0
                 */
                this.horizontal = false;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 垂直滑动开启
                 * @version m4m 1.0
                 */
                this.vertical = false;
                this.isPointDown = false;
                this.lastPoint = new m4m.math.vector2();
                this.strPoint = new m4m.math.vector2();
            }
            slideArea_1 = slideArea;
            slideArea.prototype.start = function () {
            };
            slideArea.prototype.onPlay = function () {
            };
            slideArea.prototype.update = function (delta) {
            };
            slideArea.prototype.onPointEvent = function (canvas, ev, oncap) {
                //oncap==true 是捕获阶段，一般的行为，只在pop阶段处理
                if (oncap == false) {
                    var tv2 = slideArea_1.helpv2;
                    tv2.x = ev.x;
                    tv2.y = ev.y;
                    var b = this.transform.ContainsCanvasPoint(tv2);
                    if (b) {
                        ev.eated = true;
                        if (!this.horizontal && !this.vertical)
                            return;
                        var temps = slideArea_1.helpv2;
                        m4m.math.vec2Set(temps, ev.x, ev.y);
                        var tempc = slideArea_1.helpv2_1;
                        this.transform.canvas.clipPosToCanvasPos(temps, tempc);
                        var sp = this.strPoint;
                        if (ev.type == m4m.event.PointEventEnum.PointDown) {
                            //点下
                            this.isPointDown = true;
                            sp.x = tempc.x;
                            sp.y = tempc.y;
                            if (this.onDownFun)
                                this.onDownFun(sp.x, sp.y);
                        }
                        if (ev.type == m4m.event.PointEventEnum.PointHold && this.isPointDown) {
                            //滑动中
                            var lp = this.lastPoint;
                            if (lp.x != tempc.x || lp.y != tempc.y) {
                                lp.x = tempc.x;
                                lp.y = tempc.y;
                                var addtransX = 0;
                                if (this.horizontal) {
                                    addtransX = lp.x - sp.x;
                                }
                                var addtransY = 0;
                                if (this.vertical) {
                                    addtransY = lp.y - sp.y;
                                }
                                // console.error(addtransX+"  ***  "+addtransY);
                                if (this.onMoveFun)
                                    this.onMoveFun(addtransX, addtransY);
                            }
                        }
                    }
                }
                if (ev.type == m4m.event.PointEventEnum.PointUp) {
                    //滑动结束
                    this.isPointDown = false;
                    if (this.onUpFun)
                        this.onUpFun();
                }
            };
            slideArea.prototype.remove = function () {
                this.transform = null;
            };
            var slideArea_1;
            slideArea.ClassName = "slideArea";
            slideArea.helpv2 = new m4m.math.vector2();
            slideArea.helpv2_1 = new m4m.math.vector2();
            __decorate([
                m4m.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], slideArea.prototype, "horizontal", void 0);
            __decorate([
                m4m.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], slideArea.prototype, "vertical", void 0);
            slideArea = slideArea_1 = __decorate([
                m4m.reflect.node2DComponent
            ], slideArea);
            return slideArea;
        }());
        framework.slideArea = slideArea;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../../io/reflect.ts" />
var m4m;
/// <reference path="../../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        var uirect = /** @class */ (function () {
            function uirect() {
                this.canbeClick = true;
            }
            uirect.prototype.start = function () {
            };
            uirect.prototype.onPlay = function () {
            };
            uirect.prototype.update = function (delta) {
            };
            uirect.prototype.remove = function () {
                this.transform = null;
            };
            uirect.ClassName = "uirect";
            uirect = __decorate([
                m4m.reflect.node2DComponent
            ], uirect);
            return uirect;
        }());
        framework.uirect = uirect;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var math;
    (function (math) {
        function matrixGetTranslation(src, out) {
            out.x = src.rawData[12];
            out.y = src.rawData[13];
            out.z = src.rawData[14];
            // out.rawData[0] = src.rawData[12];
            // out.rawData[1] = src.rawData[13];
            // out.rawData[2] = src.rawData[14];
            //out.rawData.set(src.rawData.subarray(12, 15));
        }
        math.matrixGetTranslation = matrixGetTranslation;
        /**
        * @language zh_CN
        * 当前矩阵转置
        * @version m4m 1.0
        * @platform Web,Native
        */
        function matrixTranspose(src, out) {
            var s1 = src.rawData[1];
            var s2 = src.rawData[2];
            var s3 = src.rawData[3];
            var s4 = src.rawData[4];
            var s6 = src.rawData[6];
            var s7 = src.rawData[7];
            var s8 = src.rawData[8];
            var s9 = src.rawData[9];
            var s11 = src.rawData[11];
            var s12 = src.rawData[12];
            var s13 = src.rawData[13];
            var s14 = src.rawData[14];
            out.rawData[1] = s4;
            out.rawData[2] = s8;
            out.rawData[3] = s12;
            out.rawData[4] = s1;
            out.rawData[6] = s9;
            out.rawData[7] = s13;
            out.rawData[8] = s2;
            out.rawData[9] = s6;
            out.rawData[11] = s14;
            out.rawData[12] = s3;
            out.rawData[13] = s7;
            out.rawData[14] = s11;
        }
        math.matrixTranspose = matrixTranspose;
        function matrixDecompose(src, scale, rotation, translation) {
            translation.x = src.rawData[12];
            translation.y = src.rawData[13];
            translation.z = src.rawData[14];
            // translation.rawData.set(src.rawData.subarray(12, 15));
            var xs = math.sign(src.rawData[0] * src.rawData[1] * src.rawData[2] * src.rawData[3]) < 0 ? -1 : 1;
            var ys = math.sign(src.rawData[4] * src.rawData[5] * src.rawData[6] * src.rawData[7]) < 0 ? -1 : 1;
            var zs = math.sign(src.rawData[8] * src.rawData[9] * src.rawData[10] * src.rawData[11]) < 0 ? -1 : 1;
            scale.x = xs * Math.sqrt(src.rawData[0] * src.rawData[0] + src.rawData[1] * src.rawData[1] + src.rawData[2] * src.rawData[2]);
            scale.y = ys * Math.sqrt(src.rawData[4] * src.rawData[4] + src.rawData[5] * src.rawData[5] + src.rawData[6] * src.rawData[6]);
            scale.z = zs * Math.sqrt(src.rawData[8] * src.rawData[8] + src.rawData[9] * src.rawData[9] + src.rawData[10] * src.rawData[10]);
            if (scale.x === 0 || scale.y === 0 || scale.z === 0) {
                rotation.x = 0;
                rotation.y = 0;
                rotation.z = 0;
                rotation.w = 1;
                return false;
            }
            var mat = math.pool.new_matrix();
            mat.rawData[0] = src.rawData[0] / scale.x;
            mat.rawData[1] = src.rawData[1] / scale.x;
            mat.rawData[2] = src.rawData[2] / scale.x;
            mat.rawData[3] = 0;
            mat.rawData[4] = src.rawData[4] / scale.y;
            mat.rawData[5] = src.rawData[5] / scale.y;
            mat.rawData[6] = src.rawData[6] / scale.y;
            mat.rawData[7] = 0;
            mat.rawData[8] = src.rawData[8] / scale.z;
            mat.rawData[9] = src.rawData[9] / scale.z;
            mat.rawData[10] = src.rawData[10] / scale.z;
            mat.rawData[11] = 0;
            matrix2Quaternion(mat, rotation);
            math.pool.delete_matrix(mat);
            return true;
        }
        math.matrixDecompose = matrixDecompose;
        var angelref = /** @class */ (function () {
            function angelref() {
            }
            return angelref;
        }());
        math.angelref = angelref;
        function matrix3x2Decompose(src, scale, rotation, translation) {
            //trans
            translation.x = src.rawData[4];
            translation.y = src.rawData[5];
            // var xs = sign(src.rawData[0] * src.rawData[1]) < 0 ? -1 : 1;
            // var ys = sign(src.rawData[2] * src.rawData[3]) < 0 ? -1 : 1;
            // scale.x = xs * Math.sqrt(src.rawData[0] * src.rawData[0] + src.rawData[1] * src.rawData[1]);
            // scale.y = ys * Math.sqrt(src.rawData[2] * src.rawData[2] + src.rawData[3] * src.rawData[3]);
            // if (scale.x === 0 || scale.y === 0)
            // {
            //     rotation.v = 0;
            //     return false;
            // }
            // var sx = src.rawData[0] / scale.x;
            // var csx = src.rawData[1] / scale.x;
            // var r1 = Math.asin(sx);
            // var r2 = Math.acos(csx);
            // rotation.v = r1;
            // return true;
            scale.x = Math.sqrt(src.rawData[0] * src.rawData[0] + src.rawData[1] * src.rawData[1]);
            scale.y = Math.sqrt(src.rawData[2] * src.rawData[2] + src.rawData[3] * src.rawData[3]);
            if (scale.x === 0 || scale.y === 0) {
                rotation.v = 0;
                return false;
            }
            var sx = src.rawData[0] / scale.x;
            var r1 = Math.acos(sx);
            var sxs = src.rawData[1] / scale.x;
            var r2 = Math.asin(sxs);
            if (sxs < 0) {
                r1 = 2 * Math.PI - r1;
                //r1=r1+Math.PI;
            }
            rotation.v = r1;
            return true;
        }
        math.matrix3x2Decompose = matrix3x2Decompose;
        function matrixGetEuler(src, order, rotation) {
            var clamp = math.floatClamp;
            //
            var rawData = src.rawData;
            var m11 = rawData[0], m12 = rawData[4], m13 = rawData[8];
            var m21 = rawData[1], m22 = rawData[5], m23 = rawData[9];
            var m31 = rawData[2], m32 = rawData[6], m33 = rawData[10];
            //
            var scaleX = Math.sqrt(m11 * m11 + m21 * m21 + m31 * m31);
            m11 /= scaleX;
            m21 /= scaleX;
            m31 /= scaleX;
            var scaleY = Math.sqrt(m12 * m12 + m22 * m22 + m32 * m32);
            m12 /= scaleY;
            m22 /= scaleY;
            m32 /= scaleY;
            var scaleZ = Math.sqrt(m13 * m13 + m23 * m23 + m33 * m33);
            m13 /= scaleZ;
            m23 /= scaleZ;
            m33 /= scaleZ;
            //
            if (order === math.RotationOrder.XYZ) {
                rotation.y = Math.asin(clamp(m13, -1, 1));
                if (Math.abs(m13) < 0.9999999) {
                    rotation.x = Math.atan2(-m23, m33);
                    rotation.z = Math.atan2(-m12, m11);
                }
                else {
                    rotation.x = Math.atan2(m32, m22);
                    rotation.z = 0;
                }
            }
            else if (order === math.RotationOrder.YXZ) {
                rotation.x = Math.asin(-clamp(m23, -1, 1));
                if (Math.abs(m23) < 0.9999999) {
                    rotation.y = Math.atan2(m13, m33);
                    rotation.z = Math.atan2(m21, m22);
                }
                else {
                    rotation.y = Math.atan2(-m31, m11);
                    rotation.z = 0;
                }
            }
            else if (order === math.RotationOrder.ZXY) {
                rotation.x = Math.asin(clamp(m32, -1, 1));
                if (Math.abs(m32) < 0.9999999) {
                    rotation.y = Math.atan2(-m31, m33);
                    rotation.z = Math.atan2(-m12, m22);
                }
                else {
                    rotation.y = 0;
                    rotation.z = Math.atan2(m21, m11);
                }
            }
            else if (order === math.RotationOrder.ZYX) {
                rotation.y = Math.asin(-clamp(m31, -1, 1));
                if (Math.abs(m31) < 0.9999999) {
                    rotation.x = Math.atan2(m32, m33);
                    rotation.z = Math.atan2(m21, m11);
                }
                else {
                    rotation.x = 0;
                    rotation.z = Math.atan2(-m12, m22);
                }
            }
            else if (order === math.RotationOrder.YZX) {
                rotation.z = Math.asin(clamp(m21, -1, 1));
                if (Math.abs(m21) < 0.9999999) {
                    rotation.x = Math.atan2(-m23, m22);
                    rotation.y = Math.atan2(-m31, m11);
                }
                else {
                    rotation.x = 0;
                    rotation.y = Math.atan2(m13, m33);
                }
            }
            else if (order === math.RotationOrder.XZY) {
                rotation.z = Math.asin(-clamp(m12, -1, 1));
                if (Math.abs(m12) < 0.9999999) {
                    rotation.x = Math.atan2(m32, m22);
                    rotation.y = Math.atan2(m13, m11);
                }
                else {
                    rotation.x = Math.atan2(-m23, m33);
                    rotation.y = 0;
                }
            }
            else {
                console.error("\u521D\u59CB\u5316\u77E9\u9635\u65F6\u9519\u8BEF\u65CB\u8F6C\u987A\u5E8F ".concat(order));
            }
        }
        math.matrixGetEuler = matrixGetEuler;
        function matrixGetRotation(src, result) {
            var xs = math.sign(src.rawData[0] * src.rawData[1] * src.rawData[2] * src.rawData[3]) < 0 ? -1 : 1;
            var ys = math.sign(src.rawData[4] * src.rawData[5] * src.rawData[6] * src.rawData[7]) < 0 ? -1 : 1;
            var zs = math.sign(src.rawData[8] * src.rawData[9] * src.rawData[10] * src.rawData[11]) < 0 ? -1 : 1;
            var scale_x = xs * Math.sqrt(src.rawData[0] * src.rawData[0] + src.rawData[1] * src.rawData[1] + src.rawData[2] * src.rawData[2]);
            var scale_y = ys * Math.sqrt(src.rawData[4] * src.rawData[4] + src.rawData[5] * src.rawData[5] + src.rawData[6] * src.rawData[6]);
            var scale_z = zs * Math.sqrt(src.rawData[8] * src.rawData[8] + src.rawData[9] * src.rawData[9] + src.rawData[10] * src.rawData[10]);
            var mat = math.pool.new_matrix();
            mat.rawData[0] = src.rawData[0] / scale_x;
            mat.rawData[1] = src.rawData[1] / scale_x;
            mat.rawData[2] = src.rawData[2] / scale_x;
            mat.rawData[3] = 0;
            mat.rawData[4] = src.rawData[4] / scale_y;
            mat.rawData[5] = src.rawData[5] / scale_y;
            mat.rawData[6] = src.rawData[6] / scale_y;
            mat.rawData[7] = 0;
            mat.rawData[8] = src.rawData[8] / scale_z;
            mat.rawData[9] = src.rawData[9] / scale_z;
            mat.rawData[10] = src.rawData[10] / scale_z;
            mat.rawData[11] = 0;
            matrix2Quaternion(mat, result);
            math.pool.delete_matrix(mat);
        }
        math.matrixGetRotation = matrixGetRotation;
        function matrix2Quaternion(matrix, result) {
            var data = matrix.rawData;
            var m11 = data[0], m12 = data[4], m13 = data[8];
            var m21 = data[1], m22 = data[5], m23 = data[9];
            var m31 = data[2], m32 = data[6], m33 = data[10];
            var trace = m11 + m22 + m33;
            var s;
            if (trace > 0) {
                s = 0.5 / Math.sqrt(trace + 1.0);
                result.w = 0.25 / s;
                result.x = (m32 - m23) * s;
                result.y = (m13 - m31) * s;
                result.z = (m21 - m12) * s;
            }
            else if (m11 > m22 && m11 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
                result.w = (m32 - m23) / s;
                result.x = 0.25 * s;
                result.y = (m12 + m21) / s;
                result.z = (m13 + m31) / s;
            }
            else if (m22 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
                result.w = (m13 - m31) / s;
                result.x = (m12 + m21) / s;
                result.y = 0.25 * s;
                result.z = (m23 + m32) / s;
            }
            else {
                s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
                result.w = (m21 - m12) / s;
                result.x = (m13 + m31) / s;
                result.y = (m23 + m32) / s;
                result.z = 0.25 * s;
            }
        }
        math.matrix2Quaternion = matrix2Quaternion;
        function unitxyzToRotation(xAxis, yAxis, zAxis, out) {
            var m11 = xAxis.x, m12 = yAxis.x, m13 = zAxis.x;
            var m21 = xAxis.y, m22 = yAxis.y, m23 = zAxis.y;
            var m31 = xAxis.z, m32 = yAxis.z, m33 = zAxis.z;
            var trace = m11 + m22 + m33;
            var s;
            if (trace > 0) {
                s = 0.5 / Math.sqrt(trace + 1.0);
                out.w = 0.25 / s;
                out.x = (m32 - m23) * s;
                out.y = (m13 - m31) * s;
                out.z = (m21 - m12) * s;
            }
            else if (m11 > m22 && m11 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
                out.w = (m32 - m23) / s;
                out.x = 0.25 * s;
                out.y = (m12 + m21) / s;
                out.z = (m13 + m31) / s;
            }
            else if (m22 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
                out.w = (m13 - m31) / s;
                out.x = (m12 + m21) / s;
                out.y = 0.25 * s;
                out.z = (m23 + m32) / s;
            }
            else {
                s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
                out.w = (m21 - m12) / s;
                out.x = (m13 + m31) / s;
                out.y = (m23 + m32) / s;
                out.z = 0.25 * s;
            }
        }
        math.unitxyzToRotation = unitxyzToRotation;
        function matrixClone(src, out) {
            for (var i = 0; i < 16; i++) {
                out.rawData[i] = src.rawData[i];
            }
            // out.rawData.set(src.rawData);
        }
        math.matrixClone = matrixClone;
        function matrix3x2Clone(src, out) {
            for (var i = 0; i < 6; i++) {
                out.rawData[i] = src.rawData[i];
            }
            // out.rawData.set(src.rawData);
        }
        math.matrix3x2Clone = matrix3x2Clone;
        function matrixMakeIdentity(out) {
            out.rawData[0] = 1;
            out.rawData[1] = 0;
            out.rawData[2] = 0;
            out.rawData[3] = 0;
            out.rawData[4] = 0;
            out.rawData[5] = 1;
            out.rawData[6] = 0;
            out.rawData[7] = 0;
            out.rawData[8] = 0;
            out.rawData[9] = 0;
            out.rawData[10] = 1;
            out.rawData[11] = 0;
            out.rawData[12] = 0;
            out.rawData[13] = 0;
            out.rawData[14] = 0;
            out.rawData[15] = 1;
        }
        math.matrixMakeIdentity = matrixMakeIdentity;
        function matrix3x2MakeIdentity(out) {
            out.rawData[0] = 1;
            out.rawData[1] = 0;
            out.rawData[2] = 0;
            out.rawData[3] = 1;
            out.rawData[4] = 0;
            out.rawData[5] = 0;
        }
        math.matrix3x2MakeIdentity = matrix3x2MakeIdentity;
        function matrixInverse(src, out) {
            var l1 = src.rawData[0];
            var l2 = src.rawData[1];
            var l3 = src.rawData[2];
            var l4 = src.rawData[3];
            var l5 = src.rawData[4];
            var l6 = src.rawData[5];
            var l7 = src.rawData[6];
            var l8 = src.rawData[7];
            var l9 = src.rawData[8];
            var l10 = src.rawData[9];
            var l11 = src.rawData[10];
            var l12 = src.rawData[11];
            var l13 = src.rawData[12];
            var l14 = src.rawData[13];
            var l15 = src.rawData[14];
            var l16 = src.rawData[15];
            var l17 = (l11 * l16) - (l12 * l15);
            var l18 = (l10 * l16) - (l12 * l14);
            var l19 = (l10 * l15) - (l11 * l14);
            var l20 = (l9 * l16) - (l12 * l13);
            var l21 = (l9 * l15) - (l11 * l13);
            var l22 = (l9 * l14) - (l10 * l13);
            var l23 = ((l6 * l17) - (l7 * l18)) + (l8 * l19);
            var l24 = -(((l5 * l17) - (l7 * l20)) + (l8 * l21));
            var l25 = ((l5 * l18) - (l6 * l20)) + (l8 * l22);
            var l26 = -(((l5 * l19) - (l6 * l21)) + (l7 * l22));
            var l27 = 1.0 / ((((l1 * l23) + (l2 * l24)) + (l3 * l25)) + (l4 * l26));
            var l28 = (l7 * l16) - (l8 * l15);
            var l29 = (l6 * l16) - (l8 * l14);
            var l30 = (l6 * l15) - (l7 * l14);
            var l31 = (l5 * l16) - (l8 * l13);
            var l32 = (l5 * l15) - (l7 * l13);
            var l33 = (l5 * l14) - (l6 * l13);
            var l34 = (l7 * l12) - (l8 * l11);
            var l35 = (l6 * l12) - (l8 * l10);
            var l36 = (l6 * l11) - (l7 * l10);
            var l37 = (l5 * l12) - (l8 * l9);
            var l38 = (l5 * l11) - (l7 * l9);
            var l39 = (l5 * l10) - (l6 * l9);
            out.rawData[0] = l23 * l27;
            out.rawData[4] = l24 * l27;
            out.rawData[8] = l25 * l27;
            out.rawData[12] = l26 * l27;
            out.rawData[1] = -(((l2 * l17) - (l3 * l18)) + (l4 * l19)) * l27;
            out.rawData[5] = (((l1 * l17) - (l3 * l20)) + (l4 * l21)) * l27;
            out.rawData[9] = -(((l1 * l18) - (l2 * l20)) + (l4 * l22)) * l27;
            out.rawData[13] = (((l1 * l19) - (l2 * l21)) + (l3 * l22)) * l27;
            out.rawData[2] = (((l2 * l28) - (l3 * l29)) + (l4 * l30)) * l27;
            out.rawData[6] = -(((l1 * l28) - (l3 * l31)) + (l4 * l32)) * l27;
            out.rawData[10] = (((l1 * l29) - (l2 * l31)) + (l4 * l33)) * l27;
            out.rawData[14] = -(((l1 * l30) - (l2 * l32)) + (l3 * l33)) * l27;
            out.rawData[3] = -(((l2 * l34) - (l3 * l35)) + (l4 * l36)) * l27;
            out.rawData[7] = (((l1 * l34) - (l3 * l37)) + (l4 * l38)) * l27;
            out.rawData[11] = -(((l1 * l35) - (l2 * l37)) + (l4 * l39)) * l27;
            out.rawData[15] = (((l1 * l36) - (l2 * l38)) + (l3 * l39)) * l27;
        }
        math.matrixInverse = matrixInverse;
        function matrix3x2Inverse(src, out) {
            var l1 = src.rawData[0];
            var l2 = src.rawData[1];
            var l5 = src.rawData[2];
            var l6 = src.rawData[3];
            var l13 = src.rawData[4];
            var l14 = src.rawData[5];
            var l26 = -(((l5 * -l14) - (l6 * -l13)));
            var l27 = 1.0 / ((((l1 * l6) + (l2 * -l5))));
            out.rawData[0] = l6 * l27;
            out.rawData[2] = -l5 * l27;
            out.rawData[4] = l26 * l27;
            out.rawData[1] = -(((l2))) * l27;
            out.rawData[3] = (((l1))) * l27;
            out.rawData[5] = (((l1 * -l14) - (l2 * -l13))) * l27;
            // var m0=src.rawData[0];
            // var m1=src.rawData[1];
            // var m2=0;
            // var m3=src.rawData[2];
            // var m4=src.rawData[3];
            // var m5=0;
            // var m6=src.rawData[4];
            // var m7=src.rawData[5];
            // var m8=1;
            // var Determinant=m0 * (m4 * m8 - m5 * m7)- m1 * (m3 * m8 - m5 * m6)+m2 * (m3 * m7 - m4 * m6);
            // out[0]=(m4 * m8 - m5 * m7)/Determinant;
            // out[1]=-(m1 * m8 -m2 * m7)/Determinant;
            // out[2]=-(m3 * m8 - m5 * m6)/Determinant;
            // out[3]=(m0 * m8 -m2 * m6)/Determinant;
            // out[4]=(m3 * m7 - m4 * m6)/Determinant;
            // out[5]=-(m0 * m7 - m1 * m6)/Determinant;
        }
        math.matrix3x2Inverse = matrix3x2Inverse;
        function matrixMakeTransformRTS(pos, scale, rot, out) {
            var matS = m4m.math.pool.new_matrix();
            matrixMakeScale(scale.x, scale.y, scale.z, matS);
            var matR = m4m.math.pool.new_matrix();
            math.quatToMatrix(rot, matR);
            matrixMultiply(matR, matS, out);
            out.rawData[12] = pos.x;
            out.rawData[13] = pos.y;
            out.rawData[14] = pos.z;
            out.rawData[15] = 1;
            m4m.math.pool.delete_matrix(matS);
            m4m.math.pool.delete_matrix(matR);
        }
        math.matrixMakeTransformRTS = matrixMakeTransformRTS;
        function matrix3x2MakeTransformRTS(pos, scale, rot, out) {
            var matS = m4m.math.pool.new_matrix3x2();
            matrix3x2MakeScale(scale.x, scale.y, matS);
            var matR = m4m.math.pool.new_matrix3x2();
            matrix3x2MakeRotate(rot, matR);
            matrix3x2Multiply(matR, matS, out);
            out.rawData[4] = pos.x;
            out.rawData[5] = pos.y;
            m4m.math.pool.delete_matrix3x2(matS);
            m4m.math.pool.delete_matrix3x2(matR);
        }
        math.matrix3x2MakeTransformRTS = matrix3x2MakeTransformRTS;
        function matrixMakeTranslate(x, y, z, out) {
            out.rawData[0] = 1.0;
            out.rawData[1] = 0.0;
            out.rawData[2] = 0.0;
            out.rawData[3] = 0;
            out.rawData[4] = 0.0;
            out.rawData[5] = 1.0;
            out.rawData[6] = 0.0;
            out.rawData[7] = 0.0;
            out.rawData[8] = 0.0;
            out.rawData[9] = 0.0;
            out.rawData[10] = 1.0;
            out.rawData[11] = 0.0;
            out.rawData[12] = x;
            out.rawData[13] = y;
            out.rawData[14] = z;
            out.rawData[15] = 1.0;
        }
        math.matrixMakeTranslate = matrixMakeTranslate;
        function matrix3x2MakeTranslate(x, y, out) {
            out.rawData[0] = 1.0;
            out.rawData[1] = 0.0;
            out.rawData[2] = 0.0;
            out.rawData[3] = 1.0;
            out.rawData[4] = x;
            out.rawData[5] = y;
        }
        math.matrix3x2MakeTranslate = matrix3x2MakeTranslate;
        function matrixGetScale(src, scale) {
            var xs = math.sign(src.rawData[0] * src.rawData[1] * src.rawData[2] * src.rawData[3]) < 0 ? -1 : 1;
            var ys = math.sign(src.rawData[4] * src.rawData[5] * src.rawData[6] * src.rawData[7]) < 0 ? -1 : 1;
            var zs = math.sign(src.rawData[8] * src.rawData[9] * src.rawData[10] * src.rawData[11]) < 0 ? -1 : 1;
            scale.x = xs * Math.sqrt(src.rawData[0] * src.rawData[0] + src.rawData[1] * src.rawData[1] + src.rawData[2] * src.rawData[2]);
            scale.y = ys * Math.sqrt(src.rawData[4] * src.rawData[4] + src.rawData[5] * src.rawData[5] + src.rawData[6] * src.rawData[6]);
            scale.z = zs * Math.sqrt(src.rawData[8] * src.rawData[8] + src.rawData[9] * src.rawData[9] + src.rawData[10] * src.rawData[10]);
            // scale.rawData[0] = xs * Math.sqrt(src.rawData[0] * src.rawData[0] + src.rawData[1] * src.rawData[1] + src.rawData[2] * src.rawData[2]);
            // scale.rawData[1] = ys * Math.sqrt(src.rawData[4] * src.rawData[4] + src.rawData[5] * src.rawData[5] + src.rawData[6] * src.rawData[6]);
            // scale.rawData[2] = zs * Math.sqrt(src.rawData[8] * src.rawData[8] + src.rawData[9] * src.rawData[9] + src.rawData[10] * src.rawData[10]);
        }
        math.matrixGetScale = matrixGetScale;
        function matrixMakeScale(xScale, yScale, zScale, out) {
            out.rawData[0] = xScale;
            out.rawData[1] = 0.0;
            out.rawData[2] = 0.0;
            out.rawData[3] = 0.0;
            out.rawData[4] = 0.0;
            out.rawData[5] = yScale;
            out.rawData[6] = 0.0;
            out.rawData[7] = 0.0;
            out.rawData[8] = 0.0;
            out.rawData[9] = 0.0;
            out.rawData[10] = zScale;
            out.rawData[11] = 0.0;
            out.rawData[12] = 0.0;
            out.rawData[13] = 0.0;
            out.rawData[14] = 0.0;
            out.rawData[15] = 1.0;
        }
        math.matrixMakeScale = matrixMakeScale;
        function matrix3x2TransformVector2(mat, inp, out) {
            var x = inp.x * mat.rawData[0] + inp.y * mat.rawData[2] + mat.rawData[4];
            var y = inp.x * mat.rawData[1] + inp.y * mat.rawData[3] + mat.rawData[5];
            out.x = x;
            out.y = y;
        }
        math.matrix3x2TransformVector2 = matrix3x2TransformVector2;
        function matrix3x2TransformNormal(mat, inp, out) {
            var x = inp.x * mat.rawData[0] + inp.y * mat.rawData[2];
            var y = inp.x * mat.rawData[1] + inp.y * mat.rawData[3];
            out.x = x;
            out.y = y;
        }
        math.matrix3x2TransformNormal = matrix3x2TransformNormal;
        function matrix3x2MakeScale(xScale, yScale, out) {
            out.rawData[0] = xScale;
            out.rawData[1] = 0.0;
            out.rawData[2] = 0.0;
            out.rawData[3] = yScale;
            out.rawData[4] = 0.0;
            out.rawData[5] = 0.0;
        }
        math.matrix3x2MakeScale = matrix3x2MakeScale;
        /**
         * 从欧拉旋转初始化矩阵
         *
         * @param rotation 旋转弧度值
         * @param order 旋转顺序
         * @param out 输出矩阵
         */
        function matrixMakeEuler(rotation, order, out) {
            var te = out.rawData;
            //
            var rx = rotation.x;
            var ry = rotation.y;
            var rz = rotation.z;
            //
            var cosX = Math.cos(rx), sinX = Math.sin(rx);
            var cosY = Math.cos(ry), sinY = Math.sin(ry);
            var cosZ = Math.cos(rz), sinZ = Math.sin(rz);
            if (order === math.RotationOrder.XYZ) {
                var ae = cosX * cosZ, af = cosX * sinZ, be = sinX * cosZ, bf = sinX * sinZ;
                te[0] = cosY * cosZ;
                te[4] = -cosY * sinZ;
                te[8] = sinY;
                te[1] = af + be * sinY;
                te[5] = ae - bf * sinY;
                te[9] = -sinX * cosY;
                te[2] = bf - ae * sinY;
                te[6] = be + af * sinY;
                te[10] = cosX * cosY;
            }
            else if (order === math.RotationOrder.YXZ) {
                var ce = cosY * cosZ, cf = cosY * sinZ, de = sinY * cosZ, df = sinY * sinZ;
                te[0] = ce + df * sinX;
                te[4] = de * sinX - cf;
                te[8] = cosX * sinY;
                te[1] = cosX * sinZ;
                te[5] = cosX * cosZ;
                te[9] = -sinX;
                te[2] = cf * sinX - de;
                te[6] = df + ce * sinX;
                te[10] = cosX * cosY;
            }
            else if (order === math.RotationOrder.ZXY) {
                var ce = cosY * cosZ, cf = cosY * sinZ, de = sinY * cosZ, df = sinY * sinZ;
                te[0] = ce - df * sinX;
                te[4] = -cosX * sinZ;
                te[8] = de + cf * sinX;
                te[1] = cf + de * sinX;
                te[5] = cosX * cosZ;
                te[9] = df - ce * sinX;
                te[2] = -cosX * sinY;
                te[6] = sinX;
                te[10] = cosX * cosY;
            }
            else if (order === math.RotationOrder.ZYX) {
                var ae = cosX * cosZ, af = cosX * sinZ, be = sinX * cosZ, bf = sinX * sinZ;
                te[0] = cosY * cosZ;
                te[4] = be * sinY - af;
                te[8] = ae * sinY + bf;
                te[1] = cosY * sinZ;
                te[5] = bf * sinY + ae;
                te[9] = af * sinY - be;
                te[2] = -sinY;
                te[6] = sinX * cosY;
                te[10] = cosX * cosY;
            }
            else if (order === math.RotationOrder.YZX) {
                var ac = cosX * cosY, ad = cosX * sinY, bc = sinX * cosY, bd = sinX * sinY;
                te[0] = cosY * cosZ;
                te[4] = bd - ac * sinZ;
                te[8] = bc * sinZ + ad;
                te[1] = sinZ;
                te[5] = cosX * cosZ;
                te[9] = -sinX * cosZ;
                te[2] = -sinY * cosZ;
                te[6] = ad * sinZ + bc;
                te[10] = ac - bd * sinZ;
            }
            else if (order === math.RotationOrder.XZY) {
                var ac = cosX * cosY, ad = cosX * sinY, bc = sinX * cosY, bd = sinX * sinY;
                te[0] = cosY * cosZ;
                te[4] = -sinZ;
                te[8] = sinY * cosZ;
                te[1] = ac * sinZ + bd;
                te[5] = cosX * cosZ;
                te[9] = ad * sinZ - bc;
                te[2] = bc * sinZ - ad;
                te[6] = sinX * cosZ;
                te[10] = bd * sinZ + ac;
            }
            else {
                console.error("\u521D\u59CB\u5316\u77E9\u9635\u65F6\u9519\u8BEF\u65CB\u8F6C\u987A\u5E8F ".concat(order));
            }
        }
        math.matrixMakeEuler = matrixMakeEuler;
        function matrixMakeRotateAxisAngle(axis, angle, out) {
            var x = axis.x, y = axis.y, z = axis.z;
            var length = Math.sqrt(x * x + y * y + z * z);
            if (!length)
                return;
            if (length !== 1) {
                length = 1 / length;
                x *= length;
                y *= length;
                z *= length;
            }
            var s = Math.sin(angle);
            var c = Math.cos(angle);
            var t = 1.0 - c;
            var b00 = x * x * t + c, b01 = y * x * t + z * s, b02 = z * x * t - y * s, b10 = x * y * t - z * s, b11 = y * y * t + c, b12 = z * y * t + x * s, b20 = x * z * t + y * s, b21 = y * z * t - x * s, b22 = z * z * t + c;
            out.rawData[0] = b00;
            out.rawData[1] = b01;
            out.rawData[2] = b02;
            out.rawData[3] = 0;
            out.rawData[4] = b10;
            out.rawData[5] = b11;
            out.rawData[6] = b12;
            out.rawData[7] = 0;
            out.rawData[8] = b20;
            out.rawData[9] = b21;
            out.rawData[10] = b22;
            out.rawData[11] = 0;
            out.rawData[12] = 0;
            out.rawData[13] = 0;
            out.rawData[14] = 0;
            out.rawData[15] = 1;
        }
        math.matrixMakeRotateAxisAngle = matrixMakeRotateAxisAngle;
        function matrix3x2MakeRotate(angle, out) {
            var x = 0, y = 0, z = 1;
            var s = Math.sin(angle);
            var c = Math.cos(angle);
            out.rawData[0] = c;
            out.rawData[1] = s;
            out.rawData[2] = -s;
            out.rawData[3] = c;
            out.rawData[4] = 0;
            out.rawData[5] = 0;
        }
        math.matrix3x2MakeRotate = matrix3x2MakeRotate;
        function matrixMultiply(lhs, rhs, out) {
            var a00 = lhs.rawData[0], a01 = lhs.rawData[1], a02 = lhs.rawData[2], a03 = lhs.rawData[3];
            var a10 = lhs.rawData[4], a11 = lhs.rawData[5], a12 = lhs.rawData[6], a13 = lhs.rawData[7];
            var a20 = lhs.rawData[8], a21 = lhs.rawData[9], a22 = lhs.rawData[10], a23 = lhs.rawData[11];
            var a30 = lhs.rawData[12], a31 = lhs.rawData[13], a32 = lhs.rawData[14], a33 = lhs.rawData[15];
            var b0 = rhs.rawData[0], b1 = rhs.rawData[1], b2 = rhs.rawData[2], b3 = rhs.rawData[3];
            out.rawData[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out.rawData[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out.rawData[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out.rawData[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            b0 = rhs.rawData[4];
            b1 = rhs.rawData[5];
            b2 = rhs.rawData[6];
            b3 = rhs.rawData[7];
            out.rawData[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out.rawData[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out.rawData[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out.rawData[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            b0 = rhs.rawData[8];
            b1 = rhs.rawData[9];
            b2 = rhs.rawData[10];
            b3 = rhs.rawData[11];
            out.rawData[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out.rawData[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out.rawData[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out.rawData[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            b0 = rhs.rawData[12];
            b1 = rhs.rawData[13];
            b2 = rhs.rawData[14];
            b3 = rhs.rawData[15];
            out.rawData[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out.rawData[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out.rawData[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out.rawData[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            //var m111: number = rhs.rawData[0], m121: number = rhs.rawData[4], m131: number = rhs.rawData[8], m141: number = rhs.rawData[12];
            //var m112: number = rhs.rawData[1], m122: number = rhs.rawData[5], m132: number = rhs.rawData[9], m142: number = rhs.rawData[13];
            //var m113: number = rhs.rawData[2], m123: number = rhs.rawData[6], m133: number = rhs.rawData[10], m143: number = rhs.rawData[14];
            //var m114: number = rhs.rawData[3], m124: number = rhs.rawData[7], m134: number = rhs.rawData[11], m144: number = rhs.rawData[15];
            //var m211: number = lhs.rawData[0], m221: number = lhs.rawData[4], m231: number = lhs.rawData[8], m241: number = lhs.rawData[12];
            //var m212: number = lhs.rawData[1], m222: number = lhs.rawData[5], m232: number = lhs.rawData[9], m242: number = lhs.rawData[13];
            //var m213: number = lhs.rawData[2], m223: number = lhs.rawData[6], m233: number = lhs.rawData[10], m243: number = lhs.rawData[14];
            //var m214: number = lhs.rawData[3], m224: number = lhs.rawData[7], m234: number = lhs.rawData[11], m244: number = lhs.rawData[15];
            //out.rawData[0] = m111 * m211 + m112 * m221 + m113 * m231 + m114 * m241;
            //out.rawData[1] = m111 * m212 + m112 * m222 + m113 * m232 + m114 * m242;
            //out.rawData[2] = m111 * m213 + m112 * m223 + m113 * m233 + m114 * m243;
            //out.rawData[3] = m111 * m214 + m112 * m224 + m113 * m234 + m114 * m244;
            //out.rawData[4] = m121 * m211 + m122 * m221 + m123 * m231 + m124 * m241;
            //out.rawData[5] = m121 * m212 + m122 * m222 + m123 * m232 + m124 * m242;
            //out.rawData[6] = m121 * m213 + m122 * m223 + m123 * m233 + m124 * m243;
            //out.rawData[7] = m121 * m214 + m122 * m224 + m123 * m234 + m124 * m244;
            //out.rawData[8] = m131 * m211 + m132 * m221 + m133 * m231 + m134 * m241;
            //out.rawData[9] = m131 * m212 + m132 * m222 + m133 * m232 + m134 * m242;
            //out.rawData[10] = m131 * m213 + m132 * m223 + m133 * m233 + m134 * m243;
            //out.rawData[11] = m131 * m214 + m132 * m224 + m133 * m234 + m134 * m244;
            //out.rawData[12] = m141 * m211 + m142 * m221 + m143 * m231 + m144 * m241;
            //out.rawData[13] = m141 * m212 + m142 * m222 + m143 * m232 + m144 * m242;
            //out.rawData[14] = m141 * m213 + m142 * m223 + m143 * m233 + m144 * m243;
            //out.rawData[15] = m141 * m214 + m142 * m224 + m143 * m234 + m144 * m244;
        }
        math.matrixMultiply = matrixMultiply;
        function matrix3x2Multiply(lhs, rhs, out) {
            var a00 = lhs.rawData[0], a01 = lhs.rawData[1], a02 = 0;
            var a10 = lhs.rawData[2], a11 = lhs.rawData[3], a12 = 0;
            var a30 = lhs.rawData[4], a31 = lhs.rawData[5], a32 = 1;
            var b0 = rhs.rawData[0], b1 = rhs.rawData[1], b3 = 0;
            var temp_0 = b0 * a00 + b1 * a10 + b3 * a30;
            var temp_1 = b0 * a01 + b1 * a11 + b3 * a31;
            b0 = rhs.rawData[2];
            b1 = rhs.rawData[3];
            b3 = 0;
            var temp_2 = b0 * a00 + b1 * a10 + b3 * a30;
            var temp_3 = b0 * a01 + b1 * a11 + b3 * a31;
            b0 = rhs.rawData[4];
            b1 = rhs.rawData[5];
            b3 = 1;
            var temp_4 = b0 * a00 + b1 * a10 + b3 * a30;
            var temp_5 = b0 * a01 + b1 * a11 + b3 * a31;
            out.rawData[0] = temp_0;
            out.rawData[1] = temp_1;
            out.rawData[2] = temp_2;
            out.rawData[3] = temp_3;
            out.rawData[4] = temp_4;
            out.rawData[5] = temp_5;
        }
        math.matrix3x2Multiply = matrix3x2Multiply;
        function matrix3x2Equal(mtx1, mtx2, threshold) {
            if (threshold === void 0) { threshold = 0.00001; }
            for (var i = 0; i < 6; i++) {
                if (Math.abs(mtx1.rawData[i] - mtx2.rawData[i]) > threshold) {
                    return false;
                }
            }
            return true;
        }
        math.matrix3x2Equal = matrix3x2Equal;
        function matrixProject_PerspectiveLH(fov, aspect, znear, zfar, out) {
            var tan = 1.0 / (Math.tan(fov * 0.5));
            out.rawData[0] = tan / aspect;
            out.rawData[1] = out.rawData[2] = out.rawData[3] = 0.0;
            out.rawData[4] = out.rawData[6] = out.rawData[7] = 0.0;
            out.rawData[5] = tan;
            out.rawData[8] = out.rawData[9] = 0.0;
            out.rawData[10] = -zfar / (znear - zfar);
            //out.rawData[10] = (zfar+znear) / (zfar - znear);//-1~1
            //out.rawData[10] = 1/(zfar-znear);//0~1
            out.rawData[11] = 1.0;
            out.rawData[12] = out.rawData[13] = out.rawData[15] = 0.0;
            out.rawData[14] = (znear * zfar) / (znear - zfar);
            //out.rawData[14] = 2*zfar*znear/(znear-zfar);
            //out.rawData[14] =znear/(znear-zfar);
        }
        math.matrixProject_PerspectiveLH = matrixProject_PerspectiveLH;
        function matrixProject_OrthoLH(width, height, znear, zfar, out) {
            var hw = 2.0 / width;
            var hh = 2.0 / height;
            var id = 2.0 / (zfar - znear); //-2.0 / (zfar - znear); 为毛是反的 ヽ(●-`Д´-)ノ
            var nid = (zfar + znear) / (znear - zfar);
            out.rawData[0] = hw;
            out.rawData[1] = 0;
            out.rawData[2] = 0;
            out.rawData[3] = 0;
            out.rawData[4] = 0;
            out.rawData[5] = hh;
            out.rawData[6] = 0;
            out.rawData[7] = 0;
            out.rawData[8] = 0;
            out.rawData[9] = 0;
            out.rawData[10] = id;
            out.rawData[11] = 0;
            out.rawData[12] = 0;
            out.rawData[13] = 0;
            out.rawData[14] = nid;
            out.rawData[15] = 1;
        }
        math.matrixProject_OrthoLH = matrixProject_OrthoLH;
        /**
         * 看向目标位置
         *
         * @param position  所在位置
         * @param target    目标位置
         * @param upAxis    向上朝向
         */
        function matrixLookat(position, target, upAxis, out) {
            //
            var xAxis = new math.vector3();
            var yAxis = new math.vector3();
            var zAxis = new math.vector3();
            upAxis = upAxis || new math.vector3(0, 1, 0);
            zAxis.x = target.x - position.x;
            zAxis.y = target.y - position.y;
            zAxis.z = target.z - position.z;
            math.vec3Normalize(zAxis, zAxis);
            xAxis.x = upAxis.y * zAxis.z - upAxis.z * zAxis.y;
            xAxis.y = upAxis.z * zAxis.x - upAxis.x * zAxis.z;
            xAxis.z = upAxis.x * zAxis.y - upAxis.y * zAxis.x;
            math.vec3Normalize(xAxis, xAxis);
            if (math.vec3SqrLength(xAxis) < .005) {
                xAxis.x = upAxis.y;
                xAxis.y = upAxis.x;
                xAxis.z = 0;
                math.vec3Normalize(xAxis, xAxis);
            }
            yAxis.x = zAxis.y * xAxis.z - zAxis.z * xAxis.y;
            yAxis.y = zAxis.z * xAxis.x - zAxis.x * xAxis.z;
            yAxis.z = zAxis.x * xAxis.y - zAxis.y * xAxis.x;
            out.rawData[0] = xAxis.x;
            out.rawData[1] = xAxis.y;
            out.rawData[2] = xAxis.z;
            out.rawData[3] = 0;
            out.rawData[4] = yAxis.x;
            out.rawData[5] = yAxis.y;
            out.rawData[6] = yAxis.z;
            out.rawData[7] = 0;
            out.rawData[8] = zAxis.x;
            out.rawData[9] = zAxis.y;
            out.rawData[10] = zAxis.z;
            out.rawData[11] = 0;
            out.rawData[12] = position.x;
            out.rawData[13] = position.y;
            out.rawData[14] = position.z;
            out.rawData[15] = 1;
        }
        math.matrixLookat = matrixLookat;
        //lights fix
        function matrixLookatLH(forward, up, out) {
            // Z axis
            var z = math.pool.new_vector3(-forward.x, -forward.y, -forward.z);
            math.vec3Normalize(z, z);
            var y = math.pool.new_vector3();
            math.vec3Clone(up, y);
            math.vec3Normalize(y, y);
            // X axis
            var x = math.pool.new_vector3();
            math.vec3Cross(y, z, x);
            math.vec3SqrLength(x);
            if (math.vec3SqrLength(x) == 0) {
                x.x = 1;
            }
            else {
                math.vec3Normalize(x, x);
            }
            // Y axis
            math.vec3Clone(math.pool.vector3_zero, y);
            math.vec3Cross(z, x, y);
            math.vec3Normalize(y, y);
            out.rawData[0] = x.x;
            out.rawData[1] = y.x;
            out.rawData[2] = z.x;
            out.rawData[3] = 0;
            out.rawData[4] = x.y;
            out.rawData[5] = y.y;
            out.rawData[6] = z.y;
            out.rawData[7] = 0;
            out.rawData[8] = x.z;
            out.rawData[9] = y.z;
            out.rawData[10] = z.z;
            out.rawData[11] = 0;
            out.rawData[12] = 0;
            out.rawData[13] = 0;
            out.rawData[14] = 0;
            out.rawData[15] = 1;
            math.pool.delete_vector3(x);
            math.pool.delete_vector3(y);
            math.pool.delete_vector3(z);
        }
        math.matrixLookatLH = matrixLookatLH;
        function matrixViewLookatLH(eye, forward, up, out) {
            // Z axis
            var z = math.pool.new_vector3(forward.x, forward.y, forward.z);
            math.vec3Normalize(z, z);
            var y = math.pool.new_vector3();
            math.vec3Clone(up, y);
            math.vec3Normalize(y, y);
            // X axis
            var x = math.pool.new_vector3();
            math.vec3Cross(y, z, x);
            math.vec3SqrLength(x);
            if (math.vec3SqrLength(x) == 0) {
                x.x = 1;
            }
            else {
                math.vec3Normalize(x, x);
            }
            // Y axis
            math.vec3Clone(math.pool.vector3_zero, y);
            math.vec3Cross(z, x, y);
            math.vec3Normalize(y, y);
            // Eye angles
            var ex = -math.vec3Dot(x, eye);
            var ey = -math.vec3Dot(y, eye);
            var ez = -math.vec3Dot(z, eye);
            out.rawData[0] = x.x;
            out.rawData[1] = y.x;
            out.rawData[2] = z.x;
            out.rawData[3] = 0;
            out.rawData[4] = x.y;
            out.rawData[5] = y.y;
            out.rawData[6] = z.y;
            out.rawData[7] = 0;
            out.rawData[8] = x.z;
            out.rawData[9] = y.z;
            out.rawData[10] = z.z;
            out.rawData[11] = 0;
            out.rawData[12] = ex;
            out.rawData[13] = ey;
            out.rawData[14] = ez;
            out.rawData[15] = 1;
            math.pool.delete_vector3(x);
            math.pool.delete_vector3(y);
            math.pool.delete_vector3(z);
        }
        math.matrixViewLookatLH = matrixViewLookatLH;
        function matrixLerp(left, right, v, out) {
            for (var i = 0; i < 16; i++) {
                out.rawData[i] = left.rawData[i] * (1 - v) + right.rawData[i] * v;
            }
        }
        math.matrixLerp = matrixLerp;
        function matrixTransformVector3(vector, transformation, result) {
            var x = (vector.x * transformation.rawData[0]) + (vector.y * transformation.rawData[4]) + (vector.z * transformation.rawData[8]) + transformation.rawData[12];
            var y = (vector.x * transformation.rawData[1]) + (vector.y * transformation.rawData[5]) + (vector.z * transformation.rawData[9]) + transformation.rawData[13];
            var z = (vector.x * transformation.rawData[2]) + (vector.y * transformation.rawData[6]) + (vector.z * transformation.rawData[10]) + transformation.rawData[14];
            var w = (vector.x * transformation.rawData[3]) + (vector.y * transformation.rawData[7]) + (vector.z * transformation.rawData[11]) + transformation.rawData[15];
            result.x = x / w;
            result.y = y / w;
            result.z = z / w;
            // result.rawData[0] = x / w;
            // result.rawData[1] = y / w;
            // result.rawData[2] = z / w;
        }
        math.matrixTransformVector3 = matrixTransformVector3;
        function matrixTransformVector4(src, mtx, out) {
            out.x = (src.x * mtx.rawData[0]) + (src.y * mtx.rawData[4]) + (src.z * mtx.rawData[8]) + (src.w * mtx.rawData[12]);
            out.y = (src.x * mtx.rawData[1]) + (src.y * mtx.rawData[5]) + (src.z * mtx.rawData[9]) + (src.w * mtx.rawData[13]);
            out.z = (src.x * mtx.rawData[2]) + (src.y * mtx.rawData[6]) + (src.z * mtx.rawData[10]) + (src.w * mtx.rawData[14]);
            out.w = (src.x * mtx.rawData[3]) + (src.y * mtx.rawData[7]) + (src.z * mtx.rawData[11]) + (src.w * mtx.rawData[15]);
            // let x = (src.rawData[0] * mtx.rawData[0]) + (src.rawData[1] * mtx.rawData[4]) + (src.rawData[2] * mtx.rawData[8]) +  (src.rawData[3] * mtx.rawData[12]);
            // let y = (src.rawData[0] * mtx.rawData[1]) + (src.rawData[1] * mtx.rawData[5]) + (src.rawData[2] * mtx.rawData[9]) +  (src.rawData[3] * mtx.rawData[13]);
            // let z = (src.rawData[0] * mtx.rawData[2]) + (src.rawData[1] * mtx.rawData[6]) + (src.rawData[2] * mtx.rawData[10]) + (src.rawData[3] * mtx.rawData[14]);
            // let w = (src.rawData[0] * mtx.rawData[3]) + (src.rawData[1] * mtx.rawData[7]) + (src.rawData[2] * mtx.rawData[11]) + (src.rawData[3] * mtx.rawData[15]);
            // out.rawData[0] = x; out.rawData[1] = y; out.rawData[2] = z; out.rawData[3] = w;
        }
        math.matrixTransformVector4 = matrixTransformVector4;
        //变换向量
        function matrixTransformNormal(vector, transformation, result) {
            var x = (vector.x * transformation.rawData[0]) + (vector.y * transformation.rawData[4]) + (vector.z * transformation.rawData[8]);
            var y = (vector.x * transformation.rawData[1]) + (vector.y * transformation.rawData[5]) + (vector.z * transformation.rawData[9]);
            var z = (vector.x * transformation.rawData[2]) + (vector.y * transformation.rawData[6]) + (vector.z * transformation.rawData[10]);
            result.x = x;
            result.y = y;
            result.z = z;
            // result.rawData[0] = x;
            // result.rawData[1] = y;
            // result.rawData[2] = z;
        }
        math.matrixTransformNormal = matrixTransformNormal;
        function matrixGetVector3ByOffset(src, offset, result) {
            result.x = src.rawData[offset];
            result.y = src.rawData[offset + 1];
            result.z = src.rawData[offset + 2];
            // result.rawData[0] = src.rawData[offset];
            // result.rawData[1] = src.rawData[offset + 1];
            // result.rawData[2] = src.rawData[offset + 2]
        }
        math.matrixGetVector3ByOffset = matrixGetVector3ByOffset;
        function matrixReset(mat) {
            mat.rawData[0] = 1;
            mat.rawData[1] = 0;
            mat.rawData[2] = 0;
            mat.rawData[3] = 0;
            mat.rawData[4] = 0;
            mat.rawData[5] = 1;
            mat.rawData[6] = 0;
            mat.rawData[7] = 0;
            mat.rawData[8] = 0;
            mat.rawData[9] = 0;
            mat.rawData[10] = 1;
            mat.rawData[11] = 0;
            mat.rawData[12] = 0;
            mat.rawData[13] = 0;
            mat.rawData[14] = 0;
            mat.rawData[15] = 1;
        }
        math.matrixReset = matrixReset;
        function matrixZero(mat) {
            mat.rawData[0] = 0;
            mat.rawData[1] = 0;
            mat.rawData[2] = 0;
            mat.rawData[3] = 0;
            mat.rawData[4] = 0;
            mat.rawData[5] = 0;
            mat.rawData[6] = 0;
            mat.rawData[7] = 0;
            mat.rawData[8] = 0;
            mat.rawData[9] = 0;
            mat.rawData[10] = 0;
            mat.rawData[11] = 0;
            mat.rawData[12] = 0;
            mat.rawData[13] = 0;
            mat.rawData[14] = 0;
            mat.rawData[15] = 1;
        }
        math.matrixZero = matrixZero;
        function matrixScaleByNum(value, mat) {
            mat.rawData[0] *= value;
            mat.rawData[1] *= value;
            mat.rawData[2] *= value;
            mat.rawData[3] *= value;
            mat.rawData[4] *= value;
            mat.rawData[5] *= value;
            mat.rawData[6] *= value;
            mat.rawData[7] *= value;
            mat.rawData[8] *= value;
            mat.rawData[9] *= value;
            mat.rawData[10] *= value;
            mat.rawData[11] *= value;
            mat.rawData[12] *= value;
            mat.rawData[13] *= value;
            mat.rawData[14] *= value;
            mat.rawData[15] *= value;
        }
        math.matrixScaleByNum = matrixScaleByNum;
        function matrixAdd(left, right, out) {
            out.rawData[0] = left.rawData[0] + right.rawData[0];
            out.rawData[1] = left.rawData[1] + right.rawData[1];
            out.rawData[2] = left.rawData[2] + right.rawData[2];
            out.rawData[3] = left.rawData[3] + right.rawData[3];
            out.rawData[4] = left.rawData[4] + right.rawData[4];
            out.rawData[5] = left.rawData[5] + right.rawData[5];
            out.rawData[6] = left.rawData[6] + right.rawData[6];
            out.rawData[7] = left.rawData[7] + right.rawData[7];
            out.rawData[8] = left.rawData[8] + right.rawData[8];
            out.rawData[9] = left.rawData[9] + right.rawData[9];
            out.rawData[10] = left.rawData[10] + right.rawData[10];
            out.rawData[11] = left.rawData[11] + right.rawData[11];
            out.rawData[12] = left.rawData[12] + right.rawData[12];
            out.rawData[13] = left.rawData[13] + right.rawData[13];
            out.rawData[14] = left.rawData[14] + right.rawData[14];
            out.rawData[15] = left.rawData[15] + right.rawData[15];
        }
        math.matrixAdd = matrixAdd;
        function matrixEqual(mtx1, mtx2, threshold) {
            if (threshold === void 0) { threshold = 0.00001; }
            for (var i = 0; i < 16; i++) {
                if (Math.abs(mtx1.rawData[i] - mtx2.rawData[i]) > threshold) {
                    return false;
                }
            }
            return true;
        }
        math.matrixEqual = matrixEqual;
        function matrixIsIdentity(mtx) {
            var m = mtx.rawData;
            var _isIdentity = (m[0] === 1.0 && m[1] === 0.0 && m[2] === 0.0 && m[3] === 0.0 &&
                m[4] === 0.0 && m[5] === 1.0 && m[6] === 0.0 && m[7] === 0.0 &&
                m[8] === 0.0 && m[9] === 0.0 && m[10] === 1.0 && m[11] === 0.0 &&
                m[12] === 0.0 && m[13] === 0.0 && m[14] === 0.0 && m[15] === 1.0);
            return _isIdentity;
        }
        math.matrixIsIdentity = matrixIsIdentity;
    })(math = m4m.math || (m4m.math = {}));
})(m4m || (m4m = {}));
/// <reference path="../../math/matrix.ts" />
var m4m;
/// <reference path="../../math/matrix.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * 2d 物理引擎Body 组件父对象
         * （本组件不会创建具体物理对象，需要使用子类对象 或者 自行在onInit回调中创建）
         */
        var physics2DBody = /** @class */ (function (_super) {
            __extends(physics2DBody, _super);
            function physics2DBody() {
                var _this = _super.call(this) || this;
                _this.lastScale = new m4m.math.vector2(1, 1);
                _this.beforePos = new m4m.math.vector2();
                _this.beforeAngle = 0;
                _this.enableBT = false;
                _this._positionOffset = new m4m.math.vector2();
                _this.options = {};
                _this.bodyWorldScale = new m4m.math.vector2(1, 1);
                _this.lastPos = new m4m.math.vector2();
                _this.lastRot = 0;
                _this._physicsEngine = framework.physics2D;
                return _this;
            }
            Object.defineProperty(physics2DBody.prototype, "physicsEngine", {
                /** 2d物理引擎实例对象 */
                get: function () {
                    if (this._physicsEngine) {
                        return this._physicsEngine;
                    }
                    else {
                        console.error("Physics not enabled. Please use scene.enable2DPhysics(...) before creating 2dPhysicsBody.");
                    }
                },
                enumerable: false,
                configurable: true
            });
            ;
            Object.defineProperty(physics2DBody.prototype, "positionOffset", {
                /** 物理对象 碰撞体位置偏移量 */
                get: function () { return this._positionOffset; },
                set: function (pos) {
                    if (!pos)
                        return;
                    m4m.math.vec2Clone(pos, this._positionOffset);
                    if (pos.x != 0 || pos.y != 0) {
                        this.enableBT = true;
                        if (!this._bodyWorldMtx)
                            this._bodyWorldMtx = new m4m.math.matrix3x2();
                        if (!this._bodyLocalMtx) {
                            this._bodyLocalMtx = new m4m.math.matrix3x2();
                            //偏移矩阵
                            var sV2 = m4m.math.pool.new_vector2(1, 1);
                            m4m.math.matrix3x2MakeTransformRTS(pos, sV2, 0, this._bodyLocalMtx);
                            m4m.math.pool.delete_vector2(sV2);
                        }
                        this._bodyLocalMtx.rawData[4] = pos.x;
                        this._bodyLocalMtx.rawData[5] = pos.y;
                    }
                    else {
                        this.enableBT = false;
                    }
                },
                enumerable: false,
                configurable: true
            });
            ;
            /** 是否已休眠
            * A flag that indicates whether the body is considered sleeping. A sleeping body acts similar to a static body, except it is only temporary and can be awoken.
            * If you need to set a body as sleeping, you should use `Sleeping.set` as this requires more than just setting this flag.
             */
            physics2DBody.prototype.isSleeping = function () {
                return this.body.isSleeping;
            };
            /** 是否是静态
            * A flag that indicates whether a body is considered static. A static body can never change position or angle and is completely fixed.
            * If you need to set a body as static after its creation, you should use `Body.setStatic` as this requires more than just setting this flag.
             */
            physics2DBody.prototype.isStatic = function () {
                return this.body.isStatic;
            };
            /** 是否是传感器
             * A flag that indicates whether a body is a sensor. Sensor triggers collision events, but doesn't react with colliding body physically.
             */
            physics2DBody.prototype.isSensor = function () {
                return this.body.isSensor;
            };
            /**
             * 施加作用力
             * @param Force
             */
            physics2DBody.prototype.addForce = function (Force) {
                this.physicsEngine.applyForceAtCenter(this.body, Force);
            };
            /**
             * 设置速度
             * @param velocity
             */
            physics2DBody.prototype.setVelocity = function (velocity) {
                this.physicsEngine.setVelocity(this.body, velocity);
            };
            /**
             * 设置角速度
             * @param velocity
             */
            physics2DBody.prototype.setAngularVelocity = function (velocity) {
                this.physicsEngine.setAngularVelocity(this.body, velocity);
            };
            /**
             * 设置密度
             * @param Desity
             */
            physics2DBody.prototype.setDensity = function (Desity) {
                this.physicsEngine.setDensity(this.body, Desity);
            };
            /**
             * 设置空气摩擦力
             * @param frictionAir
             */
            physics2DBody.prototype.setFrictionAir = function (frictionAir) {
                this.body.frictionAir = frictionAir;
            };
            /**
             * 设置摩擦力
             * @param friction
             */
            physics2DBody.prototype.setFriction = function (friction) {
                this.body.friction = friction;
            };
            /**
             * 设置静态摩擦力
             * @param frictionStatic
             */
            physics2DBody.prototype.setFrictionStatic = function (frictionStatic) {
                this.body.frictionStatic = frictionStatic;
            };
            /**
             * 设置还原张力
             * @param restitution
             */
            physics2DBody.prototype.setRestitution = function (restitution) {
                this.body.restitution = restitution;
            };
            /**
             * 设置质量
             * @param mass
             */
            physics2DBody.prototype.setMass = function (mass) {
                this.physicsEngine.setMass(this.body, mass);
            };
            /**
             * 设置选项数据
             * @param options 选项数据
             */
            physics2DBody.prototype.setInitData = function (options) {
                this.options = options;
            };
            /**
             * 设置位置
             * @param pos 位置vec2
             */
            physics2DBody.prototype.setPosition = function (pos) {
                // this.physicsEngine.setPosition(this.body, pos);
                if (this.enableBT) {
                    var trans = this.transform;
                    trans.localTranslate.x = pos.x;
                    trans.localTranslate.y = pos.y;
                    trans.markDirty();
                }
                else {
                    this.setPositionByPhy(pos);
                }
            };
            //通过 物理设置角度
            physics2DBody.prototype.setPositionByPhy = function (pos) {
                this._physicsEngine.setPosition(this.body, pos);
            };
            /**
             * 设置旋转角度
             * @param angle
             */
            physics2DBody.prototype.setAngle = function (angle) {
                if (this.enableBT) {
                    var trans = this.transform;
                    trans.localRotate = angle;
                    trans.markDirty();
                }
                else {
                    this.setAngleByPhy(angle);
                }
            };
            //通过 物理设置角度
            physics2DBody.prototype.setAngleByPhy = function (angle) {
                this._physicsEngine.setAngle(this.body, angle);
            };
            physics2DBody.prototype.setScale = function (scale) {
                var wScal = this.bodyWorldScale;
                var sX = Math.pow(wScal.x, -1) * scale.x;
                var sY = Math.pow(wScal.y, -1) * scale.y;
                this._physicsEngine.setScale(this.body, sX, sY);
                m4m.math.vec2Set(this.bodyWorldScale, sX, sY);
            };
            /** 设置静态状态
             * Sets the body as static, including isStatic flag and setting mass and inertia to Infinity.
             */
            physics2DBody.prototype.setStatic = function (isStatic) {
                this.physicsEngine.setStatic(this.body, isStatic);
            };
            /** 设置休眠状态
             */
            physics2DBody.prototype.setSleeping = function (isSleeping) {
                this.physicsEngine.setSleeping(this.body, isSleeping);
            };
            /** 设置惯性值
             * Sets the moment of inertia (i.e. second moment of area) of the body.
             * Inverse inertia is automatically updated to reflect the change. Mass is not changed.
             */
            physics2DBody.prototype.setInertia = function (Inertia) {
                this.physicsEngine.setInertia(this.body, Inertia);
            };
            /** 设置顶点
            * Sets the body's vertices and updates body properties accordingly, including inertia, area and mass (with respect to `body.density`).
            * Vertices will be automatically transformed to be orientated around their centre of mass as the origin.
            * They are then automatically translated to world space based on `body.position`.
            *
            * The `vertices` argument should be passed as an array of `Matter.Vector` points (or a `Matter.Vertices` array).
            * Vertices must form a convex hull, concave hulls are not supported.
            */
            physics2DBody.prototype.setVertices = function (vertices) {
                this.physicsEngine.setVertices(this.body, vertices);
            };
            /** 设置成员
            * Sets the parts of the `body` and updates mass, inertia and centroid.
            * Each part will have its parent set to `body`.
            * By default the convex hull will be automatically computed and set on `body`, unless `autoHull` is set to `false.`
            * Note that this method will ensure that the first part in `body.parts` will always be the `body`.
            */
            physics2DBody.prototype.setParts = function (parts, autoHull) {
                if (autoHull === void 0) { autoHull = true; }
                this.physicsEngine.setParts(this.body, parts, autoHull);
            };
            /** 设置中心点
            * Set the centre of mass of the body.
            * The `centre` is a vector in world-space unless `relative` is set, in which case it is a translation.
            * The centre of mass is the point the body rotates about and can be used to simulate non-uniform density.
            * This is equal to moving `body.position` but not the `body.vertices`.
            * Invalid if the `centre` falls outside the body's convex hull.
            */
            physics2DBody.prototype.setCentre = function (centre, relative) {
                if (relative === void 0) { relative = false; }
                this.physicsEngine.setCentre(this.body, centre, relative);
            };
            physics2DBody.prototype.start = function () {
                if (this.onInit)
                    this.onInit(this);
            };
            physics2DBody.prototype.update = function (delta) {
            };
            physics2DBody.prototype.beforeStep = function () {
                if (!this.body)
                    return;
                //缩放
                var tSca = this.transform.localScale;
                if (!m4m.math.vec2Equal(this.lastScale, tSca)) {
                    this.setScale(tSca);
                }
                m4m.math.vec2Clone(tSca, this.lastScale);
                //位移、旋转
                if (this.enableBT) {
                    this.setPhyBodyTransformation();
                }
            };
            physics2DBody.prototype.afterStep = function () {
                if (!this.body)
                    return;
                this.setTransformationFormPhyBody();
            };
            //设置物理的 旋转、位移
            physics2DBody.prototype.setPhyBodyTransformation = function () {
                var tran = this.transform;
                var lpos = tran.localTranslate;
                if (lpos.x == this.lastPos.x && lpos.y == this.lastPos.y && this.lastRot == tran.localRotate)
                    return; //没有变化
                //同步到物理对象
                var posOs = this._positionOffset;
                var mPos;
                var mAngle;
                if (posOs.x != 0 || posOs.y != 0) {
                    var _scalR = physics2DBody.helpV2;
                    mPos = physics2DBody.helpV2_1;
                    var _angleR = physics2DBody.helpRefAngle;
                    m4m.math.matrix3x2Multiply(tran.getLocalMatrix(), this._bodyLocalMtx, this._bodyWorldMtx);
                    m4m.math.matrix3x2Decompose(this._bodyWorldMtx, _scalR, _angleR, mPos);
                    mAngle = _angleR.v;
                }
                else {
                    mPos = tran.localTranslate;
                    mAngle = tran.localRotate;
                }
                this.setPositionByPhy(mPos);
                this.setAngleByPhy(mAngle);
                //记录 before数据
                var bPos = this.body.position;
                m4m.math.vec2Set(this.beforePos, bPos.x, bPos.y);
                this.beforeAngle = this.body.angle;
            };
            //从物理 设置 旋转、位移
            physics2DBody.prototype.setTransformationFormPhyBody = function () {
                var trans = this.transform;
                var bPos = this.body.position;
                if (this.enableBT) {
                    var bfPos = this.beforePos;
                    var deltaX = bPos.x - bfPos.x;
                    var deltaY = bPos.y - bfPos.y;
                    var deltaRot = this.body.angle - this.beforeAngle;
                    if (deltaX == 0 && deltaY == 0 && deltaRot == 0)
                        return; //没有变化退出
                    var lPos = trans.localTranslate;
                    m4m.math.vec2Set(lPos, lPos.x + deltaX, lPos.y + deltaY);
                    trans.localRotate += deltaRot;
                }
                else {
                    var tPos = trans.localTranslate;
                    if (bPos.x == tPos.x && bPos.y == tPos.y && trans.localRotate == this.body.angle) { //没有变化退出
                        return;
                    }
                    framework.physicTool.Ivec2Copy(this.body.position, trans.localTranslate);
                    trans.localRotate = this.body.angle;
                }
                trans.markDirty();
            };
            physics2DBody.prototype.remove = function () {
                this.physicsEngine.removeBody(this);
                this.body = null;
            };
            physics2DBody.helpV2 = new m4m.math.vector2();
            physics2DBody.helpV2_1 = new m4m.math.vector2();
            physics2DBody.helpRefAngle = new m4m.math.angelref();
            return physics2DBody;
        }(framework.behaviour2d));
        framework.physics2DBody = physics2DBody;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../../io/reflect.ts" />
var m4m;
/// <reference path="../../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
        * @public
        * @language zh_CN
        * @classdesc
        * 胶囊体 2d刚体 （图形的朝向会根据 transform 的宽和高来适配）
        * @version m4m 1.0
        */
        var capsuleBody2d = /** @class */ (function (_super) {
            __extends(capsuleBody2d, _super);
            function capsuleBody2d() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.maxSides = 25;
                return _this;
            }
            Object.defineProperty(capsuleBody2d.prototype, "y_Axis", {
                /** 胶囊体朝向为 Y 轴 */
                get: function () { return this.transform.height > this.transform.width; },
                enumerable: false,
                configurable: true
            });
            ;
            capsuleBody2d.prototype.start = function () {
                this.options.angle = this.transform.localRotate;
                var body = this.physicsEngine.createCapsuleByPBody(this, this.maxSides);
                this.physicsEngine.addBody(this);
                _super.prototype.start.call(this);
            };
            capsuleBody2d.prototype.onPlay = function () {
            };
            capsuleBody2d.ClassName = "capsuleBody2d";
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], capsuleBody2d.prototype, "maxSides", void 0);
            capsuleBody2d = __decorate([
                m4m.reflect.node2DComponent,
                m4m.reflect.node2DPhysicsBody
            ], capsuleBody2d);
            return capsuleBody2d;
        }(framework.physics2DBody));
        framework.capsuleBody2d = capsuleBody2d;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../../io/reflect.ts" />
var m4m;
/// <reference path="../../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
        * @public
        * @language zh_CN
        * @classdesc
        * 圆形 2d刚体
        * @version m4m 1.0
        */
        var circleBody2d = /** @class */ (function (_super) {
            __extends(circleBody2d, _super);
            function circleBody2d() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.maxSides = 25;
                return _this;
            }
            Object.defineProperty(circleBody2d.prototype, "radius", {
                /** 圆形的半径（取 宽和高两者之间最大的值为半径） */
                get: function () {
                    return (this.transform.width > this.transform.height ? this.transform.width : this.transform.height) * 0.5;
                },
                enumerable: false,
                configurable: true
            });
            ;
            circleBody2d.prototype.start = function () {
                this.options.angle = this.transform.localRotate;
                var body = this.physicsEngine.createCircleByPBody(this, this.maxSides);
                this.physicsEngine.addBody(this);
                _super.prototype.start.call(this);
            };
            circleBody2d.prototype.onPlay = function () {
            };
            circleBody2d.ClassName = "circleBody2d";
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], circleBody2d.prototype, "maxSides", void 0);
            circleBody2d = __decorate([
                m4m.reflect.node2DComponent,
                m4m.reflect.node2DPhysicsBody
            ], circleBody2d);
            return circleBody2d;
        }(framework.physics2DBody));
        framework.circleBody2d = circleBody2d;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../../io/reflect.ts" />
var m4m;
/// <reference path="../../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
        * @public
        * @language zh_CN
        * @classdesc
        * 复合 2d 刚体
        * @version m4m 1.0
        */
        var compoundBody2d = /** @class */ (function (_super) {
            __extends(compoundBody2d, _super);
            function compoundBody2d() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._bodys = [];
                return _this;
            }
            compoundBody2d.prototype.start = function () {
                // let body = this.physicsEngine.createCircleBodyByInitData(this,this.radius,this.maxSides);
                var engine = this.physicsEngine;
                //校准位置
                var pos = this.transform.getWorldTranslate();
                var tempv2 = m4m.poolv2();
                var len = this._bodys.length;
                for (var i = 0; i < len; i++) {
                    var body = this._bodys[i];
                    tempv2.x = body.position.x + pos.x;
                    tempv2.y = body.position.y + pos.y;
                    engine.setPosition(body, tempv2);
                }
                this.options.parts = this._bodys;
                //root body
                this.options.angle = this.transform.localRotate;
                this.body = engine.createBody(this.options);
                engine.addBody(this);
                m4m.poolv2_del(tempv2);
                _super.prototype.start.call(this);
            };
            /** 添加部分 body */
            compoundBody2d.prototype.addPart = function (body) {
                if (!body)
                    return;
                this._bodys.push(body);
            };
            compoundBody2d.prototype.onPlay = function () {
            };
            compoundBody2d.ClassName = "compoundBody2d";
            compoundBody2d = __decorate([
                m4m.reflect.node2DComponent,
                m4m.reflect.node2DPhysicsBody
            ], compoundBody2d);
            return compoundBody2d;
        }(framework.physics2DBody));
        framework.compoundBody2d = compoundBody2d;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../../io/reflect.ts" />
var m4m;
/// <reference path="../../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
        * @public
        * @language zh_CN
        * @classdesc
        * 多面凸包 2d刚体
        * @version m4m 1.0
        */
        var convexHullBody2d = /** @class */ (function (_super) {
            __extends(convexHullBody2d, _super);
            function convexHullBody2d() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.vertexSets = [];
                _this.flagInternal = false;
                _this.removeCollinear = 0.01;
                _this.minimumArea = 10;
                return _this;
            }
            convexHullBody2d.prototype.start = function () {
                this.options.angle = this.transform.localRotate;
                var body = this.physicsEngine.ConvexHullByPBody(this, this.vertexSets, this.flagInternal, this.removeCollinear, this.minimumArea);
                //this.body=physic2D.creatRectBody(this.transform.localTranslate.x,this.transform.localTranslate.y,this.transform.width,this.transform.height,this.beStatic);
                this.fixCenter();
                this.physicsEngine.addBody(this);
                _super.prototype.start.call(this);
            };
            //校准 重心 初始位置
            convexHullBody2d.prototype.fixCenter = function () {
                var max = this.body.bounds.max;
                var min = this.body.bounds.min;
                var center = m4m.poolv2();
                this.calceBoundingCenter(max, min, center);
                var offset = m4m.poolv2();
                m4m.math.vec2Subtract(this.transform.localTranslate, center, offset);
                var newpos = offset;
                m4m.math.vec2Add(this.transform.localTranslate, offset, newpos);
                this.setPosition(newpos);
                this.transform.markDirty();
                m4m.poolv2_del(center);
                m4m.poolv2_del(offset);
            };
            convexHullBody2d.prototype.calceBoundingCenter = function (max, min, center) {
                center.x = (max.x + min.x) / 2;
                center.y = (max.y + min.y) / 2;
            };
            convexHullBody2d.prototype.onPlay = function () {
            };
            convexHullBody2d.ClassName = "convexHullBody2d";
            __decorate([
                m4m.reflect.Field("vector2[]"),
                __metadata("design:type", Array)
            ], convexHullBody2d.prototype, "vertexSets", void 0);
            __decorate([
                m4m.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], convexHullBody2d.prototype, "flagInternal", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], convexHullBody2d.prototype, "removeCollinear", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], convexHullBody2d.prototype, "minimumArea", void 0);
            convexHullBody2d = __decorate([
                m4m.reflect.node2DComponent,
                m4m.reflect.node2DPhysicsBody
            ], convexHullBody2d);
            return convexHullBody2d;
        }(framework.physics2DBody));
        framework.convexHullBody2d = convexHullBody2d;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        // export declare let physic: PhysicsEngine;
        //export declare let physic2D: physicEngine2D;
        var physicEngine2D = /** @class */ (function () {
            function physicEngine2D(op) {
                if (op === void 0) { op = null; }
                var _this = this;
                this.eventer = new m4m.event.Physic2dEvent();
                this._bodysObjMap = {};
                op = op || {};
                if (Matter == undefined) {
                    console.error(" Matter not found , create physicEngine2D fail");
                    return;
                }
                this._Matter = Matter;
                this.matterEngine = Matter.Engine.create(op);
                this.engineWorld = this.matterEngine.world;
                var engine = this.matterEngine;
                var runnerOp = { fps: op.runnerFps || 60, isFixed: op.runnerIsFixed == true };
                var runner = Matter.Runner.create(runnerOp);
                //---------run the engine
                var modeSceneCtr = true;
                if (modeSceneCtr) {
                    this.engineRunner = runner;
                    var nowTime_1 = 0;
                    var frameCounter_1 = 0;
                    var counterTimestamp_1 = 0;
                    var dt = 1 / runner.fps;
                    runner.delta = dt;
                    runner.deltaMin = dt * 0.5;
                    runner.deltaMax = dt * 4;
                    this.engineRunner.tick = function (delta) {
                        //beforeStep
                        _this.beforeStep();
                        // Matter.Runner.tick(runner , engine , nowTime);
                        _this.RunnerTick(runner, engine, delta);
                        //aftereStep
                        _this.afterStep();
                        if (!runnerOp.isFixed) {
                            // fps counter
                            nowTime_1 += delta;
                            frameCounter_1 += 1;
                            if (nowTime_1 - counterTimestamp_1 >= 1) {
                                runner.fps = frameCounter_1 * ((nowTime_1 - counterTimestamp_1));
                                // console.log(`fps : ${runner.fps} , delta: ${runner.delta}`);
                                counterTimestamp_1 = nowTime_1;
                                frameCounter_1 = 0;
                            }
                        }
                    };
                }
                else {
                    // Matter.Engine.run(this.matterEngine);
                    Matter.Runner.run(runner, engine);
                }
                //Event
                Matter.Events.on(this.matterEngine, "beforeUpdate", this.beforeUpdate.bind(this));
                Matter.Events.on(this.matterEngine, "afterUpdate", this.afterUpdate.bind(this));
                Matter.Events.on(this.matterEngine, "collisionStart", this.collisionStart.bind(this));
                Matter.Events.on(this.matterEngine, "collisionActive", this.collisionActive.bind(this));
                Matter.Events.on(this.matterEngine, "collisionEnd", this.collisionEnd.bind(this));
            }
            Object.defineProperty(physicEngine2D.prototype, "Matter", {
                get: function () { return this._Matter; },
                enumerable: false,
                configurable: true
            });
            ;
            physicEngine2D.prototype.RunnerTick = function (runner, engine, delta) {
                var Events = Matter.Events;
                var Engine = Matter.Engine;
                var timing = engine.timing;
                var correction = 1;
                // create an event object
                var event = {
                    timestamp: timing.timestamp
                };
                Events.trigger(runner, 'beforeTick', event);
                Events.trigger(engine, 'beforeTick', event); // @deprecated
                if (runner.isFixed) {
                    // fixed timestep
                    delta = runner.delta;
                }
                else {
                    // optimistically filter delta over a few frames, to improve stability
                    runner.deltaHistory.push(delta);
                    runner.deltaHistory = runner.deltaHistory.slice(-runner.deltaSampleSize);
                    delta = Math.min.apply(null, runner.deltaHistory);
                    // limit delta
                    delta = delta < runner.deltaMin ? runner.deltaMin : delta;
                    delta = delta > runner.deltaMax ? runner.deltaMax : delta;
                    // correction for delta
                    correction = delta / runner.delta;
                    // update engine timing object
                    runner.delta = delta;
                }
                // time correction for time scaling
                if (runner.timeScalePrev !== 0)
                    correction *= timing.timeScale / runner.timeScalePrev;
                if (timing.timeScale === 0)
                    correction = 0;
                runner.timeScalePrev = timing.timeScale;
                runner.correction = correction;
                // fps counter
                Events.trigger(runner, 'tick', event);
                Events.trigger(engine, 'tick', event); // @deprecated
                // update
                Events.trigger(runner, 'beforeUpdate', event);
                Engine.update(engine, delta * 1000, correction);
                Events.trigger(runner, 'afterUpdate', event);
                //afterTick
                Events.trigger(runner, 'afterTick', event);
                Events.trigger(engine, 'afterTick', event); // @deprecated
            };
            physicEngine2D.prototype.beforeStep = function () {
                var omap = this._bodysObjMap;
                for (var key in omap) {
                    var phyBody = omap[key];
                    if (phyBody) {
                        phyBody.beforeStep();
                    }
                }
            };
            physicEngine2D.prototype.afterStep = function () {
                var omap = this._bodysObjMap;
                for (var key in omap) {
                    var phyBody = omap[key];
                    if (phyBody) {
                        phyBody.afterStep();
                    }
                }
            };
            physicEngine2D.prototype.update = function (delta) {
                Matter.Engine.update(this.matterEngine, delta);
            };
            /** Matter.Engine update 调用前 */
            physicEngine2D.prototype.beforeUpdate = function (ev) {
                this.eventer.EmitEnum(m4m.event.Physic2dEventEnum.BeforeUpdate, ev);
            };
            /** Matter.Engine update 调用之后 */
            physicEngine2D.prototype.afterUpdate = function (ev) {
                this.eventer.EmitEnum(m4m.event.Physic2dEventEnum.afterUpdate, ev);
            };
            /** 开始碰撞 ， Matter.Engine update 调用之后 */
            physicEngine2D.prototype.collisionStart = function (ev) {
                this.eventer.EmitEnum(m4m.event.Physic2dEventEnum.collisionStart, ev);
            };
            /** 碰撞持续中， Matter.Engine update 调用之后 */
            physicEngine2D.prototype.collisionActive = function (ev) {
                this.eventer.EmitEnum(m4m.event.Physic2dEventEnum.collisionActive, ev);
            };
            /** 碰撞结束 ， Matter.Engine update 调用之后 */
            physicEngine2D.prototype.collisionEnd = function (ev) {
                this.eventer.EmitEnum(m4m.event.Physic2dEventEnum.collisionEnd, ev);
            };
            /**
             * 添加事件监听
             * @param eventEnum 事件类型
             * @param func 事件回调函数
             * @param thisArg 函数持有对象
             */
            physicEngine2D.prototype.addEventListener = function (eventEnum, func, thisArg) {
                this.eventer.OnEnum(eventEnum, func, thisArg);
            };
            /**
             * 移除事件监听
             * @param eventEnum 事件类型
             * @param func 事件回调函数
             * @param thisArg 函数持有对象
             */
            physicEngine2D.prototype.removeEventListener = function (eventEnum, func, thisArg) {
                this.eventer.RemoveListener(m4m.event.Physic2dEventEnum[eventEnum], func, thisArg);
            };
            /**
             * 创建一个新的矩形Body
             * @param pBody I2DPhysicsBody 实例
             */
            physicEngine2D.prototype.createRectByPBody = function (pBody) {
                if (!pBody || !pBody.transform)
                    return;
                var tran = pBody.transform;
                var pos = tran.getWorldTranslate();
                // let body = Matter.Bodies.rectangle(pos.x, pos.y, tran.width, tran.height, pBody.options);
                if (!pBody.options.label)
                    pBody.options.label = 'Rect Body';
                var body = this.createRectangle(pos.x, pos.y, tran.width, tran.height, pBody.options);
                pBody.body = body;
                // this.addBody(pBody);
                return body;
            };
            /**
             * 创建一个新的圆形Body
             * @param pBody I2DPhysicsBody 实例
             * @param radius 半径
             * @param maxSides 最大边
             */
            physicEngine2D.prototype.createCircleByPBody = function (pBody, maxSides) {
                if (maxSides === void 0) { maxSides = 25; }
                if (!pBody || !pBody.transform)
                    return;
                var tran = pBody.transform;
                var pos = tran.getWorldTranslate();
                var r = tran.width > tran.height ? tran.width : tran.height;
                r *= 0.5;
                if (!pBody.options.label)
                    pBody.options.label = 'Circle Body';
                var body = this.createCircle(pos.x, pos.y, r, pBody.options, maxSides);
                pBody.body = body;
                return body;
            };
            /**
             * 使用提供的顶点（或包含多组顶点的数组）创建一个新的物理实体
             * 详细参考： createFromVertices（）
             * @param pBody I2DPhysicsBody 实例
             * @param vertexSets 顶点集合
             * @param flagInternal 内部模式标记
             * @param removeCollinear 共线移除参考值
             * @param minimumArea 最小面积
             */
            physicEngine2D.prototype.ConvexHullByPBody = function (pBody, vertexSets, flagInternal, removeCollinear, minimumArea) {
                if (flagInternal === void 0) { flagInternal = false; }
                if (removeCollinear === void 0) { removeCollinear = 0.01; }
                if (minimumArea === void 0) { minimumArea = 10; }
                if (!pBody || !pBody.transform)
                    return;
                var tran = pBody.transform;
                var pos = tran.getWorldTranslate();
                // let body = Matter.Bodies.fromVertices(pos.x, pos.y, vertexSets, pBody.options , flagInternal , removeCollinear , minimumArea);
                if (!pBody.options.label)
                    pBody.options.label = 'ConvexHull Body';
                var body = this.createFromVertices(pos.x, pos.y, vertexSets, pBody.options, flagInternal, removeCollinear, minimumArea);
                pBody.body = body;
                // this.addBody(pBody,);
                return body;
            };
            /**
             * 创建一个新的胶囊体Body
             * @param pBody
             * @param maxSides
             */
            physicEngine2D.prototype.createCapsuleByPBody = function (pBody, maxSides) {
                if (maxSides === void 0) { maxSides = 25; }
                if (!pBody || !pBody.transform)
                    return;
                var tran = pBody.transform;
                var pos = tran.getWorldTranslate();
                var y_Axis = tran.height > tran.width;
                var r = y_Axis ? tran.width : tran.height;
                r *= 0.5;
                var h = y_Axis ? tran.height : tran.width;
                var angle = y_Axis ? 0 : Math.PI * 0.5;
                if (!pBody.options.label)
                    pBody.options.label = 'Capsule Body';
                var body = this.createCapsule(pos.x, pos.y, r, h, pBody.options, angle, maxSides);
                pBody.body = body;
                return body;
            };
            /**
             * Creates a new rigid body model. The options parameter is an object that specifies any properties you wish to override the defaults.
             * All properties have default values, and many are pre-calculated automatically based on other properties.
             * Vertices must be specified in clockwise order.
             * See the properties section below for detailed information on what you can pass via the `options` object.
             * @param options
             */
            physicEngine2D.prototype.createBody = function (options) {
                return Matter.Body.create(options);
            };
            /**
             * Creates a new rigid body model with a circle hull.
             * The options parameter is an object that specifies any properties you wish to override the defaults.
             * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
             * @method circle
             * @param {number} x
             * @param {number} y
             * @param {number} radius
             * @param {object} [options]
             * @param {number} [maxSides]
             * @return {body} A new circle body
             */
            physicEngine2D.prototype.createCircle = function (x, y, radius, options, maxSides) {
                return Matter.Bodies.circle(x, y, radius, options, maxSides);
            };
            /**
             * Creates a new rigid body model with a rectangle hull.
             * The options parameter is an object that specifies any properties you wish to override the defaults.
             * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
             * @method rectangle
             * @param {number} x
             * @param {number} y
             * @param {number} width
             * @param {number} height
             * @param {object} [options]
             * @return {body} A new rectangle body
             */
            physicEngine2D.prototype.createRectangle = function (x, y, width, height, options) {
                return Matter.Bodies.rectangle(x, y, width, height, options);
            };
            /**
             * Creates a new rigid body model with a trapezoid hull.
             * The options parameter is an object that specifies any properties you wish to override the defaults.
             * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
             * @method trapezoid
             * @param {number} x
             * @param {number} y
             * @param {number} width
             * @param {number} height
             * @param {number} slope
             * @param {object} [options]
             * @return {body} A new trapezoid body
             */
            physicEngine2D.prototype.createTrapezoid = function (x, y, width, height, slope, options) {
                return Matter.Bodies.trapezoid(x, y, width, height, slope, options);
            };
            /**
             * Creates a new rigid body model with a regular polygon hull with the given number of sides.
             * The options parameter is an object that specifies any properties you wish to override the defaults.
             * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
             * @method polygon
             * @param {number} x
             * @param {number} y
             * @param {number} sides
             * @param {number} radius
             * @param {object} [options]
             * @return {body} A new regular polygon body
             */
            physicEngine2D.prototype.createPolygon = function (x, y, sides, radius, options) {
                return Matter.Bodies.polygon(x, y, sides, radius, options);
            };
            /**
             * Creates a body using the supplied vertices (or an array containing multiple sets of vertices).
             * If the vertices are convex, they will pass through as supplied.
             * Otherwise if the vertices are concave, they will be decomposed if [poly-decomp.js](https://github.com/schteppe/poly-decomp.js) is available.
             * Note that this process is not guaranteed to support complex sets of vertices (e.g. those with holes may fail).
             * By default the decomposition will discard collinear edges (to improve performance).
             * It can also optionally discard any parts that have an area less than `minimumArea`.
             * If the vertices can not be decomposed, the result will fall back to using the convex hull.
             * The options parameter is an object that specifies any `Matter.Body` properties you wish to override the defaults.
             * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
             * @method fromVertices
             * @param {number} x
             * @param {number} y
             * @param [Ivec2] vertexSets
             * @param {object} [options]
             * @param {bool} [flagInternal=false]
             * @param {number} [removeCollinear=0.01]
             * @param {number} [minimumArea=10]
             * @return {body}
             */
            physicEngine2D.prototype.createFromVertices = function (x, y, vertexSets, options, flagInternal, removeCollinear, minimumArea) {
                if (flagInternal === void 0) { flagInternal = false; }
                if (removeCollinear === void 0) { removeCollinear = 0.01; }
                if (minimumArea === void 0) { minimumArea = 10; }
                return Matter.Bodies.fromVertices(x, y, vertexSets, options, flagInternal, removeCollinear, minimumArea);
            };
            /**
             * Creates a new rigid body model with a capsule hull.
             * The options parameter is an object that specifies any properties you wish to override the defaults.
             * See the properties section of the `Matter.Body` module for detailed information on what you can pass via the `options` object.
             * @method createCapsule
             * @param {number} x
             * @param {number} y
             * @param {number} radius
             * @param {number} height
             * @param {object} [options]
             * @param {number} rotation vertices roate of angle
             * @param {number} [maxSides]
             * @return {body} A new capsule body
             */
            physicEngine2D.prototype.createCapsule = function (x, y, radius, height, options, rotation, maxSides) {
                if (rotation === void 0) { rotation = 0; }
                if (maxSides === void 0) { maxSides = 25; }
                options = options || {};
                maxSides = maxSides || 25;
                var sides = Math.ceil(Math.max(6, Math.min(maxSides, radius)));
                // optimisation: always use even number of sides (half the number of unique axes)
                sides = sides % 2 === 1 ? sides++ : sides;
                var halfSides = sides / 2, halfDiff = (height - radius) / 2, theta = 2 * Math.PI / sides, path = '', angOffset = Math.PI + theta * 0.5, angle, xx, yy, yOffset;
                // Always greater than 0 of halfDiff
                halfDiff = halfDiff < 0 ? 0 : halfDiff;
                for (var i = 0; i < sides; i++) {
                    yOffset = i > halfSides ? halfDiff : -halfDiff;
                    angle = angOffset + (i * theta);
                    xx = Math.cos(angle) * radius;
                    yy = Math.sin(angle) * radius + yOffset;
                    if (i == 0) {
                        path += 'L ' + xx.toFixed(3) + ' ' + (yy - yOffset * 2).toFixed(3) + ' ';
                    }
                    path += 'L ' + xx.toFixed(3) + ' ' + yy.toFixed(3) + ' ';
                    if (i == halfSides) {
                        path += 'L ' + xx.toFixed(3) + ' ' + (yy - yOffset * 2).toFixed(3) + ' ';
                    }
                }
                var createCapsule = {
                    label: 'Capsule Body',
                    position: { x: x, y: y },
                    vertices: Matter.Vertices.fromPath(path)
                };
                if (rotation != null || rotation % (Math.PI * 2) == 0) {
                    Matter.Vertices.rotate(createCapsule.vertices, rotation, { x: x, y: y });
                }
                return Matter.Body.create(Matter.Common.extend({}, createCapsule, options));
            };
            /** 添加 I2DPhysicsBody 实例到 2d物理世界*/
            physicEngine2D.prototype.addBody = function (_Pbody) {
                if (!_Pbody || !_Pbody.body)
                    return;
                this._bodysObjMap[_Pbody.body.id] = _Pbody;
                Matter.World.add(this.engineWorld, _Pbody.body);
            };
            /** 移除 指定 I2DPhysicsBody 实例 */
            physicEngine2D.prototype.removeBody = function (_Pbody) {
                if (!_Pbody || !_Pbody.body)
                    return;
                delete this._bodysObjMap[_Pbody.body.id];
                Matter.World.remove(this.engineWorld, _Pbody.body);
            };
            /** 获取 I2DPhysicsBody 对象通过 Ibody.id */
            physicEngine2D.prototype.getBody = function (bodyId) {
                return this._bodysObjMap[bodyId];
            };
            /** 清理世界 */
            physicEngine2D.prototype.clearWorld = function (keepStatic) {
                if (keepStatic === void 0) { keepStatic = false; }
                Matter.World.clear(this.engineWorld, keepStatic);
            };
            physicEngine2D.prototype.applyForce = function (body, positon, force) {
                Matter.Body.applyForce(body, positon, force);
            };
            physicEngine2D.prototype.applyForceAtCenter = function (body, force) {
                Matter.Body.applyForce(body, body.position, force);
            };
            physicEngine2D.prototype.setGravity = function (x, y) {
                this.engineWorld.gravity.x = x;
                this.engineWorld.gravity.y = y;
            };
            Object.defineProperty(physicEngine2D.prototype, "enableSleeping", {
                get: function () {
                    return this.matterEngine.enableSleeping;
                },
                set: function (val) {
                    this.matterEngine.enableSleeping = val;
                },
                enumerable: false,
                configurable: true
            });
            //-----------------body设置-------------------------
            /** 设置速度
             * Sets the linear velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.
             */
            physicEngine2D.prototype.setVelocity = function (body, velocity) {
                Matter.Body.setVelocity(body, velocity);
            };
            /** 设置位置
             * Moves a body by a given vector relative to its current position, without imparting any velocity.
            */
            physicEngine2D.prototype.setPosition = function (body, pos) {
                Matter.Body.setPosition(body, pos);
            };
            /**
             * Sets the angle of the body instantly. Angular velocity, position, force etc. are unchanged.
             * @param body body
             * @param angle 旋转角度
             */
            physicEngine2D.prototype.setAngle = function (body, angle) {
                Matter.Body.setAngle(body, angle);
            };
            /** 设置质量
             * Sets the mass of the body. Inverse mass, density and inertia are automatically updated to reflect the change.
            */
            physicEngine2D.prototype.setMass = function (body, mass) {
                Matter.Body.setMass(body, mass);
            };
            /** 设置密度
             * Sets the density of the body. Mass and inertia are automatically updated to reflect the change.
             */
            physicEngine2D.prototype.setDensity = function (body, Desity) {
                Matter.Body.setDensity(body, Desity);
            };
            /**
             * 设置角速度
             * Sets the angular velocity of the body instantly. Position, angle, force etc. are unchanged. See also `Body.applyForce`.
             */
            physicEngine2D.prototype.setAngularVelocity = function (body, angularVelocity) {
                Matter.Body.setAngularVelocity(body, angularVelocity);
            };
            /** 设置静态状态
             * Sets the body as static, including isStatic flag and setting mass and inertia to Infinity.
             */
            physicEngine2D.prototype.setStatic = function (body, isStatic) {
                Matter.Body.setStatic(body, isStatic);
            };
            /** 设置休眠状态
             */
            physicEngine2D.prototype.setSleeping = function (body, isSleeping) {
                Matter.Sleeping.set(body, isSleeping);
            };
            /** 设置惯性值
             * Sets the moment of inertia (i.e. second moment of area) of the body.
             * Inverse inertia is automatically updated to reflect the change. Mass is not changed.
             */
            physicEngine2D.prototype.setInertia = function (body, Inertia) {
                Matter.Body.setInertia(body, Inertia);
            };
            /** 设置顶点
            * Sets the body's vertices and updates body properties accordingly, including inertia, area and mass (with respect to `body.density`).
            * Vertices will be automatically transformed to be orientated around their centre of mass as the origin.
            * They are then automatically translated to world space based on `body.position`.
            *
            * The `vertices` argument should be passed as an array of `Matter.Vector` points (or a `Matter.Vertices` array).
            * Vertices must form a convex hull, concave hulls are not supported.
            */
            physicEngine2D.prototype.setVertices = function (body, vertices) {
                Matter.Body.setVertices(body, vertices);
            };
            /** 设置成员
            * Sets the parts of the `body` and updates mass, inertia and centroid.
            * Each part will have its parent set to `body`.
            * By default the convex hull will be automatically computed and set on `body`, unless `autoHull` is set to `false.`
            * Note that this method will ensure that the first part in `body.parts` will always be the `body`.
            */
            physicEngine2D.prototype.setParts = function (body, parts, autoHull) {
                if (autoHull === void 0) { autoHull = true; }
                Matter.Body.setParts(body, parts, autoHull);
            };
            /** 设置中心点
            * Set the centre of mass of the body.
            * The `centre` is a vector in world-space unless `relative` is set, in which case it is a translation.
            * The centre of mass is the point the body rotates about and can be used to simulate non-uniform density.
            * This is equal to moving `body.position` but not the `body.vertices`.
            * Invalid if the `centre` falls outside the body's convex hull.
            */
            physicEngine2D.prototype.setCentre = function (body, centre, relative) {
                if (relative === void 0) { relative = false; }
                Matter.Body.setCentre(body, centre, relative);
            };
            /**
             * 设置缩放
             * Scales the body, including updating physical properties (mass, area, axes, inertia), from a world-space point (default is body centre).
             */
            physicEngine2D.prototype.setScale = function (body, scaleX, scaleY, point) {
                if (point === void 0) { point = null; }
                Matter.Body.scale(body, scaleX, scaleY, point);
            };
            /**
             * 复合体缩放
             * Scales all children in the composite, including updating physical properties (mass, area, axes, inertia), from a world-space point.
             */
            physicEngine2D.prototype.compositeScale = function (composite, scaleX, scaleY, point, recursive) {
                if (recursive === void 0) { recursive = false; }
                Matter.Composite.scale(composite, scaleX, scaleY, point, recursive);
            };
            return physicEngine2D;
        }());
        framework.physicEngine2D = physicEngine2D;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../../io/reflect.ts" />
var m4m;
/// <reference path="../../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
        * @public
        * @language zh_CN
        * @classdesc
        * 矩形 2d刚体
        * @version m4m 1.0
        */
        var rectBody2d = /** @class */ (function (_super) {
            __extends(rectBody2d, _super);
            function rectBody2d() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            rectBody2d.prototype.start = function () {
                this.options.angle = this.transform.localRotate;
                var body = this.physicsEngine.createRectByPBody(this);
                this.physicsEngine.addBody(this);
                _super.prototype.start.call(this);
            };
            rectBody2d.prototype.onPlay = function () {
            };
            rectBody2d.ClassName = "rectBody2d";
            rectBody2d = __decorate([
                m4m.reflect.node2DComponent,
                m4m.reflect.node2DPhysicsBody
            ], rectBody2d);
            return rectBody2d;
        }(framework.physics2DBody));
        framework.rectBody2d = rectBody2d;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        //资源不能随意改名，否则药丸
        //资源需要有一个固定的名字，一个唯一的id
        //唯一的id 是定位的需求，他不需要assetMgr就能够满足
        //name 是我们做named的管理时，需要
        //资源的来源有三种，     
        //一，随意new，这个也可以用引用计数管理，随你
        //二，加载而来，也是这个使用引用计数管理
        //三，静态管理，这个是特殊的，不要为他设计
        var resID = /** @class */ (function () {
            function resID() {
                this.id = resID.next();
            }
            resID.next = function () {
                var next = resID.idAll;
                resID.idAll++;
                return next;
            };
            resID.prototype.getID = function () {
                return this.id;
            };
            resID.idAll = 100000000; //从 100000000 开始累加ID， 避免 guidlist 冲突
            return resID;
        }());
        framework.resID = resID;
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 静态text 初始化后不可修改
         * @version m4m 1.0
         */
        var constText = /** @class */ (function () {
            function constText(text) {
                this.name = text;
            }
            constText.prototype.getText = function () {
                return this.name;
            };
            constText = __decorate([
                m4m.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], constText);
            return constText;
        }());
        framework.constText = constText;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
// namespace m4m.framework.old {
//     /**
//      * @public
//      * @language zh_CN
//      * @classdesc
//      * 资源包
//      * @version m4m 1.0
//      */
//     export class assetBundle {
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 包名
//          * @version m4m 1.0
//          */
//         public name: string;
//         /**
//          * @public
//          * @language zh_CN
//          * 资源管理器实例
//          * @version m4m 1.0
//          */
//         assetmgr: assetMgr;
//         private files: { name: string, length: number, packes: number, guid: string, zip_Length: number }[] = [];
//         private packages: string[] = [];
//         private bundlePackBin: { [name: string]: ArrayBuffer } = {};
//         private bundlePackJson: JSON;
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 包完整路径
//          * @version m4m 1.0
//          */
//         url: string;
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 不带包名路径
//          * @version m4m 1.0
//          */
//         path: string;
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 资源的总字节数
//          * @version m4m 1.0
//          */
//         totalLength: number = 0;
//         loadLightMap: boolean = true;
//         //guid等待加载完毕回调 资源计数
//         private waitGuidCount = 0;
//         constructor(url: string) {
//             this.url = url;
//             let i = url.lastIndexOf("/");
//             this.path = url.substring(0, i);
//             // this.assetmgr = m4m.framework.sceneMgr.app.getAssetMgr();
//             if (this.assetmgr.waitlightmapScene[url]) {
//                 this.loadLightMap = false;
//             }
//         }
//         loadCompressBundle(url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetmgr: assetMgr) {
//             state.totalByteLength = this.totalLength;
//             // console.log(`ab loadCompressBundle ${url}`);
//             m4m.io.loadText(url, (txt, err, isloadFail) => {
//                 if (err != null) {
//                     state.isloadFail = isloadFail ? true : false;
//                     state.iserror = true;
//                     state.errs.push(new Error(err.message));
//                     onstate(state);
//                     return;
//                 }
//                 // console.log(`ab loadCompressBundlew 下载完成 ${url}`);
//                 let json = JSON.parse(txt);
//                 this.bundlePackJson = json;
//                 this.parse(json["bundleinfo"], this.totalLength);
//                 this.load(assetmgr, onstate, state);
//                 assetmgr.mapBundle[this.name] = this;
//             },
//                 (loadedLength, totalLength) => {
//                     state.compressTextLoaded = loadedLength;
//                     onstate(state);
//                 });
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 解析包
//          * @param json 
//          * @version m4m 1.0
//          */
//         parse(json: any, totalLength: number = 0) {
//             let files = json["files"];
//             for (let i = 0; i < files.length; i++) {
//                 let item = files[i];
//                 let packes = -1;
//                 if (item.packes != undefined)
//                     packes = item.packes;
//                 if (!this.loadLightMap && (item.name as string).indexOf("LightmapFar-") >= 0) {
//                     this.assetmgr.waitlightmapScene[this.url].push(this.path + "/" + item.name);
//                     continue;
//                 }
//                 this.files.push({ name: item.name, length: item.length, packes: packes, guid: item.guid, zip_Length: item.zip_Length });
//                 if (item.guid != undefined) {
//                     this.mapNameGuid[item.name] = item.guid;
//                 }
//             }
//             if (json["packes"] != undefined) {
//                 let packes = json["packes"];
//                 for (let i = 0; i < packes.length; i++) {
//                     this.packages.push(packes[i]);
//                 }
//             } else {
//                 if (json["totalLength"] != undefined) {
//                     if (totalLength == 0) {
//                         this.totalLength = json["totalLength"];
//                     }
//                 }
//             }
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 卸载包 包内对应的资源引用计数减一
//          * @param disposeNow 如果引用计数归零则立即释放
//          * @version m4m 1.0
//          */
//         unload(disposeNow: boolean = false) {
//             for (let key in this.mapNamed) {
//                 let asset = this.assetmgr.getAssetByName(key, this.name);
//                 if (asset) {
//                     this.assetmgr.unuse(asset, disposeNow);
//                 }
//             }
//             this.assetmgr.removeAssetBundle(this.name);
//         }
//         private isTextureRepeat(_type : AssetTypeEnum , name : string , list : {[name:string] : boolean }):boolean{
//             //是否是图片资源
//             if(_type != AssetTypeEnum.Texture && _type != AssetTypeEnum.PVR && _type != AssetTypeEnum.DDS) return false;
//             let idx = name.indexOf(".");
//             let decName = name.substr(0,idx) + `.imgdesc.json`;
//             return list[decName] == true;
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 加载包
//          * @param assetmgr 资源管理器实例
//          * @param stateinfo 加载的状态信息实例
//          * @version m4m 1.0
//          */
//         load(assetmgr: assetMgr, onstate: (state: stateLoad) => void, state: stateLoad) {
//             if (assetmgr && assetmgr != this.assetmgr) {
//                 this.assetmgr = assetmgr;
//             }
//             state.totalByteLength = this.totalLength;
//             let filse = this.files;
//             let fLen = filse.length;
//             let glvshaders: { url: string, type: AssetTypeEnum, asset: IAsset }[] = [];
//             let glfshaders: { url: string, type: AssetTypeEnum, asset: IAsset }[] = [];
//             let shaders: { url: string, type: AssetTypeEnum, asset: IAsset }[] = [];
//             let meshs: { url: string, type: AssetTypeEnum, asset: IAsset }[] = [];
//             let textures: { url: string, type: AssetTypeEnum, asset: IAsset }[] = [];
//             let texturedescs: { url: string, type: AssetTypeEnum, asset: IAsset }[] = [];
//             let materials: { url: string, type: AssetTypeEnum, asset: IAsset }[] = [];
//             let anclips: { url: string, type: AssetTypeEnum, asset: IAsset }[] = [];
//             let prefabs: { url: string, type: AssetTypeEnum, asset: IAsset }[] = [];
//             let scenes: { url: string, type: AssetTypeEnum, asset: IAsset }[] = [];
//             let textassets: { url: string, type: AssetTypeEnum, asset: IAsset }[] = [];
//             let pvrs: { url: string, type: AssetTypeEnum, asset: IAsset }[] = [];
//             let packs: { url: string, type: AssetTypeEnum, asset: IAsset }[] = [];
//             let f14effs: { url: string, type: AssetTypeEnum, asset: IAsset }[] = [];
//             let fonts: { url: string, type: AssetTypeEnum, asset: IAsset }[] = [];
//             let atlass: { url: string, type: AssetTypeEnum, asset: IAsset }[] = [];
//             let ddss: { url: string, type: AssetTypeEnum, asset: IAsset }[] = [];
//             let kfaniclips: { url: string, type: AssetTypeEnum, asset: IAsset }[] = [];
//             let asslist: any[] = [];
//             //这里定义了加载顺序
//             asslist.push(packs, glvshaders, glfshaders, shaders, textassets, meshs,
//                 textures, pvrs, ddss, texturedescs, fonts, atlass,
//                 materials, anclips, kfaniclips, f14effs, prefabs, scenes);
//             let mapPackes: { [id: string]: number } = {};
//             //合并的包要先加载
//             for (let pack of this.packages) {
//                 let type: AssetTypeEnum = assetmgr.calcType(pack);
//                 let url = this.path + "/" + pack;
//                 packs.push({ url: url, type: type, asset: null });
//             }
//             //name map 重复贴图资源需要使用
//             let nameMap = {};
//             for(let i=0; i < fLen ;i++){
//                 let file = filse[i];
//                 nameMap[file.name] = true;
//             }            
//             let guidList : {[guid:string] : boolean} = {};
//             let list: { url: string, type: AssetTypeEnum, guid : string , asset: IAsset, handle: () => any }[] = [];
//             //遍历每项资源 整理到加载列表
//             for(let i=0; i < fLen ;i++){
//                 let fitem = filse[i];
//                 let type: AssetTypeEnum = assetmgr.calcType(fitem.name);
//                 //检查重复贴图资源
//                 if(this.isTextureRepeat(type,fitem.name,nameMap)) continue;
//                 let url = this.path + "/" + fitem.name;
//                 let fileName = assetmgr.getFileName(url);
//                 let guid = fitem.guid;
//                 // if (guid != undefined && !assetBundle.noParsingLoadedDic[guid]) {   //已预载过 处理
//                     if (guid != undefined) {   //已预载过 处理
//                     let mapGuid = assetmgr.mapGuidId;
//                     let mAssId = mapGuid[guid];
//                     // guid重复性检查
//                     //是否guid_map 中包含 (重复资源)
//                     if (mAssId != undefined) {
//                         //如果是来自同一个ab包的 guid重复资源 ，则不放入等待列表
//                         if (guidList[guid]) {
//                             continue;
//                         }
//                         let sRef = assetmgr.mapRes[mAssId];
//                         //同guid 资源 是否 正在加载中 
//                         if (sRef && assetmgr.assetIsLoing(sRef)) {
//                             //是 加入 guid_waitLoad_map
//                             //关联到 bundle 的 加载状态队列
//                             state.resstate[fileName] = new ResourceState();
//                             //考虑-- 失败 情况
//                             //等待执行 前后时间
//                             this.waitGuidCount++; //加入等待列表 ，计数增加
//                             let waitLoaded = () => {
//                                 let old = this.waitGuidCount;
//                                 this.waitGuidCount--; //减少计数
//                                 //检查加载结束to解析资源
//                                 this.CkNextHandleOfGuid(list, state, onstate);
//                             };
//                             assetBundle.addToWaitList(this.assetmgr,waitLoaded,guid);
//                         }
//                         continue;  //跳过 不放入加载队列
//                     }
//                 }
//                 guidList[guid] = true; //
//                 // let url = this.path + "/" + fitem.name;
//                 // let fileName = assetmgr.getFileName(url);
//                 if (fitem.packes != -1) {
//                     //压缩在包里的
//                     mapPackes[url] = fitem.packes;
//                 }
//                 {
//                     let asset = null;
//                     let _item = { url, type, guid, asset: null };
//                     switch (type) {
//                         case AssetTypeEnum.GLFragmentShader:
//                             glfshaders.push(_item);
//                             break;
//                         case AssetTypeEnum.GLVertexShader:
//                             glvshaders.push(_item);
//                             break;
//                         case AssetTypeEnum.Shader:
//                             asset = new shader(fileName);
//                             shaders.push(_item);
//                             break;
//                         case AssetTypeEnum.Texture:
//                             asset = new texture(fileName);
//                             textures.push(_item);
//                             break;
//                         case AssetTypeEnum.TextureDesc:
//                             asset = new texture(fileName);
//                             texturedescs.push(_item);
//                             break;
//                         case AssetTypeEnum.Mesh:
//                             asset = new mesh(fileName);
//                             meshs.push(_item);
//                             break;
//                         case AssetTypeEnum.Material:
//                             asset = new material(fileName);
//                             materials.push(_item);
//                             break;
//                         case AssetTypeEnum.Aniclip:
//                             asset = new animationClip(fileName);
//                             anclips.push(_item);
//                             break;
//                         case AssetTypeEnum.Prefab:
//                             asset = new prefab(fileName);
//                             prefabs.push(_item);
//                             break;
//                         case AssetTypeEnum.cPrefab:
//                             asset = new prefab(fileName);
//                             prefabs.push(_item);
//                             break;
//                         case AssetTypeEnum.Scene:
//                             asset = new rawscene(fileName);
//                             scenes.push(_item);
//                             break;
//                         case AssetTypeEnum.TextAsset:
//                             asset = new textasset(fileName);
//                             textassets.push(_item);
//                             break;
//                         case AssetTypeEnum.PVR:
//                             asset = new texture(fileName);
//                             pvrs.push(_item);
//                             break;
//                         case AssetTypeEnum.F14Effect:
//                             asset = new f14eff(fileName);
//                             f14effs.push(_item);
//                             break;
//                         case AssetTypeEnum.DDS:
//                             asset = new texture(fileName);
//                             ddss.push(_item);
//                             break;
//                         case AssetTypeEnum.Font:
//                             asset = new font(fileName);
//                             fonts.push(_item);
//                             break;
//                         case AssetTypeEnum.Atlas:
//                             asset = new atlas(fileName);
//                             atlass.push(_item);
//                             break;
//                         case AssetTypeEnum.KeyFrameAniclip:
//                             asset = new keyFrameAniClip(fileName);
//                             kfaniclips.push(_item);
//                             break;
//                     }
//                     _item.asset = asset;
//                     if (type != AssetTypeEnum.GLVertexShader && 
//                         type != AssetTypeEnum.GLFragmentShader && 
//                         type != AssetTypeEnum.Shader&& 
//                         type != AssetTypeEnum.PackBin && 
//                         type != AssetTypeEnum.PackTxt && 
//                         type != AssetTypeEnum.Prefab&&
//                         type != AssetTypeEnum.cPrefab
//                         ) {
//                         if (!asset)
//                             continue;
//                         let assId = asset.getGUID();
//                         this.mapNamed[fileName] = assId;
//                         assetmgr.regRes(fileName, asset);
//                         //注册 guid_map  {guid : AssetId}
//                         if (guid && assetmgr.mapGuidId[guid] == undefined) {
//                             assetmgr.mapGuidId[guid] = assId;
//                         }
//                     }
//                 }
//             }
//             let handles = {};
//             //按类型整理顺序到list 
//             for (let i = 0, len = asslist.length; i < len; ++i) {
//                 for (let j = 0, clen = asslist[i].length; j < clen; ++j) {
//                     let item = asslist[i][j];
//                     handles[item.url] = list.length;
//                     list.push({ url: item.url, type: item.type, guid: item.guid, asset: item.asset, handle: undefined });
//                 }
//             }
//             let packlist = [];
//             let haveBin = false;
//             let tempMap = {};
//             //按list 顺序加载
//             for (let item of list) {
//                 // let guid = item.guid;
//                 // if(guid != undefined && assetBundle.noParsingLoadedDic[guid]) continue; //判断是否在 不解析加载流程中 已经完成
//                 let surl = item.url;
//                 let type = item.type;
//                 let asset = item.asset;
//                 tempMap[surl] = 1;
//                 if (mapPackes[surl] != undefined) {
//                     packlist.push({ surl, type, asset });
//                     delete tempMap[surl];
//                     if (this.mapIsNull(tempMap))
//                         this.downloadFinsih(state, list, haveBin, onstate, packlist, mapPackes, handles);
//                 }
//                 else {
//                     if (type == AssetTypeEnum.PackBin) {
//                         haveBin = true;
//                         m4m.io.loadArrayBuffer(surl, (_buffer, err, isloadFail) => {
//                             if (err != null) {
//                                 state.isloadFail = isloadFail ? true : false;
//                                 state.iserror = true;
//                                 state.errs.push(new Error(err.message));
//                                 onstate(state);
//                                 return;
//                             }
//                             let read: m4m.io.binReader = new m4m.io.binReader(_buffer);
//                             let index = read.readInt32();
//                             read.position = index;
//                             while (read.canread()) {
//                                 let indindex = read.readInt32();
//                                 if (index == 0) break;
//                                 let key = read.readStringUtf8FixLength(indindex);
//                                 let strs: string[] = key.split('|');
//                                 let start = parseInt(strs[1]);
//                                 let len = parseInt(strs[2]);
//                                 let bufs: ArrayBuffer = _buffer.slice(start, start + len);
//                                 this.bundlePackBin[strs[0]] = bufs;
//                             }
//                             delete tempMap[surl];
//                             if (this.mapIsNull(tempMap))
//                                 this.downloadFinsih(state, list, haveBin, onstate, packlist, mapPackes, handles);
//                         },
//                             (loadedLength, totalLength) => {
//                                 state.compressBinLoaded = loadedLength;
//                                 onstate(state);
//                             });
//                     }
//                     else {
//                         assetmgr.loadSingleRes(surl, type, (s) => {
//                             if (s.iserror) {
//                                 state.iserror = true;
//                                 onstate(state);
//                                 return;
//                             }
//                             if (s.progressCall) {
//                                 s.progressCall = false;
//                                 onstate(state);
//                                 return;
//                             }
//                         }, state, asset, (data) => {
//                             list[handles[data.url]].handle = data.handle;
//                             delete tempMap[data.url];
//                             if (this.mapIsNull(tempMap))
//                                 this.downloadFinsih(state, list, haveBin, onstate, packlist, mapPackes, handles);
//                         });
//                     }
//                 }
//             }
//         }
//         //加载完毕处理
//         private downloadFinsih(state, list, haveBin: boolean, onstate, packlist, mapPackes, handles) {
//             if (haveBin) {
//                 let respackCall = (fcall: () => void) => {
//                     if (packlist.length < 1)
//                         fcall();
//                     let count = 0;
//                     for (let uitem of packlist) {
//                         //在pack里
//                         let respack;
//                         if (mapPackes[uitem.surl] == 0) respack = this.bundlePackJson;
//                         else if (mapPackes[uitem.surl] == 1) respack = this.bundlePackBin;
//                         else console.log("未识别的packnum: " + mapPackes[uitem.surl]);
//                         this.assetmgr.loadResByPack(respack, uitem.surl, uitem.type, (s) => {
//                             if (s.progressCall) {
//                                 s.progressCall = false;
//                                 onstate(state);
//                                 return;
//                             }
//                             if (state != undefined)
//                                 state.bundleLoadState |= uitem.loadstate;
//                         }, state, uitem.asset, (data) => {
//                             list[handles[data.url]].handle = data.handle;
//                             if (++count >= packlist.length)
//                                 fcall();
//                         });
//                     }
//                 };
//                 respackCall(() => {
//                     // this.NextHandle(list, state, onstate , assetmgr);
//                     this.CkNextHandleOfGuid(list, state, onstate);
//                 });
//             }
//             else
//                 // this.NextHandle(list, state, onstate,assetmgr);
//                 this.CkNextHandleOfGuid(list, state, onstate);
//         }
//         //检查GUID 去重 依赖资源包加载完毕
//         private CkNextHandleOfGuid(list, state, onstate) {
//             if (this.waitGuidCount > 0) return;
//             // this.NextHandle(list, state, onstate);
//             this.NextHandleParsing(list, state, onstate);
//         }
//         /**
//          * 添加到仅加载不解析列表 (true 成功)
//          * @param url assetBundle 的 url
//          * @param assetmgr 
//          */
//         // static addNoParsing(url:string , assetmgr : assetMgr):boolean{
//         //     if(! url || assetmgr.maploaded[url]) return false;  //对应资源已在 加载中或加载完成的 不处理
//         //     let fname = assetmgr.getFileName(url);
//         //     if(assetmgr.mapInLoad[fname] ) return false;
//         //     this.noParsingDic[url] = true;
//         //     return true;
//         // }
//         // private static noParsingDic : {[url:string]: boolean} = {};
//         // //是否需要解析
//         // static needParsing: boolean = true;
//         //待解析列表
//         // private static needParsesArr: {
//         //     [key: string]: {
//         //         keyList : string [];
//         //         list: { url: string, type: AssetTypeEnum, guid: string, asset: IAsset, handle: () => any }[],
//         //         state,
//         //         onstate,
//         //         call: (list: { url: string, type: AssetTypeEnum, guid: string, asset: IAsset, handle: () => any }[], state, onstate) => void
//         //     }
//         // } = {};
//         // //加载完毕后没解析的 字典列表
//         // private static noParsingLoadedDic : {[guid:string] : { url: string, type: AssetTypeEnum, guid: string, asset: IAsset, handle: () => any }} = {};
//         // private static pardingGuidDic : {[key:string] : boolean} = {};
//         /**
//          * 尝试解析预载过的 AB 资源 
//          * return true 解析成功
//          * @param url assetBundle 的 url
//          */
//         // static tryParsePreloadAB(url: string , onstate: (state: stateLoad) => void , assetmgr : assetMgr):boolean {
//         //     let source = this.needParsesArr[url];
//         //     if(!source) return false;
//         //     delete this.needParsesArr[url];
//         //     // let fname = assetmgr.getFileName(url);
//         //     // assetmgr.mapInLoad[fname] = source.state; //inload add
//         //     let loadlist = [];
//         //     let keys = source.keyList;
//         //     let len = keys.length;
//         //     let guidCount = 0;
//         //     let waitLoaded = () => {
//         //         guidCount--; //减少计数
//         //         if(guidCount <= 0 ){
//         //             //检查加载结束to解析资源
//         //             source.call(loadlist, source.state, onstate);
//         //         }
//         //     };
//         //     for(let i=0;i < len ;i++){
//         //         let key = keys[i];
//         //         let l = assetBundle.noParsingLoadedDic[key];
//         //         let needWait = false;
//         //         if(!l){
//         //             if(this.pardingGuidDic[key]) {
//         //                 needWait = true;
//         //             }
//         //             if(needWait){
//         //                 guidCount++;
//         //                 assetBundle.addToWaitList(assetmgr,waitLoaded,l.guid);
//         //             }
//         //             continue;
//         //         }
//         //         if(l && l.guid == key){
//         //             //guid 标记(需要等待去重解析回调)
//         //             this.pardingGuidDic[key] = true;
//         //             delete assetBundle.noParsingLoadedDic[key];
//         //         }
//         //         loadlist.push(l);
//         //     }
//         //     if(guidCount == 0){
//         //         source.call(loadlist, source.state, onstate);                           
//         //     }
//         //     return true;
//         // }
//         /** 仅资源加载完毕 回调 , ( 仅 addNoParsing() 调用过的有效 ) */
//         // static preloadCompleteFun:(url:string)=>any;
//         //文件加载完毕后统一解析处理 
//         // private NextHandle(list: { url: string, type: AssetTypeEnum, guid: string, asset: IAsset, handle: () => any }[], state, onstate) {
//         //     // if (assetBundle.needParsing) {
//         //     if (!assetBundle.noParsingDic[this.url]) {
//         //         this.NextHandleParsing(list, state, onstate);
//         //     } else {
//         //         // console.log("只预加载    " + this.url);
//         //         delete assetBundle.noParsingDic[this.url];  //清理记录
//         //         // let fname = this.assetmgr.getFileName(this.url);
//         //         // delete this.assetmgr.mapInLoad[fname]; //inload 记录清除
//         //         let keyList = [];
//         //         let len = list.length;
//         //         for(let i=0; i < len ;i++){  //不解析资源 下载完毕 的guid 或者 url 标记 
//         //             let l = list[i];
//         //             let key = "";   
//         //             if(!l )continue;
//         //             key = l.guid;
//         //             if(!key) key = l.url;
//         //             if(!key) continue;
//         //             if(!assetBundle.noParsingLoadedDic[key])    assetBundle.noParsingLoadedDic[key] = l;
//         //             keyList.push(key);
//         //         }
//         //         //放入容器等待 以后调用解析
//         //         assetBundle.needParsesArr[this.url] = {
//         //             keyList : keyList,
//         //             list: list,
//         //             state: state,
//         //             onstate: onstate,
//         //             call: this.NextHandleParsing.bind(this)
//         //         }
//         //         assetBundle.endWaitList(this.assetmgr,list); //去重依赖调用
//         //         if(assetBundle.preloadCompleteFun)  assetBundle.preloadCompleteFun(this.url);  //回调
//         //     }
//         // }
//         private NextHandleParsing(list: { url: string, type: AssetTypeEnum, guid: string, asset: IAsset, handle: () => any }[], state, onstate) {
//             let waitArrs = [];
//             let count = 0;
//             let lastHandle = [];
//             let finish = () => {
//                 // console.log(`资源包 :${this.url} 加载完成`);
//                 state.isfinish = true;
//                 onstate(state);
//                 //回调 guid列表
//                 assetBundle.endWaitList(this.assetmgr,list);
//             };
//             for (var i = 0, l = list.length; i < l; ++i) {
//                 var hitem = list[i];
//                 if (!hitem.handle)
//                     continue;
//                 if (hitem.type == AssetTypeEnum.Scene || 
//                     hitem.type == AssetTypeEnum.Prefab || 
//                     hitem.type == AssetTypeEnum.cPrefab || 
//                     hitem.type == AssetTypeEnum.F14Effect) {
//                     lastHandle.push(hitem)
//                     continue;
//                 }
//                 let waiting = hitem.handle();
//                 if (waiting&&waiting.then) {
//                     waitArrs.push(waiting);
//                     waiting.then(() => {
//                         if (++count >= waitArrs.length) {
//                             lastHandle.sort((a, b) => {
//                                 return b.type - a.type;
//                             })
//                             this.ReadyFinish(lastHandle,finish);
//                             waitArrs.length = 0;
//                             // finish();
//                         }
//                     });
//                 }
//             }
//             if (waitArrs.length < 1) {
//                 this.ReadyFinish(lastHandle,finish);
//             }
//         }
//         private ReadyFinish(lastHandle:any[],finish:()=>void)
//         {
//             let awaits = [];
//             let count = 0;
//             while (lastHandle.length > 0){
//                 let awaiting =  lastHandle.shift().handle();
//                 if(awaiting&&awaiting.then)
//                 {
//                     awaits.push(awaiting);
//                     awaiting.then(() => {
//                         if (++count >= awaits.length) {
//                             finish();
//                             awaits.length = 0;
//                         }
//                     });                   
//                 }
//             }
//             if(awaits.length == 0){
//                 finish();
//             }
//         }
//         private static addToWaitList(assetmgr : assetMgr,fun:Function,guid: string){
//             if(!guid)return;
//             let waitList: any[];
//             if (!assetmgr.mapGuidWaitLoaded[guid]) {
//                 assetmgr.mapGuidWaitLoaded[guid] = [];
//             }
//             waitList = assetmgr.mapGuidWaitLoaded[guid];
//             waitList.push(fun);//等待同guid资源加完 回调处理
//         }
//         private static endWaitList(assetmgr : assetMgr , list: { url: string, type: AssetTypeEnum, guid: string, asset: IAsset, handle: () => any }[]) {
//             //回调guid列表
//             let len = list.length;
//             for (let i = 0; i < len; i++) {
//                 let item = list[i];
//                 if (item.guid == undefined) continue;
//                 let guid = item.guid;
//                 // if(this.pardingGuidDic[guid]) delete this.pardingGuidDic[guid];
//                 let wlMap = assetmgr.mapGuidWaitLoaded;
//                 if (wlMap[guid] == undefined) continue;
//                 let waitList = wlMap[guid];
//                 if (waitList) {
//                     let len = waitList.length;
//                     for(let i=0 ;i < len ; i++){
//                         waitList[i]();
//                     }
//                     waitList.length = 0;
//                     delete wlMap[guid];
//                 }
//             }
//         }
//         private mapIsNull(map): boolean {
//             if (!map)
//                 return true;
//             for (let k in map)
//                 return false;
//             return true;
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * 资源GUID的字典，key为资源的名称
//          * @version m4m 1.0
//          */
//         mapNamed: { [name: string]: number } = {};
//         /**
//          * 资源名- Guid 字典
//          */
//         mapNameGuid: { [name: string]: string } = {};
//     }
// }
// namespace m4m.framework.old
// {
//     /**
//      * @public
//      * @language zh_CN
//      * @classdesc
//      * 资源类型
//      * @version m4m 1.0
//      */
//     // export enum AssetTypeEnum
//     // {
//     //     /**
//     //      * @public
//     //      * @language zh_CN
//     //      * 未知
//     //      * @version m4m 1.0
//     //      */
//     //     Unknown,
//     //     /**
//     //      * @public
//     //      * @language zh_CN
//     //      * 根据后缀 动态识别
//     //      * @version m4m 1.0
//     //      */
//     //     Auto,
//     //     /**
//     //      * @public
//     //      * @language zh_CN
//     //      * 资源包
//     //      * @version m4m 1.0
//     //      */
//     //     Bundle,
//     //     /**
//     //      * @public
//     //      * @language zh_CN
//     //      * 压缩的资源包
//     //      * @version m4m 1.0
//     //      */
//     //     CompressBundle,
//     //     /**
//     //      * @public
//     //      * @language zh_CN
//     //      * glsl vs
//     //      * @version m4m 1.0
//     //      */
//     //     GLVertexShader,
//     //     /**
//     //      * @public
//     //      * @language zh_CN
//     //      * glsl fs
//     //      * @version m4m 1.0
//     //      */
//     //     GLFragmentShader,
//     //     /**
//     //      * @public
//     //      * @language zh_CN
//     //      * shader
//     //      * @version m4m 1.0
//     //      */
//     //     Shader,
//     //     /**
//     //      * @public
//     //      * @language zh_CN
//     //      * 贴图
//     //      * @version m4m 1.0
//     //      */
//     //     Texture,
//     //     /**
//     //      * @public
//     //      * @language zh_CN
//     //      * 贴图desc
//     //      * @version m4m 1.0
//     //      */
//     //     TextureDesc,
//     //     /**
//     //      * @public
//     //      * @language zh_CN
//     //      * 模型
//     //      * @version m4m 1.0
//     //      */
//     //     Mesh,
//     //     /**
//     //      * @public
//     //      * @language zh_CN
//     //      * 材质
//     //      * @version m4m 1.0
//     //      */
//     //     Material,
//     //     /**
//     //      * @public
//     //      * @language zh_CN
//     //      * 动画片段
//     //      * @version m4m 1.0
//     //      */
//     //     Aniclip,
//     //     /**
//     //      * @public
//     //      * @language zh_CN
//     //      * 关键帧动画片段
//     //      * @version m4m 1.0
//     //      */
//     //     KeyFrameAniclip,
//     //     /**
//     //      * @public
//     //      * @language zh_CN
//     //      * 图集
//     //      * @version m4m 1.0
//     //      */
//     //     Atlas,
//     //     /**
//     //      * @public
//     //      * @language zh_CN
//     //      * 字体
//     //      * @version m4m 1.0
//     //      */
//     //     Font,
//     //     /**
//     //      * @public
//     //      * @language zh_CN
//     //      * 文本
//     //      * @version m4m 1.0
//     //      */
//     //     TextAsset,
//     //     /**
//     //      * @private
//     //      */
//     //     PackBin,
//     //     /**
//     //      * @private
//     //      */
//     //     PackTxt,
//     //     /**
//     //      * @public
//     //      * @language zh_CN
//     //      * 可编辑路径
//     //      * @version m4m 1.0
//     //      */
//     //     PathAsset,
//     //     /**
//     //      * @public
//     //      * @language zh_CN
//     //      * pvr贴图
//     //      * @version m4m 1.0
//     //      */
//     //     PVR,
//     //     F14Effect,
//     //     /**
//     //      * @public
//     //      * @language zh_CN
//     //      * dds贴图
//     //      * @version m4m 1.0
//     //      */
//     //     DDS,
//     //     /**
//     //      * @public
//     //      * @language zh_CN
//     //      * 场景
//     //      * @version m4m 1.0
//     //      */
//     //     Scene,
//     //     /**
//     //      * @public
//     //      * @language zh_CN
//     //      * 预设
//     //      * @version m4m 1.0
//     //      */
//     //     Prefab,
//     //     cPrefab,
//     // }
//     /**
//      * @public
//      * @language zh_CN
//      * @classdesc
//      * 资源加载状态
//      * @version m4m 1.0
//      */
//     export class ResourceState
//     {
//         res: IAsset = null;
//         state: number = 0;
//         loadedLength: number = 0;
//         // totalLength: number = 0;
//     }
//     /**
//      * @public
//      * @language zh_CN
//      * @classdesc
//      * 带引用的资源加载状态
//      * @version m4m 1.0
//      */
//     export class RefResourceState extends ResourceState
//     {
//         refLoadedLength: number = 0;
//     }
//     /**
//      * @public
//      * @language zh_CN
//      * @classdesc
//      * 加载状态
//      * @version m4m 1.0
//      */
//     export class stateLoad
//     {
//         /**
//          * @public
//          * @language zh_CN
//          * 加载是否失败
//          * @version m4m 1.0
//          */
//         isloadFail: boolean = false;
//         /**
//          * @public
//          * @language zh_CN
//          * 加载是否遇到错误
//          * @version m4m 1.0
//          */
//         iserror: boolean = false;
//         /**
//          * @public
//          * @language zh_CN
//          * 加载是否完成
//          * @version m4m 1.0
//          */
//         isfinish: boolean = false;
//         /**
//          * @public
//          * @language zh_CN
//          * 记录需要加载的每一个的状态和资源引用
//          * @version m4m 1.0
//          */
//         resstate: { [id: string]: ResourceState } = {};
//         /**
//          * @public
//          * @language zh_CN
//          * 记录加载的第一个的状态和资源引用
//          * @version m4m 1.0
//          */
//         resstateFirst: ResourceState = null;
//         /**
//          * @public
//          * @language zh_CN
//          * 当前的文件数进度
//          * @version m4m 1.0
//          */
//         curtask: number = 0;
//         /**
//          * @public
//          * @language zh_CN
//          * 文件数的总进度
//          * @version m4m 1.0
//          */
//         totaltask: number = 0;
//         /**
//          * @public
//          * @language zh_CN
//          * 获取文件数加载进度
//          * @version m4m 1.0
//          */
//         get fileProgress(): number
//         {
//             return this.curtask / this.totaltask;
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * 已加载的字节长度
//          * @version m4m 1.0
//          */
//         get curByteLength(): number
//         {
//             let result = 0;
//             for (let key in this.resstate)
//             {
//                 let _resState = this.resstate[key];
//                 result += _resState.loadedLength;
//                 if (_resState instanceof RefResourceState)
//                 {
//                     result += _resState.refLoadedLength;
//                 }
//             }
//             result += this.compressTextLoaded + this.compressBinLoaded;
//             return result;
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * 总字节长度
//          * @version m4m 1.0
//          */
//         totalByteLength: number = 0;
//         /**
//          * @public
//          * @language zh_CN
//          * 获取文件真实加载进度
//          * @version m4m 1.0
//          */
//         get progress(): number
//         {
//             return this.curByteLength / this.totalByteLength;
//         }
//         progressCall: boolean = false;
//         compressTextLoaded: number = 0;
//         compressBinLoaded: number = 0;
//         /**
//          * @public
//          * @language zh_CN
//          * 加载过程中记录的log
//          * @version m4m 1.0
//          */
//         logs: string[] = [];
//         /**
//          * @public
//          * @language zh_CN
//          * 加载过程中记录的错误信息
//          * @version m4m 1.0
//          */
//         errs: Error[] = [];
//         /**
//          * @public
//          * @language zh_CN
//          * 源url地址
//          * @version m4m 1.0
//          */
//         url: string;
//     }
//     /**
//      * @public
//      * @language zh_CN
//      * @classdesc
//      * 通用的资源管理器，你也可以自己搞个东西当资源，继承IResource即可<p/>
//      * 资源管理器用引用计数法管理资源，计数混乱会导致问题，循环引用也会导致问题，需要注意<p/>
//      * js 语法层面不能提供可靠的自动引用计数机制，所以如果你用乱了，哪啊就是乱了<p/>
//      * 所有的资源都是从资源管理器get出来的<p/>
//      * 所有的资源不用的时候都要还到资源管理器<p/>
//      * @version m4m 1.0
//      */
//     export class assetMgr
//     {
//         /**
//          * @private
//          */
//         app: application;
//         /**
//          * @private
//          */
//         webgl: WebGL2RenderingContext;
//         /**
//          * @private
//          */
//         shaderPool: m4m.render.shaderPool;
//         /**
//          * @private
//          */
//         constructor(app: application)
//         {
//             this.app = app;
//             this.webgl = app.webgl;
//             this.shaderPool = new m4m.render.shaderPool();
//             this.initAssetFactorys();
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 初始化默认资源
//          * @version m4m 1.0
//          */
//         initDefAsset()
//         {
//             // defMesh.initDefaultMesh(this);
//             // defTexture.initDefaultTexture(this);
//             // defsprite.initDefaultSprite(this);
//             // defShader.initDefaultShader(this);
//             // defmaterial.initDefaultMaterial(this);
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * shader字典
//          * @version m4m 1.0
//          */
//         mapShader: { [id: string]: shader } = {};
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 通过name获取shader资源
//          * @param name 
//          * @version m4m 1.0
//          */
//         getShader(name: string): shader
//         {
//             return this.mapShader[name];
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 默认Mesh资源
//          * @version m4m 1.0
//          */
//         mapDefaultMesh: { [id: string]: mesh } = {};
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 通过name获取默认mesh资源
//          * @param name
//          * @version m4m 1.0
//          */
//         getDefaultMesh(name: string): mesh
//         {
//             return this.mapDefaultMesh[name];
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 默认图片资源
//          * @version m4m 1.0
//          */
//         mapDefaultTexture: { [id: string]: texture } = {};
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 通过name获取默认贴图资源
//          * @param name
//          * @version m4m 1.0
//          */
//         getDefaultTexture(name: string): texture
//         {
//             return this.mapDefaultTexture[name];
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 默认cube贴图资源
//          * @version m4m 1.0
//          */
//         mapDefaultCubeTexture: { [id: string]: texture } = {};
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 通过name获取默认cube贴图资源
//          * @param name
//          * @version m4m 1.0
//          */
//         getDefaultCubeTexture(name: string): texture
//         {
//             return this.mapDefaultCubeTexture[name];
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 默认sprite资源
//          * @version m4m 1.0
//          */
//         mapDefaultSprite: { [id: string]: sprite } = {};
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 通过name获取默认sprite资源
//          * @param name
//          * @version m4m 1.0
//          */
//         getDefaultSprite(name: string): sprite
//         {
//             return this.mapDefaultSprite[name];
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 默认材质资源
//          * @version m4m 1.0
//          */
//         mapMaterial: { [id: string]: material } = {};
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 通过name获取材质资源
//          * @param name
//          * @version m4m 1.0
//          */
//         getMaterial(name: string): material
//         {
//             return this.mapMaterial[name];
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * assetbundle的字典，key为bundlename
//          * @version m4m 1.0
//          */
//         mapBundle: { [id: string]: assetBundle } = {};
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 资源的字典，key为资源的GUID
//          * @version m4m 1.0
//          */
//         mapRes: { [id: number]: assetRef } = {};
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 资源GUID的字典，key为资源的名称
//          * @version m4m 1.0
//          */
//         mapNamed: { [id: string]: number[] } = {};
//         /**
//          * 资源guid的字典，key为资源的ID
//          */
//         mapGuidId: { [guid: string]: number } = {};
//         /**
//          * 等待加载完毕后 统一回调 字典
//          */
//         mapGuidWaitLoaded: { [guid: string]: Function[] } = {};
//         /**
//         * @public
//         * @language zh_CN
//         * @version m4m 1.0
//          * @classdesc
//         * 通过资源的GUID获取资源
//         * @param id 资源的GUID
//         */
//         getAsset(id: number): IAsset
//         {
//             var r = this.mapRes[id];
//             if (r == null) return null;
//             return r.asset;
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 通过资源的名称获取资源
//          * @version m4m 1.0
//          * @param name 资源的名称
//          */
//         getAssetByName(name: string, bundlename: string = null): IAsset
//         {
//             let id = null;
//             if (this.mapNamed[name] != null)
//             {
//                 //id = this.mapNamed[name][0];
//                 id = this.mapNamed[name][this.mapNamed[name].length - 1];
//             }
//             if (bundlename != null)
//             {
//                 let ab = this.mapBundle[bundlename] as assetBundle;
//                 if (ab != null)
//                 {
//                     if (ab.mapNamed[name])
//                     {  //尝试从Name 列表中取
//                         id = ab.mapNamed[name]
//                     } else if (ab.mapNameGuid[name])
//                     {  //尝试从guid 列表中取
//                         let guid = ab.mapNameGuid[name];
//                         if (this.mapGuidId[guid] != undefined)
//                             id = this.mapGuidId[guid];
//                     }
//                 }
//             }
//             let flag: boolean = true;
//             if (id != null)
//             {
//                 var r = this.mapRes[id];
//                 if (r != null && !r[this._loadingTag])//)
//                     return r.asset;
//             }
//             if (flag)
//             {
//                 if (this.mapDefaultMesh[name] != undefined)
//                     return this.mapDefaultMesh[name];
//                 if (this.mapDefaultTexture[name] != undefined)
//                     return this.mapDefaultTexture[name];
//                 if (this.mapShader[name] != undefined)
//                     return this.mapShader[name];
//             }
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 通过assetbundle的名称获取包
//          * @param bundlename 包的名称
//          * @version m4m 1.0
//          */
//         getAssetBundle(bundlename: string): assetBundle
//         {
//             if (this.mapBundle[bundlename])
//                 return this.mapBundle[bundlename];
//             return null;
//         }
//         static useBinJs: boolean = false;
//         private static bin = ".bin";
//         static correctFileName(name: string): string
//         {
//             if (name.indexOf(this.bin) < 0)
//             {
//                 return name;
//             }
//             let binlen = this.bin.length;
//             let substr = name.substring(name.length - binlen);
//             if (substr == this.bin)
//             {
//                 return name + ".js";
//             }
//             return name;
//         }
//         static txt = ".txt";
//         static correctTxtFileName(name: string): string
//         {
//             if (name.indexOf(this.txt) < 0)
//             {
//                 return name;
//             }
//             let len = this.txt.length;
//             let substr = name.substring(name.length - len);
//             if (substr == this.txt)
//             {
//                 return name + ".js";
//             }
//             return name;
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 取消资源的引用，当前资源的引用计数减一
//          * @param res 需要取消引用的资源
//          * @param disposeNow 如果引用计数归零则立即释放
//          * @version m4m 1.0
//          */
//         unuse(res: IAsset, disposeNow: boolean = false)
//         {
//             var id = res.getGUID();
//             var name = res.getName();
//             if (res.defaultAsset)//静态资源不参与引用计数管理
//             {
//                 return;
//             }
//             if (!this.mapRes[id]) return;
//             this.mapRes[id].refcount--;
//             if (disposeNow || this.mapRes[id].refcount <= 0)
//             {
//                 this.mapRes[id].asset.dispose();
//                 if (name != null)
//                 {
//                     if (this.mapNamed[name].length <= 1)
//                     {
//                         delete this.mapNamed[name];
//                     }
//                     else
//                     {
//                         for (let key in this.mapNamed[name])
//                         {
//                             if (id == this.mapNamed[name][key])
//                             {
//                                 this.mapNamed[name].splice(parseInt(key), 1);
//                             }
//                         }
//                     }
//                 }
//                 delete this.mapRes[id];
//             }
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 引用资源，当前资源的引用计数加一
//          * @param res 需要引用的资源
//          * @version m4m 1.0
//          */
//         use(res: IAsset)
//         {
//             var id = res.getGUID();
//             var name = res.getName();
//             if (id <= 0)//如果没有id，分配一个
//             {
//                 throw new Error("不合法的res guid:" + name);
//             }
//             if (res.defaultAsset)//静态资源不参与引用计数管理
//             {
//                 return;
//             }
//             if (this.mapRes[id] == null)
//             {
//                 this.mapRes[id] = { asset: res, refcount: 0 };
//                 if (name != null)
//                 {
//                     if (this.mapNamed[name] == null)
//                         this.mapNamed[name] = [];
//                     this.mapNamed[name].push(id);
//                 }
//             }
//             this.mapRes[id].refcount++;
//             if (this.mapRes[id][this._loadingTag])
//             {
//                 delete this.mapRes[id][this._loadingTag];
//             }
//         }
//         private readonly _loadingTag = "_AssetLoingTag_";
//         /** 判断是否在加载中 */
//         assetIsLoing(asRef: assetRef)
//         {
//             if (!asRef) return false;
//             return this._loadingTag in asRef;
//         }
//         regRes(name: string, asset: IAsset)
//         {
//             let id = asset.getGUID();
//             if (this.mapRes[id] == null)
//             {
//                 this.mapRes[id] = { asset: asset, refcount: 0 };
//                 this.mapRes[id][this._loadingTag] = true; //没加载完之前 标记一下防止被清理
//                 if (name != null)
//                 {
//                     if (this.mapNamed[name] == null)
//                         this.mapNamed[name] = [];
//                     this.mapNamed[name].push(id);
//                 }
//             }
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 释放所有引用为零的资源
//          * @version m4m 1.0
//          */
//         releaseUnuseAsset()
//         {
//             for (let k in this.mapRes)
//             {
//                 if (this.mapRes[k].refcount <= 0)
//                 {
//                     if (this.mapRes[k][this._loadingTag]) continue;
//                     let name = this.mapRes[k].asset.getName();
//                     if (this.mapNamed[name].length <= 1)
//                     {
//                         delete this.mapNamed[name];
//                     }
//                     else
//                     {
//                         for (let key in this.mapNamed[name])
//                         {
//                             if (this.mapRes[k].asset.getGUID() == this.mapNamed[name][key])
//                             {
//                                 this.mapNamed[name].splice(parseInt(key), 1);
//                             }
//                         }
//                     }
//                     this.mapRes[k].asset.dispose();
//                     delete this.mapRes[k];
//                 }
//             }
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 返回所有资源引用计数
//          * @version m4m 1.0
//          */
//         getAssetsRefcount(): { [id: string]: number }
//         {
//             let mapRefcout: { [id: string]: number } = {};
//             for (var k in this.mapNamed)
//             {
//                 if (this.mapNamed[k].length == 1)
//                 {
//                     let res = this.mapRes[this.mapNamed[k][0]];
//                     mapRefcout[k] = res.refcount;
//                 }
//                 else
//                 {
//                     for (let key in this.mapNamed[k])
//                     {
//                         let res = this.mapRes[this.mapNamed[k][key]];
//                         mapRefcout[k + "(" + key + ")"] = res.refcount;
//                     }
//                 }
//             }
//             return mapRefcout;
//         }
//         mapInLoad: { [id: string]: stateLoad } = {};
//         removeAssetBundle(name: string)
//         {
//             if (this.mapBundle[name] != null)
//                 delete this.mapBundle[name];
//             if (this.mapInLoad[name] != null)
//                 delete this.mapInLoad[name];
//         }
//         private assetUrlDic: { [id: number]: string } = {};
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 设置资源的url
//          * @version m4m 1.0
//          * @param asset 资源
//          * @param url url
//          */
//         setAssetUrl(asset: IAsset, url: string)
//         {
//             this.assetUrlDic[asset.getGUID()] = url;
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 获取资源的url
//          * @version m4m 1.0
//          * @param asset 资源
//          */
//         getAssetUrl(asset: IAsset): string
//         {
//             return this.assetUrlDic[asset.getGUID()];
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 加载单个资源
//          * 所有load进来的资源，均use一遍，引用计数为1
//          * 再unload 一次 归0，则可dispose（）
//          * @version m4m 1.0
//          * @param url 资源的url
//          * @param type 资源的类型
//          * @param onstate 状态返回的回调
//          * @param state 资源加载的总状态
//          */
//         loadSingleRes(url: string, type: AssetTypeEnum, onstate: (state: stateLoad) => void, state: stateLoad, asset: IAsset, call: (handle: any) => void)
//         {
//             let assetFactory: IAssetFactory = this.getAssetFactory(type);
//             if (assetFactory != null)
//             {
//                 // assetFactory.load(url, onstate, state, this, asset, (chandle) =>
//                 // {
//                 //     call({ url: url, handle: chandle });
//                 // });
//             }
//             else
//             {
//                 throw new Error("cant use the type:" + type);
//             }
//         }
//         /**
//          * @private
//          * @param packnum 
//          * @param url 
//          * @param type 
//          * @param onstate 
//          * @param state 
//          */
//         loadResByPack(respack: any, url: string, type: AssetTypeEnum, onstate: (state: stateLoad) => void, state: stateLoad, asset: IAsset, call: (handle: any) => void)
//         {
//             let assetFactory: IAssetFactory = this.getAssetFactory(type);
//             if (assetFactory != null)
//             {
//                 // assetFactory.loadByPack(respack, url, onstate, state, this, asset, ((chandle) =>
//                 // {
//                 //     call({ url: url, handle: chandle });
//                 // }));
//             }
//             else
//             {
//                 throw new Error("cant use the type:" + type);
//             }
//         }
//         private assetFactorys: { [key: string]: IAssetFactory } = {};
//         private regAssetFactory(type: AssetTypeEnum, factory: IAssetFactory)
//         {
//             this.assetFactorys[type.toString()] = factory;
//         }
//         private getAssetFactory(type: AssetTypeEnum)
//         {
//             return this.assetFactorys[type];
//         }
//         private initAssetFactorys()
//         {
//             this.regAssetFactory(AssetTypeEnum.GLVertexShader, new AssetFactory_GLVertexShader());
//             this.regAssetFactory(AssetTypeEnum.GLFragmentShader, new AssetFactory_GLFragmentShader());
//             this.regAssetFactory(AssetTypeEnum.Shader, new AssetFactory_Shader());
//             this.regAssetFactory(AssetTypeEnum.Texture, new AssetFactory_Texture());
//             this.regAssetFactory(AssetTypeEnum.TextureDesc, new AssetFactory_TextureDesc());
//             this.regAssetFactory(AssetTypeEnum.Mesh, new AssetFactory_Mesh());
//             // this.regAssetFactory(AssetTypeEnum.Prefab, new AssetFactory_Prefab());
//             this.regAssetFactory(AssetTypeEnum.cPrefab, new AssetFactory_cPrefab());
//             this.regAssetFactory(AssetTypeEnum.Material, new AssetFactory_Material());
//             this.regAssetFactory(AssetTypeEnum.Aniclip, new AssetFactory_Aniclip());
//             this.regAssetFactory(AssetTypeEnum.Scene, new AssetFactory_Scene());
//             this.regAssetFactory(AssetTypeEnum.Atlas, new AssetFactory_Atlas());
//             this.regAssetFactory(AssetTypeEnum.Font, new AssetFactory_Font());
//             this.regAssetFactory(AssetTypeEnum.TextAsset, new AssetFactory_TextAsset());
//             // this.regAssetFactory(AssetTypeEnum.PackBin,new AssetFactory_PackBin());
//             // this.regAssetFactory(AssetTypeEnum.PackTxt,new AssetFactory_PackTxt());
//             this.regAssetFactory(AssetTypeEnum.PathAsset, new AssetFactory_PathAsset());
//             this.regAssetFactory(AssetTypeEnum.PVR, new AssetFactory_PVR());
//             this.regAssetFactory(AssetTypeEnum.F14Effect, new AssetFactory_f14eff());
//             this.regAssetFactory(AssetTypeEnum.DDS, new AssetFactory_DDS());
//             this.regAssetFactory(AssetTypeEnum.KeyFrameAniclip, new assetfactory_keyFrameAniClip());
//         }
//         private waitStateDic: { [name: string]: Function[] } = {};
//         /**
//          * @private
//          * @param name 
//          * @param state 
//          */
//         public doWaitState(name: string, state: stateLoad)
//         {
//             if (this.waitStateDic[name] == null)
//                 return;
//             for (var key in this.waitStateDic[name])
//             {
//                 this.waitStateDic[name][key](state);
//             }
//             if (state.isfinish)
//             {
//                 this.waitStateDic[name].length = 0;
//             }
//         }
//         private waitQueueState: { state: stateLoad, type: AssetTypeEnum, onstate: (state: stateLoad) => void }[] = [];
//         private loadingQueueState: { state: stateLoad, type: AssetTypeEnum, onstate: (state: stateLoad) => void }[] = [];
//         private loadingCountLimit: number = 10;
//         private checkFreeChannel(): number
//         {
//             let freechannel = -1;
//             for (let k = 0; k < this.loadingQueueState.length; k++)
//             {
//                 if (this.loadingQueueState[k] == undefined)
//                 {
//                     freechannel = k;
//                     break;
//                 }
//                 else if (!this.loadingQueueState[k].state.isfinish && !this.loadingQueueState[k].state.iserror)
//                 {
//                     continue;
//                 }
//                 else
//                 {
//                     delete this.loadingQueueState[k];
//                     freechannel = k;
//                     break;
//                 }
//             }
//             if (freechannel == -1 && this.loadingQueueState.length < this.loadingCountLimit)
//             {
//                 freechannel = this.loadingQueueState.length;
//             }
//             return freechannel;
//         }
//         // public loadByMulQueue()
//         // {
//         //     if (this.waitQueueState.length == 0) return;
//         //     let freechannel = this.checkFreeChannel();
//         //     if (freechannel == -1) return;
//         //     let curloadinfo = this.waitQueueState.shift();
//         //     this.loadingQueueState[freechannel] = curloadinfo;
//         //     let state = curloadinfo.state;
//         //     let url = state.url;
//         //     let type = curloadinfo.type;
//         //     let onstate = curloadinfo.onstate;
//         //     if (type == AssetTypeEnum.Bundle)//加载包
//         //     {
//         //         m4m.io.loadText(url, (txt, err) =>
//         //         {
//         //             if (err != null)
//         //             {
//         //                 curloadinfo.state.iserror = true;
//         //                 curloadinfo.state.errs.push(new Error(err.message));
//         //                 onstate(state);
//         //                 return;
//         //             }
//         //             let json = JSON.parse(txt);
//         //             let filename = "";
//         //             if (json["files"])
//         //             {
//         //                 filename = this.getFileName(url);
//         //                 var ab = new assetBundle(url);
//         //                 ab.name = filename;
//         //                 ab.parse(JSON.parse(txt));
//         //                 ab.load(this, onstate, state);
//         //             } else
//         //             {
//         //                 let loadurl = url.replace(".assetbundle.json", ".packs.txt");
//         //                 filename = this.getFileName(url);
//         //                 var ab = new assetBundle(url);
//         //                 ab.name = filename;
//         //                 ab.totalLength = json["totalLength"];
//         //                 ab.loadCompressBundle(loadurl, onstate, state, this);
//         //             }
//         //             this.mapBundle[filename] = ab;
//         //         });
//         //     }
//         //     else if (type == AssetTypeEnum.CompressBundle)
//         //     {
//         //         m4m.io.loadText(url, (txt, err) =>
//         //         {
//         //             if (err != null)
//         //             {
//         //                 curloadinfo.state.iserror = true;
//         //                 curloadinfo.state.errs.push(new Error(err.message));
//         //                 onstate(state);
//         //                 return;
//         //             }
//         //             //压缩的bundle在packs.txt中
//         //             let loadurl = url.replace(".assetbundle.json", ".packs.txt");
//         //             let filename = this.getFileName(url);
//         //             let json = JSON.parse(txt);
//         //             var ab = new assetBundle(url);
//         //             ab.name = filename;
//         //             ab.totalLength = json["totalLength"];
//         //             ab.loadCompressBundle(loadurl, onstate, state, this);
//         //         });
//         //     }
//         //     else
//         //     {
//         //         state.totaltask = 1;
//         //         this.loadSingleRes(url, type, (s) =>
//         //         {
//         //             if (s.iserror)
//         //             {
//         //                 onstate(state);
//         //                 this.loadByMulQueue();
//         //                 return;
//         //             }
//         //             if (s.progressCall)
//         //             {
//         //                 s.progressCall = false;
//         //                 onstate(state);
//         //                 return;
//         //             }
//         //             state.curtask = 1;
//         //             s.isfinish = true;
//         //             onstate(s);
//         //             this.doWaitState(url, s);
//         //             this.loadByMulQueue();
//         //         }, state, null, (handle) =>
//         //             {
//         //             });
//         //     }
//         // }
//         private unPkg(type: AssetTypeEnum, url: string, state: stateLoad, onstate: (state: stateLoad) => void)
//         {
//             //加载AB bundle 包
//             if (type == AssetTypeEnum.Bundle)
//             {
//                 m4m.io.loadText(url, (txt, err, isloadFail) =>
//                 {
//                     if (err != null)
//                     {
//                         state.isloadFail = isloadFail ? true : false;
//                         state.iserror = true;
//                         state.errs.push(new Error(err.message));
//                         onstate(state);
//                         return;
//                     }
//                     let json = JSON.parse(txt);
//                     let filename = "";
//                     if (json["files"])
//                     {
//                         filename = this.getFileName(url);
//                         var ab = new assetBundle(url);
//                         ab.name = filename;
//                         ab.parse(json);
//                         ab.load(this, onstate, state);
//                     } else
//                     {
//                         let loadurl = url.replace(".assetbundle.json", ".packs.txt");
//                         filename = this.getFileName(url);
//                         var ab = new assetBundle(url);
//                         ab.name = filename;
//                         ab.totalLength = json["totalLength"];
//                         ab.loadCompressBundle(loadurl, onstate, state, this);
//                     }
//                     this.mapBundle[filename] = ab;
//                 });
//             }
//             else if (type == AssetTypeEnum.CompressBundle)   //加载 压缩的 AB bundle 包
//             {
//                 m4m.io.loadText(url, (txt, err, isloadFail) =>
//                 {
//                     if (err != null)
//                     {
//                         state.isloadFail = isloadFail ? true : false;
//                         state.iserror = true;
//                         state.errs.push(new Error(err.message));
//                         onstate(state);
//                         return;
//                     }
//                     //压缩的bundle在packs.txt中
//                     let loadurl = url.replace(".assetbundle.json", ".packs.txt");
//                     let filename = this.getFileName(url);
//                     let json = JSON.parse(txt);
//                     var ab = new assetBundle(url);
//                     ab.name = filename;
//                     ab.totalLength = json["totalLength"];
//                     ab.loadCompressBundle(loadurl, onstate, state, this);
//                 });
//             }
//             else
//             {
//                 state.totaltask = 1;
//                 this.loadSingleRes(url, type, (s) =>
//                 {
//                     if (s.iserror)
//                     {
//                         state.iserror = true;
//                         onstate(state);
//                         return;
//                     }
//                     if (s.progressCall)
//                     {
//                         s.progressCall = false;
//                         onstate(state);
//                         return;
//                     }
//                     state.curtask = 1;
//                     s.isfinish = true;
//                     onstate(s);
//                     this.doWaitState(url, s);
//                 }, state, null, (data) =>
//                     {
//                         if (data.handle)
//                             data.handle();
//                     });
//             }
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 加载压缩后的包
//          * @version m4m 1.0
//          * @param url 资源的url
//          * @param type 资源的类型
//          * @param onstate 状态返回的回调
//          */
//         loadCompressBundle(url: string, onstate: (state: stateLoad) => void = null)
//         {
//             if (this.maploaded[url])
//             {
//                 if (onstate)
//                 {
//                     let state = new stateLoad();
//                     state.isfinish = true;
//                     onstate(state);
//                 }
//                 return;
//             }
//             let name = this.getFileName(url);
//             let type = this.calcType(url);
//             var state = new stateLoad();
//             this.mapInLoad[name] = state;
//             state.url = url;
//             if (type != AssetTypeEnum.Bundle)
//             {
//                 state.errs.push(new Error("is not bundle compress type:" + url));
//                 state.iserror = true;
//                 onstate(state);
//                 this.doWaitState(url, state);
//                 return;
//             }
//             // console.log(`** mgr loadCompressBundle: ${url}`);
//             type = AssetTypeEnum.CompressBundle;
//             this.unPkg(type, url, state, onstate);
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 加载资源
//          * 这里来区分assetbundle和单个资源
//          * @version m4m 1.0
//          * @param url 资源的url
//          * @param type 资源的类型
//          * @param onstate 状态返回的回调
//          */
//         // private time: number;
//         maploaded: { [url: string]: IAsset } = {};
//         load(url: string, type: AssetTypeEnum = AssetTypeEnum.Auto, onstate: (state: stateLoad) => void = null)
//         {
//             if (onstate == null)
//                 onstate = () => { };
//             // let parsed =  assetBundle.tryParsePreloadAB(url , onstate , this);
//             // if(parsed) return;   //尝试 直接解析之前加载完毕的资源
//             // console.log(`资源包 : ${url} 开始加载`);
//             if (this.maploaded[url])
//             {
//                 if (onstate)
//                 {
//                     var state = new stateLoad();
//                     state.isfinish = true;
//                     onstate(state);
//                 }
//                 return;
//             }
//             let name = this.getFileName(url);
//             if (this.mapInLoad[name] != null)
//             {
//                 let _state = this.mapInLoad[name];
//                 if (_state.isfinish)
//                 {
//                     onstate(this.mapInLoad[name]);
//                 }
//                 return;
//             }
//             var state = new stateLoad();
//             this.mapInLoad[name] = state;
//             state.url = url;
//             //确定资源类型
//             if (type == AssetTypeEnum.Auto)
//             {
//                 type = this.calcType(url);
//             }
//             if (type == AssetTypeEnum.Unknown)
//             {
//                 state.errs.push(new Error("can not sure about type:" + url));
//                 state.iserror = true;
//                 onstate(state);
//                 return;
//             }
//             this.unPkg(type, url, state, onstate);
//         }
//         private loadForNoCache(url: string, type: AssetTypeEnum = AssetTypeEnum.Auto, onstate: (state: stateLoad) => void = null)
//         {
//             if (onstate == null)
//                 onstate = () => { };
//             let name = this.getFileName(url);
//             var state = new stateLoad();
//             this.mapInLoad[name] = state;
//             state.url = url;
//             //确定资源类型
//             if (type == AssetTypeEnum.Auto)
//             {
//                 type = this.calcType(url);
//             }
//             if (type == AssetTypeEnum.Unknown)
//             {
//                 state.errs.push(new Error("can not sure about type:" + url));
//                 state.iserror = true;
//                 onstate(state);
//                 this.doWaitState(url, state);
//                 return;
//             }
//             this.unPkg(type, url, state, onstate);
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 卸载资源
//          * @version m4m 1.0
//          * @param url 资源的url
//          * @param onstate 状态返回的回调
//          */
//         unload(url: string, onstate: () => void = null)
//         {
//             //如果资源没有被加载，则往后不执行
//             let name = this.getFileName(url);
//             if (this.mapInLoad[name] == null)
//                 return;
//             let state: stateLoad = this.mapInLoad[name];
//             for (let key in state.resstate)
//             {
//                 if (state.resstate[key] && state.resstate[key].res)
//                 {
//                     state.resstate[key].res.unuse();
//                 }
//             }
//             delete this.mapInLoad[name];
//         }
//         waitlightmapScene: { [sceneurl: string]: string[] } = {};
//         loadSceneAssetbundleWithoutLightMap(url: string, type: AssetTypeEnum = AssetTypeEnum.Auto, onstate: (state: stateLoad) => void = null)
//         {
//             this.waitlightmapScene[url] = [];
//             this.load(url, type, onstate);
//         }
//         /**
//          * 
//          * @param scenename 场景名字 (***.scene.json)
//          */
//         loadSceneLightmap(sceneurl: string)
//         {
//             let arr = this.waitlightmapScene[sceneurl];
//             let scenename = this.getFileName(sceneurl).replace(".assetbundle.json", ".scene.json");
//             let scene = this.getAssetByName(scenename) as rawscene;
//             if (scene == null) return;
//             scene["lightmaps"] = [];
//             let texarr: string[] = [];
//             let texcount = 0;
//             if (arr)
//             {
//                 for (let key in arr)
//                 {
//                     let texurl = arr[key].replace(".imgdesc.json", ".png");
//                     texarr.push(texurl);
//                     this.loadForNoCache(texurl, AssetTypeEnum.Texture, (state) =>
//                     {
//                         if (state.isfinish)
//                         {
//                             texcount++;
//                             if (texcount == arr.length)
//                             {
//                                 for (let item in texarr)
//                                 {
//                                     let texname = this.getFileName(texarr[item]);
//                                     let tex = this.getAssetByName(texname) as texture;
//                                     if (tex)
//                                     {
//                                         scene["lightmaps"].push(tex);
//                                         tex.use();
//                                     }
//                                 }
//                                 scene.useLightMap(this.app.getScene());
//                             }
//                         }
//                     });
//                 }
//             }
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 加载场景
//          * 只有先load完包含场景的assetbundle，才能load场景
//          * @version m4m 1.0
//          * @param sceneName 场景名称
//          * @param onComplete 加载完成回调
//          */
//         loadScene(sceneName: string, onComplete: (firstChilds: Array<transform>) => void)
//         {
//             let firstChilds = new Array<transform>();
//             let scene = this.app.getScene();
//             if (sceneName.length > 0)
//             {
//                 var _rawscene: rawscene = this.getAssetByName(sceneName) as rawscene;
//                 let willLoadRoot = _rawscene.getSceneRoot();
//                 while (willLoadRoot.children.length > 0)
//                 {
//                     let trans = willLoadRoot.children.shift();
//                     firstChilds.push(trans);
//                     scene.addChild(trans);
//                 }
//                 //清空原场景UI
//                 scene["_overlay2d"] = new Array<overlay2D>();
//                 //lightmap
//                 _rawscene.useLightMap(scene);
//                 //fog
//                 _rawscene.useFog(scene);
//                 //nav
//                 _rawscene.useNavMesh(scene);
//             }
//             else
//             {
//                 var _camera: transform = new transform();
//                 _camera.gameObject.addComponent("camera");
//                 _camera.name = "camera";
//                 firstChilds.push(_camera);
//                 scene.addChild(_camera);
//             }
//             scene.name = sceneName;
//             scene.getRoot().markDirty();
//             onComplete(firstChilds);
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 保存场景
//          * 这里只是把场景序列化
//          * 具体保存要编辑器来进行
//          * 保存的地址和内容通过回调返回
//          * @version m4m 1.0
//          * @param fun 回调
//          */
//         saveScene(fun: (data: SaveInfo, resourses?: string[]) => void)
//         {
//             io.SerializeDependent.resourseDatas = [];//先清空下资源引用
//             let info: SaveInfo = new SaveInfo();
//             let _scene = {};
//             let scene = this.app.getScene();
//             let _rootNode = io.serializeObj(scene.getRoot(), null, this);
//             let _lightmaps = [];
//             let lightmaps = scene.lightmaps;
//             for (var str in lightmaps)
//             {
//                 let _lightmap = {};
//                 _lightmap["name"] = lightmaps[str].getName();
//                 _lightmaps.push(_lightmap);
//                 let lightMapUrl = this.getAssetUrl(lightmaps[str]);
//                 io.SerializeDependent.resourseDatas.push({ "url": lightMapUrl, "type": io.SaveAssetType.FullUrl });
//             }
//             //navmesh
//             let navstr = NavMeshLoadManager.Instance.navmeshJson;
//             navstr = navstr == null ? "" : navstr;
//             let navmeshJson = { data: navstr };
//             let cup;
//             if (scene.fog)
//             {
//                 let cup = scene.fog._Color;
//                 scene.fog._Color = `${scene.fog._Color.x},${scene.fog._Color.y},${scene.fog._Color.z},${scene.fog._Color.z}` as any;  //
//             }
//             _scene["fog"] = scene.fog;
//             _scene["rootNode"] = _rootNode;
//             _scene["lightmap"] = _lightmaps;
//             _scene["navmesh"] = navmeshJson;
//             let _sceneStr = JSON.stringify(_scene);
//             if (scene.fog) scene.fog._Color = cup;
//             var _rawscene: rawscene = this.getAssetByName(scene.name) as rawscene;
//             // _rawscene.Parse(_sceneStr, this); ---
//             let url = this.getAssetUrl(_rawscene);
//             info.files[url] = _sceneStr;
//             fun(info, io.SerializeDependent.resourseDatas);
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 保存预设
//          * 这里只是把预设序列化
//          * 具体保存要编辑器来进行
//          * 保存的地址和内容通过回调返回
//          * @version m4m 1.0
//          * @param fun 回调
//          */
//         savePrefab(trans: transform, prefabName: string, fun: (data: SaveInfo, resourses?: string[], contents?: any[]) => void)
//         {
//             io.SerializeDependent.resourseDatas = [];//先清空下资源引用
//             let info: SaveInfo = new SaveInfo();
//             var _prefab: prefab = this.getAssetByName(prefabName) as prefab;
//             _prefab.apply(trans);
//             let _rootTrans = io.serializeObj(trans, null, this);
//             let url = this.getAssetUrl(_prefab);
//             info.files[url] = JSON.stringify(_rootTrans);
//             fun(info, io.SerializeDependent.resourseDatas);
//         }
//         /**
//          * @language zh_CN
//          * @classdesc
//          * 保存材质
//          * @param mat 
//          * @param fun 
//          */
//         saveMaterial(mat: material, fun: (data: SaveInfo) => void)
//         {
//             let info: SaveInfo = new SaveInfo();
//             let data = {};
//             let mapUniform = {};
//             let shader = mat.getShader();
//             let shaderPropertis = shader.defaultMapUniform;
//             data["shader"] = shader.getName();
//             data["mapUniform"] = mapUniform;
//             // for (let key in shaderPropertis) {
//             //     if (mat.mapUniform[key] != undefined) {
//             //         let propertyDdata = {};
//             //         let uniformData = mat.mapUniform[key];
//             //         propertyDdata["type"] = uniformData.type;
//             //         switch (uniformData.type) {
//             //             case m4m.render.UniformTypeEnum.Texture:
//             //                 propertyDdata["value"] = uniformData.value != null ? uniformData.value.name.name : "";
//             //                 break;
//             //             case m4m.render.UniformTypeEnum.Float4:
//             //                 propertyDdata["value"] = uniformData.value;
//             //                 break;
//             //             case m4m.render.UniformTypeEnum.Float:
//             //                 propertyDdata["value"] = uniformData.value;
//             //                 break;
//             //         }
//             //         mapUniform[key] = propertyDdata;
//             //     }
//             // }
//             let url = this.getAssetUrl(mat);
//             info.files[url] = JSON.stringify(data);
//             fun(info);
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 同步加载单个资源（伪同步，只是创建了一个资源的实例返回，还是要等待资源数据加载完成来填充数据）
//          * 这个接口还需要完善
//          * @version m4m 1.0
//          * @param url 资源的url
//          * @param type 资源的类型
//          */
//         loadSingleResImmediate(url: string, type: AssetTypeEnum): any
//         {
//             let result: any;
//             let filename = this.getFileName(url);
//             let name = filename.substring(0, filename.indexOf("."));
//             if (type == AssetTypeEnum.GLVertexShader)
//             {
//                 m4m.io.loadText(url, (txt, err) =>
//                 {
//                     this.shaderPool.compileVS(this.webgl, name, txt);
//                 }
//                 );
//             }
//             else if (type == AssetTypeEnum.GLFragmentShader)
//             {
//                 m4m.io.loadText(url, (txt, err) =>
//                 {
//                     this.shaderPool.compileFS(this.webgl, name, txt);
//                 }
//                 );
//             }
//             else if (type == AssetTypeEnum.Shader)
//             {
//                 result = new shader(filename);
//                 m4m.io.loadText(url, (txt, err) =>
//                 {
//                     result.parse(this, JSON.parse(txt));
//                     this.mapShader[filename] = result;
//                 });
//             }
//             else if (type == AssetTypeEnum.Texture)
//             {
//                 result = new texture(filename);
//                 var img = new Image();
//                 img.src = url;
//                 img.onload = () =>
//                 {
//                     var _textureFormat = render.TextureFormatEnum.RGBA;//这里需要确定格式
//                     result.glTexture = new m4m.render.glTexture2D(this.webgl, _textureFormat);
//                     result.glTexture.uploadImage(img, true, true, true, true);
//                     this.use(result);
//                 }
//             }
//             else if (type == AssetTypeEnum.Mesh)
//             {
//                 result = new mesh(filename);
//                 m4m.io.loadArrayBuffer(url, (txt, err) =>
//                 {
//                     result.Parse(txt, this.webgl);
//                     this.use(result);
//                 })
//             }
//             else
//             {
//                 throw new Error("cant use the type:" + type);
//             }
//             this.regRes(filename, result);
//             return result;
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 同步加载资源（伪同步，只是创建了一个资源的实例返回，还是要等待资源数据加载完成来填充数据）
//          * 这个接口还需要完善
//          * 这里有个问题，如果是assetbundle，那么实例究竟是个啥东西。
//          * @version m4m 1.0
//          * @param url 资源的url
//          * @param type 资源的类型
//          */
//         loadImmediate(url: string, type: AssetTypeEnum = AssetTypeEnum.Auto): any
//         {
//             var result: any;
//             //确定资源类型
//             if (type == AssetTypeEnum.Auto)
//             {
//                 type = this.calcType(url);
//             }
//             if (type == AssetTypeEnum.Unknown)
//             {
//                 throw new Error("unknown format");
//             }
//             else if (type == AssetTypeEnum.Bundle)//加载包
//             {
//                 result = new assetBundle(url);
//                 m4m.io.loadText(url, (txt, err) =>
//                 {
//                     result.parse(JSON.parse(txt));
//                 });
//             }
//             else
//             {
//                 result = this.loadSingleResImmediate(url, type);
//             }
//             return result;
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 通过url获取资源的名称
//          * @version m4m 1.0
//          * @param url 资源的url
//          */
//         getFileName(url: string): string
//         {
//             var filei = url.lastIndexOf("/");
//             var file = url.substr(filei + 1);
//             return file;
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 通过url获取资源的类型
//          * @version m4m 1.0
//          * @param url 资源的url
//          */
//         calcType(url: string | any): AssetTypeEnum
//         {
//             var filei = url.lastIndexOf("/");
//             var file = url.substr(filei + 1);
//             var i = file.indexOf(".", 0);
//             var extname = null;
//             while (i >= 0)
//             {
//                 extname = file.substr(i);
//                 if (extname == ".vs.glsl")
//                 {
//                     return AssetTypeEnum.GLVertexShader;
//                 }
//                 else if (extname == ".assetbundle.json")
//                 {
//                     return AssetTypeEnum.Bundle;
//                 }
//                 else if (extname == ".fs.glsl")
//                 {
//                     return AssetTypeEnum.GLFragmentShader;
//                 }
//                 else if (extname == ".shader.json")
//                 {
//                     return AssetTypeEnum.Shader;
//                 }
//                 else if (extname == ".png" || extname == ".jpg")
//                 {
//                     return AssetTypeEnum.Texture;
//                 }
//                 else if (extname == ".pvr.bin" || extname == ".pvr" || extname == ".pvr.bin.js")
//                 {
//                     return AssetTypeEnum.PVR;
//                 }
//                 else if (extname == ".imgdesc.json")
//                 {
//                     return AssetTypeEnum.TextureDesc;
//                 }
//                 else if (extname == ".mat.json")
//                 {
//                     return AssetTypeEnum.Material;
//                 }
//                 else if (extname == ".mesh.bin" || extname == ".cmesh.bin" || extname == ".mesh.bin.js" || extname == ".mesh.json")
//                 {
//                     return AssetTypeEnum.Mesh;
//                 }
//                 else if (extname == ".aniclip.bin" || extname == ".aniclip.bin.js")
//                 {
//                     return AssetTypeEnum.Aniclip;
//                 }
//                 else if (extname == ".prefab.json")
//                 {
//                     return AssetTypeEnum.Prefab;
//                 } else if (extname == ".cprefab.json")
//                 {
//                     return AssetTypeEnum.cPrefab;
//                 }
//                 else if (extname == ".scene.json")
//                 {
//                     return AssetTypeEnum.Scene;
//                 }
//                 else if (extname == ".atlas.json")
//                 {
//                     return AssetTypeEnum.Atlas;
//                 }
//                 else if (extname == ".font.json")
//                 {
//                     return AssetTypeEnum.Font;
//                 }
//                 else if (extname == ".json" || extname == ".txt" || extname == ".effect.json")
//                 {
//                     return AssetTypeEnum.TextAsset;
//                 }
//                 else if (extname == ".packs.bin" || extname == ".packs.bin.js")
//                 {
//                     return AssetTypeEnum.PackBin;
//                 }
//                 else if (extname == ".packs.txt")
//                 {
//                     return AssetTypeEnum.PackTxt;
//                 }
//                 else if (extname == ".path.json")
//                 {
//                     return AssetTypeEnum.PathAsset;
//                 }
//                 else if (extname == ".f14effect.json")
//                 {
//                     return AssetTypeEnum.F14Effect;
//                 } else if (extname == ".dds" || extname == ".dds.bin")
//                 {
//                     return AssetTypeEnum.DDS;
//                 } else if (extname == ".keyframeAniclip.json")
//                 {
//                     return AssetTypeEnum.KeyFrameAniclip;
//                 }
//                 i = file.indexOf(".", i + 1);
//             }
//             // if (url.endsWith(".vs.glsl"))
//             //     return AssetTypeEnum.GLVertexShader;
//             // else if (url.endsWith(".assetbundle.json"))
//             //     return AssetTypeEnum.Bundle;
//             // else if (url.endsWith(".fs.glsl"))
//             // {
//             //     return AssetTypeEnum.GLFragmentShader;
//             // }
//             // else if (url.endsWith(".shader.json"))
//             // {
//             //     return AssetTypeEnum.Shader;
//             // }
//             // else if (url.endsWith(".png") || url.endsWith(".jpg"))
//             // {
//             //     return AssetTypeEnum.Texture;
//             // }
//             // else if (url.endsWith(".pvr.bin") || url.endsWith(".pvr") || url.endsWith(".pvr.bin.js"))
//             // {
//             //     return AssetTypeEnum.PVR;
//             // }
//             // else if (url.endsWith(".imgdesc.json"))
//             // {
//             //     return AssetTypeEnum.TextureDesc;
//             // }
//             // else if (url.endsWith(".mat.json"))
//             // {
//             //     return AssetTypeEnum.Material;
//             // }
//             // else if (url.endsWith(".mesh.bin") || url.endsWith(".mesh.bin.js"))
//             // {
//             //     return AssetTypeEnum.Mesh;
//             // }
//             // else if (url.endsWith(".aniclip.bin") || url.endsWith(".aniclip.bin.js"))
//             // {
//             //     return AssetTypeEnum.Aniclip;
//             // }
//             // else if (url.endsWith(".prefab.json"))
//             // {
//             //     return AssetTypeEnum.Prefab;
//             // }
//             // else if (url.endsWith(".scene.json"))
//             // {
//             //     return AssetTypeEnum.Scene;
//             // }
//             // else if (url.endsWith(".atlas.json"))
//             // {
//             //     return AssetTypeEnum.Atlas;
//             // }
//             // else if (url.endsWith(".font.json"))
//             // {
//             //     return AssetTypeEnum.Font;
//             // }
//             // else if (url.endsWith(".json") || url.endsWith(".txt") || url.endsWith(".effect.json"))
//             // {
//             //     return AssetTypeEnum.TextAsset;
//             // }
//             // else if (url.endsWith(".packs.bin") || url.endsWith(".packs.bin.js"))
//             // {
//             //     return AssetTypeEnum.PackBin;
//             // }
//             // else if (url.endsWith(".packs.txt"))
//             // {
//             //     return AssetTypeEnum.PackTxt;
//             // }
//             // else if (url.endsWith(".path.json"))
//             // {
//             //     return AssetTypeEnum.PathAsset;
//             // }
//             // else if (url.endsWith(".f14effect.json"))
//             // {
//             //     return AssetTypeEnum.F14Effect;
//             // } else if (url.endsWith(".dds") || url.endsWith(".dds.bin"))
//             // {
//             //     return AssetTypeEnum.DDS;
//             // } else if (url.endsWith(".keyframeAniclip.json"))
//             // {
//             //     return AssetTypeEnum.KeyFrameAniclip;
//             // }
//             return AssetTypeEnum.Unknown;
//         }
//         private particlemat: material;
//         getDefParticleMat(): material
//         {
//             if (this.particlemat == null)
//             {
//                 var mat = new material("defparticle");
//                 var shader = this.getShader("particles_additive.shader.json");
//                 if (shader == null)
//                 {
//                     shader = this.getShader("shader/def");
//                 }
//                 mat.setShader(shader);
//                 var tex = this.getDefaultTexture("grid");
//                 mat.setTexture("_MainTex", tex);
//                 this.particlemat = mat;
//             }
//             return this.particlemat;
//         }
//     }
//     /**
//      * @public
//      * @language zh_CN
//      * @classdesc
//      * 资源引用计数的结构
//      * @version m4m 1.0
//      */
//     export class assetRef
//     {
//         asset: IAsset;
//         refcount: number;
//     }
//     /**
//      * @private
//      */
//     export class SaveInfo
//     {
//         files: { [key: string]: string } = {};
//     }
// }
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         *
         * astc 格式概述  https://github.com/ARM-software/astc-encoder/blob/main/Docs/FormatOverview.md
         * Khronos Group  astc格式规范 https://www.khronos.org/registry/DataFormat/specs/1.3/dataformat.1.3.html#ASTC
         */
        var ASTCParse = /** @class */ (function () {
            function ASTCParse() {
            }
            /**
             *
             * @param gl WebGL2RenderingContext
             * @param arrayBuffer contents of the ASTC container file
             */
            ASTCParse.parse = function (gl, arrayBuffer) {
                var result;
                // let ext = gl.getExtension('WEBGL_compressed_texture_astc');
                var ext = gl.extensions.WEBGL_compressed_texture_astc;
                if (!ext) {
                    console.error("\u5F53\u524D\u73AF\u5883 \u4E0D\u652F\u6301 ASTC \u538B\u7F29\u7EB9\u7406");
                    return;
                }
                ext.COMPRESSED_RGBA_ASTC_10x10_KHR;
                this.decodeBuffer(ext, arrayBuffer);
                // 初始化纹理
                var t2d = result = new m4m.render.glTexture2D(gl);
                t2d.width = this.pixelHeight;
                t2d.height = this.pixelWidth;
                t2d.format = this.getTextureFormat(ext, this.gLInternalFormat);
                var target = gl.TEXTURE_2D;
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(target, t2d.texture);
                //当前框架下 ，这里无法处理 mipmap
                var textureBuf = new Uint8Array(arrayBuffer, this.HEADER_MAX);
                gl.compressedTexImage2D(target, 0, this.gLInternalFormat, t2d.width, t2d.height, 0, textureBuf);
                gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                //clear
                this.gLInternalFormat = null;
                this.pixelWidth = null;
                this.pixelHeight = null;
                return result;
            };
            //解码 
            ASTCParse.decodeBuffer = function (ext, _buf) {
                var header = new Uint8Array(_buf, 0, this.HEADER_MAX);
                var astcTag = header[3] + (header[2] << 8) + (header[1] << 16) + (header[0] << 24);
                if (astcTag !== 0x13ABA15C) {
                    throw new Error('ASTC 无效的头文件');
                }
                var xdim = header[4];
                var ydim = header[5];
                var zdim = header[6];
                if ((xdim < 3 || xdim > 6 || ydim < 3 || ydim > 6 || zdim < 3 || zdim > 6)
                    && (xdim < 4 || xdim === 7 || xdim === 9 || xdim === 11 || xdim > 12
                        || ydim < 4 || ydim === 7 || ydim === 9 || ydim === 11 || ydim > 12 || zdim !== 1)) {
                    throw new Error(' ASTC 无效的头文件');
                }
                this.gLInternalFormat = ext["COMPRESSED_RGBA_ASTC_".concat(xdim, "x").concat(ydim, "_KHR")];
                this.pixelWidth = header[this.HEADER_SIZE_X] + (header[this.HEADER_SIZE_X + 1] << 8) + (header[this.HEADER_SIZE_X + 2] << 16);
                this.pixelHeight = header[this.HEADER_SIZE_Y] + (header[this.HEADER_SIZE_Y + 1] << 8) + (header[this.HEADER_SIZE_Y + 2] << 16);
                // let pixeLen = header[this.HEADER_SIZE_Z] + (header[this.HEADER_SIZE_Z + 1] << 8) + (header[this.HEADER_SIZE_Z + 2] << 16);
            };
            ASTCParse.getTextureFormat = function (ext, gLInternalFormat) {
                ext.COMPRESSED_RGBA_ASTC_4x4_KHR;
                var tfEnum = m4m.render.TextureFormatEnum;
                switch (gLInternalFormat) {
                    case ext.COMPRESSED_RGBA_ASTC_4x4_KHR: return tfEnum.ASTC_RGBA_4x4;
                    case ext.COMPRESSED_RGBA_ASTC_5x4_KHR: return tfEnum.ASTC_RGBA_5x4;
                    case ext.COMPRESSED_RGBA_ASTC_5x5_KHR: return tfEnum.ASTC_RGBA_5x5;
                    case ext.COMPRESSED_RGBA_ASTC_6x5_KHR: return tfEnum.ASTC_RGBA_6x5;
                    case ext.COMPRESSED_RGBA_ASTC_6x6_KHR: return tfEnum.ASTC_RGBA_6x6;
                    case ext.COMPRESSED_RGBA_ASTC_8x5_KHR: return tfEnum.ASTC_RGBA_8x5;
                    case ext.COMPRESSED_RGBA_ASTC_8x6_KHR: return tfEnum.ASTC_RGBA_8x6;
                    case ext.COMPRESSED_RGBA_ASTC_8x8_KHR: return tfEnum.ASTC_RGBA_8x8;
                    case ext.COMPRESSED_RGBA_ASTC_10x5_KHR: return tfEnum.ASTC_RGBA_10x5;
                    case ext.COMPRESSED_RGBA_ASTC_10x6_KHR: return tfEnum.ASTC_RGBA_10x6;
                    case ext.COMPRESSED_RGBA_ASTC_10x8_KHR: return tfEnum.ASTC_RGBA_10x8;
                    case ext.COMPRESSED_RGBA_ASTC_10x10_KHR: return tfEnum.ASTC_RGBA_10x10;
                    case ext.COMPRESSED_RGBA_ASTC_12x10_KHR: return tfEnum.ASTC_RGBA_12x10;
                    case ext.COMPRESSED_RGBA_ASTC_12x12_KHR: return tfEnum.ASTC_RGBA_12x12;
                    default:
                }
            };
            ASTCParse.HEADER_SIZE_X = 7;
            ASTCParse.HEADER_SIZE_Y = 10;
            ASTCParse.HEADER_SIZE_Z = 13;
            ASTCParse.HEADER_MAX = 16;
            return ASTCParse;
        }());
        framework.ASTCParse = ASTCParse;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var HdrParser = /** @class */ (function () {
    function HdrParser(gl) {
        this.gl = gl;
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 解析hdr图片
         * @param raw 图片二进制数据
         * @version m4m 1.0
         */
        this.textDecoder = new TextDecoder();
    }
    HdrParser.prototype.parseRGBE = function (raw) {
        var data = new Uint8Array(raw);
        var p = 0;
        while (!(data[p] === 0x0A && data[p + 1] === 0x0A))
            p++;
        var info = this.textDecoder.decode(data.subarray(0, p)).split('\n');
        if (info[0] !== '#?RADIANCE') {
            console.warn('unexpected magic number');
        }
        var size_base = p += 2;
        while (data[++p] !== 0x0A)
            ;
        var _a = this.textDecoder.decode(data.subarray(size_base, p)).split(' ').map(function (e) { return Number(e); }), height = _a[1], width = _a[3];
        var total = height * width;
        var rgbeData = data.subarray(p + 1);
        // allocate memory for uncompressed data
        var buffer = new Uint8Array(total * 4);
        var ptr = 0;
        if (total * 4 !== rgbeData.length) {
            var _loop_2 = function (y) {
                var flag = rgbeData.subarray(ptr, ptr += 4);
                if (flag.slice(0, 2).every(function (e) { return e === 0x02; })) {
                    var scanline_buf_1 = new Array(4).fill(0)
                        .map(function () { return new Uint8Array(width); })
                        .map(function (line) {
                        var lp = 0;
                        while (lp < width) {
                            var count = 0;
                            var data_1 = rgbeData.subarray(ptr, ptr += 2);
                            if (data_1[0] > 128) {
                                count = data_1[0] - 128;
                                while (count--) {
                                    line[lp++] = data_1[1];
                                }
                            }
                            else {
                                count = data_1[0] - 1;
                                line[lp++] = data_1[1];
                                while (count--) {
                                    line[lp++] = rgbeData.subarray(ptr, ++ptr)[0];
                                }
                            }
                        }
                        return line;
                    });
                    var _loop_4 = function (x) {
                        var pixel = buffer.subarray((y * width + x) * 4, (y * width + (x + 1)) * 4);
                        pixel.forEach(function (_, i) { return pixel[i] = scanline_buf_1[i][x]; });
                    };
                    for (var x = 0; x < width; x++) {
                        _loop_4(x);
                    }
                }
            };
            // RLE
            for (var y = 0; y < height; y++) {
                _loop_2(y);
            }
        }
        else {
            var _loop_3 = function (x) {
                var rgbe = rgbeData.subarray(x * 4, (x + 1) * 4);
                var pixel = buffer.subarray(x * 4, (x + 1) * 4);
                pixel.forEach(function (_, i) { return pixel[i] = rgbe[i]; });
            };
            for (var x = 0; x < total; x++) {
                _loop_3(x);
            }
        }
        return {
            width: width,
            height: height,
            buffer: buffer,
        };
    };
    HdrParser.prototype.get2DTexture = function (raw) {
        var _a = this.parseRGBE(raw), width = _a.width, height = _a.height, buffer = _a.buffer;
        var t2d = new m4m.render.glTexture2D(this.gl);
        t2d.width = width;
        t2d.height = height;
        t2d.format = m4m.render.TextureFormatEnum.RGBA;
        this.gl.activeTexture(this.gl.TEXTURE0);
        this.gl.bindTexture(this.gl.TEXTURE_2D, t2d.texture);
        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, 0); //不对Y翻转
        this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 1); //对齐方式
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, width, height, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, buffer);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);
        return t2d;
    };
    return HdrParser;
}());
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         *
         * for description see https://www.khronos.org/opengles/sdk/tools/KTX/
         * for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/
         *
         * ported from https://github.com/BabylonJS/Babylon.js/blob/master/src/Misc/khronosTextureContainer.ts
         */
        var KTXParse = /** @class */ (function () {
            function KTXParse() {
            }
            /**
             *
             * @param gl
             * @param arrayBuffer contents of the KTX container file
             * @param facesExpected should be either 1 or 6, based whether a cube texture or or
             */
            KTXParse.parse = function (gl, arrayBuffer, facesExpected, loadMipmaps) {
                if (facesExpected === void 0) { facesExpected = 1; }
                if (loadMipmaps === void 0) { loadMipmaps = true; }
                // Test that it is a ktx formatted file, based on the first 12 bytes, character representation is:
                // '´', 'K', 'T', 'X', ' ', '1', '1', 'ª', '\r', '\n', '\x1A', '\n'
                // 0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A
                var identifier = new Uint8Array(arrayBuffer, 0, 12);
                if (identifier[0] !== 0xAB ||
                    identifier[1] !== 0x4B ||
                    identifier[2] !== 0x54 ||
                    identifier[3] !== 0x58 ||
                    identifier[4] !== 0x20 ||
                    identifier[5] !== 0x31 ||
                    identifier[6] !== 0x31 ||
                    identifier[7] !== 0xBB ||
                    identifier[8] !== 0x0D ||
                    identifier[9] !== 0x0A ||
                    identifier[10] !== 0x1A ||
                    identifier[11] !== 0x0A) {
                    console.error('texture missing KTX identifier');
                    return;
                }
                // gl.getExtension('WEBGL_compressed_texture_etc1');
                var ext = gl.extensions.WEBGL_compressed_texture_etc1;
                if (!ext) {
                    console.error("\u5F53\u524D\u73AF\u5883 \u4E0D\u652F\u6301 ETC \u538B\u7F29\u7EB9\u7406");
                    return;
                }
                // load the reset of the header in native 32 bit uint
                var dataSize = Uint32Array.BYTES_PER_ELEMENT;
                var headerDataView = new DataView(arrayBuffer, 12, 13 * dataSize);
                var endianness = headerDataView.getUint32(0, true);
                var littleEndian = endianness === 0x04030201;
                var glType = headerDataView.getUint32(1 * dataSize, littleEndian); // must be 0 for compressed textures
                var glTypeSize = headerDataView.getUint32(2 * dataSize, littleEndian); // must be 1 for compressed textures
                var glFormat = headerDataView.getUint32(3 * dataSize, littleEndian); // must be 0 for compressed textures
                var glInternalFormat = headerDataView.getUint32(4 * dataSize, littleEndian); // the value of arg passed to gl.compressedTexImage2D(,,x,,,,)
                var glBaseInternalFormat = headerDataView.getUint32(5 * dataSize, littleEndian); // specify GL_RGB, GL_RGBA, GL_ALPHA, etc (un-compressed only)
                var pixelWidth = headerDataView.getUint32(6 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage2D(,,,x,,,)
                var pixelHeight = headerDataView.getUint32(7 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage2D(,,,,x,,)
                var pixelDepth = headerDataView.getUint32(8 * dataSize, littleEndian); // level 0 value of arg passed to gl.compressedTexImage3D(,,,,,x,,)
                var numberOfArrayElements = headerDataView.getUint32(9 * dataSize, littleEndian); // used for texture arrays
                var numberOfFaces = headerDataView.getUint32(10 * dataSize, littleEndian); // used for cubemap textures, should either be 1 or 6
                var numberOfMipmapLevels = headerDataView.getUint32(11 * dataSize, littleEndian); // number of levels; disregard possibility of 0 for compressed textures
                var bytesOfKeyValueData = headerDataView.getUint32(12 * dataSize, littleEndian); // the amount of space after the header for meta-data
                // Make sure we have a compressed type.  Not only reduces work, but probably better to let dev know they are not compressing.
                if (glType !== 0) {
                    console.warn('only compressed formats currently supported');
                    return null;
                }
                else {
                    // value of zero is an indication to generate mipmaps @ runtime.  Not usually allowed for compressed, so disregard.
                    numberOfMipmapLevels = Math.max(1, numberOfMipmapLevels);
                }
                if (pixelHeight === 0 || pixelDepth !== 0) {
                    console.warn('only 2D textures currently supported');
                    return null;
                }
                if (numberOfArrayElements !== 0) {
                    console.warn('texture arrays not currently supported');
                    return null;
                }
                if (numberOfFaces !== facesExpected) {
                    console.warn('number of faces expected' + facesExpected + ', but found ' + numberOfFaces);
                    return null;
                }
                // 初始化纹理
                var t2d = new m4m.render.glTexture2D(gl);
                t2d.height = pixelHeight;
                t2d.width = pixelWidth;
                t2d.format = m4m.render.TextureFormatEnum.KTX;
                var target = gl.TEXTURE_2D;
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(target, t2d.texture);
                // initialize width & height for level 1
                var dataOffset = KTXParse.HEADER_LEN + bytesOfKeyValueData;
                var width = pixelWidth;
                var height = pixelHeight;
                var mipmapCount = loadMipmaps ? numberOfMipmapLevels : 1;
                for (var level = 0; level < mipmapCount; level++) {
                    var imageSize = new Int32Array(arrayBuffer, dataOffset, 1)[0]; // size per face, since not supporting array cubemaps
                    dataOffset += 4; // size of the image + 4 for the imageSize field
                    for (var face = 0; face < numberOfFaces; face++) {
                        var byteArray = new Uint8Array(arrayBuffer, dataOffset, imageSize);
                        gl.compressedTexImage2D(target, level, glInternalFormat, width, height, 0, byteArray);
                        dataOffset += imageSize;
                        dataOffset += 3 - ((imageSize + 3) % 4); // add padding for odd sized image
                    }
                    width = Math.max(1.0, width * 0.5);
                    height = Math.max(1.0, height * 0.5);
                }
                if (mipmapCount > 1) {
                    gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
                }
                else {
                    gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                }
                return t2d;
            };
            KTXParse.HEADER_LEN = 12 + (13 * 4); // identifier + header elements (not including key value meta-data pairs)
            return KTXParse;
        }());
        framework.KTXParse = KTXParse;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var PvrParse = /** @class */ (function () {
            function PvrParse(gl) {
                this.version = 0x03525650;
                this.flags = 0;
                this.pixelFormatH = 0;
                this.pixelFormatL = 0;
                // private colourSpace = 0;
                this.channelType = 0;
                this.height = 1;
                this.width = 1;
                this.depth = 1;
                // private numSurfaces = 1;
                this.numFaces = 1;
                this.mipMapCount = 1;
                this.metaDataSize = 0;
                this.gl = gl;
            }
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 解析pvr图片
             * @param _buffer 图片二进制数据
             * @version m4m 1.0
             */
            PvrParse.prototype.parse = function (_buffer) {
                var ar = new Uint8Array(_buffer);
                _buffer = null;
                var tool = new m4m.io.binTool();
                tool.writeUint8Array(ar);
                this.version = tool.readUInt32();
                if (this.version === 0x03525650) {
                    var tex = this.parseV3(tool);
                    tool.dispose();
                    return tex;
                }
                else if (this.version === 0x50565203) {
                    //v2
                    console.error("v2");
                }
                else {
                    console.error("pvr parse error!:" + this.version);
                    return null;
                }
            };
            PvrParse.prototype.parseV3 = function (tool) {
                var ext = framework.sceneMgr.app.webgl.extensions.WEBGL_compressed_texture_pvrtc;
                if (!ext) {
                    console.error("\u5F53\u524D\u73AF\u5883 \u4E0D\u652F\u6301 PVR \u538B\u7F29\u7EB9\u7406");
                    return;
                }
                this.flags = tool.readUInt32(); //0:没有设置  0x02 ：alpha预乘
                if (this.flags == 0)
                    this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0); //开启预乘
                else
                    this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1); //开启预乘
                this.pixelFormatH = tool.readUInt32(); //高4位 rgba
                this.pixelFormatL = tool.readUInt32(); //低4位 8888/4444/5551/565    高四位和低四位共同决定了其格式RGBA（32位）、RGBA4（16位）、    RGB、RGB5_A1、RGB565、  LUMINANCE_ALPHA、LUMINANCE、ALPHA
                // this.colourSpace = tool.readUInt32();//0:linear rgb   1:srgb
                tool.readBytes(4);
                this.channelType = tool.readUInt32(); //格式
                this.height = tool.readUInt32();
                this.width = tool.readUInt32();
                this.depth = tool.readUInt32();
                // this.numSurfaces = tool.readUInt32();
                tool.readBytes(4);
                this.numFaces = tool.readUInt32();
                this.mipMapCount = tool.readUInt32();
                this.metaDataSize = tool.readUInt32();
                tool.readBytes(this.metaDataSize);
                var engineFormat;
                var textureFormat;
                var textureType;
                var t2d = new m4m.render.glTexture2D(this.gl);
                t2d.height = this.height;
                t2d.width = this.width;
                switch (this.pixelFormatH) {
                    case 0:
                        textureFormat = ext.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        engineFormat = m4m.render.TextureFormatEnum.PVRTC2_RGB;
                        break;
                    case 1:
                        textureFormat = ext.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                        engineFormat = m4m.render.TextureFormatEnum.PVRTC2_RGBA;
                        break;
                    case 2:
                        textureFormat = ext.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        engineFormat = m4m.render.TextureFormatEnum.PVRTC4_RGB;
                        break;
                    case 3:
                        textureFormat = ext.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        engineFormat = m4m.render.TextureFormatEnum.PVRTC4_RGBA;
                        break;
                    default:
                        textureFormat = this.gl.RGB;
                        engineFormat = m4m.render.TextureFormatEnum.RGB;
                        console.log("unknow pixel format::" + this.pixelFormatH);
                }
                t2d.format = engineFormat;
                switch (this.channelType) {
                    case ChannelTypes.UnsignedByteNorm:
                        textureType = this.gl.UNSIGNED_BYTE;
                        break;
                    case ChannelTypes.UnsignedShortNorm:
                        break;
                }
                var target = this.gl.TEXTURE_2D;
                if (this.numFaces > 1)
                    target = this.gl.TEXTURE_CUBE_MAP;
                // //v3
                // this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, 1);//对齐方式
                // this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, 0);//不对Y翻转  //压缩纹理 pixelStorei 状态不受影响
                this.gl.activeTexture(this.gl.TEXTURE0);
                this.gl.bindTexture(target, t2d.texture);
                if (this.numFaces > 1)
                    target = this.gl.TEXTURE_CUBE_MAP_POSITIVE_X;
                function textureLevelSize(format, width, height) {
                    switch (format) {
                        case ext.COMPRESSED_RGB_S3TC_DXT1_EXT:
                        case ext.COMPRESSED_RGB_ATC_WEBGL:
                        case ext.COMPRESSED_RGB_ETC1_WEBGL:
                            return ((width + 3) >> 2) * ((height + 3) >> 2) * 8;
                        case ext.COMPRESSED_RGBA_S3TC_DXT3_EXT:
                        case ext.COMPRESSED_RGBA_S3TC_DXT5_EXT:
                        case ext.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL:
                        case ext.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL:
                            return ((width + 3) >> 2) * ((height + 3) >> 2) * 16;
                        case ext.COMPRESSED_RGB_PVRTC_4BPPV1_IMG:
                        case ext.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:
                            return Math.floor((Math.max(width, 8) * Math.max(height, 8) * 4 + 7) / 8);
                        case ext.COMPRESSED_RGB_PVRTC_2BPPV1_IMG:
                        case ext.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG:
                            return Math.floor((Math.max(width, 16) * Math.max(height, 8) * 2 + 7) / 8);
                        default:
                            return 0;
                    }
                }
                var offset = 0;
                var _width = this.width;
                var _height = this.height;
                for (var i = 0; i < this.mipMapCount; ++i) {
                    var levelSize = textureLevelSize(textureFormat, _width, _height);
                    var data = tool.readBytes(levelSize);
                    this.gl.compressedTexImage2D(this.gl.TEXTURE_2D, i, textureFormat, _width, _height, 0, data);
                    _width = _width >> 1;
                    if (_width < 1)
                        _width = 1;
                    _height = _height >> 1;
                    if (_height < 1)
                        _height = 1;
                    offset += levelSize;
                }
                if (this.mipMapCount > 1) {
                    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
                    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR_MIPMAP_NEAREST);
                }
                else {
                    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);
                    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);
                }
                return t2d;
            };
            return PvrParse;
        }());
        framework.PvrParse = PvrParse;
        var ChannelTypes;
        (function (ChannelTypes) {
            ChannelTypes[ChannelTypes["UnsignedByteNorm"] = 0] = "UnsignedByteNorm";
            ChannelTypes[ChannelTypes["SignedByteNorm"] = 1] = "SignedByteNorm";
            ChannelTypes[ChannelTypes["UnsignedByte"] = 2] = "UnsignedByte";
            ChannelTypes[ChannelTypes["SignedByte"] = 3] = "SignedByte";
            ChannelTypes[ChannelTypes["UnsignedShortNorm"] = 4] = "UnsignedShortNorm";
            ChannelTypes[ChannelTypes["SignedShortNorm"] = 5] = "SignedShortNorm";
            ChannelTypes[ChannelTypes["UnsignedShort"] = 6] = "UnsignedShort";
            ChannelTypes[ChannelTypes["SignedShort"] = 7] = "SignedShort";
            ChannelTypes[ChannelTypes["UnsignedIntegerNorm"] = 8] = "UnsignedIntegerNorm";
            ChannelTypes[ChannelTypes["SignedIntegerNorm"] = 9] = "SignedIntegerNorm";
            ChannelTypes[ChannelTypes["UnsignedInteger"] = 10] = "UnsignedInteger";
            ChannelTypes[ChannelTypes["SignedInteger"] = 11] = "SignedInteger";
            ChannelTypes[ChannelTypes["SignedFloat"] = 12] = "SignedFloat";
            ChannelTypes[ChannelTypes["Float"] = 12] = "Float";
            ChannelTypes[ChannelTypes["UnsignedFloat"] = 13] = "UnsignedFloat";
        })(ChannelTypes || (ChannelTypes = {}));
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var RAWParse = /** @class */ (function () {
            function RAWParse() {
            }
            /**
             *
             * @param gl WebGL2RenderingContext
             * @param arrayBuffer contents of the ASTC container file
             */
            RAWParse.parse = function (gl, arrayBuffer) {
                return this.parseByAtt(gl, arrayBuffer);
            };
            /**
             * 解析纹理 通过参数
             * @param gl
             * @param arrayBuffer
             * @param _mipmap
             * @param _linear
             * @param _premultiplyAlpha
             * @param _repeat
             * @returns
             */
            RAWParse.parseByAtt = function (gl, arrayBuffer, _mipmap, _linear, _premultiplyAlpha, _repeat) {
                if (_mipmap === void 0) { _mipmap = true; }
                if (_linear === void 0) { _linear = true; }
                if (_premultiplyAlpha === void 0) { _premultiplyAlpha = false; }
                if (_repeat === void 0) { _repeat = false; }
                var reader = new m4m.io.binReader(arrayBuffer);
                var w = reader.readUInt16();
                var h = reader.readUInt16();
                var data = new ArrayBuffer(w * h * 8);
                var bts = new Uint8Array(data);
                var f16 = new Uint16Array(data);
                reader.readBytes(bts, 0, bts.length);
                var result;
                //webgl2 默认支持
                // let ext = gl.getExtension("OES_texture_half_float");
                // if (!ext) {
                //     console.error(`当前环境 不支持 float 16 texture 纹理`);
                //     return;
                // }
                // 初始化纹理
                var t2d = result = new m4m.render.glTexture2D(gl);
                t2d.width = this.pixelHeight;
                t2d.height = this.pixelWidth;
                t2d.format = m4m.render.TextureFormatEnum.FLOAT16;
                t2d.mipmap = false;
                //额外处理
                var webgl = framework.sceneMgr.app.webgl;
                webgl.bindTexture(webgl.TEXTURE_2D, t2d.texture);
                //纹理 Y 翻转
                webgl.pixelStorei(webgl.UNPACK_FLIP_Y_WEBGL, 0);
                t2d.uploadByteArray(_mipmap, _linear, w, h, f16, _repeat, false, false, _premultiplyAlpha, true, webgl.HALF_FLOAT);
                //结束
                webgl.bindTexture(webgl.TEXTURE_2D, null);
                return result;
            };
            RAWParse.HEADER_SIZE_X = 7;
            RAWParse.HEADER_SIZE_Y = 10;
            RAWParse.HEADER_SIZE_Z = 13;
            RAWParse.HEADER_MAX = 16;
            return RAWParse;
        }());
        framework.RAWParse = RAWParse;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * S3TC 压缩纹理解析
         * .dds格式文件
         * 参考
         * https://developer.mozilla.org/en-US/docs/Web/API/WEBGL_compressed_texture_s3tc
         * https://docs.microsoft.com/zh-cn/windows/win32/direct3ddds/dx-graphics-dds-pguide
         * https://docs.microsoft.com/zh-cn/windows/win32/direct3ddds/dds-header
         */
        var S3TCParse = /** @class */ (function () {
            function S3TCParse() {
            }
            /**
             *
             * @param gl
             * @param arrayBuffer
             */
            S3TCParse.parse = function (gl, arrayBuffer) {
                var ext = gl.extensions.WEBGL_compressed_texture_s3tc;
                if (!ext) {
                    console.error("\u5F53\u524D\u73AF\u5883 \u4E0D\u652F\u6301 S3TC \u538B\u7F29\u7EB9\u7406");
                    return;
                }
                var buf = new Uint8Array(arrayBuffer);
                var info = this.getS3TCInfo(buf, ext);
                // 初始化纹理
                var result;
                var t2d = result = new m4m.render.glTexture2D(gl);
                t2d.width = info.width;
                t2d.height = info.height;
                t2d.format = info.textureType;
                var target = gl.TEXTURE_2D;
                // //纹理 Y 翻转
                // gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);   //压缩纹理不受 pixelStorei 影响
                gl.bindTexture(target, t2d.texture);
                //当前框架下 ，这里无法处理 mipmap
                var mipmapCount = Math.max(1, info.mipmapCount);
                if (info.isCompressed) {
                    var dataLength = (((Math.max(4, t2d.width) / 4) * Math.max(4, t2d.height)) / 4) * info.blockBytes;
                    var texBuf = new Uint8Array(arrayBuffer, info.dataOffset, dataLength);
                    //当前框架下 ，这里无法处理 mipmap
                    gl.compressedTexImage2D(target, 0, info.internalformat, t2d.width, t2d.height, 0, texBuf);
                    gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                    gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                }
                //结束
                gl.bindTexture(target, null);
                return result;
            };
            /**
             * 获取S3TC 信息
             * @param data 纹理的buffer数据对象
             */
            S3TCParse.getS3TCInfo = function (data, ext) {
                var off_size = 1;
                var off_flags = 2;
                var off_height = 3;
                var off_width = 4;
                var off_mipmapCount = 7;
                var off_pfFlags = 20;
                var off_caps2 = 28;
                var off_pfFourCC = 21;
                var off_dxgiFormat = 32;
                var DDSD_MIPMAPCOUNT = 0x20000;
                var DDPF_FOURCC = 0x4;
                var DDPF_RGB = 0x40;
                var DDPF_LUMINANCE = 0x20000;
                var DDSCAPS2_CUBEMAP = 0x200;
                var FOURCC_D3DFMT_R16G16B16A16F = 113;
                var FOURCC_D3DFMT_R32G32B32A32F = 116;
                var DXGI_FORMAT_R32G32B32A32_FLOAT = 2;
                var DXGI_FORMAT_R16G16B16A16_FLOAT = 10;
                var DXGI_FORMAT_B8G8R8X8_UNORM = 88;
                var FOURCC_DX10 = this.FourCCToInt32("DX10");
                var FOURCC_DXT1 = this.FourCCToInt32("DXT1");
                var FOURCC_DXT3 = this.FourCCToInt32("DXT3");
                var FOURCC_DXT5 = this.FourCCToInt32("DXT5");
                var info = new S3TCInfo();
                var header = new Int32Array(data.buffer, data.byteOffset, this.headerLengthInt);
                var extendedHeader = new Int32Array(data.buffer, data.byteOffset, this.headerLengthInt + 4);
                var mipmapCount = 1;
                if (header[off_flags] & DDSD_MIPMAPCOUNT) {
                    mipmapCount = Math.max(1, header[off_mipmapCount]);
                }
                var fourCC = header[off_pfFourCC];
                var dxgiFormat = fourCC === FOURCC_DX10 ? extendedHeader[off_dxgiFormat] : 0;
                //
                info.width = header[off_width];
                info.height = header[off_height];
                info.mipmapCount = mipmapCount;
                info.isFourCC = (header[off_pfFlags] & DDPF_FOURCC) === DDPF_FOURCC;
                info.isRGB = (header[off_pfFlags] & DDPF_RGB) === DDPF_RGB;
                info.isLuminance = (header[off_pfFlags] & DDPF_LUMINANCE) === DDPF_LUMINANCE;
                info.isCube = (header[off_caps2] & DDSCAPS2_CUBEMAP) === DDSCAPS2_CUBEMAP;
                info.isCompressed = fourCC === FOURCC_DXT1 || fourCC === FOURCC_DXT3 || fourCC === FOURCC_DXT5;
                info.dxgiFormat = dxgiFormat;
                //
                var textureType = m4m.render.TextureFormatEnum.RGBA;
                var internalformat = 0;
                var blockBytes = 1;
                var dataOffset = header[off_size] + 4;
                switch (fourCC) {
                    case FOURCC_DXT1:
                        blockBytes = 8;
                        if (info.isRGB)
                            textureType = m4m.render.TextureFormatEnum.RGB;
                        internalformat = info.isRGB ? ext.COMPRESSED_RGB_S3TC_DXT1_EXT : ext.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        break;
                    case FOURCC_DXT3:
                        blockBytes = 16;
                        internalformat = ext.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        break;
                    case FOURCC_DXT5:
                        blockBytes = 16;
                        internalformat = ext.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                        break;
                    case FOURCC_D3DFMT_R16G16B16A16F:
                        textureType = m4m.render.TextureFormatEnum.FLOAT16;
                        internalformat = WebGL2RenderingContext.HALF_FLOAT;
                        break;
                    case FOURCC_D3DFMT_R32G32B32A32F:
                        textureType = m4m.render.TextureFormatEnum.FLOAT32;
                        internalformat = WebGL2RenderingContext.FLOAT;
                        break;
                    case FOURCC_DX10:
                        dataOffset += 5 * 4; // 5 uints
                        switch (dxgiFormat) {
                            case DXGI_FORMAT_R16G16B16A16_FLOAT:
                                textureType = m4m.render.TextureFormatEnum.FLOAT16;
                                internalformat = WebGL2RenderingContext.HALF_FLOAT;
                                break;
                            case DXGI_FORMAT_R32G32B32A32_FLOAT:
                                textureType = m4m.render.TextureFormatEnum.FLOAT32;
                                internalformat = WebGL2RenderingContext.FLOAT;
                                break;
                        }
                        break;
                }
                info.textureType = textureType;
                info.internalformat = internalformat;
                info.blockBytes = blockBytes;
                info.dataOffset = dataOffset;
                return info;
            };
            S3TCParse.FourCCToInt32 = function (value) {
                return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);
            };
            S3TCParse.headerLengthInt = 31;
            return S3TCParse;
        }());
        framework.S3TCParse = S3TCParse;
        /** S3TC 信息 */
        var S3TCInfo = /** @class */ (function () {
            function S3TCInfo() {
            }
            return S3TCInfo;
        }());
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 资源类型
         * @version m4m 1.0
         */
        var AssetTypeEnum;
        (function (AssetTypeEnum) {
            /**
             * @public
             * @language zh_CN
             * 未知
             * @version m4m 1.0
             */
            AssetTypeEnum[AssetTypeEnum["Unknown"] = 0] = "Unknown";
            /**
             * @public
             * @language zh_CN
             * 根据后缀 动态识别
             * @version m4m 1.0
             */
            AssetTypeEnum[AssetTypeEnum["Auto"] = 1] = "Auto";
            /**
             * @public
             * @language zh_CN
             * 资源包
             * @version m4m 1.0
             */
            AssetTypeEnum[AssetTypeEnum["Bundle"] = 2] = "Bundle";
            /**
             * @public
             * @language zh_CN
             * 压缩的资源包
             * @version m4m 1.0
             */
            AssetTypeEnum[AssetTypeEnum["CompressBundle"] = 3] = "CompressBundle";
            /**
             * @public
             * @language zh_CN
             * glsl vs
             * @version m4m 1.0
             */
            AssetTypeEnum[AssetTypeEnum["GLVertexShader"] = 4] = "GLVertexShader";
            /**
             * @public
             * @language zh_CN
             * glsl fs
             * @version m4m 1.0
             */
            AssetTypeEnum[AssetTypeEnum["GLFragmentShader"] = 5] = "GLFragmentShader";
            /**
             * @public
             * @language zh_CN
             * shader
             * @version m4m 1.0
             */
            AssetTypeEnum[AssetTypeEnum["Shader"] = 6] = "Shader";
            /**
             * @public
             * @language zh_CN
             * 贴图
             * @version m4m 1.0
             */
            AssetTypeEnum[AssetTypeEnum["Texture"] = 7] = "Texture";
            /**
             * @public
             * @language zh_CN
             * 贴图desc
             * @version m4m 1.0
             */
            AssetTypeEnum[AssetTypeEnum["TextureDesc"] = 8] = "TextureDesc";
            /**
             * @public
             * @language zh_CN
             * 模型
             * @version m4m 1.0
             */
            AssetTypeEnum[AssetTypeEnum["Mesh"] = 9] = "Mesh";
            /**
             * @public
             * @language zh_CN
             * 材质
             * @version m4m 1.0
             */
            AssetTypeEnum[AssetTypeEnum["Material"] = 10] = "Material";
            /**
             * @public
             * @language zh_CN
             * 动画片段
             * @version m4m 1.0
             */
            AssetTypeEnum[AssetTypeEnum["Aniclip"] = 11] = "Aniclip";
            /**
             * @public
             * @language zh_CN
             * 关键帧动画片段
             * @version m4m 1.0
             */
            AssetTypeEnum[AssetTypeEnum["KeyFrameAniclip"] = 12] = "KeyFrameAniclip";
            /**
             * @public
             * @language zh_CN
             * 图集
             * @version m4m 1.0
             */
            AssetTypeEnum[AssetTypeEnum["Atlas"] = 13] = "Atlas";
            /**
             * @public
             * @language zh_CN
             * 字体
             * @version m4m 1.0
             */
            AssetTypeEnum[AssetTypeEnum["Font"] = 14] = "Font";
            /**
             * @public
             * @language zh_CN
             * 文本
             * @version m4m 1.0
             */
            AssetTypeEnum[AssetTypeEnum["TextAsset"] = 15] = "TextAsset";
            /**
             * @private
             */
            AssetTypeEnum[AssetTypeEnum["PackBin"] = 16] = "PackBin";
            /**
             * @private
             */
            AssetTypeEnum[AssetTypeEnum["PackTxt"] = 17] = "PackTxt";
            /**
             * @public
             * @language zh_CN
             * 可编辑路径
             * @version m4m 1.0
             */
            AssetTypeEnum[AssetTypeEnum["PathAsset"] = 18] = "PathAsset";
            /**
             * @public
             * @language zh_CN
             * pvr贴图
             * @version m4m 1.0
             */
            AssetTypeEnum[AssetTypeEnum["PVR"] = 19] = "PVR";
            /**
             * Android平台ETC1压缩纹理
             */
            AssetTypeEnum[AssetTypeEnum["KTX"] = 20] = "KTX";
            /**
             * ARM 压缩纹理，ios 、android 通用
             */
            AssetTypeEnum[AssetTypeEnum["ASTC"] = 21] = "ASTC";
            /** float 16 texture */
            AssetTypeEnum[AssetTypeEnum["RAW"] = 22] = "RAW";
            AssetTypeEnum[AssetTypeEnum["F14Effect"] = 23] = "F14Effect";
            /**
             * @public
             * @language zh_CN
             * dds贴图
             * @version m4m 1.0
             */
            AssetTypeEnum[AssetTypeEnum["DDS"] = 24] = "DDS";
            /**
             * @public
             * @language zh_CN
             * 场景
             * @version m4m 1.0
             */
            AssetTypeEnum[AssetTypeEnum["Scene"] = 25] = "Scene";
            /**
             * @public
             * @language zh_CN
             * 预设
             * @version m4m 1.0
             */
            AssetTypeEnum[AssetTypeEnum["Prefab"] = 26] = "Prefab";
            AssetTypeEnum[AssetTypeEnum["cPrefab"] = 27] = "cPrefab";
            /**
             * 粒子系统
             */
            AssetTypeEnum[AssetTypeEnum["ParticleSystem"] = 28] = "ParticleSystem";
            /**
             * 拖尾
             */
            AssetTypeEnum[AssetTypeEnum["TrailRenderer"] = 29] = "TrailRenderer";
            /**
             * HDR贴图
             */
            AssetTypeEnum[AssetTypeEnum["HDR"] = 30] = "HDR";
            /** 二进制文件 */
            AssetTypeEnum[AssetTypeEnum["BIN"] = 31] = "BIN";
            /** gltf 模型资源 */
            AssetTypeEnum[AssetTypeEnum["GLTF"] = 32] = "GLTF";
            /** gltf 二进制 资源 */
            AssetTypeEnum[AssetTypeEnum["GLB"] = 33] = "GLB";
        })(AssetTypeEnum = framework.AssetTypeEnum || (framework.AssetTypeEnum = {}));
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 资源加载状态
         * @version m4m 1.0
         */
        var ResourceState = /** @class */ (function () {
            function ResourceState() {
                this.res = null;
                this.state = 0;
                this.loadedLength = 0;
                // totalLength: number = 0;
            }
            return ResourceState;
        }());
        framework.ResourceState = ResourceState;
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 带引用的资源加载状态
         * @version m4m 1.0
         */
        var RefResourceState = /** @class */ (function (_super) {
            __extends(RefResourceState, _super);
            function RefResourceState() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.refLoadedLength = 0;
                return _this;
            }
            return RefResourceState;
        }(ResourceState));
        framework.RefResourceState = RefResourceState;
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 加载状态
         * @version m4m 1.0
         */
        var stateLoad = /** @class */ (function () {
            function stateLoad() {
                /**
                 * @public
                 * @language zh_CN
                 * 加载是否失败
                 * @version m4m 1.0
                 */
                this.isloadFail = false;
                /**
                 * @public
                 * @language zh_CN
                 * 加载是否遇到错误
                 * @version m4m 1.0
                 */
                this.iserror = false;
                /**
                 * @public
                 * @language zh_CN
                 * 加载是否完成
                 * @version m4m 1.0
                 */
                this.isfinish = false;
                /**
                 * @public
                 * @language zh_CN
                 * 记录需要加载的每一个的状态和资源引用
                 * @version m4m 1.0
                 */
                this.resstate = {};
                /**
                 * @public
                 * @language zh_CN
                 * 记录加载的第一个的状态和资源引用
                 * @version m4m 1.0
                 */
                this.resstateFirst = null;
                /**
                 * @public
                 * @language zh_CN
                 * 当前的文件数进度
                 * @version m4m 1.0
                 */
                this.curtask = 0;
                /**
                 * @public
                 * @language zh_CN
                 * 文件数的总进度
                 * @version m4m 1.0
                 */
                this.totaltask = 0;
                /**
                 * @public
                 * @language zh_CN
                 * 总字节长度
                 * @version m4m 1.0
                 */
                this.totalByteLength = 0;
                this.progressCall = false;
                this.compressTextLoaded = 0;
                this.compressBinLoaded = 0;
                /**
                 * @public
                 * @language zh_CN
                 * 加载过程中记录的log
                 * @version m4m 1.0
                 */
                this.logs = [];
                /**
                 * @public
                 * @language zh_CN
                 * 加载过程中记录的错误信息
                 * @version m4m 1.0
                 */
                this.errs = [];
            }
            Object.defineProperty(stateLoad.prototype, "fileProgress", {
                /**
                 * @public
                 * @language zh_CN
                 * 获取文件数加载进度
                 * @version m4m 1.0
                 */
                get: function () {
                    return this.curtask / this.totaltask;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(stateLoad.prototype, "curByteLength", {
                /**
                 * @public
                 * @language zh_CN
                 * 已加载的字节长度
                 * @version m4m 1.0
                 */
                get: function () {
                    var result = 0;
                    for (var key in this.resstate) {
                        var _resState = this.resstate[key];
                        result += _resState.loadedLength;
                        if (_resState instanceof RefResourceState) {
                            result += _resState.refLoadedLength;
                        }
                    }
                    result += this.compressTextLoaded + this.compressBinLoaded;
                    return result;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(stateLoad.prototype, "progress", {
                /**
                 * @public
                 * @language zh_CN
                 * 获取文件真实加载进度
                 * @version m4m 1.0
                 */
                get: function () {
                    return this.curByteLength / this.totalByteLength;
                },
                enumerable: false,
                configurable: true
            });
            return stateLoad;
        }());
        framework.stateLoad = stateLoad;
        var assetRef = /** @class */ (function () {
            function assetRef() {
            }
            return assetRef;
        }());
        framework.assetRef = assetRef;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var assetBundle = /** @class */ (function () {
            function assetBundle(url, assetmgr, guid) {
                this.assetmgr = assetmgr;
                this.files = {}; //Array<{ name: string, guid: number }>;
                this.texs = {};
                this.pkgs = [];
                this.pkgsGuid = [];
                this.isunload = false;
                this.guid = guid || assetBundle.buildGuid();
                this.url = url;
                this.baseUrl = url.substring(0, url.lastIndexOf("/") + 1);
                this.name = url.substring(url.lastIndexOf("/") + 1);
                this.keyUrl = url.replace(framework.assetMgr.cdnRoot, "");
            }
            assetBundle.buildGuid = function () {
                //资源包自己的使用的GUID
                return --assetBundle.idNext;
            };
            assetBundle.prototype.getFixBundleTextures = function (texMap, fileMap) {
                var result = {};
                var careBinMap = assetBundle.careBinTexMap;
                var careMap = assetBundle.careBaseTexMap;
                var texStrList = Object.keys(careMap).concat(Object.keys(careBinMap));
                for (var key in texMap) {
                    if (!key)
                        continue;
                    var val = texMap[key];
                    result[key] = val; //已有的 
                    var idx = key.lastIndexOf(".");
                    var fileName = key;
                    if (idx != -1) {
                        fileName = key.substring(0, idx);
                    }
                    for (var i = 0, len = texStrList.length; i < len; i++) {
                        //包含以有文件
                        var val_1 = texStrList[i];
                        var fullName = "".concat(fileName).concat(val_1);
                        if (fileMap[fullName] == null)
                            continue;
                        result[fullName] = fileMap[fullName]; //其他格式的
                    }
                }
                return result;
            };
            //解析资源包描述文件 和下载
            assetBundle.prototype.parseBundle = function (data) {
                var _this = this;
                return new Promise(function (resolve, reject) {
                    _this.parseResolve = resolve;
                    _this.parseReject = reject;
                    if (assetBundle.reTryTest[_this.name]) {
                        console.error("\u8D44\u6E90 ".concat(_this.name, " \u6B63\u5728\u91CD\u8BD5 , ").concat(_this.url));
                        delete assetBundle.reTryTest[_this.name];
                        _this.ready = false;
                    }
                    var json;
                    try {
                        json = JSON.parse(data);
                    }
                    catch (error) {
                        _this.fail(new Error("[\u8D44\u6E90]\u63CF\u8FF0\u6587\u4EF6\u9519\u8BEF ".concat(_this.url, " ,").concat(error.message)));
                        return;
                    }
                    _this.files = json.files;
                    _this.texs = assetBundle.enableFixTexs ? _this.getFixBundleTextures(json.texs, json.files) : json.texs;
                    _this.pkgs = json.pkg;
                    if (!framework.assetMgr.openGuid) {
                        for (var k in _this.files)
                            _this.files[k] = assetBundle.buildGuid();
                        for (var k in _this.texs)
                            _this.texs[k] = assetBundle.buildGuid();
                    }
                    _this.dw_imgCount = _this.dw_fileCount = Object.keys(_this.texs || {}).length;
                    var dwpkgCount = 0;
                    if (_this.pkgs) {
                        _this.dw_fileCount += Object.keys(_this.pkgs).length;
                        // console.log(`当前资源是压缩状态.`);
                        _this.pkgsGuid = _this.pkgsGuid || [];
                        var nameURL = _this.url.substring(0, _this.url.lastIndexOf(".assetbundle"));
                        var _loop_5 = function (i, len) {
                            var extName = _this.pkgs[i].substring(_this.pkgs[i].indexOf("."));
                            var url = nameURL + extName;
                            var kurl = url.replace(framework.assetMgr.cdnRoot, "");
                            var guid = framework.assetMgr.urlmapGuid[kurl];
                            if (!guid)
                                guid = assetBundle.buildGuid();
                            _this.pkgsGuid.push(guid);
                            // console.error(`[下載資源] 00 ${this.name},${url}  ,${dwpkgCount}/${this.dw_fileCount}`);
                            _this.assetmgr.download(guid, url, framework.calcType(url), function () {
                                ++dwpkgCount;
                                // console.error(`[下載資源] 11 ${this.name},${url}  ,${dwpkgCount}/${this.dw_fileCount}`);
                                if (dwpkgCount >= _this.dw_fileCount)
                                    _this.parseFile();
                            }, function () {
                                console.error("[\u4E0B\u8F09\u8CC7\u6E90]\u5931\u8D25:".concat(kurl, " ,bundle:").concat(_this.name));
                            }, _this);
                        };
                        for (var i = 0, len = _this.pkgs.length; i < len; ++i) {
                            _loop_5(i, len);
                        }
                    }
                    else {
                        _this.dw_fileCount += Object.keys(_this.files).length;
                        var _loop_6 = function (k) {
                            var guid = _this.files[k];
                            var url = "".concat(_this.baseUrl, "resources/").concat(k);
                            // console.error(`[下載資源] 00 ${this.name},${url}  ,${dwpkgCount}/${this.dw_fileCount}`);
                            _this.assetmgr.download(guid, url, framework.calcType(k), function () {
                                ++dwpkgCount;
                                // console.error(`[下載資源] 11 ${this.name},${url}  ,${dwpkgCount}/${this.dw_fileCount}`);
                                if (dwpkgCount >= _this.dw_fileCount)
                                    _this.parseFile();
                            }, function () {
                                console.error("[\u4E0B\u8F09\u8CC7\u6E90]\u5931\u8D25:".concat(url, " ,bundle:").concat(_this.name));
                            }, _this);
                        };
                        // console.log(`当前资源是分包状态.`);
                        for (var k in _this.files) {
                            _loop_6(k);
                        }
                    }
                    //下载图片
                    var imageNext = function (url) {
                        ++dwpkgCount;
                        // console.error(`[下載資源] 11 ${this.name},${url}  ,${dwpkgCount}/${this.dw_fileCount}`);
                        if (dwpkgCount >= this.dw_fileCount)
                            this.parseFile();
                    };
                    var careBinMap = assetBundle.careBinTexMap;
                    var careMap = assetBundle.careBaseTexMap;
                    var _loop_7 = function (k) {
                        var guid = _this.texs[k];
                        _this.files[k] = guid; //先下载 然后给解析器补充一个key
                        var url = "".concat(_this.baseUrl, "resources/").concat(k);
                        // console.error(`[下載資源] 00 ${this.name},${url}  ,${dwpkgCount}/${this.dw_fileCount}`);
                        var suffix = framework.StringUtil.GetSuffix(k);
                        if (careMap[suffix] != null) {
                            _this.assetmgr.loadImg(guid, url, imageNext.bind(_this, url), _this);
                            return "continue";
                        }
                        if (careBinMap[suffix] != null) {
                            var t = careBinMap[suffix];
                            _this.assetmgr.download(guid, url, t, imageNext.bind(_this, url), function () {
                                console.error("[\u4E0B\u8F09\u8CC7\u6E90]\u5931\u8D25:".concat(url, " ,bundle:").concat(_this.name));
                            }, _this);
                        }
                    };
                    for (var k in _this.texs) {
                        _loop_7(k);
                    }
                });
            };
            //解包
            assetBundle.prototype.unpkg = function () {
                for (var i = this.pkgsGuid.length - 1; i >= 0; --i) {
                    var pkgGuid = this.pkgsGuid[i];
                    var pkgld = framework.assetMgr.mapLoading[pkgGuid];
                    if (!pkgld || !pkgld.data || pkgld.data == 0) //被解析过了不再解析 项目中标记的 
                        continue;
                    var isbin = this.pkgs[i].endsWith(".bpkg.json");
                    pkgld.subRes = [];
                    if (isbin) { //二进制压缩 带图片
                        try {
                            var buffer = pkgld.data;
                            var reader = new m4m.io.binReader(buffer);
                            var count = reader.readByte();
                            // console.log(`解压二进制包,文件数:${count}`);
                            while (count-- > 0) {
                                var nl = reader.readByte();
                                var namebytes = reader.readBytesRef(nl);
                                var name = String.fromCharCode.apply(null, namebytes);
                                var fsize = reader.readUInt32();
                                var bin = reader.readBytesRef(fsize);
                                var guid = this.files[name] || this.texs[name]; //如果文件找不到,就去找图片                            
                                framework.assetMgr.setLoading(guid, { readyok: true, data: bin.buffer });
                                pkgld.subRes.push(guid);
                                // console.log(`解压 bin文件${name},size:${fsize},guid:${guid}`);
                            }
                        }
                        catch (error) {
                            throw new Error("[\u89E3\u6790\u8CC7\u6E90]unpkg bpkg\u5931\u8D25:".concat(this.url, ",").concat(this.pkgs[i], "\n").concat(error.message));
                        }
                    }
                    else {
                        try {
                            var json = JSON.parse(pkgld.data);
                            // console.log(`解压文本包,文件数:${Object.keys(json).length}`);
                            for (var k in json) {
                                var guid = this.files[k];
                                framework.assetMgr.setLoading(guid, { readyok: true, data: json[k] });
                                pkgld.subRes.push(guid);
                                // console.log(`解压 text文件${k},size:${json[k].length},${guid}`);
                            }
                        }
                        catch (error) {
                            throw new Error("[\u89E3\u6790\u8CC7\u6E90]unpkg jpkg\u5931\u8D25:".concat(this.url, ",").concat(this.pkgs[i], "\n").concat(error.message));
                        }
                    }
                    //释放原数据
                    delete pkgld.data;
                }
            };
            //解析
            assetBundle.prototype.parseFile = function () {
                return __awaiter(this, void 0, void 0, function () {
                    var assets, k, type, i, len, asset, error_1, texs, key, id, loading;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (this.onDownloadFinish)
                                    this.onDownloadFinish();
                                // if (!assetMgr.atonceParse)
                                // {
                                //     assetMgr.noparseBundle.push(this);
                                //     return;
                                // }
                                if (this.pkgs) //如果需要解包就解
                                 {
                                    try {
                                        this.unpkg();
                                    }
                                    catch (error) {
                                        this.fail(error);
                                        return [2 /*return*/];
                                    }
                                }
                                assets = [];
                                // let idx = 0;
                                for (k in this.files) {
                                    //已经解析的资源不再做解析
                                    if (framework.assetMgr.mapGuid[this.files[k]])
                                        continue;
                                    type = framework.calcType(k);
                                    assets.push({
                                        type: type,
                                        name: k,
                                        guid: this.files[k]
                                    });
                                }
                                //解析顺序按枚举从小到大来排序
                                assets.sort(function (a, b) { return a.type - b.type; });
                                i = 0, len = assets.length;
                                _a.label = 1;
                            case 1:
                                if (!(i < len)) return [3 /*break*/, 6];
                                asset = assets[i];
                                // console.error(`[解析资源] 00 name:${asset.name} ,bundle:${this.name}  ${i}/${assets.length}`);
                                if (framework.assetMgr.mapGuid[asset.guid])
                                    return [3 /*break*/, 5]; //已经解析好的资源不需要再解析
                                _a.label = 2;
                            case 2:
                                _a.trys.push([2, 4, , 5]);
                                return [4 /*yield*/, this.assetmgr.parseRes(asset, this)];
                            case 3:
                                _a.sent();
                                return [3 /*break*/, 5];
                            case 4:
                                error_1 = _a.sent();
                                // console.error(`[解析资源]失败:${asset.name} ,bundle:${this.name} ${i}/${assets.length}`);
                                this.fail(error_1);
                                return [2 /*return*/];
                            case 5:
                                ++i;
                                return [3 /*break*/, 1];
                            case 6:
                                this.ready = true;
                                // console.log(`资源包:${this.name} 准备完毕. 解析耗时${Date.now() - time}/ms`);
                                //清理 多余img
                                if (assetBundle.needClearLoadedRes) {
                                    texs = this.texs;
                                    for (key in texs) {
                                        id = texs[key];
                                        delete framework.assetMgr.mapImage[id];
                                        loading = framework.assetMgr.mapLoading[id];
                                        if (loading && loading.readyok) {
                                            delete loading.data;
                                        }
                                    }
                                }
                                this.parseResolve();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            assetBundle.prototype.unload = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                this.isunload = true;
                for (var k in this.files) {
                    var ref = framework.assetMgr.mapGuid[this.files[k]];
                    if (ref)
                        this.assetmgr.unuse(ref.asset, disposeNow);
                }
                for (var k in this.texs)
                    delete framework.assetMgr.mapImage[this.texs[k]];
                while (this.pkgsGuid.length > 0) {
                    var guid = this.pkgsGuid.pop();
                    var ref_1 = framework.assetMgr.mapGuid[guid];
                    if (ref_1)
                        this.assetmgr.unuse(ref_1.asset, disposeNow);
                    else
                        delete framework.assetMgr.mapLoading[guid];
                }
                delete this.assetmgr.guid_bundles[this.guid];
                delete this.assetmgr.name_bundles[this.name];
                delete this.assetmgr.kurl_bundles[this.keyUrl];
                delete framework.assetMgr.mapBundleNamed[this.guid];
                delete framework.assetMgr.mapGuid[this.guid];
            };
            assetBundle.prototype.fail = function (error) {
                assetBundle.reTryTest[this.name] = 1;
                // this.unload(true);
                this.parseReject(error);
            };
            /** 解析后清理 加载缓存资源数据 */
            assetBundle.needClearLoadedRes = false;
            assetBundle.idNext = -1; //id起始位置               
            /** 关注的 二进制 纹理格式 字符串 */
            assetBundle.careBinTexMap = {
                ".raw": framework.AssetTypeEnum.RAW,
                ".pvr": framework.AssetTypeEnum.PVR,
                ".pvr.bin": framework.AssetTypeEnum.PVR,
                ".astc": framework.AssetTypeEnum.ASTC,
                ".ktx": framework.AssetTypeEnum.KTX,
            };
            /** 关注的 基础 纹理格式 字符串 */
            assetBundle.careBaseTexMap = {
                ".png": framework.AssetTypeEnum.Texture,
                ".jpg": framework.AssetTypeEnum.Texture,
            };
            /** 修复 texs map */
            assetBundle.enableFixTexs = true;
            assetBundle.reTryTest = {};
            return assetBundle;
        }());
        framework.assetBundle = assetBundle;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        framework.assetParseMap = {};
        //资源处理装饰器
        function assetF(type) {
            return function (ctor) {
                framework.assetParseMap[type] = new ctor();
            };
        }
        framework.assetF = assetF;
        //#region 资源类型
        function calcType(url) {
            var filei = url.lastIndexOf("/");
            var file = url.substr(filei + 1);
            var i = file.indexOf(".", 0);
            var extname = null;
            while (i >= 0) {
                extname = file.substr(i);
                switch (extname) {
                    case ".vs.glsl":
                        return framework.AssetTypeEnum.GLVertexShader;
                    case ".fs.glsl":
                        return framework.AssetTypeEnum.GLFragmentShader;
                    case ".assetbundle.json":
                        return framework.AssetTypeEnum.Bundle;
                    case ".shader.json":
                        return framework.AssetTypeEnum.Shader;
                    case ".png":
                    case ".jpg":
                        return framework.AssetTypeEnum.Texture;
                    case ".pvr.bin":
                    case ".pvr":
                    case ".pvr.bin.js":
                        return framework.AssetTypeEnum.PVR;
                    case ".astc.bin":
                    case ".astc":
                    case ".astc.bin.js":
                        return framework.AssetTypeEnum.ASTC;
                    case ".raw.bin":
                    case ".raw":
                    case ".raw.bin.js":
                        return framework.AssetTypeEnum.RAW;
                    case ".ktx.bin":
                    case ".ktx":
                    case ".ktx.bin.js":
                        return framework.AssetTypeEnum.KTX;
                    case ".imgdesc.json":
                        return framework.AssetTypeEnum.TextureDesc;
                    case ".mesh.bin":
                    case ".mesh.bin.js":
                    case ".cmesh.bin":
                        return framework.AssetTypeEnum.Mesh;
                    case ".aniclip.bin":
                    case ".aniclip.bin.js":
                        return framework.AssetTypeEnum.Aniclip;
                    case ".prefab.json":
                        return framework.AssetTypeEnum.Prefab;
                    case ".cprefab.json":
                        return framework.AssetTypeEnum.cPrefab;
                    case ".scene.json":
                        return framework.AssetTypeEnum.Scene;
                    case ".atlas.json":
                        return framework.AssetTypeEnum.Atlas;
                    case ".font.json":
                        return framework.AssetTypeEnum.Font;
                    case ".json":
                    case ".txt":
                    case ".effect.json":
                        return framework.AssetTypeEnum.TextAsset;
                    case ".mat.json":
                        return framework.AssetTypeEnum.Material;
                    case ".bpkg.json":
                    case ".packs.bin":
                    case ".packs.bin.js":
                        return framework.AssetTypeEnum.PackBin;
                    case ".jpkg.json":
                    case ".packs.txt":
                        return framework.AssetTypeEnum.PackTxt;
                    case ".path.json":
                        return framework.AssetTypeEnum.PathAsset;
                    case ".f14effect.json":
                        return framework.AssetTypeEnum.F14Effect;
                    case ".dds":
                    case ".dds.bin":
                        return framework.AssetTypeEnum.DDS;
                    case ".keyframeAniclip.json":
                        return framework.AssetTypeEnum.KeyFrameAniclip;
                    case ".particlesystem.json":
                        return framework.AssetTypeEnum.ParticleSystem;
                    case ".trailrenderer.json":
                        return framework.AssetTypeEnum.TrailRenderer;
                    case ".hdr":
                        return framework.AssetTypeEnum.HDR;
                    case ".gltf":
                        return framework.AssetTypeEnum.GLTF;
                    case ".glb":
                        return framework.AssetTypeEnum.GLB;
                    case ".bin":
                        return framework.AssetTypeEnum.BIN;
                }
                i = file.indexOf(".", i + 1);
            }
        }
        framework.calcType = calcType;
        function calcReqType(type) {
            var e = framework.AssetTypeEnum;
            switch (type) {
                case e.PackTxt:
                case e.Bundle:
                case e.Atlas:
                case e.cPrefab:
                case e.F14Effect:
                case e.Font:
                case e.GLFragmentShader:
                case e.GLVertexShader:
                case e.KeyFrameAniclip:
                case e.Material:
                case e.PathAsset:
                case e.Scene:
                case e.Shader:
                case e.TextAsset:
                case e.TextureDesc:
                case e.PackTxt:
                case e.ParticleSystem:
                case e.GLTF:
                    return "text";
                case e.Aniclip:
                case e.DDS:
                case e.Mesh:
                case e.PVR:
                case e.KTX:
                case e.ASTC:
                case e.PackBin:
                case e.HDR:
                case e.RAW:
                case e.BIN:
                case e.GLB:
                    return "arraybuffer";
                default:
                    // throw Error(`无法识别类型 enum:${AssetTypeEnum[type]},type:${type}`);
                    return null;
            }
        }
        framework.calcReqType = calcReqType;
        //#endregion
        //资源管理器
        var assetMgr = /** @class */ (function () {
            function assetMgr(app) {
                this.name_bundles = {};
                this.kurl_bundles = {};
                this.guid_bundles = {};
                this.mapShader = {};
                //#region api保留
                this.mapDefaultMesh = {};
                this.mapDefaultTexture = {};
                this.mapDefaultCubeTexture = {};
                this.mapDefaultSprite = {};
                this.mapMaterial = {};
                this.mapRes = {};
                this.app = app;
                this.webgl = app.webgl;
                this.shaderPool = new m4m.render.shaderPool();
                // this.initAssetFactorys();
            }
            //外部才能确定在哪用,初始化全局资源记录
            assetMgr.initGuidList = function () {
                m4m.io.loadJSON(assetMgr.guidlistURL, function (json) {
                    assetMgr.urlmapGuid = json.res;
                    // console.log(`initGuidList  资源GUID从[${json.__useid}]开始计数`);
                    // resID.idAll = json.__useid;
                    if (assetMgr.onGuidInit)
                        assetMgr.onGuidInit();
                });
            };
            assetMgr.setLoading = function (guid, data) {
                // let loading = assetMgr.mapLoading[guid];
                // if (loading && loading.readyok)
                //     throw new Error(`冲突的guid:${guid}`);
                assetMgr.mapLoading[guid] = data;
            };
            //加载资源
            assetMgr.prototype.load = function (url, type, 
            /** 这是解析完成的回调 */
            onstate, downloadFinish) {
                var _this_1 = this;
                if (type === void 0) { type = framework.AssetTypeEnum.Auto; }
                if (onstate === void 0) { onstate = null; }
                if (downloadFinish === void 0) { downloadFinish = null; }
                var keyUrl = url.replace(assetMgr.cdnRoot, "");
                var guid = assetMgr.urlmapGuid[keyUrl];
                if (!guid) {
                    if (url.endsWith(".assetbundle.json"))
                        guid = framework.assetBundle.buildGuid();
                    else
                        guid = framework.resID.next(); //生成一个guid
                }
                var state = new framework.stateLoad();
                type = type == framework.AssetTypeEnum.Auto ? calcType(url) : type;
                if (assetMgr.mapGuid[guid]) //已下载的资源
                 {
                    state.bundle = this.guid_bundles[guid];
                    state.isfinish = true;
                    if (onstate)
                        onstate(state);
                    return;
                }
                //只下载一次 其他入队
                this.download(guid, url, type, function () {
                    var loading = assetMgr.mapLoading[guid];
                    if (type == framework.AssetTypeEnum.Bundle) {
                        var bundle_1 = new framework.assetBundle(url, _this_1, guid);
                        bundle_1.onDownloadFinish = downloadFinish;
                        _this_1.name_bundles[bundle_1.name] = _this_1.kurl_bundles[keyUrl] = _this_1.guid_bundles[bundle_1.guid] = bundle_1;
                        //这个过程中有可能会被释放 ,所以以下从新赋值引用
                        bundle_1.parseBundle(loading.data).then(function () {
                            //加载完成时再次 存储引用
                            if (!_this_1.name_bundles[bundle_1.name] || !_this_1.kurl_bundles[keyUrl] || !_this_1.guid_bundles[bundle_1.guid])
                                _this_1.name_bundles[bundle_1.name] = _this_1.kurl_bundles[keyUrl] = _this_1.guid_bundles[bundle_1.guid] = bundle_1;
                            state.bundle = bundle_1;
                            state.isfinish = true;
                            if (onstate)
                                onstate(state);
                        }).catch(function (err) {
                            framework.error.push(err);
                            state.iserror = true;
                            // console.error(`##抛出重试 ${bundle.name} ---- `);
                            if (onstate)
                                onstate(state);
                        });
                    }
                    else {
                        var filename = framework.getFileName(url);
                        var next = function (name, guid, type, dwguid) {
                            _this_1.parseRes({ name: name, guid: guid, type: type, dwguid: dwguid }).then(function (asset) {
                                //解析完毕
                                state.isfinish = true;
                                if (asset) {
                                    state.resstateFirst = {
                                        res: asset,
                                        state: 0,
                                        loadedLength: 0
                                    };
                                }
                                if (onstate)
                                    onstate(state);
                            });
                        };
                        var factory = framework.assetParseMap[type];
                        if (factory.needDownload) {
                            var nname = factory.needDownload(assetMgr.mapLoading[guid].data);
                            var nurl = url.replace(filename, nname);
                            var nguid = framework.resID.next();
                            var ntype = calcType(nname);
                            if (ntype == framework.AssetTypeEnum.Texture)
                                _this_1.loadImg(nguid, nurl, next.bind(_this_1, filename, guid, type, nguid)); //不一样的是这里带了一个需要下载的GUID
                            else
                                _this_1.download(nguid, nurl, ntype, next.bind(_this_1, filename, guid, type, nguid), function (err) {
                                    assetMgr.setStateError(state, onstate, err);
                                }); //不一样的是这里带了一个需要下载的GUID
                        }
                        else {
                            var dwguid = type == framework.AssetTypeEnum.Texture ? guid : null;
                            next.call(_this_1, filename, guid, type, dwguid);
                        }
                    }
                }, function (err) {
                    assetMgr.setStateError(state, onstate, err);
                });
            };
            assetMgr.setStateError = function (state, onstate, err) {
                state.errs.push(err);
                state.iserror = true;
                if (onstate)
                    onstate(state);
            };
            assetMgr.prototype.download = function (guid, url, type, finish, errcb, bundle) {
                var loading = assetMgr.mapLoading[guid];
                //下载完成的不再下载
                if (loading && loading.readyok && finish)
                    return finish();
                else if (!loading) {
                    loading = { readyok: false, url: url };
                    assetMgr.setLoading(guid, loading);
                }
                if (type == framework.AssetTypeEnum.Texture) {
                    loading.cbQueue = [];
                    this.loadImg(guid, url, function (img) {
                        finish();
                    }, bundle);
                    return;
                }
                var repType = calcReqType(type);
                if (repType == null) {
                    framework.error.push(new Error("\u65E0\u6CD5\u8BC6\u522B\u7C7B\u578B url:".concat(url, " , guid:").concat(guid, " , enum:").concat(framework.AssetTypeEnum[type], ",type:").concat(type)));
                    return;
                }
                m4m.io.xhrLoad(url, function (data, err) {
                    console.error(err.stack);
                    if (errcb)
                        errcb(err);
                }, function () { }, repType, function (xhr) {
                    var loading = assetMgr.mapLoading[guid];
                    if (!loading) {
                        if (bundle && bundle.isunload == true) {
                            console.error("\u8D44\u6E90\u4E0B\u8F7D\u53D6\u6D88:".concat(url, " , bundle:").concat(bundle.name, " \u5DF2\u91CA\u653E"));
                            return;
                        }
                        loading = { readyok: true };
                        assetMgr.setLoading(guid, loading);
                    }
                    else {
                        loading.readyok = true;
                    }
                    loading.data = xhr.response;
                    finish();
                });
            };
            //加载图片
            assetMgr.prototype.loadImg = function (guid, url, cb, bundle) {
                if (assetMgr.mapImage[guid])
                    return cb(assetMgr.mapImage[guid]);
                var loading = assetMgr.mapLoading[guid];
                if (!loading) {
                    loading = { readyok: false, cbQueue: [] };
                    assetMgr.setLoading(guid, loading);
                }
                loading.cbQueue.push(cb);
                this._loadImg(url, function (img, err) {
                    if (bundle && bundle.isunload == true) {
                        console.error("img\u4E0B\u8F7D\u53D6\u6D88:".concat(url, " , bundle:").concat(bundle.name, " \u5DF2\u91CA\u653E"));
                        loading.cbQueue = [];
                        return;
                    }
                    assetMgr.mapImage[guid] = img;
                    loading.readyok = true;
                    loading.data = img;
                    while (loading.cbQueue.length > 0) {
                        var _cb = loading.cbQueue.shift();
                        if (_cb)
                            _cb(img, err);
                    }
                });
            };
            //微信可复写
            assetMgr.prototype._loadImg = function (url, cb) {
                var img = new Image();
                //webgl跨域渲染要这样玩 [crossOrigin = ""]否则服务器允许跨域也没用
                img.crossOrigin = "";
                img.src = url;
                img.onload = function () {
                    if (cb)
                        cb(img);
                };
                img.onerror = function (_err) {
                    if (cb)
                        cb(img, _err);
                };
            };
            assetMgr.prototype.use = function (asset) {
                var guid = asset.getGUID();
                var ref = assetMgr.mapGuid[guid];
                if (!ref) {
                    ref = new framework.assetRef();
                    ref.asset = asset;
                    ref.refcount = 1;
                    assetMgr.mapGuid[guid] = ref;
                    if (asset.bundle) {
                        if (!assetMgr.mapBundleNamed[asset.bundle.guid]) {
                            assetMgr.mapBundleNamed[asset.bundle.guid] = {};
                            assetMgr.mapBundleNamed[asset.bundle.guid][asset.getName()] = ref;
                        }
                        else {
                            if (!assetMgr.mapBundleNamed[asset.bundle.guid][asset.getName()])
                                assetMgr.mapBundleNamed[asset.bundle.guid][asset.getName()] = ref;
                            // else
                            //     console.warn(`资源命名冲突:${asset.getName()}`);
                        }
                    }
                    else {
                        // if (assetMgr.mapNamed[asset.getName()])
                        //     console.warn(`资源命名冲突:${asset.getName()}`);
                        assetMgr.mapNamed[asset.getName()] = asset;
                    }
                }
                else
                    ++ref.refcount;
            };
            assetMgr.prototype.unuse = function (asset, disposeNow) {
                if (disposeNow === void 0) { disposeNow = true; }
                var guid = asset.getGUID();
                var assetref = assetMgr.mapGuid[guid];
                if (disposeNow && assetref && --assetref.refcount < 1) {
                    delete assetMgr.mapGuid[guid];
                    delete assetMgr.mapLoading[asset.getGUID()];
                    delete assetMgr.mapNamed[assetref.asset.getName()];
                }
            };
            assetMgr.prototype.parseRes = function (asset, bundle) {
                var _this_1 = this;
                return new Promise(function (resolve, reject) {
                    if (assetMgr.mapGuid[asset.guid]) {
                        resolve(assetMgr.mapGuid[asset.guid].asset);
                        return;
                    }
                    // let ctime = Date.now();
                    var loading = assetMgr.mapLoading[asset.guid];
                    if (!loading)
                        return reject(new Error("\u8D44\u6E90\u89E3\u6790\u5931\u8D25 name:".concat(asset.name, ",bundle:").concat(bundle ? bundle.url : "", " assetMgr.mapLoading \u65E0\u6CD5\u627E\u5230guid:").concat(asset.guid)));
                    var data = loading.data;
                    var factory = framework.assetParseMap[asset.type];
                    if (!factory)
                        return reject(new Error("\u65E0\u6CD5\u627E\u5230[".concat(framework.AssetTypeEnum[asset.type], "]\u7684\u89E3\u6790\u5668")));
                    if (!factory.parse)
                        return reject(new Error("\u89E3\u6790\u5668 ".concat(factory.constructor.name, " \u6CA1\u6709\u5B9E\u73B0parse\u65B9\u6CD5")));
                    var _this = _this_1;
                    function nextRes(retasset) {
                        if (retasset) {
                            if (bundle) {
                                if (bundle.isunload == true) {
                                    console.error("\u8D44\u6E90\u89E3\u6790\u53D6\u6D88 name:".concat(asset.name, " , bundle:").concat(bundle.name));
                                    return;
                                }
                                retasset["id"].id = asset.guid;
                            }
                            retasset.bundle = bundle;
                            _this.use(retasset);
                        }
                        resolve(retasset);
                    }
                    try {
                        var __asset = factory.parse(_this_1, bundle, asset.name, data, asset.dwguid);
                        var retasset = __asset;
                        // if (__asset instanceof threading.gdPromise){
                        if (__asset && __asset["then"]) {
                            __asset.then(function (res) {
                                nextRes(res);
                            }).catch(function (e) {
                                reject(e);
                            });
                            // console.error(`[解析资源] await 完成 ${asset.name}`);
                        }
                        else
                            nextRes(retasset);
                    }
                    catch (error) {
                        console.error("\u8D44\u6E90\u89E3\u6790\u9519\u8BEF:".concat(error.message, "\n").concat(error.stack));
                        reject(error);
                    }
                    // console.log(`解析完成[${AssetTypeEnum[asset.type]}]${Date.now() - ctime}ms,解析器:${factory.constructor.name},guid:${asset.guid},name:${asset.name}`);
                });
            };
            assetMgr.prototype.getAssetByName = function (name, bundlename) {
                if (bundlename) {
                    var bundle = this.kurl_bundles[bundlename] || this.name_bundles[bundlename];
                    if (bundle) {
                        var guid = bundle.files[name.replace(".prefab", ".cprefab")];
                        if (guid != undefined && assetMgr.mapGuid[guid])
                            return assetMgr.mapGuid[guid].asset;
                    }
                }
                return assetMgr.mapNamed[name];
            };
            assetMgr.prototype.getDefaultMesh = function (name) { return this.mapDefaultMesh[name]; };
            assetMgr.prototype.getDefaultTexture = function (name) { return this.mapDefaultTexture[name]; };
            assetMgr.prototype.getDefaultCubeTexture = function (name) { return this.mapDefaultCubeTexture[name]; };
            assetMgr.prototype.getDefaultSprite = function (name) { return this.mapDefaultSprite[name]; };
            assetMgr.prototype.getMaterial = function (name) { return this.mapMaterial[name]; };
            assetMgr.correctFileName = function (name) {
                if (name.indexOf(this.bin) < 0) {
                    return name;
                }
                var binlen = this.bin.length;
                var substr = name.substring(name.length - binlen);
                if (substr == this.bin) {
                    return name + ".js";
                }
                return name;
            };
            assetMgr.correctTxtFileName = function (name) {
                if (name.indexOf(this.txt) < 0) {
                    return name;
                }
                var len = this.txt.length;
                var substr = name.substring(name.length - len);
                if (substr == this.txt) {
                    return name + ".js";
                }
                return name;
            };
            assetMgr.prototype.getShader = function (name) {
                return this.mapShader[name];
            };
            assetMgr.prototype.getDefLineRendererMat = function () {
                if (this.linerenderermat == null) {
                    var material_1 = new framework.material();
                    material_1.use();
                    material_1.setShader(framework.sceneMgr.app.getAssetMgr().getShader("shader/deflinetrail"));
                    var tex = this.getDefaultTexture(framework.defTexture.white);
                    material_1.setTexture("_MainTex", tex);
                    this.linerenderermat = material_1;
                }
                return this.linerenderermat;
            };
            assetMgr.prototype.getDefParticleMat = function () {
                if (this.particlemat == null) {
                    var mat = new framework.material("defparticle");
                    var shader = this.getShader("particles_additive.shader.json");
                    if (shader == null) {
                        shader = this.getShader("shader/def");
                    }
                    mat.setShader(shader);
                    var tex = this.getDefaultTexture("grid");
                    mat.setTexture("_MainTex", tex);
                    this.particlemat = mat;
                }
                return this.particlemat;
            };
            assetMgr.prototype.setAssetUrl = function (asset, url) {
                // this.assetUrlDic[asset.getGUID()] = url;
            };
            assetMgr.prototype.getAssetUrl = function (asset) {
                return this.assetUrlDic[asset.getGUID()];
            };
            assetMgr.prototype.savePrefab = function (trans, prefabName, fun) {
            };
            assetMgr.prototype.loadCompressBundle = function (url, a) {
            };
            assetMgr.prototype.loadImmediate = function (url) {
                return null;
            };
            assetMgr.prototype.getAssetBundle = function (url) {
                return this.name_bundles[url];
            };
            assetMgr.prototype.releaseUnuseAsset = function () {
            };
            assetMgr.prototype.initDefAsset = function () {
                framework.defMesh.initDefaultMesh(this);
                framework.defTexture.initDefaultTexture(this);
                framework.defsprite.initDefaultSprite(this);
                framework.defShader.initDefaultShader(this);
                framework.defmaterial.initDefaultMaterial(this);
            };
            assetMgr.prototype.loadScene = function (sceneName, onComplete) {
                var firstChilds = new Array();
                var scene = this.app.getScene();
                if (sceneName.length > 0) {
                    var _rawscene = this.getAssetByName(sceneName, sceneName.replace(".scene.json", ".assetbundle.json"));
                    var willLoadRoot = _rawscene.getSceneRoot();
                    while (willLoadRoot.children.length > 0) {
                        var trans = willLoadRoot.children.shift();
                        firstChilds.push(trans);
                        scene.addChild(trans);
                    }
                    //清空原场景UI
                    scene["_overlay2d"] = new Array();
                    //lightmap
                    _rawscene.useLightMap(scene);
                    //fog
                    _rawscene.useFog(scene);
                    //nav
                    _rawscene.useNavMesh(scene);
                }
                else {
                    var _camera = new framework.transform();
                    _camera.gameObject.addComponent("camera");
                    _camera.name = "camera";
                    firstChilds.push(_camera);
                    scene.addChild(_camera);
                }
                scene.name = sceneName;
                scene.getRoot().markDirty();
                onComplete(firstChilds);
            };
            assetMgr.prototype.unload = function (url) {
                var keyUrl = url.replace(assetMgr.cdnRoot, "");
                var guid = assetMgr.urlmapGuid[keyUrl];
                if (guid) {
                    var name_1 = framework.getFileName(keyUrl);
                    delete assetMgr.mapNamed[name_1];
                    delete assetMgr.mapLoading[guid];
                    delete assetMgr.mapGuid[guid];
                }
                else if (this.kurl_bundles[keyUrl]) {
                    var bundle = this.kurl_bundles[keyUrl];
                    bundle.unload();
                }
            };
            assetMgr.urlmapGuid = {}; //全局资源记录
            assetMgr.mapLoading = {}; //下载好的,未下载好的,资源
            assetMgr.mapGuid = {}; //解析好的资源
            assetMgr.mapImage = {}; //图片缓存
            assetMgr.mapNamed = {}; //资源名是 ,系统资源类型的名字 或自己定义的名字
            assetMgr.mapBundleNamed = {};
            assetMgr.noparseBundle = []; //未解析的资源包
            assetMgr.atonceParse = true; //是否立即解析
            assetMgr.openGuid = true; //是否开启去重能力
            assetMgr.useBinJs = false;
            assetMgr.txt = ".txt";
            assetMgr.bin = ".bin";
            return assetMgr;
        }());
        framework.assetMgr = assetMgr;
        //#region api保留
        var SaveInfo = /** @class */ (function () {
            function SaveInfo() {
                this.files = {};
            }
            return SaveInfo;
        }());
        framework.SaveInfo = SaveInfo;
        //#endregion api保留
        //--------------api保留----------------end
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var defmaterial = /** @class */ (function () {
            function defmaterial() {
            }
            defmaterial.initDefaultMaterial = function (assetmgr) {
                {
                    var mat = new framework.material();
                    var sh = assetmgr.getShader("shader/defui");
                    mat.setShader(sh);
                    assetmgr.mapMaterial[sh.getName()] = mat;
                }
            };
            return defmaterial;
        }());
        framework.defmaterial = defmaterial;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var defMesh = /** @class */ (function () {
            function defMesh() {
            }
            defMesh.initDefaultMesh = function (assetmgr) {
                assetmgr.mapDefaultMesh[this.cube] = this.createDefaultMesh(this.cube, m4m.render.meshData.genBoxCCW(1.0), assetmgr.webgl);
                assetmgr.mapDefaultMesh[this.quad] = this.createDefaultMesh(this.quad, m4m.render.meshData.genQuad(1.0), assetmgr.webgl);
                assetmgr.mapDefaultMesh[this.quad_particle] = this.createDefaultMesh(this.quad_particle, m4m.render.meshData.genQuad_forparticle(1.0), assetmgr.webgl);
                assetmgr.mapDefaultMesh[this.plane] = this.createDefaultMesh(this.plane, m4m.render.meshData.genPlaneCCW(10), assetmgr.webgl);
                assetmgr.mapDefaultMesh[this.sphere] = this.createDefaultMesh(this.sphere, m4m.render.meshData.genSphereCCW(), assetmgr.webgl);
                assetmgr.mapDefaultMesh[this.sphere_quality] = this.createDefaultMesh(this.sphere_quality, m4m.render.meshData.genSphereCCW(2.58, 40, 40), assetmgr.webgl);
                assetmgr.mapDefaultMesh[this.pyramid] = this.createDefaultMesh(this.pyramid, m4m.render.meshData.genPyramid(2, 0.5), assetmgr.webgl);
                assetmgr.mapDefaultMesh[this.cylinder] = this.createDefaultMesh(this.cylinder, m4m.render.meshData.genCylinderCCW(2, 0.5), assetmgr.webgl);
                assetmgr.mapDefaultMesh[this.circleline] = this.createDefaultMesh(this.circleline, m4m.render.meshData.genCircleLineCCW(1), assetmgr.webgl);
            };
            defMesh.createDefaultMesh = function (name, meshData, webgl) {
                var _mesh = new m4m.framework.mesh(name + ".mesh.bin");
                _mesh.defaultAsset = true;
                _mesh.data = meshData;
                var vf = m4m.render.VertexFormatMask.Position | m4m.render.VertexFormatMask.Normal | m4m.render.VertexFormatMask.Tangent | m4m.render.VertexFormatMask.Color | m4m.render.VertexFormatMask.UV0;
                _mesh.data.originVF = vf;
                var v32 = _mesh.data.genVertexDataArray(vf);
                var i16 = _mesh.data.genIndexDataArray();
                _mesh.glMesh = new m4m.render.glMesh();
                _mesh.glMesh.initBuffer(webgl, vf, _mesh.data.getVertexCount());
                _mesh.glMesh.uploadVertexData(webgl, v32);
                _mesh.glMesh.addIndex(webgl, i16.length);
                _mesh.glMesh.uploadIndexData(webgl, 0, i16);
                _mesh.glMesh.initVAO();
                _mesh.submesh = [];
                {
                    var sm = new m4m.framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = i16.length;
                    sm.line = false;
                    _mesh.submesh.push(sm);
                }
                return _mesh;
            };
            defMesh.cube = "cube";
            defMesh.quad = "quad";
            defMesh.quad_particle = "quad_particle";
            defMesh.plane = "plane";
            defMesh.sphere = "sphere";
            defMesh.sphere_quality = "sphere_quality";
            defMesh.pyramid = "pyramid";
            defMesh.cylinder = "cylinder";
            defMesh.circleline = "circleline";
            return defMesh;
        }());
        framework.defMesh = defMesh;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var defShader = /** @class */ (function () {
            function defShader() {
            }
            defShader.initDefaultShader = function (assetmgr) {
                var pool = assetmgr.shaderPool;
                //鍙戠幇鏄簳灞備竴涓紩鐢ㄤ贡浜嗭紝鍘熺粨鏋勬病闂
                // pool.compileVS(assetmgr.webgl, "test", defShader.vscode_test);
                // pool.compileFS(assetmgr.webgl, "test", defShader.fscode_test);
                pool.compileVS(assetmgr.webgl, "def", defShader.vscode);
                pool.compileFS(assetmgr.webgl, "def", defShader.fscode);
                pool.compileFS(assetmgr.webgl, "def2", defShader.fscode2);
                pool.compileVS(assetmgr.webgl, "defui", defShader.vscodeUI);
                pool.compileFS(assetmgr.webgl, "defui", defShader.fscodeUI);
                pool.compileVS(assetmgr.webgl, "defuifont", defShader.vscodefontUI);
                pool.compileFS(assetmgr.webgl, "defuifont", defShader.fscodefontUI);
                pool.compileVS(assetmgr.webgl, "diffuse", defShader.vsdiffuse);
                pool.compileFS(assetmgr.webgl, "diffuse", defShader.fsdiffuse);
                pool.compileVS(assetmgr.webgl, "line", defShader.vsline);
                pool.compileFS(assetmgr.webgl, "line", defShader.fsline);
                pool.compileVS(assetmgr.webgl, "materialcolor", defShader.vsmaterialcolor);
                pool.compileVS(assetmgr.webgl, "defUIMaskVS", defShader.vscodeMaskUI);
                pool.compileFS(assetmgr.webgl, "defUIMaskFS", defShader.fscodeMaskUI);
                pool.compileVS(assetmgr.webgl, "defuifontMaskVS", defShader.vscodeuifontmask);
                pool.compileFS(assetmgr.webgl, "defuifontMaskFS", defShader.fscodeuifontmask);
                pool.compileVS(assetmgr.webgl, "deflinetrailVS", defShader.vslinetrail);
                pool.compileFS(assetmgr.webgl, "deflinetrailFS", defShader.fslinetrail);
                // var program_test = pool.linkProgram(assetmgr.webgl, "test", "test");
                var program = pool.linkProgram(assetmgr.webgl, "def", "def");
                var program2 = pool.linkProgram(assetmgr.webgl, "defui", "defui");
                var programuifont = pool.linkProgram(assetmgr.webgl, "defuifont", "defuifont");
                var programdiffuse = pool.linkProgram(assetmgr.webgl, "diffuse", "diffuse");
                var programline = pool.linkProgram(assetmgr.webgl, "line", "line");
                var programmaterialcolor = pool.linkProgram(assetmgr.webgl, "materialcolor", "line");
                var programMaskUI = pool.linkProgram(assetmgr.webgl, "defUIMaskVS", "defUIMaskFS");
                var programMaskfont = pool.linkProgram(assetmgr.webgl, "defuifontMaskVS", "defuifontMaskFS");
                var programlinetrail = pool.linkProgram(assetmgr.webgl, "deflinetrailVS", "deflinetrailFS");
                // {
                //     var sh = new shader("shader/test");
                //     sh.defaultAsset = true;
                //     sh.passes["base"] = [];
                //     var p = new render.glDrawPass();
                //     p.setProgram(program_test);
                //     sh.passes["base"].push(p);
                //     sh.fillUnDefUniform(p);
                //     //sh._parseProperties(assetmgr,JSON.parse(this.shader0).properties);
                //     p.state_ztest = true;
                //     p.state_ztest_method = render.webglkit.LEQUAL;
                //     p.state_zwrite = false;
                //     p.state_showface = render.ShowFaceStateEnum.ALL;
                //     p.setAlphaBlend(render.BlendModeEnum.Close);
                //     //p.uniformTexture("_MainTex", null);
                //     assetmgr.mapShader[sh.getName()] = sh;
                // }
                {
                    var sh = new framework.shader("shader/def");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new m4m.render.glDrawPass();
                    p.setProgram(program);
                    sh.passes["base"].push(p);
                    sh.fillUnDefUniform(p);
                    //sh._parseProperties(assetmgr,JSON.parse(this.shader0).properties);
                    p.state_ztest = true;
                    p.state_ztest_method = m4m.render.webglkit.LEQUAL;
                    p.state_zwrite = true;
                    p.state_showface = m4m.render.ShowFaceStateEnum.CCW;
                    p.setAlphaBlend(m4m.render.BlendModeEnum.Close);
                    //p.uniformTexture("_MainTex", null);
                    assetmgr.mapShader[sh.getName()] = sh;
                }
                {
                    var sh = new framework.shader("shader/def3dbeforeui");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new m4m.render.glDrawPass();
                    p.setProgram(programdiffuse);
                    sh.passes["base"].push(p);
                    sh.fillUnDefUniform(p);
                    //sh._parseProperties(assetmgr,JSON.parse(this.diffuseShader).properties);
                    p.state_ztest = false;
                    p.state_ztest_method = m4m.render.webglkit.LEQUAL;
                    p.state_zwrite = false;
                    p.state_showface = m4m.render.ShowFaceStateEnum.CCW;
                    p.setAlphaBlend(m4m.render.BlendModeEnum.Close);
                    //p.uniformTexture("_MainTex", null);
                    assetmgr.mapShader[sh.getName()] = sh;
                }
                {
                    var sh = new framework.shader("shader/def2");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new m4m.render.glDrawPass();
                    p.setProgram(program2);
                    sh.passes["base"].push(p);
                    sh.fillUnDefUniform(p);
                    //sh._parseProperties(assetmgr,JSON.parse(this.uishader).properties);
                    p.state_showface = m4m.render.ShowFaceStateEnum.ALL;
                    p.state_ztest = false;
                    p.state_ztest_method = m4m.render.webglkit.LEQUAL;
                    p.setAlphaBlend(m4m.render.BlendModeEnum.Close);
                    assetmgr.mapShader[sh.getName()] = sh;
                }
                {
                    var sh = new framework.shader("shader/defui");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new m4m.render.glDrawPass();
                    p.setProgram(program2);
                    sh.passes["base"].push(p);
                    sh.fillUnDefUniform(p);
                    sh._parseProperties(assetmgr, JSON.parse(this.uishader).properties);
                    p.state_showface = m4m.render.ShowFaceStateEnum.ALL;
                    p.state_ztest = false;
                    p.state_zwrite = false;
                    p.state_ztest_method = m4m.render.webglkit.LEQUAL;
                    p.setAlphaBlend(m4m.render.BlendModeEnum.Blend);
                    assetmgr.mapShader[sh.getName()] = sh;
                }
                {
                    var sh = new framework.shader("shader/defuifont");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new m4m.render.glDrawPass();
                    p.setProgram(programuifont);
                    sh.passes["base"].push(p);
                    sh.fillUnDefUniform(p);
                    // sh._parseProperties(assetmgr, JSON.parse(this.shaderuifront).properties);
                    p.state_showface = m4m.render.ShowFaceStateEnum.ALL;
                    p.state_ztest = false;
                    p.state_zwrite = false;
                    p.state_ztest_method = m4m.render.webglkit.LEQUAL;
                    p.setAlphaBlend(m4m.render.BlendModeEnum.Blend);
                    assetmgr.mapShader[sh.getName()] = sh;
                }
                {
                    var sh = new framework.shader("shader/line");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new m4m.render.glDrawPass();
                    sh.passes["base"].push(p);
                    p.setProgram(programline);
                    sh.fillUnDefUniform(p);
                    p.state_ztest = true;
                    p.state_ztest_method = m4m.render.webglkit.LEQUAL;
                    p.state_zwrite = true;
                    p.state_showface = m4m.render.ShowFaceStateEnum.ALL;
                    p.setAlphaBlend(m4m.render.BlendModeEnum.Close);
                    assetmgr.mapShader[sh.getName()] = sh;
                }
                {
                    var sh = new framework.shader("shader/materialcolor");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new m4m.render.glDrawPass();
                    sh.passes["base"].push(p);
                    //sh._parseProperties(assetmgr,JSON.parse(this.materialShader).properties);
                    p.setProgram(programmaterialcolor);
                    sh.fillUnDefUniform(p);
                    p.state_ztest = false;
                    //p.state_ztest_method = render.webglkit.LEQUAL;
                    //p.state_zwrite = true;
                    p.state_showface = m4m.render.ShowFaceStateEnum.ALL;
                    p.setAlphaBlend(m4m.render.BlendModeEnum.Blend);
                    sh.layer = framework.RenderLayerEnum.Overlay;
                    assetmgr.mapShader[sh.getName()] = sh;
                }
                {
                    var sh = new framework.shader("shader/defmaskui");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new m4m.render.glDrawPass();
                    sh.passes["base"].push(p);
                    sh._parseProperties(assetmgr, JSON.parse(this.uishader).properties);
                    p.setProgram(programMaskUI);
                    sh.fillUnDefUniform(p);
                    p.state_showface = m4m.render.ShowFaceStateEnum.ALL;
                    p.state_ztest = false;
                    p.state_zwrite = false;
                    p.state_ztest_method = m4m.render.webglkit.LEQUAL;
                    p.setAlphaBlend(m4m.render.BlendModeEnum.Blend);
                    assetmgr.mapShader[sh.getName()] = sh;
                }
                {
                    var sh = new framework.shader("shader/defmaskfont");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new m4m.render.glDrawPass();
                    sh.passes["base"].push(p);
                    sh._parseProperties(assetmgr, JSON.parse(this.shaderuifront).properties);
                    p.setProgram(programMaskfont);
                    sh.fillUnDefUniform(p);
                    p.state_showface = m4m.render.ShowFaceStateEnum.ALL;
                    p.state_ztest = false;
                    p.state_zwrite = false;
                    p.state_ztest_method = m4m.render.webglkit.LEQUAL;
                    p.setAlphaBlend(m4m.render.BlendModeEnum.Blend);
                    assetmgr.mapShader[sh.getName()] = sh;
                }
                {
                    var sh = new framework.shader("shader/deflinetrail");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new m4m.render.glDrawPass();
                    sh.passes["base"].push(p);
                    sh._parseProperties(assetmgr, JSON.parse(this.linetrailShader).properties);
                    p.setProgram(programlinetrail);
                    sh.fillUnDefUniform(p);
                    p.state_showface = m4m.render.ShowFaceStateEnum.ALL;
                    p.state_ztest = false;
                    p.state_zwrite = false;
                    p.state_ztest_method = m4m.render.webglkit.LEQUAL;
                    p.setAlphaBlend(m4m.render.BlendModeEnum.Blend);
                    assetmgr.mapShader[sh.getName()] = sh;
                }
                {
                    var sh = new framework.shader("shader/ulit");
                    sh.defaultAsset = true;
                    sh.passes["base"] = [];
                    var p = new m4m.render.glDrawPass();
                    sh.passes["base"].push(p);
                    p.setProgram(programdiffuse);
                    sh.fillUnDefUniform(p);
                    p.state_ztest = true;
                    p.state_zwrite = true;
                    p.state_showface = m4m.render.ShowFaceStateEnum.ALL;
                    sh.layer = framework.RenderLayerEnum.Common;
                    assetmgr.mapShader[sh.getName()] = sh;
                }
            };
            defShader.vscode = "#version 300 es\n            precision mediump float;\n\n            layout(location = 0) in vec3 _glesVertex;\n            layout(location = 3) in vec4 _glesColor;\n            layout(location = 4) in vec4 _glesMultiTexCoord0;\n            uniform highp mat4 glstate_matrix_mvp;\n            out lowp vec4 xlv_COLOR;\n            out highp vec2 xlv_TEXCOORD0;\n            void main()\n            {\n                highp vec4 tmpvar_1;\n                tmpvar_1.w = 1.0;\n                tmpvar_1.xyz = _glesVertex.xyz;\n                xlv_COLOR = _glesColor;\n                xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;\n                gl_Position = (glstate_matrix_mvp * tmpvar_1);\n            }\n        ";
            defShader.fscode = "#version 300 es\n            precision mediump float;\n\n            uniform sampler2D _MainTex;\n            in lowp vec4 xlv_COLOR;\n            in highp vec2 xlv_TEXCOORD0;\n            out vec4 color;\n            void main()\n            {\n                lowp vec4 col_1;\n                mediump vec4 prev_2;\n                lowp vec4 tmpvar_3;\n                tmpvar_3 = (xlv_COLOR * texture(_MainTex, xlv_TEXCOORD0));\n                prev_2 = tmpvar_3;\n                mediump vec4 tmpvar_4;\n                tmpvar_4 = mix(vec4(1.0, 1.0, 1.0, 1.0), prev_2, prev_2.wwww);\n                col_1 = tmpvar_4;\n                col_1.x =xlv_TEXCOORD0.x;\n                col_1.y =xlv_TEXCOORD0.y;\n                color = col_1;\n            }\n        ";
            defShader.fscode2 = "#version 300 es\n            precision mediump float;\n\n            out vec4 color;\n            void main()\n            {\n                color = vec4(1.0, 1.0, 1.0, 1.0);\n            }\n        ";
            //----------------------------------------UI-------------------------
            defShader.uishader = "{\n                \"properties\": [\n                \"_MainTex('MainTex',Texture)='white'{}\",\n                \"_MaskTex('MaskTex',Texture)='white'{}\"\n                ]\n            }\n        ";
            defShader.fscodeUI = "#version 300 es\n            precision mediump float;\n\n            uniform sampler2D _MainTex;\n            in lowp vec4 xlv_COLOR;\n            in highp vec2 xlv_TEXCOORD0;\n            out vec4 color;\n            void main()\n            {\n                lowp vec4 tmpvar_3;\n                tmpvar_3 = (xlv_COLOR * texture(_MainTex, xlv_TEXCOORD0));\n                color = tmpvar_3;\n            }\n            ";
            defShader.vscodeUI = "#version 300 es\n            precision mediump float;\n\n            layout(location = 0) in vec3 _glesVertex;    \n            layout(location = 3) in vec4 _glesColor;                   \n            layout(location = 4) in vec4 _glesMultiTexCoord0;          \n            uniform highp mat4 glstate_matrix_mvp;       \n            out lowp vec4 xlv_COLOR;                 \n            out highp vec2 xlv_TEXCOORD0;            \n            void main()                                      \n            {                                                \n                highp vec4 tmpvar_1;                         \n                tmpvar_1.w = 1.0;                            \n                tmpvar_1.xyz = _glesVertex.xyz;              \n                xlv_COLOR = _glesColor;                      \n                xlv_TEXCOORD0 = vec2(_glesMultiTexCoord0.x,1.0-_glesMultiTexCoord0.y);      \n                gl_Position = (glstate_matrix_mvp * tmpvar_1);   \n            }\n        ";
            defShader.vscodeMaskUI = "#version 300 es\n            precision mediump float;\n\n            layout(location = 0) in vec3 _glesVertex;    \n            layout(location = 3) in vec4 _glesColor;                   \n            layout(location = 4) in vec4 _glesMultiTexCoord0;          \n            uniform highp mat4 glstate_matrix_mvp;       \n            out lowp vec4 xlv_COLOR;                 \n            out highp vec2 xlv_TEXCOORD0;            \n            out highp vec2 mask_TEXCOORD;            \n            void main()                                      \n            {                                                \n                highp vec4 tmpvar_1;                         \n                tmpvar_1.w = 1.0;                            \n                tmpvar_1.xyz = _glesVertex.xyz;              \n                xlv_COLOR = _glesColor;                      \n                xlv_TEXCOORD0 = vec2(_glesMultiTexCoord0.x,1.0-_glesMultiTexCoord0.y);      \n                mask_TEXCOORD.x = (_glesVertex.x - 1.0)/-2.0; \n                mask_TEXCOORD.y = (_glesVertex.y - 1.0)/-2.0; \n                gl_Position = (glstate_matrix_mvp * tmpvar_1);   \n            }\n        ";
            defShader.fscodeMaskUI = "#version 300 es\n            precision mediump float;\n\n            uniform sampler2D _MainTex;                                                  \n            uniform highp vec4 _maskRect;                                                  \n            in lowp vec4 xlv_COLOR;                                                  \n            in highp vec2 xlv_TEXCOORD0;    \n            in highp vec2 mask_TEXCOORD;            \n            bool CalcuCut(){    \n                highp float l; \n                highp float t; \n                highp float r; \n                highp float b; \n                highp vec2 texc1; \n                bool beCut; \n                l = _maskRect.x; \n                t = _maskRect.y; \n                r = _maskRect.z + l; \n                b = _maskRect.w + t; \n                texc1 = mask_TEXCOORD; \n                if(texc1.x >(1.0 - l) || texc1.x <(1.0 - r) || texc1.y <t || texc1.y>b){  \n                    beCut = true;  \n                }else{ \n                    beCut = false; \n                } \n                return beCut; \n            } \n                \n            out vec4 color;\n            void main()  \n            { \n                if(CalcuCut()) discard; \n                lowp vec4 tmpvar_3; \n                tmpvar_3 = (xlv_COLOR * texture(_MainTex, xlv_TEXCOORD0)); \n                color = tmpvar_3 ; \n            } \n        ";
            defShader.shaderuifront = "{\n                \"properties\": [\n                \"_MainTex('MainTex',Texture)='white'{}\"\n                ]\n            }";
            defShader.vscodefontUI = "#version 300 es\n            precision mediump float;\n\n            layout(location = 0) in vec3 _glesVertex;    \n            layout(location = 3) in vec4 _glesColor;                   \n            layout(location = 8) in vec4 _glesColorEx;                   \n            layout(location = 4) in vec4 _glesMultiTexCoord0;          \n            uniform highp mat4 glstate_matrix_mvp;       \n            out lowp vec4 xlv_COLOR;                 \n            out lowp vec4 xlv_COLOREx;                                                  \n            out highp vec2 xlv_TEXCOORD0;            \n            void main()                                      \n            {                                                \n                highp vec4 tmpvar_1;                         \n                tmpvar_1.w = 1.0;                            \n                tmpvar_1.xyz = _glesVertex.xyz;              \n                xlv_COLOR = _glesColor;                      \n                xlv_COLOREx = _glesColorEx;                      \n                xlv_TEXCOORD0 = vec2(_glesMultiTexCoord0.x,1.0-_glesMultiTexCoord0.y);      \n                gl_Position = (glstate_matrix_mvp * tmpvar_1);   \n            }\n        ";
            // 根据 https://zhuanlan.zhihu.com/p/26217154 文章进行修改的shader
            defShader.fscodefontUI = "#version 300 es\n            precision mediump float ; \n            uniform sampler2D _MainTex; \n\n            uniform highp float _outlineWidth; // \u63CF\u8FB9\u5BBD\u5EA6\n\n            in lowp vec4 xlv_COLOR; // \u5B57\u4F53\u989C\u8272\n            in lowp vec4 xlv_COLOREx; // \u63CF\u8FB9\u989C\u8272\n            in highp vec2 xlv_TEXCOORD0;     \n            out vec4 color;\n            void main()   \n            {  \n                // \u5728m4m\u4E2D\u4F7F\u7528\u7684sdf\u5B57\u4F53\u505A\u4E86\u6700\u5927\u503C\u4E3A2\u50CF\u7D20\u7684\u6709\u5411\u8DDD\u79BB\u8FD0\u7B97\u4E14\u4FDD\u5B58\u5230\u4F4D\u56FE\u4E0A\u3002\n                // \u989C\u8272\u503C[0,255]\u5BF9\u4E8E\u533A\u95F4[-2,2]\u3002\n                // \u989C\u8272\u503Cv\u8868\u793A\u8DDD\u79BB\u5B57\u7B26\u8FB9\u7F18\u6709 (v/255*4-2) \u5355\u4F4D\u8DDD\u79BB\u3002\u5355\u4F4D\u8DDD\u79BB\u4E3A\u6B63\u8868\u793A\u5728\u5B57\u7B26\u5185\uFF0C\u5426\u5219\u5728\u5B57\u7B26\u5916\u3002\n                \n                float _DistanceMark = 0.0; // \u8DDD\u79BB\u4E3A 0 \u5904\u662F\u5B57\u7B26\u8FB9\u7F18\n                float _SmoothDelta = 0.5; // \u5728\u5B57\u7B26\u8FB9\u7F18 0.5 \u50CF\u7D20\u8FDB\u884C\u63D2\u503C \n\n                float _OutlineDistanceMark = -_outlineWidth; // \u63CF\u8FB9\u4F4D\u7F6E\n\n                vec4 col = texture(_MainTex, xlv_TEXCOORD0);\n                float distance = col.r * 4.0 - 2.0;\n\n                // \u5E73\u6ED1\u5B57\u4F53\u8FB9\u7F18\n                col.a = smoothstep(_DistanceMark - _SmoothDelta, _DistanceMark + _SmoothDelta, distance);\n                // \u4E0D\u5E73\u6ED1 \u76F8\u5F53\u4E8E _SmoothDelta = 0\n                // if (distance < _DistanceMark)\n                //     col.a = 0.0;\n                // else\n                //     col.a = 1.0;\n\n                col.rgb = xlv_COLOR.rgb;\n            \n                // Outlining \u63CF\u8FB9\n                vec4 outlineCol = vec4(1.0,1.0,1.0,1.0);\n\n                outlineCol.a = smoothstep(_OutlineDistanceMark - _outlineWidth, _OutlineDistanceMark + _outlineWidth, distance);\n                outlineCol.rgb = xlv_COLOREx.rgb;\n                outlineCol.a = outlineCol.a * xlv_COLOREx.a;\n                \n                // \u6DF7\u5408\u5B57\u4F53\u4E0E\u63CF\u8FB9\u989C\u8272\n                col = mix(outlineCol, col, col.a);\n\n                col.a = col.a * xlv_COLOR.a;\n                \n                // \u8BBE\u7F6E\u6700\u7EC8\u503C\n                color = col;\n        }";
            defShader.vscodeuifontmask = "#version 300 es\n            precision mediump float;\n\n            layout(location = 0) in vec3 _glesVertex;    \n            layout(location = 3) in vec4 _glesColor;                   \n            layout(location = 8) in vec4 _glesColorEx;                   \n            layout(location = 4) in vec4 _glesMultiTexCoord0;          \n            uniform highp mat4 glstate_matrix_mvp;       \n            out lowp vec4 xlv_COLOR;                 \n            out lowp vec4 xlv_COLOREx;                                                  \n            out highp vec2 xlv_TEXCOORD0;            \n            out highp vec2 mask_TEXCOORD;            \n            void main()                                      \n            {                                                \n                highp vec4 tmpvar_1;                         \n                tmpvar_1.w = 1.0;                            \n                tmpvar_1.xyz = _glesVertex.xyz;              \n                xlv_COLOR = _glesColor;                      \n                xlv_COLOREx = _glesColorEx;                      \n                xlv_TEXCOORD0 = vec2(_glesMultiTexCoord0.x,1.0-_glesMultiTexCoord0.y);      \n                mask_TEXCOORD.x = (_glesVertex.x - 1.0)/-2.0; \n                mask_TEXCOORD.y = (_glesVertex.y - 1.0)/-2.0; \n                gl_Position = (glstate_matrix_mvp * tmpvar_1);   \n            }";
            defShader.fscodeuifontmask = "#version 300 es\n            precision mediump float; \n            uniform sampler2D _MainTex;   \n            uniform highp vec4 _maskRect;        \n            in lowp vec4 xlv_COLOR;  \n            in lowp vec4 xlv_COLOREx;  \n            in highp vec2 xlv_TEXCOORD0;     \n            in highp vec2 mask_TEXCOORD;      \n            bool CalcuCut(){    \n                highp float l; \n                highp float t; \n                highp float r; \n                highp float b; \n                highp vec2 texc1; \n                bool beCut; \n                l = _maskRect.x; \n                t = _maskRect.y; \n                r = _maskRect.z + l; \n                b = _maskRect.w + t; \n                texc1 = mask_TEXCOORD; \n                if(texc1.x >(1.0 - l) || texc1.x <(1.0 - r) || texc1.y <t || texc1.y>b){  \n                    beCut = true;  \n                }else{ \n                    beCut = false; \n                } \n                return beCut; \n            } \n             \n            out vec4 color;\n            void main()   \n            {  \n                if(CalcuCut())  discard; \n                float scale = 10.0;    \n                float d = (texture(_MainTex, xlv_TEXCOORD0).r - 0.47)*scale;   \n                float bd = (texture(_MainTex, xlv_TEXCOORD0).r - 0.4)*scale;   \n                \n                float c=xlv_COLOR.a * clamp ( d,0.0,1.0);   \n                float bc=xlv_COLOREx.a * clamp ( bd,0.0,1.0);   \n                bc =min(1.0-c,bc);  \n                lowp vec4 final =  xlv_COLOR*c + xlv_COLOREx*bc ; \n                color = final ; \n            }";
            defShader.vsdiffuse = "#version 300 es\n            precision mediump float;\n\n            layout(location = 0) in vec3 _glesVertex;\n            layout(location = 4) in vec4 _glesMultiTexCoord0;\n            uniform highp mat4 glstate_matrix_mvp;\n            out highp vec2 xlv_TEXCOORD0;\n            void main()\n            {\n                highp vec4 tmpvar_1;\n                tmpvar_1.w = 1.0;\n                tmpvar_1.xyz = _glesVertex.xyz;\n                xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;\n                gl_Position = (glstate_matrix_mvp * tmpvar_1);\n            }\n        ";
            defShader.fsdiffuse = "#version 300 es\n            precision mediump float;\n\n            uniform sampler2D _MainTex;\n            uniform vec4 _MainColor;\n            uniform lowp float _AlphaCut;\n            in highp vec2 xlv_TEXCOORD0;\n            out vec4 color;\n            void main()\n            {\n                lowp vec4 _color = texture(_MainTex, xlv_TEXCOORD0) * _MainColor;\n                if(_color.a < _AlphaCut)\n                    discard;\n                color = _color;\n            }\n        ";
            //editor
            defShader.vsline = "#version 300 es\n            precision mediump float;\n\n            layout(location = 0) in vec3 _glesVertex;\n            layout(location = 3) in vec4 _glesColor;\n            uniform highp mat4 glstate_matrix_mvp;\n            out lowp vec4 xlv_COLOR;\n            void main()\n            {\n                highp vec4 tmpvar_1;\n                tmpvar_1.w = 1.0;\n                tmpvar_1.xyz = _glesVertex.xyz;\n                xlv_COLOR = _glesColor;\n                gl_Position = (glstate_matrix_mvp * tmpvar_1);\n            }\n        ";
            defShader.fsline = "#version 300 es\n            precision mediump float;\n\n            in lowp vec4 xlv_COLOR;\n            out vec4 color;\n            void main()\n            {\n                color = xlv_COLOR;\n            }\n        ";
            defShader.vsmaterialcolor = "#version 300 es\n            precision mediump float;\n\n            layout(location = 0) in vec3 _glesVertex;\n            uniform vec4 _Color;\n            uniform float _Alpha;\n            uniform highp mat4 glstate_matrix_mvp;\n            out lowp vec4 xlv_COLOR;\n            void main()\n            {\n                highp vec4 tmpvar_1;\n                tmpvar_1.w = 1.0;\n                tmpvar_1.xyz = _glesVertex.xyz;\n                xlv_COLOR = _Color;\n                xlv_COLOR.a = xlv_COLOR.a * _Alpha;\n                gl_Position = (glstate_matrix_mvp * tmpvar_1);\n            }\n        ";
            defShader.vslinetrail = "#version 300 es\n            precision mediump float;\n            layout(location = 0) in vec3 _glesVertex;\n            layout(location = 4) in vec4 _glesMultiTexCoord0;\n            layout(location = 3) in vec4 _glesColor;\n            \n            uniform mat4 glstate_matrix_mvp;\n            \n            out vec2 xlv_TEXCOORD0;\n            out vec4 xlv_COLOR;\n            \n            void main() \n            {\n                gl_Position = glstate_matrix_mvp * vec4(_glesVertex , 1.0);\n                xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;\n                xlv_COLOR = _glesColor;\n            }\n        ";
            defShader.linetrailShader = "{\n                \"properties\": [\n                \"_MainTex('MainTex',Texture)='white'{}\"\n                ]\n            }\n            ";
            defShader.fslinetrail = "#version 300 es\n            precision mediump float;\n\n            uniform sampler2D _MainTex; \n            \n            in vec2 xlv_TEXCOORD0;\n            in vec4 xlv_COLOR;\n            \n            out vec4 color;\n            void main() \n            {\n                vec4 color = texture(_MainTex, xlv_TEXCOORD0);\n                color = color * xlv_COLOR;\n            }\n        ";
            return defShader;
        }());
        framework.defShader = defShader;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var defsprite = /** @class */ (function () {
            function defsprite() {
            }
            defsprite.initDefaultSprite = function (assetmgr) {
                var spt_white = new framework.sprite(this.white_sprite);
                spt_white.texture = assetmgr.getDefaultTexture("white");
                spt_white.defaultAsset = true;
                spt_white.rect = new m4m.math.rect(0, 0, spt_white.texture.glTexture.width, spt_white.texture.glTexture.height);
                assetmgr.mapDefaultSprite[this.white_sprite] = spt_white;
                var spt_gray = new framework.sprite(this.gray_sprite);
                spt_gray.texture = assetmgr.getDefaultTexture("gray");
                spt_gray.defaultAsset = true;
                spt_gray.rect = new m4m.math.rect(0, 0, spt_gray.texture.glTexture.width, spt_gray.texture.glTexture.height);
                assetmgr.mapDefaultSprite[this.gray_sprite] = spt_gray;
                var spt_grid = new framework.sprite(this.grid_sprite);
                spt_grid.texture = assetmgr.getDefaultTexture("grid");
                spt_grid.defaultAsset = true;
                spt_grid.rect = new m4m.math.rect(0, 0, spt_grid.texture.glTexture.width, spt_grid.texture.glTexture.height);
                assetmgr.mapDefaultSprite[this.grid_sprite] = spt_grid;
            };
            defsprite.white_sprite = "white_sprite";
            defsprite.gray_sprite = "gray_sprite";
            defsprite.grid_sprite = "grid_sprite";
            return defsprite;
        }());
        framework.defsprite = defsprite;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var defTexture = /** @class */ (function () {
            function defTexture() {
            }
            defTexture.initDefaultTexture = function (assetmgr) {
                var t = new framework.texture(this.white);
                t.glTexture = m4m.render.glTexture2D.staticTexture(assetmgr.webgl, this.white);
                t.defaultAsset = true;
                assetmgr.mapDefaultTexture[this.white] = t;
                var t = new framework.texture(this.black);
                t.glTexture = m4m.render.glTexture2D.staticTexture(assetmgr.webgl, this.black);
                t.defaultAsset = true;
                assetmgr.mapDefaultTexture[this.black] = t;
                var t = new framework.texture(this.gray);
                t.glTexture = m4m.render.glTexture2D.staticTexture(assetmgr.webgl, this.gray);
                t.defaultAsset = true;
                assetmgr.mapDefaultTexture[this.gray] = t;
                var t = new framework.texture(this.normal);
                t.glTexture = m4m.render.glTexture2D.staticTexture(assetmgr.webgl, this.normal);
                t.defaultAsset = true;
                assetmgr.mapDefaultTexture[this.normal] = t;
                var t = new framework.texture(this.grid);
                t.glTexture = m4m.render.glTexture2D.staticTexture(assetmgr.webgl, this.grid);
                t.defaultAsset = true;
                assetmgr.mapDefaultTexture[this.grid] = t;
                var t = new framework.texture(this.particle);
                t.glTexture = m4m.render.glTexture2D.particleTexture(assetmgr.webgl);
                t.defaultAsset = true;
                assetmgr.mapDefaultTexture[this.particle] = t;
                //must in end
                defTexture.initDefaultCubeTexture(assetmgr);
            };
            defTexture.initDefaultCubeTexture = function (assetmgr) {
                var whiteTex = assetmgr.mapDefaultTexture[this.white];
                var t = new framework.texture(this.white);
                t.glTexture = new m4m.render.glTextureCube(assetmgr.app.webgl);
                t.glTexture.uploadImages(whiteTex, whiteTex, whiteTex, whiteTex, whiteTex, whiteTex);
                t.defaultAsset = true;
                assetmgr.mapDefaultCubeTexture[this.white] = t;
            };
            defTexture.white = "white";
            defTexture.black = "black";
            defTexture.gray = "gray";
            defTexture.normal = "normal";
            defTexture.grid = "grid";
            defTexture.particle = "particle";
            return defTexture;
        }());
        framework.defTexture = defTexture;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var AssetFactory_Aniclip = /** @class */ (function () {
            function AssetFactory_Aniclip() {
            }
            //#region 废弃de参考代码
            /*
            newAsset(): animationClip
            {
                return null;
            }
    
            load(url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset: animationClip, call: (handle: () => void) => void)
            {
                let filename = getFileName(url);
    
                state.resstate[filename] = new ResourceState();
                if(state.resstateFirst==null)
                {
                    state.resstateFirst=state.resstate[filename];
                }
                m4m.io.loadArrayBuffer(url,
                    (_buffer, err, isloadFail) =>
                    {
    
                        call(() =>
                        {
                            state.isloadFail = isloadFail ? true : false;
                            if (AssetFactoryTools.catchError(err, onstate, state))
                                return;
                            let time = Date.now();
                            let _clip = asset ? asset : new animationClip(filename);
                            // _clip.Parse(_buffer);
    
                            // AssetFactoryTools.useAsset(assetMgr, onstate, state, _clip, url);
                            return _clip.Parse(_buffer).then(() =>
                            {
                                let calc = Date.now() - time;
                                console.log(`[animiclip]解析:${url}  耗时:${calc}/ms`);
                                AssetFactoryTools.useAsset(assetMgr, onstate, state, _clip, url);
                            });
                        });
    
                    },
                    (loadedLength, totalLength) =>
                    {
                        AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                    })
            }
    
            loadByPack(respack, url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset: animationClip, call: (handle: () => void) => void)
            {
                let filename = getFileName(url);
    
                state.resstate[filename] = new ResourceState();
                if(state.resstateFirst==null)
                {
                    state.resstateFirst=state.resstate[filename];
                }
                let time = Date.now();
                let _buffer = respack[filename];
                let _clip = asset ? asset : new animationClip(filename);
                // _clip.Parse(_buffer);
    
                // AssetFactoryTools.useAsset(assetMgr, onstate, state, _clip, url);
                call(() =>
                {
                   return _clip.Parse(_buffer).then(() =>
                    {
                        let calc = Date.now() - time;
                        console.log(`[animiclip]解析:${url}  耗时:${calc}/ms`);
                        AssetFactoryTools.useAsset(assetMgr, onstate, state, _clip, url);
                    });
                });
            }
            */
            //#endregion
            AssetFactory_Aniclip.prototype.parse = function (assetmgr, bundle, filename, bytes) {
                return new framework.animationClip(filename).Parse(bytes);
            };
            AssetFactory_Aniclip = __decorate([
                framework.assetF(framework.AssetTypeEnum.Aniclip)
            ], AssetFactory_Aniclip);
            return AssetFactory_Aniclip;
        }());
        framework.AssetFactory_Aniclip = AssetFactory_Aniclip;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var AssetFactory_ASTC = /** @class */ (function () {
            function AssetFactory_ASTC() {
            }
            AssetFactory_ASTC.prototype.parse = function (assetmgr, bundle, name, bytes, dwguid) {
                var _texture = new framework.texture(name);
                _texture.glTexture = framework.ASTCParse.parse(assetmgr.webgl, bytes);
                return _texture;
            };
            AssetFactory_ASTC = __decorate([
                framework.assetF(framework.AssetTypeEnum.ASTC)
            ], AssetFactory_ASTC);
            return AssetFactory_ASTC;
        }());
        framework.AssetFactory_ASTC = AssetFactory_ASTC;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var AssetFactory_Atlas = /** @class */ (function () {
            function AssetFactory_Atlas() {
            }
            //#region 废弃de参考代码
            /*
            newAsset(): atlas
            {
                return null;
            }
    
            load(url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset: atlas, call: (handle: () => void) => void)
            {
                let filename = getFileName(url);
    
                state.resstate[filename] = new ResourceState();
                if(state.resstateFirst==null)
                {
                    state.resstateFirst=state.resstate[filename];
                }
                m4m.io.loadText(url, (txt, err, isloadFail) =>
                {
                    call(() =>
                    {
                        state.isloadFail = isloadFail ? true : false;
                        if (AssetFactoryTools.catchError(err, onstate, state))
                            return;
    
                        let _atlas = asset ? asset : new atlas(filename);
                        _atlas.Parse(txt, assetMgr);
    
                        AssetFactoryTools.useAsset(assetMgr, onstate, state, _atlas, url);
                    });
                },
                    (loadedLength, totalLength) =>
                    {
                        AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                    })
            }
    
            loadByPack(respack: any, url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset: atlas, call: (handle: () => void) => void)
            {
                call(() =>
                {
                    let filename = getFileName(url);
                    state.resstate[filename] = new ResourceState();
                    if(state.resstateFirst==null)
                    {
                        state.resstateFirst=state.resstate[filename];
                    }
                    let txt = respack[filename];
                    let _atlas = asset ? asset : new atlas(filename);
                    _atlas.Parse(txt, assetMgr);
    
                    AssetFactoryTools.useAsset(assetMgr, onstate, state, _atlas, url);
                });
            }*/
            //#endregion
            AssetFactory_Atlas.prototype.parse = function (assetmgr, bundle, filename, txt) {
                var bName = bundle ? bundle.name : null;
                return new framework.atlas(filename).Parse(txt, assetmgr, bName);
            };
            AssetFactory_Atlas = __decorate([
                framework.assetF(framework.AssetTypeEnum.Atlas)
            ], AssetFactory_Atlas);
            return AssetFactory_Atlas;
        }());
        framework.AssetFactory_Atlas = AssetFactory_Atlas;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var AssetFactory_BIN = /** @class */ (function () {
            function AssetFactory_BIN() {
            }
            AssetFactory_BIN.prototype.parse = function (assetmgr, bundle, name, bytes) {
                return new framework.bin(name, bytes);
            };
            AssetFactory_BIN = __decorate([
                framework.assetF(framework.AssetTypeEnum.BIN)
            ], AssetFactory_BIN);
            return AssetFactory_BIN;
        }());
        framework.AssetFactory_BIN = AssetFactory_BIN;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var AssetFactory_cPrefab = /** @class */ (function () {
            function AssetFactory_cPrefab() {
            }
            //#region 废弃de参考代码
            // newAsset(): prefab
            // {
            //     return null;
            // }
            // load(url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset: prefab, call: (handle: () => void) => void)
            // {
            //     let bundlename = getFileName(state.url);
            //     let filename = getFileName(url);
            //     filename = filename.replace("cprefab", "prefab");
            //     state.resstate[filename] = new ResourceState();
            //     if (state.resstateFirst == null)
            //     {
            //         state.resstateFirst = state.resstate[filename];
            //     }
            //     m4m.io.loadJSON(url, (json, err, isloadFail) =>
            //     {
            //         call(() =>
            //         {
            //             state.isloadFail = isloadFail ? true : false;
            //             if (AssetFactoryTools.catchError(err, onstate, state))
            //                 return;
            //             let _prefab = asset ? asset : new prefab(filename);
            //             _prefab.assetbundle = bundlename;
            //             // _prefab.Parse(txt, assetMgr);
            //             // AssetFactoryTools.useAsset(assetMgr, onstate, state, _prefab, url);
            //             _prefab.cParse(json);
            //             AssetFactoryTools.useAsset(assetMgr, onstate, state, _prefab, url.replace("cprefab", "prefab"));
            //         });
            //         // AssetFactoryTools.useAsset(assetMgr, onstate, state, _prefab, url);
            //     },
            //         (loadedLength, totalLength) =>
            //         {
            //             AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
            //         })
            // }
            // loadByPack(respack: any, url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset: prefab, call: (handle: () => void) => void)
            // {
            //     call(() =>
            //     {
            //         let bundlename = getFileName(state.url);
            //         let filename = getFileName(url);
            //         let oldName = filename;
            //         filename = filename.replace("cprefab", "prefab");
            //         state.resstate[filename] = new ResourceState();
            //         if (state.resstateFirst == null)
            //         {
            //             state.resstateFirst = state.resstate[filename];
            //         }
            //         let txt = respack[oldName];
            //         let _prefab = asset ? asset : new prefab(filename);
            //         _prefab.assetbundle = bundlename;
            //         return io.JSONParse(txt).then((json) =>
            //         {
            //             _prefab.cParse(json);
            //             AssetFactoryTools.useAsset(assetMgr, onstate, state, _prefab, url.replace("cprefab", "prefab"));
            //         });
            //         // await _prefab.Parse(txt, assetMgr);
            //         // AssetFactoryTools.useAsset(assetMgr, onstate, state, _prefab, url);
            //     });
            // }
            //#endregion
            AssetFactory_cPrefab.prototype.parse = function (assetmgr, bundle, filename, txt) {
                var asset = new framework.prefab(filename);
                asset.assetbundle = bundle.name;
                asset.cParse(JSON.parse(txt));
                return asset;
            };
            AssetFactory_cPrefab = __decorate([
                framework.assetF(framework.AssetTypeEnum.cPrefab)
            ], AssetFactory_cPrefab);
            return AssetFactory_cPrefab;
        }());
        framework.AssetFactory_cPrefab = AssetFactory_cPrefab;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var AssetFactory_DDS = /** @class */ (function () {
            function AssetFactory_DDS() {
            }
            AssetFactory_DDS.prototype.parse = function (assetmgr, bundle, name, bytes) {
                var _texture = new framework.texture(name);
                _texture.glTexture = framework.S3TCParse.parse(assetmgr.webgl, bytes);
                return _texture;
            };
            AssetFactory_DDS = __decorate([
                framework.assetF(framework.AssetTypeEnum.DDS)
            ], AssetFactory_DDS);
            return AssetFactory_DDS;
        }());
        framework.AssetFactory_DDS = AssetFactory_DDS;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var AssetFactory_ETC1 = /** @class */ (function () {
            function AssetFactory_ETC1() {
            }
            AssetFactory_ETC1.prototype.parse = function (assetmgr, bundle, name, bytes, dwguid) {
                var _texture = new framework.texture(name);
                _texture.glTexture = framework.KTXParse.parse(assetmgr.webgl, bytes);
                return _texture;
            };
            AssetFactory_ETC1 = __decorate([
                framework.assetF(framework.AssetTypeEnum.KTX)
            ], AssetFactory_ETC1);
            return AssetFactory_ETC1;
        }());
        framework.AssetFactory_ETC1 = AssetFactory_ETC1;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var AssetFactory_f14eff = /** @class */ (function () {
            function AssetFactory_f14eff() {
            }
            //#region 废弃de参考代码
            // newAsset(): f14eff
            // {
            //     return null;
            // }
            // load(url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset: f14eff, call: (handle: () => void) => void)
            // {
            //     let bundlename = getFileName(state.url);
            //     let filename = getFileName(url);
            //     state.resstate[filename] = new ResourceState();
            //     if (state.resstateFirst == null)
            //     {
            //         state.resstateFirst = state.resstate[filename];
            //     }
            //     m4m.io.loadText(url, (txt, err, isloadFail) =>
            //     {
            //         call(() =>
            //         {
            //             state.isloadFail = isloadFail ? true : false;
            //             if (AssetFactoryTools.catchError(err, onstate, state))
            //                 return;
            //             let time = Date.now();
            //             let _f14eff = asset ? asset : new f14eff(filename);
            //             _f14eff.assetbundle = bundlename;
            //             _f14eff.Parse(txt, assetMgr);
            //             let calc = Date.now() - time;
            //             console.log(`[特效]解析:${url}  耗时:${calc}/ms`);
            //             AssetFactoryTools.useAsset(assetMgr, onstate, state, _f14eff, url);
            //             // _f14eff.Parse(txt, assetMgr).then(() =>
            //             // {
            //             //     AssetFactoryTools.useAsset(assetMgr, onstate, state, _f14eff, url);
            //             // });
            //         });
            //     },
            //         (loadedLength, totalLength) =>
            //         {
            //             AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
            //         })
            // }
            // loadByPack(respack: any, url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset: f14eff, call: (handle: () => void) => void)
            // {
            //     call(() =>
            //     {
            //         let bundlename = getFileName(state.url);
            //         let filename = getFileName(url);
            //         state.resstate[filename] = new ResourceState();
            //         if (state.resstateFirst == null)
            //         {
            //             state.resstateFirst = state.resstate[filename];
            //         }
            //         let time = Date.now();
            //         let txt = respack[filename];
            //         let _f14eff = asset ? asset : new f14eff(filename);
            //         _f14eff.assetbundle = bundlename;
            //         _f14eff.Parse(txt, assetMgr);
            //         let calc = Date.now() - time;
            //         console.log(`[特效]解析:${url}  耗时:${calc}/ms`);
            //         AssetFactoryTools.useAsset(assetMgr, onstate, state, _f14eff, url);
            //         // _f14eff.Parse(txt, assetMgr).then(() =>
            //         // {
            //         //     AssetFactoryTools.useAsset(assetMgr, onstate, state, _f14eff, url);
            //         // });
            //     });
            // }
            //#endregion
            AssetFactory_f14eff.prototype.parse = function (assetmgr, bundle, filename, txt) {
                var _f14eff = new framework.f14eff(filename);
                _f14eff.assetbundle = bundle.name;
                _f14eff.Parse(txt, assetmgr);
                return _f14eff;
            };
            AssetFactory_f14eff = __decorate([
                framework.assetF(framework.AssetTypeEnum.F14Effect)
            ], AssetFactory_f14eff);
            return AssetFactory_f14eff;
        }());
        framework.AssetFactory_f14eff = AssetFactory_f14eff;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var AssetFactory_Font = /** @class */ (function () {
            function AssetFactory_Font() {
            }
            //#region 废弃de参考代码
            // newAsset(filename?: string): font
            // {
            //     return null;
            // }
            // load(url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset: font, call: (handle: () => void) => void)
            // {
            //     let filename = getFileName(url);
            //     state.resstate[filename] = new ResourceState();
            //     if (state.resstateFirst == null)
            //     {
            //         state.resstateFirst = state.resstate[filename];
            //     }
            //     m4m.io.loadText(url,
            //         (txt, err, isloadFail) =>
            //         {
            //             call(() =>
            //             {
            //                 state.isloadFail = isloadFail ? true : false;
            //                 if (AssetFactoryTools.catchError(err, onstate, state))
            //                     return;
            //                 let _font = asset ? asset : new font(filename);
            //                 _font.Parse(txt, assetMgr);
            //                 AssetFactoryTools.useAsset(assetMgr, onstate, state, _font, url);
            //             });
            //         },
            //         (loadedLength, totalLength) =>
            //         {
            //             AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
            //         })
            // }
            // loadByPack(respack: any, url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset: font, call: (handle: () => void) => void)
            // {
            //     call(() =>
            //     {
            //         let filename = getFileName(url);
            //         state.resstate[filename] = new ResourceState();
            //         if (state.resstateFirst == null)
            //         {
            //             state.resstateFirst = state.resstate[filename];
            //         }
            //         let txt = respack[filename];
            //         let _font = asset ? asset : new font(filename);
            //         _font.Parse(txt, assetMgr);
            //         AssetFactoryTools.useAsset(assetMgr, onstate, state, _font, url);
            //     });
            // }
            //#endregion
            AssetFactory_Font.prototype.parse = function (assetmgr, bundle, filename, txt) {
                var bName = bundle ? bundle.name : null;
                return new framework.font(filename).Parse(txt, assetmgr, bName);
            };
            AssetFactory_Font = __decorate([
                framework.assetF(framework.AssetTypeEnum.Font)
            ], AssetFactory_Font);
            return AssetFactory_Font;
        }());
        framework.AssetFactory_Font = AssetFactory_Font;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var AssetFactory_GLB = /** @class */ (function () {
            function AssetFactory_GLB() {
            }
            AssetFactory_GLB.prototype.parse = function (assetmgr, bundle, filename, data) {
                //解析GLB 
                var HEADER_MAGIC = "glTF";
                var HEADER_LENGTH = 12;
                var CHUNK_TYPES_BIN = 0x004E4942;
                var CHUNK_TYPES_JSON = 0x4E4F534A;
                var headerView = new DataView(data, 0, HEADER_LENGTH);
                var header = {
                    magic: framework.StringUtil.decodeText(new Uint8Array(data.slice(0, 4))),
                    version: headerView.getUint32(4, true),
                    length: headerView.getUint32(8, true)
                };
                //检查 data 是否是有效的 GLB 格式 ，版本是否支持
                if (header.magic !== HEADER_MAGIC) {
                    throw new Error('Unsupported glTF-Binary header. ');
                }
                else if (header.version < 2.0) {
                    throw new Error('Legacy binary file detected.');
                }
                //分解块数据
                var chunkContentsLength = header.length - HEADER_LENGTH;
                var chunkView = new DataView(data, HEADER_LENGTH);
                var chunkIndex = 0;
                var gltfJsonText;
                var binData;
                while (chunkIndex < chunkContentsLength) {
                    var chunkLength = chunkView.getUint32(chunkIndex, true);
                    chunkIndex += 4;
                    var chunkType = chunkView.getUint32(chunkIndex, true);
                    chunkIndex += 4;
                    if (chunkType === CHUNK_TYPES_JSON) {
                        var contentArray = new Uint8Array(data, HEADER_LENGTH + chunkIndex, chunkLength);
                        gltfJsonText = framework.StringUtil.decodeText(contentArray);
                    }
                    else if (chunkType === CHUNK_TYPES_BIN) {
                        var byteOffset = HEADER_LENGTH + chunkIndex;
                        binData = data.slice(byteOffset, byteOffset + chunkLength);
                    } // Clients must ignore chunks with unknown types.
                    chunkIndex += chunkLength;
                }
                //gltf 资源
                var bin = new m4m.framework.bin("".concat(filename, "_bin"), binData);
                var reuslt = new m4m.framework.gltf(filename, JSON.parse(gltfJsonText));
                reuslt.buffers = [bin];
                return reuslt;
            };
            AssetFactory_GLB = __decorate([
                framework.assetF(framework.AssetTypeEnum.GLB)
            ], AssetFactory_GLB);
            return AssetFactory_GLB;
        }());
        framework.AssetFactory_GLB = AssetFactory_GLB;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var AssetFactory_GLFragmentShader = /** @class */ (function () {
            function AssetFactory_GLFragmentShader() {
            }
            //#region 废弃de参考代码
            // newAsset(): IAsset
            // {
            //     return null;
            // }
            // load(url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset: IAsset, call: (handle: () => void) => void)
            // {
            //     let filename = getFileName(url);
            //     let name = filename.substring(0, filename.indexOf("."));
            //     state.resstate[filename] = new ResourceState();
            //     if (state.resstateFirst == null)
            //     {
            //         state.resstateFirst = state.resstate[filename];
            //     }
            //     m4m.io.loadText(url, (txt, err, isloadFail) =>
            //     {
            //         call(() =>
            //         {
            //             state.isloadFail = isloadFail ? true : false;
            //             if (AssetFactoryTools.catchError(err, onstate, state))
            //                 return;
            //             state.resstate[filename].state = 1;//完成
            //             state.logs.push("load a glshader:" + filename);
            //             assetMgr.shaderPool.mapFSString[name] = txt;
            //             // assetMgr.shaderPool.compileFS(assetMgr.webgl, name, txt);
            //             onstate(state);
            //         });
            //     },
            //         (loadedLength, totalLength) =>
            //         {
            //             AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
            //         });
            // }
            // loadByPack(respack: any, url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset: IAsset, call: (handle: () => void) => void)
            // {
            //     call(() =>
            //     {
            //         let filename = getFileName(url);
            //         let name = filename.substring(0, filename.indexOf("."));
            //         state.resstate[filename] = new ResourceState();
            //         if (state.resstateFirst == null)
            //         {
            //             state.resstateFirst = state.resstate[filename];
            //         }
            //         let txt = respack[filename];
            //         txt = decodeURI(txt);
            //         state.resstate[filename].state = 1;//完成
            //         state.logs.push("load a glshader:" + filename);
            //         assetMgr.shaderPool.mapFSString[name] = txt;
            //         //assetMgr.shaderPool.compileFS(assetMgr.webgl, name, txt);
            //         onstate(state);
            //     });
            // }
            //#endregion
            AssetFactory_GLFragmentShader.prototype.parse = function (assetmgr, bundle, filename, txt) {
                assetmgr.shaderPool.mapFSString[filename.substring(0, filename.indexOf("."))] = txt;
            };
            AssetFactory_GLFragmentShader = __decorate([
                framework.assetF(framework.AssetTypeEnum.GLFragmentShader)
            ], AssetFactory_GLFragmentShader);
            return AssetFactory_GLFragmentShader;
        }());
        framework.AssetFactory_GLFragmentShader = AssetFactory_GLFragmentShader;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var AssetFactory_GLTF = /** @class */ (function () {
            function AssetFactory_GLTF() {
            }
            AssetFactory_GLTF.prototype.parse = function (assetmgr, bundle, filename, txt) {
                return new m4m.framework.gltf(filename, JSON.parse(txt));
            };
            AssetFactory_GLTF = __decorate([
                framework.assetF(framework.AssetTypeEnum.GLTF)
            ], AssetFactory_GLTF);
            return AssetFactory_GLTF;
        }());
        framework.AssetFactory_GLTF = AssetFactory_GLTF;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var AssetFactory_GLVertexShader = /** @class */ (function () {
            function AssetFactory_GLVertexShader() {
            }
            //#region 废弃de参考代码
            // newAsset(): IAsset
            // {
            //     return null;
            // }
            // load(url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset: IAsset, call: (handle: () => void) => void)
            // {
            //     let filename = getFileName(url);
            //     let name = filename.substring(0, filename.indexOf("."));
            //     state.resstate[filename] = new ResourceState();
            //     if(state.resstateFirst==null)
            //     {
            //         state.resstateFirst=state.resstate[filename];
            //     }
            //     m4m.io.loadText(url,
            //         (txt, err, isloadFail) =>
            //         {
            //             call(() =>
            //             {
            //                 state.isloadFail = isloadFail ? true : false;
            //                 if (AssetFactoryTools.catchError(err, onstate, state))
            //                     return;
            //                 state.resstate[filename].state = 1;//完成
            //                 state.logs.push("load a glshader:" + filename);
            //                 assetMgr.shaderPool.mapVSString[name] = txt;
            //                 //assetMgr.shaderPool.compileVS(assetMgr.webgl, name, txt);
            //                 onstate(state);
            //             });
            //         },
            //         (loadedLength, totalLength) =>
            //         {
            //             AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
            //         });
            // }
            // loadByPack(respack: any, url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset: IAsset, call: (handle: () => void) => void)
            // {
            //     call(() =>
            //     {
            //     let filename = getFileName(url);
            //     let name = filename.substring(0, filename.indexOf("."));
            //     state.resstate[filename] = new ResourceState();
            //     if(state.resstateFirst==null)
            //     {
            //         state.resstateFirst=state.resstate[filename];
            //     }
            //     let txt = respack[filename];
            //     txt = decodeURI(txt);
            //     state.resstate[filename].state = 1;//完成
            //     state.logs.push("load a glshader:" + filename);
            //     assetMgr.shaderPool.mapVSString[name] = txt;
            //     //assetMgr.shaderPool.compileVS(assetMgr.webgl, name, txt);
            //     onstate(state);
            //     });
            // }
            //#endregion
            AssetFactory_GLVertexShader.prototype.parse = function (assetmgr, bundle, filename, txt) {
                assetmgr.shaderPool.mapVSString[filename.substring(0, filename.indexOf("."))] = txt;
            };
            AssetFactory_GLVertexShader = __decorate([
                framework.assetF(framework.AssetTypeEnum.GLVertexShader)
            ], AssetFactory_GLVertexShader);
            return AssetFactory_GLVertexShader;
        }());
        framework.AssetFactory_GLVertexShader = AssetFactory_GLVertexShader;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var AssetFactory_HDR = /** @class */ (function () {
            function AssetFactory_HDR() {
            }
            AssetFactory_HDR.prototype.parse = function (assetmgr, bundle, name, bytes) {
                var _texture = new framework.texture(name);
                _texture.glTexture = new HdrParser(assetmgr.webgl).get2DTexture(bytes);
                return _texture;
            };
            AssetFactory_HDR = __decorate([
                framework.assetF(framework.AssetTypeEnum.HDR)
            ], AssetFactory_HDR);
            return AssetFactory_HDR;
        }());
        framework.AssetFactory_HDR = AssetFactory_HDR;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var AssetFactoryTools = /** @class */ (function () {
            function AssetFactoryTools() {
            }
            AssetFactoryTools.catchError = function (err, onstate, state) {
                if (err != null) {
                    state.iserror = true;
                    state.errs.push(new Error(err.message));
                    onstate(state);
                    return true;
                }
                return false;
            };
            AssetFactoryTools.useAsset = function (assetMgr, onstate, state, asset, url) {
                var fileName = getFileName(url);
                assetMgr.setAssetUrl(asset, url);
                assetMgr.maploaded[url] = asset;
                assetMgr.use(asset);
                state.resstate[fileName].state = 1;
                state.resstate[fileName].res = asset;
                onstate(state);
            };
            AssetFactoryTools.onProgress = function (loadedLength, totalLength, onstate, state, filename) {
                state.resstate[filename].loadedLength = loadedLength;
                // state.resstate[filename].totalLength = totalLength;
                state.progressCall = true;
                onstate(state);
            };
            AssetFactoryTools.onRefProgress = function (loadedLength, totalLength, onstate, state, filename) {
                var _restate = state.resstate[filename];
                _restate.refLoadedLength = loadedLength;
                // state.resstate[filename].totalLength = totalLength;
                state.progressCall = true;
                onstate(state);
            };
            return AssetFactoryTools;
        }());
        framework.AssetFactoryTools = AssetFactoryTools;
        function getFileName(url) {
            var filei = url.lastIndexOf("/");
            var file = url.substr(filei + 1);
            return file;
        }
        framework.getFileName = getFileName;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var assetfactory_keyFrameAniClip = /** @class */ (function () {
            function assetfactory_keyFrameAniClip() {
            }
            //#region 废弃de参考代码
            // newAsset(): keyFrameAniClip
            // {
            //     return null;
            // }
            // load(url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset: keyFrameAniClip, call: (handle: () => void) => void)
            // {
            //     let filename = getFileName(url);
            //     state.resstate[filename] = new ResourceState();
            //     if (state.resstateFirst == null)
            //     {
            //         state.resstateFirst = state.resstate[filename];
            //     }
            //     m4m.io.loadText(url,
            //         (text, err, isloadFail) =>
            //         {
            //             call(() =>
            //             {
            //                 state.isloadFail = isloadFail ? true : false;
            //                 if (AssetFactoryTools.catchError(err, onstate, state))
            //                     return;
            //                 let time = Date.now();
            //                 let _clip = asset ? asset : new keyFrameAniClip(filename);
            //                 _clip.Parse(text);
            //                 let calc = Date.now() - time;
            //                 console.log(`[序列帧动画]解析:${url}  耗时:${calc}/ms`);
            //                 AssetFactoryTools.useAsset(assetMgr, onstate, state, _clip, url);
            //             });
            //         },
            //         (loadedLength, totalLength) =>
            //         {
            //             AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
            //         })
            // }
            // loadByPack(respack, url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset: keyFrameAniClip, call: (handle: () => void) => void)
            // {
            //     call(() =>
            //     {
            //         let filename = getFileName(url);
            //         state.resstate[filename] = new ResourceState();
            //         if (state.resstateFirst == null)
            //         {
            //             state.resstateFirst = state.resstate[filename];
            //         }
            //         let time = Date.now();
            //         let _buffer = respack[filename];
            //         let _clip = asset ? asset : new keyFrameAniClip(filename);
            //         _clip.Parse(_buffer);
            //         let calc = Date.now() - time;
            //         console.log(`[序列帧动画]解析:${url}  耗时:${calc}/ms`);
            //         AssetFactoryTools.useAsset(assetMgr, onstate, state, _clip, url);
            //     });
            // }
            //#endregion
            assetfactory_keyFrameAniClip.prototype.parse = function (assetmgr, bundle, filename, txt) {
                return new framework.keyFrameAniClip(filename).Parse(txt);
            };
            assetfactory_keyFrameAniClip = __decorate([
                framework.assetF(framework.AssetTypeEnum.KeyFrameAniclip)
            ], assetfactory_keyFrameAniClip);
            return assetfactory_keyFrameAniClip;
        }());
        framework.assetfactory_keyFrameAniClip = assetfactory_keyFrameAniClip;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var AssetFactory_Material = /** @class */ (function () {
            function AssetFactory_Material() {
            }
            //#region  废弃de参考代码
            // newAsset(filename?: string): material
            // {
            //     return null;
            // }
            // load(url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset: material, call: (handle: () => void) => void)
            // {
            //     let filename = getFileName(url);
            //     let assetbundleName = getFileName(state.url);
            //     state.resstate[filename] = new ResourceState();
            //     if (state.resstateFirst == null)
            //     {
            //         state.resstateFirst = state.resstate[filename];
            //     }
            //     m4m.io.loadText(url,
            //         (txt, err, isloadFail) =>
            //         {
            //             call(() =>
            //             {
            //                 state.isloadFail = isloadFail ? true : false;
            //                 if (AssetFactoryTools.catchError(err, onstate, state))
            //                     return;
            //                 let _material = asset ? asset : new material(filename);
            //                 _material.Parse(assetMgr, JSON.parse(txt), assetbundleName);
            //                 AssetFactoryTools.useAsset(assetMgr, onstate, state, _material, url);
            //             });
            //         },
            //         (loadedLength, totalLength) =>
            //         {
            //             AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
            //         })
            // }
            // loadByPack(respack: any, url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset: material, call: (handle: () => void) => void)
            // {
            //     call(() =>
            //     {
            //         let filename = getFileName(url);
            //         let assetbundleName = getFileName(state.url);
            //         state.resstate[filename] = new ResourceState();
            //         if (state.resstateFirst == null)
            //         {
            //             state.resstateFirst = state.resstate[filename];
            //         }
            //         let txt = respack[filename];
            //         let _material = asset ? asset : new material(filename);
            //         _material.Parse(assetMgr, JSON.parse(txt), assetbundleName);
            //         AssetFactoryTools.useAsset(assetMgr, onstate, state, _material, url);
            //     });
            // }
            //#endregion
            AssetFactory_Material.prototype.parse = function (assetmgr, bundle, name, txt) {
                return new framework.material(name).Parse(assetmgr, JSON.parse(txt), bundle.name);
            };
            AssetFactory_Material = __decorate([
                framework.assetF(framework.AssetTypeEnum.Material)
            ], AssetFactory_Material);
            return AssetFactory_Material;
        }());
        framework.AssetFactory_Material = AssetFactory_Material;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var AssetFactory_Mesh = /** @class */ (function () {
            function AssetFactory_Mesh() {
            }
            //#region  废弃de参考代码
            // newAsset(): mesh
            // {
            //     return null;
            // }
            // load(url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset: mesh, call: (handle: () => void) => void)
            // {
            //     let filename = getFileName(url);
            //     state.resstate[filename] = new ResourceState();
            //     if (state.resstateFirst == null)
            //     {
            //         state.resstateFirst = state.resstate[filename];
            //     }
            //     // if (url.lastIndexOf(".bin") != -1)
            //     // {
            //     m4m.io.loadArrayBuffer(url,
            //         (_buffer, err, isloadFail) =>
            //         {
            //             call(() =>
            //             {
            //                 state.isloadFail = isloadFail ? true : false;
            //                 if (AssetFactoryTools.catchError(err, onstate, state))
            //                     return;
            //                 let _mesh = asset ? asset : new mesh(filename);
            //                 let time = Date.now();
            //                 return _mesh.Parse(_buffer, assetMgr.webgl).then(() =>
            //                 {
            //                     let calc = Date.now() - time;
            //                     console.log(`[bin]加载:${url}  耗时:${calc}/ms`);
            //                     AssetFactoryTools.useAsset(assetMgr, onstate, state, _mesh, url);
            //                 });
            //             });
            //         },
            //         (loadedLength, totalLength) =>
            //         {
            //             AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
            //         })
            //     // } else if (url.lastIndexOf(".json") != -1)
            //     // {
            //     //     m4m.io.loadJSON(url, (_buffer, err, isloadFail) =>
            //     //     {
            //     //         call(() =>
            //     //         {
            //     //             state.isloadFail = isloadFail ? true : false;
            //     //             if (AssetFactoryTools.catchError(err, onstate, state))
            //     //                 return;
            //     //             let _mesh = asset ? asset : new mesh(filename);
            //     //             let time = Date.now();
            //     //             return _mesh.Parse(_buffer, assetMgr.webgl).then(() =>
            //     //             {                            
            //     //                 AssetFactoryTools.useAsset(assetMgr, onstate, state, _mesh, url);
            //     //                 let calc = Date.now() - time;
            //     //                 console.log(`[json]加载:${url}  耗时:${calc}/ms`);
            //     //             });
            //     //             // _mesh.Parse(_buffer, assetMgr.webgl);
            //     //             // AssetFactoryTools.useAsset(assetMgr, onstate, state, _mesh, url);
            //     //         });
            //     //     }, (loadedLength, totalLength) =>
            //     //         {
            //     //             AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
            //     //         });
            //     // }
            // }
            // loadByPack(respack: any, url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset: mesh, call: (handle: () => void) => void)
            // {
            //     let filename = getFileName(url);
            //     state.resstate[filename] = new ResourceState();
            //     if (state.resstateFirst == null)
            //     {
            //         state.resstateFirst = state.resstate[filename];
            //     }
            //     let _buffer = respack[filename];
            //     let _mesh = asset ? asset : new mesh(filename);
            //     call(() =>
            //     {
            //         // if(typeof(_buffer)=="string")
            //         //     _buffer = JSON.parse(_buffer);
            //         return _mesh.Parse(_buffer, assetMgr.webgl).then(() =>
            //         {
            //             AssetFactoryTools.useAsset(assetMgr, onstate, state, _mesh, url);
            //         });
            //         // _mesh.Parse(io.GetJSON(url,_buffer), assetMgr.webgl);
            //         // AssetFactoryTools.useAsset(assetMgr, onstate, state, _mesh, url);
            //     });
            // }
            //#endregion
            AssetFactory_Mesh.prototype.parse = function (assetMgr, bundle, name, data) {
                // if (name.lastIndexOf("jellysh3") != -1)
                // {
                //     console.error(`######### 水母3 #######`);
                //     console.error(data);
                //     console.error(data.byteLength);
                // }
                if (!(data instanceof ArrayBuffer)) {
                    // console.error(`####### data not ArrayBuffer instance ,mesh name:${name},bundle:${bundle ? bundle.url : null} `);
                    // console.error(data);
                    // error.push(new Error(`data not ArrayBuffer instance ,mesh name:${name},bundle:${bundle ? bundle.url : null} `));
                    // return new mesh(name);
                    throw new Error("data not ArrayBuffer instance ,mesh name:".concat(name, ",bundle:").concat(bundle ? bundle.url : null, " "));
                }
                return new framework.mesh(name).Parse(data, assetMgr.webgl);
                //return new mesh("Meshes_nav_test.obj_Generic.cmesh.bin").Parse(data, assetMgr.webgl);
            };
            AssetFactory_Mesh = __decorate([
                framework.assetF(framework.AssetTypeEnum.Mesh)
            ], AssetFactory_Mesh);
            return AssetFactory_Mesh;
        }());
        framework.AssetFactory_Mesh = AssetFactory_Mesh;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
// namespace m4m.framework
// {
//     export class AssetFactory_PackBin implements IAssetFactory
//     {
//         newAsset(): IAsset
//         {
//             return null;
//         }
//         load(url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset?: IAsset)
//         {
//             let filename = getFileName(url);
//             m4m.io.loadArrayBuffer(url, (_buffer, err) =>
//                 {
//                     if (AssetFactoryTools.catchError(err, onstate, state))
//                         return;
//                     var read: m4m.io.binReader = new m4m.io.binReader(_buffer);
//                     let index = read.readInt32();
//                     read.position = index;
//                     while (read.canread())
//                     {
//                         let indindex = read.readInt32();
//                         if (index == 0) break;
//                         let key = read.readStringUtf8FixLength(indindex);
//                         let strs: string[] = key.split('|');
//                         let start = parseInt(strs[1]);
//                         let len = parseInt(strs[2]);
//                         let bufs: ArrayBuffer = _buffer.slice(start, start + len);
//                         assetMgr.bundlePackBin[strs[0]] = bufs;
//                     }
//                     onstate(state);
//                 },
//                 (loadedLength, totalLength) =>
//                 {
//                     state.compressBinLoaded = loadedLength;
//                     // state.resstate[filename].loadedLength = loadedLength;
//                     // state.resstate[filename].totalLength = totalLength;
//                     state.progressCall = true;
//                     onstate(state);
//                 });
//         }
//         loadByPack(packnum: number, url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset?: IAsset)
//         {
//         }
//     }
// }
// namespace m4m.framework
// {
//     export class AssetFactory_PackTxt implements IAssetFactory
//     {
//         newAsset(): IAsset
//         {
//             return null;
//         }
//         load(url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset?: IAsset)
//         {
//             let filename = getFileName(url);
//             m4m.io.loadArrayBuffer(url, (_buffer, err) =>
//                 {
//                     if (AssetFactoryTools.catchError(err, onstate, state))
//                         return;
//                     var read: m4m.io.binReader = new m4m.io.binReader(_buffer);
//                     var arr = new Uint8Array(_buffer.byteLength);
//                     read.readUint8Array(arr);
//                     let txt = m4m.io.binReader.utf8ArrayToString(arr);
//                     assetMgr.bundlePackJson = JSON.parse(txt);
//                     onstate(state);
//                 },
//                 (loadedLength, totalLength) =>
//                 {
//                     state.compressTextLoaded = loadedLength;
//                     // state.resstate[filename].loadedLength = loadedLength;
//                     // state.resstate[filename].totalLength = totalLength;
//                     state.progressCall = true;
//                     onstate(state);
//                 });
//         }
//         loadByPack(packnum: number, url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset?: IAsset)
//         {
//         }
//     }
// }
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var AssetFactory_ParticleSystem = /** @class */ (function () {
            function AssetFactory_ParticleSystem() {
            }
            AssetFactory_ParticleSystem.prototype.parse = function (assetmgr, bundle, name, txt) {
                var data = framework.ParticleSystemData.get(name);
                if (!data) {
                    data = new framework.ParticleSystemData();
                    data.value = name;
                }
                data.setData(txt);
                return data;
            };
            AssetFactory_ParticleSystem = __decorate([
                framework.assetF(framework.AssetTypeEnum.ParticleSystem)
            ], AssetFactory_ParticleSystem);
            return AssetFactory_ParticleSystem;
        }());
        framework.AssetFactory_ParticleSystem = AssetFactory_ParticleSystem;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var AssetFactory_PathAsset = /** @class */ (function () {
            function AssetFactory_PathAsset() {
            }
            //#region 废弃de参考代码
            // newAsset(): pathasset
            // {
            //     return null;
            // }
            // load(url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset: pathasset, call: (handle: () => void) => void)
            // {
            //     let filename = getFileName(url);
            //     state.resstate[filename] = new ResourceState();
            //     if (state.resstateFirst == null)
            //     {
            //         state.resstateFirst = state.resstate[filename];
            //     }
            //     m4m.io.loadText(url,
            //         (txt, err, isloadFail) =>
            //         {
            //             call(() =>
            //             {
            //                 state.isloadFail = isloadFail ? true : false;
            //                 if (AssetFactoryTools.catchError(err, onstate, state))
            //                     return;
            //                 let _path = asset ? asset : new pathasset(filename);
            //                 _path.Parse(JSON.parse(txt));
            //                 AssetFactoryTools.useAsset(assetMgr, onstate, state, _path, url);
            //             });
            //         },
            //         (loadedLength, totalLength) =>
            //         {
            //             AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
            //         })
            // }
            // loadByPack(respack: any, url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset: pathasset, call: (handle: () => void) => void)
            // {
            //     call(() =>
            //     {
            //         let filename = getFileName(url);
            //         state.resstate[filename] = new ResourceState();
            //         if (state.resstateFirst == null)
            //         {
            //             state.resstateFirst = state.resstate[filename];
            //         }
            //         let txt = respack[filename];
            //         let _path = asset ? asset : new pathasset(filename);
            //         _path.Parse(JSON.parse(txt));
            //         AssetFactoryTools.useAsset(assetMgr, onstate, state, _path, url);
            //     });
            // }
            //#endregion
            AssetFactory_PathAsset.prototype.parse = function (assetmgr, bundle, name, txt) {
                return new framework.pathasset(name).Parse(JSON.parse(txt));
            };
            AssetFactory_PathAsset = __decorate([
                framework.assetF(framework.AssetTypeEnum.PathAsset)
            ], AssetFactory_PathAsset);
            return AssetFactory_PathAsset;
        }());
        framework.AssetFactory_PathAsset = AssetFactory_PathAsset;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
// namespace m4m.framework
// {
//     export class AssetFactory_Prefab implements IAssetFactory
//     {
//         newAsset(): prefab
//         {
//             return null;
//         }
//         load(url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset: prefab, call: (handle: () => void) => void)
//         {
//             let bundlename = getFileName(state.url);
//             let filename = getFileName(url);
//             state.resstate[filename] = new ResourceState();
//             if (state.resstateFirst == null)
//             {
//                 state.resstateFirst = state.resstate[filename];
//             }
//             m4m.io.loadText(url, (txt, err, isloadFail) =>
//             {
//                 call(() =>
//                 {
//                     state.isloadFail = isloadFail ? true : false;
//                     if (AssetFactoryTools.catchError(err, onstate, state))
//                         return;
//                     let _prefab = asset ? asset : new prefab(filename);
//                     _prefab.assetbundle = bundlename;
//                     // _prefab.Parse(txt, assetMgr);
//                     // AssetFactoryTools.useAsset(assetMgr, onstate, state, _prefab, url);
//                     return _prefab.Parse(txt, assetMgr).then(() =>
//                     {
//                         AssetFactoryTools.useAsset(assetMgr, onstate, state, _prefab, url);
//                     });
//                 });
//                 // AssetFactoryTools.useAsset(assetMgr, onstate, state, _prefab, url);
//             },
//                 (loadedLength, totalLength) =>
//                 {
//                     AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
//                 })
//         }
//         loadByPack(respack: any, url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset: prefab, call: (handle: () => void) => void)
//         {
//             call(() =>
//             {
//                     let bundlename = getFileName(state.url);
//                     let filename = getFileName(url);
//                     state.resstate[filename] = new ResourceState();
//                     if (state.resstateFirst == null)
//                     {
//                         state.resstateFirst = state.resstate[filename];
//                     }
//                     let txt = respack[filename];
//                     let _prefab = asset ? asset : new prefab(filename);
//                     _prefab.assetbundle = bundlename;
//                     return _prefab.Parse(txt, assetMgr).then(() =>
//                     {
//                         AssetFactoryTools.useAsset(assetMgr, onstate, state, _prefab, url);
//                     });
//                     // await _prefab.Parse(txt, assetMgr);
//                     // AssetFactoryTools.useAsset(assetMgr, onstate, state, _prefab, url);
//             });
//         }
//     }
// }
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var AssetFactory_PVR = /** @class */ (function () {
            function AssetFactory_PVR() {
            }
            //#region 废弃de参考代码
            // newAsset(): texture
            // {
            //     return null;
            // }
            // load(url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset: texture, call: (handle: () => void) => void)
            // {
            //     let filename = getFileName(url);
            //     state.resstate[filename] = new ResourceState();
            //     if (state.resstateFirst == null)
            //     {
            //         state.resstateFirst = state.resstate[filename];
            //     }
            //     m4m.io.loadArrayBuffer(url,
            //         (_buffer, err, isloadFail) =>
            //         {
            //             call(() =>
            //             {
            //                 state.isloadFail = isloadFail ? true : false;
            //                 if (AssetFactoryTools.catchError(err, onstate, state))
            //                     return;
            //                 let _texture = asset ? asset : new texture(filename);
            //                 let pvr: PvrParse = new PvrParse(assetMgr.webgl);
            //                 _texture.glTexture = pvr.parse(_buffer);
            //                 AssetFactoryTools.useAsset(assetMgr, onstate, state, _texture, url);
            //             });
            //         },
            //         (loadedLength, totalLength) =>
            //         {
            //             AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
            //         });
            // }
            // loadByPack(respack: any, url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset: texture, call: (handle: () => void) => void)
            // {
            //     call(() =>
            //     { });
            // }
            //#endregion
            AssetFactory_PVR.prototype.parse = function (assetmgr, bundle, name, bytes) {
                var _texture = new framework.texture(name);
                var pvr = new framework.PvrParse(assetmgr.webgl);
                _texture.glTexture = pvr.parse(bytes);
                return _texture;
            };
            AssetFactory_PVR = __decorate([
                framework.assetF(framework.AssetTypeEnum.PVR)
            ], AssetFactory_PVR);
            return AssetFactory_PVR;
        }());
        framework.AssetFactory_PVR = AssetFactory_PVR;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var AssetFactory_RAW = /** @class */ (function () {
            function AssetFactory_RAW() {
            }
            AssetFactory_RAW.prototype.parse = function (assetmgr, bundle, name, bytes, dwguid) {
                var _texture = new framework.texture(name);
                _texture.glTexture = framework.RAWParse.parse(assetmgr.webgl, bytes);
                return _texture;
            };
            AssetFactory_RAW = __decorate([
                framework.assetF(framework.AssetTypeEnum.RAW)
            ], AssetFactory_RAW);
            return AssetFactory_RAW;
        }());
        framework.AssetFactory_RAW = AssetFactory_RAW;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var AssetFactory_Scene = /** @class */ (function () {
            function AssetFactory_Scene() {
            }
            //#region 废弃de参考代码
            // newAsset(): rawscene
            // {
            //     return null;
            // }
            // load(url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset: rawscene, call: (handle: () => void) => void)
            // {
            //     let bundlename = getFileName(state.url);
            //     let filename = getFileName(url);
            //     state.resstate[filename] = new ResourceState();
            //     if (state.resstateFirst == null)
            //     {
            //         state.resstateFirst = state.resstate[filename];
            //     }
            //     m4m.io.loadText(url,
            //         (txt, err, isloadFail) =>
            //         {
            //             call(() =>
            //             {
            //                 state.isloadFail = isloadFail ? true : false;
            //                 if (AssetFactoryTools.catchError(err, onstate, state))
            //                     return;
            //                 let _scene = asset ? asset : new rawscene(filename);
            //                 _scene.assetbundle = bundlename;
            //                 // _scene.Parse(txt, assetMgr);
            //                 // AssetFactoryTools.useAsset(assetMgr, onstate, state, _scene, url);
            //                 return _scene.Parse(txt, assetMgr).then(() =>
            //                 {
            //                     AssetFactoryTools.useAsset(assetMgr, onstate, state, _scene, url);
            //                 });
            //             });
            //         },
            //         (loadedLength, totalLength) =>
            //         {
            //             AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
            //         })
            // }
            // loadByPack(respack: any, url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset: rawscene, call: (handle: () => void) => void)
            // {
            //     call(() =>
            //     {
            //         let bundlename = getFileName(state.url);
            //         let filename = getFileName(url);
            //         state.resstate[filename] = new ResourceState();
            //         if (state.resstateFirst == null)
            //         {
            //             state.resstateFirst = state.resstate[filename];
            //         }
            //         let txt = respack[filename];
            //         let _scene = asset ? asset : new rawscene(filename);
            //         _scene.assetbundle = bundlename;
            //         //  _scene.Parse(txt, assetMgr);
            //         // AssetFactoryTools.useAsset(assetMgr, onstate, state, _scene, url);
            //         return _scene.Parse(txt, assetMgr).then(() =>
            //         {
            //             AssetFactoryTools.useAsset(assetMgr, onstate, state, _scene, url);
            //         });
            //     });
            // }
            //#endregion
            AssetFactory_Scene.prototype.parse = function (assetmgr, bundle, name, txt) {
                var _scene = new framework.rawscene(name);
                _scene.assetbundle = bundle.name;
                return _scene.Parse(txt, assetmgr);
            };
            AssetFactory_Scene = __decorate([
                framework.assetF(framework.AssetTypeEnum.Scene)
            ], AssetFactory_Scene);
            return AssetFactory_Scene;
        }());
        framework.AssetFactory_Scene = AssetFactory_Scene;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var AssetFactory_Shader = /** @class */ (function () {
            function AssetFactory_Shader() {
                //#region 废弃de参考代码
                // newAsset(): shader
                // {
                //     return null;
                // }
                // load(url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset: shader, call: (handle: () => void) => void)
                // {
                //     let filename = getFileName(url);
                //     state.resstate[filename] = new ResourceState();
                //     if(state.resstateFirst==null)
                //     {
                //         state.resstateFirst=state.resstate[filename];
                //     }
                //     m4m.io.loadText(url,
                //         (txt, err, isloadFail) =>
                //         {
                //             call(() =>
                //             {
                //                 state.isloadFail = isloadFail ? true : false;
                //                 if (AssetFactoryTools.catchError(err, onstate, state))
                //                     return;
                //                 var _shader = new shader(filename);
                //                 // try
                //                 // {
                //                 //     _shader.parse(assetMgr, JSON.parse(txt));
                //                 // }
                //                 // catch (e)
                //                 // {
                //                 //     console.error("error  filename :" + filename);
                //                 //     throw new Error("shader on parse");
                //                 // }
                //                 this.parseShader(_shader,assetMgr,txt,filename);
                //                 assetMgr.setAssetUrl(_shader, url);
                //                 assetMgr.mapShader[filename] = _shader;
                //                 state.resstate[filename].state = 1;//完成
                //                 onstate(state);
                //             });
                //         },
                //         (loadedLength, totalLength) =>
                //         {
                //             AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
                //         });
                // }
                // loadByPack(respack: any, url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset: shader, call: (handle: () => void) => void)
                // {
                //     call(() =>
                //     {
                //         let filename = getFileName(url);
                //         let name = filename.substring(0, filename.indexOf("."));
                //         state.resstate[filename] = new ResourceState();
                //         if(state.resstateFirst==null)
                //         {
                //             state.resstateFirst=state.resstate[filename];
                //         }
                //         let txt = respack[filename];
                //         state.resstate[filename].state = 1;//完成
                //         var _shader = new shader(filename);
                //         // try
                //         // {
                //         //     _shader.parse(assetMgr, JSON.parse(txt));
                //         // }
                //         // catch (e)
                //         // {
                //         //     console.error("error  filename :" + filename);
                //         //     throw new Error("shader on parse");
                //         // }
                //         this.parseShader(_shader,assetMgr,txt,filename);
                //         assetMgr.setAssetUrl(_shader, url);
                //         assetMgr.mapShader[filename] = _shader;
                //         onstate(state);
                //     });
                // }
                //#endregion
                this.TryParseMap = {};
            }
            AssetFactory_Shader.prototype.parseShader = function (sd, assetMgr, txt, filename) {
                try {
                    sd.parse(assetMgr, JSON.parse(txt));
                }
                catch (e) {
                    if (!this.TryParseMap[filename])
                        this.TryParseMap[filename] = 0;
                    if (this.TryParseMap[filename] < 3) { //可以尝试三次
                        this.TryParseMap[filename]++;
                        this.parseShader(sd, assetMgr, txt, filename);
                    }
                    else {
                        throw new Error("shader on parse , filename :".concat(filename, "   :\n").concat(txt));
                    }
                }
            };
            AssetFactory_Shader.prototype.parse = function (assetmgr, bundle, filename, txt) {
                // if(assetmgr.mapShader[filename]!=null)            
                //     console.error(`##shader重复设置:${filename}`);                
                // assetmgr.setAssetUrl(_shader, url);
                var _shader = new framework.shader(filename);
                this.parseShader(_shader, assetmgr, txt, filename);
                assetmgr.mapShader[filename] = _shader;
                // console.warn(`@@ shader :${filename} 加载成功`);
                return _shader;
            };
            AssetFactory_Shader = __decorate([
                framework.assetF(framework.AssetTypeEnum.Shader)
            ], AssetFactory_Shader);
            return AssetFactory_Shader;
        }());
        framework.AssetFactory_Shader = AssetFactory_Shader;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var AssetFactory_TextAsset = /** @class */ (function () {
            function AssetFactory_TextAsset() {
            }
            //#region  废弃de参考代码
            // newAsset(): textasset
            // {
            //     return null;
            // }
            // load(url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset: textasset, call: (handle: () => void) => void)
            // {
            //     let filename = getFileName(url);
            //     state.resstate[filename] = new ResourceState();
            //     if(state.resstateFirst==null)
            //     {
            //         state.resstateFirst=state.resstate[filename];
            //     }
            //     m4m.io.loadText(url,
            //         (txt, err, isloadFail) =>
            //         {
            //             call(() =>
            //             {
            //                 state.isloadFail = isloadFail ? true : false;
            //                 if (AssetFactoryTools.catchError(err, onstate, state))
            //                     return;
            //                 let _textasset = asset ? asset : new textasset(filename);
            //                 _textasset.content = txt;
            //                 AssetFactoryTools.useAsset(assetMgr, onstate, state, _textasset, url);
            //             });
            //         },
            //         (loadedLength, totalLength) =>
            //         {
            //             AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
            //         })
            // }
            // loadByPack(respack: any, url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset: textasset, call: (handle: () => void) => void)
            // {
            //     call(() =>
            //     {
            //         let filename = getFileName(url);
            //         state.resstate[filename] = new ResourceState();
            //         if(state.resstateFirst==null)
            //         {
            //             state.resstateFirst=state.resstate[filename];
            //         }
            //         let txt = respack[filename];
            //         let _textasset = asset ? asset : new textasset(filename);
            //         _textasset.content = txt;
            //         AssetFactoryTools.useAsset(assetMgr, onstate, state, _textasset, url);
            //     });
            // }
            //#endregion
            AssetFactory_TextAsset.prototype.parse = function (assetmgr, bundle, filename, txt) {
                var asset = new framework.textasset(filename);
                asset.content = txt;
                return asset;
            };
            AssetFactory_TextAsset = __decorate([
                framework.assetF(framework.AssetTypeEnum.TextAsset)
            ], AssetFactory_TextAsset);
            return AssetFactory_TextAsset;
        }());
        framework.AssetFactory_TextAsset = AssetFactory_TextAsset;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var AssetFactory_Texture = /** @class */ (function () {
            function AssetFactory_Texture() {
            }
            //#region 废弃de参考代码
            // newAsset(): texture
            // {
            //     return null;
            // }
            // load(url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset: texture, call: (handle: () => void) => void)
            // {
            //     let filename = getFileName(url);
            //     state.resstate[filename] = new ResourceState();
            //     if(state.resstateFirst==null)
            //     {
            //         state.resstateFirst=state.resstate[filename];
            //     }
            //     m4m.io.loadImg(url,
            //         (_tex, _err, isloadFail) =>
            //         {
            //             call(() =>
            //             {
            //                 state.isloadFail = isloadFail ? true : false;
            //                 if (AssetFactoryTools.catchError(_err, onstate, state))
            //                     return;
            //                 let _texture = asset ? asset : new texture(filename);
            //                 var _textureFormat = render.TextureFormatEnum.RGBA;//这里需要确定格式
            //                 var t2d = new m4m.render.glTexture2D(assetMgr.webgl, _textureFormat);
            //                 t2d.uploadImage(_tex, false, true, true, false);
            //                 _texture.glTexture = t2d;
            //                 AssetFactoryTools.useAsset(assetMgr, onstate, state, _texture, url);
            //             });
            //         },
            //         (loadedLength, totalLength) =>
            //         {
            //             AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename);
            //         });
            // }
            // loadByPack(respack: any, url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset: texture, call: (handle: () => void) => void)
            // {
            //     call(() =>
            //     {
            //     });
            // }
            //#endregion
            AssetFactory_Texture.prototype.parse = function (assetmgr, bundle, filename, txt, dwguid) {
                var imgGuid = bundle && bundle.texs ? bundle.texs[filename] : dwguid;
                var _tex = framework.assetMgr.mapImage[imgGuid] || framework.assetMgr.mapLoading[imgGuid].data;
                var _texture = new framework.texture(filename);
                var _textureFormat = m4m.render.TextureFormatEnum.RGBA; //这里需要确定格式
                var t2d = new m4m.render.glTexture2D(assetmgr.webgl, _textureFormat);
                if (_tex) {
                    t2d.uploadImage(_tex, false, true, true, true); // TODO:
                    // t2d.uploadImage(_tex, false, true, true, false);
                }
                else {
                    console.warn("_tex load fail !");
                }
                _texture.glTexture = t2d;
                return _texture;
            };
            AssetFactory_Texture = __decorate([
                framework.assetF(framework.AssetTypeEnum.Texture)
            ], AssetFactory_Texture);
            return AssetFactory_Texture;
        }());
        framework.AssetFactory_Texture = AssetFactory_Texture;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var AssetFactory_TextureDesc = /** @class */ (function () {
            function AssetFactory_TextureDesc() {
                this.t_Normal = "t_Normal";
                this.t_PVR = "t_PVR";
                this.t_DDS = "t_DDS";
                this.t_KTX = "t_KTX";
                this.t_ASTC = "t_ASTC";
                this.t_RAW = "t_RAW";
            }
            //#region 废弃de参考代码
            // newAsset(): texture
            // {
            //     return null;
            // }
            // private parseTexture(txt: string, url: string, call: (handle: () => void) => void, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset: texture)
            // {
            //     let filename = getFileName(url);
            //     var _texturedesc = JSON.parse(txt);
            //     var _name: string = _texturedesc["name"];
            //     var _filterMode: string = _texturedesc["filterMode"];
            //     var _format: string = _texturedesc["format"];
            //     var _mipmap: boolean = _texturedesc["mipmap"];
            //     var _wrap: string = _texturedesc["wrap"];
            //     var _premultiplyAlpha: boolean = _texturedesc["premultiplyAlpha"];
            //     if (_premultiplyAlpha == undefined)
            //     {
            //         _premultiplyAlpha = true;
            //     }
            //     var _textureFormat = render.TextureFormatEnum.RGBA;//这里需要确定格式
            //     if (_format == "RGB")
            //         _textureFormat = render.TextureFormatEnum.RGB;
            //     else if (_format == "Gray")
            //         _textureFormat = render.TextureFormatEnum.Gray;
            //     var _linear: boolean = true;
            //     if (_filterMode.indexOf("linear") < 0)
            //         _linear = false;
            //     var _repeat: boolean = false;
            //     if (_wrap.indexOf("Repeat") >= 0)
            //         _repeat = true;
            //     var _textureSrc: string = url.replace(filename, _name);
            //     //图片类型
            //     let loadFun: (url: string, fun: (_bin: ArrayBuffer | HTMLImageElement, _err: Error, isloadFail?: boolean) => void, onprocess: (curLength: number, totalLength: number) => void) => any;
            //     let tType = this.t_Normal;
            //     if (_textureSrc.indexOf(".pvr.bin") >= 0)
            //     {
            //         tType = this.t_PVR;
            //     } else if (_textureSrc.indexOf(".dds.bin") >= 0)
            //     {
            //         tType = this.t_DDS;
            //     }
            //     loadFun = tType == this.t_Normal ? m4m.io.loadImg : m4m.io.loadArrayBuffer;
            //     loadFun(_textureSrc,
            //         (data, _err, isloadFail) =>
            //         {
            //             call(() =>
            //             {
            //                 state.isloadFail = isloadFail ? true : false;
            //                 if (AssetFactoryTools.catchError(_err, onstate, state))
            //                     return;
            //                 let _texture = asset ? asset : new texture(filename);
            //                 _texture.realName = _name;
            //                 //构建贴图
            //                 switch (tType)
            //                 {
            //                     case this.t_Normal:
            //                         var t2d = new m4m.render.glTexture2D(assetMgr.webgl, _textureFormat);
            //                         t2d.uploadImage(data as any, _mipmap, _linear, _premultiplyAlpha, _repeat);
            //                         _texture.glTexture = t2d;
            //                         break;
            //                     case this.t_PVR:
            //                         let pvr: PvrParse = new PvrParse(assetMgr.webgl);
            //                         _texture.glTexture = pvr.parse(data as any);
            //                         break;
            //                     case this.t_DDS:
            //                         assetMgr.webgl.pixelStorei(assetMgr.webgl.UNPACK_FLIP_Y_WEBGL, 1);
            //                         let textureUtil = new WebGLTextureUtil(assetMgr.webgl, true);
            //                         textureUtil.loadDDS(_textureSrc, null, (texture, error, stats) =>
            //                         {
            //                             let t2d = new m4m.render.glTexture2D(assetMgr.webgl);
            //                             t2d.format = m4m.render.TextureFormatEnum.PVRTC2_RGB;
            //                             t2d.texture = texture;
            //                             _texture.glTexture = t2d;
            //                         });
            //                         break;
            //                 }
            //                 AssetFactoryTools.useAsset(assetMgr, onstate, state, _texture, url);
            //             });
            //         },
            //         (loadedLength, totalLength) =>
            //         {
            //             AssetFactoryTools.onRefProgress(loadedLength, totalLength, onstate, state, filename);
            //         });
            // }
            // load(url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset: texture, call: (handle: () => void) => void)
            // {
            //     let filename = getFileName(url);
            //     state.resstate[filename] = new RefResourceState();
            //     if (state.resstateFirst == null)
            //     {
            //         state.resstateFirst = state.resstate[filename];
            //     }
            //     m4m.io.loadText(url,
            //         (txt, err, isloadFail) =>
            //         {
            //             state.isloadFail = isloadFail ? true : false;
            //             if (AssetFactoryTools.catchError(err, onstate, state))
            //                 return;
            //             this.parseTexture(txt, url, call, onstate, state, assetMgr, asset);
            //         },
            //         (loadedLength, totalLength) => { AssetFactoryTools.onProgress(loadedLength, totalLength, onstate, state, filename); }
            //     );
            // }
            // loadByPack(respack: any, url: string, onstate: (state: stateLoad) => void, state: stateLoad, assetMgr: assetMgr, asset: texture, call: (handle: () => void) => void)
            // {
            //     let filename = getFileName(url);
            //     state.resstate[filename] = new RefResourceState();
            //     let txt = respack[filename];
            //     this.parseTexture(txt, url, call, onstate, state, assetMgr, asset);
            // }
            //#endregion
            AssetFactory_TextureDesc.prototype.parse = function (assetmgr, bundle, name, data, dwguid) {
                var _texturedesc = JSON.parse(data);
                var _name = _texturedesc["name"];
                var _filterMode = _texturedesc["filterMode"];
                var _format = _texturedesc["format"];
                var _mipmap = _texturedesc["mipmap"];
                var _wrap = _texturedesc["wrap"];
                var _premultiplyAlpha = _texturedesc["premultiplyAlpha"];
                if (_premultiplyAlpha == undefined) {
                    _premultiplyAlpha = true;
                }
                var _textureFormat = m4m.render.TextureFormatEnum.RGBA; //这里需要确定格式
                if (_format == "RGB")
                    _textureFormat = m4m.render.TextureFormatEnum.RGB;
                else if (_format == "Gray")
                    _textureFormat = m4m.render.TextureFormatEnum.Gray;
                var _linear = true;
                if (_filterMode.indexOf("linear") < 0)
                    _linear = false;
                var _repeat = false;
                if (_wrap.indexOf("Repeat") >= 0)
                    _repeat = true;
                // let _texture = asset ? asset : new texture(url);
                var _texture = new framework.texture(name);
                _texture.realName = _name;
                var tType = this.t_Normal;
                if (_name.indexOf(".astc") >= 0) {
                    tType = this.t_ASTC;
                }
                else if (_name.indexOf(".pvr.bin") >= 0) {
                    tType = this.t_PVR;
                }
                else if (_name.indexOf(".ktx") >= 0) {
                    tType = this.t_KTX;
                }
                else if (_name.indexOf(".dds.bin") >= 0) {
                    tType = this.t_DDS;
                }
                else if (_name.indexOf(".raw") >= 0) {
                    tType = this.t_RAW;
                }
                var imgGuid = dwguid || bundle.texs[_name] || bundle.files[_name];
                var img = framework.assetMgr.mapImage[imgGuid] || framework.assetMgr.mapLoading[imgGuid].data;
                //构建贴图
                switch (tType) {
                    case this.t_Normal:
                        var t2d = new m4m.render.glTexture2D(assetmgr.webgl, _textureFormat);
                        if (img) {
                            t2d.uploadImage(img, _mipmap, _linear, _premultiplyAlpha, _repeat);
                        }
                        _texture.glTexture = t2d;
                        break;
                    case this.t_RAW:
                        //检查是否有 已经解析完的 资源了 
                        //替换原有资源
                        _texture.glTexture = framework.RAWParse.parseByAtt(assetmgr.webgl, img, _mipmap, _linear, _premultiplyAlpha, _repeat);
                        break;
                    case this.t_ASTC:
                        _texture.glTexture = framework.ASTCParse.parse(assetmgr.webgl, img);
                        break;
                    case this.t_PVR:
                        var pvr = new framework.PvrParse(assetmgr.webgl);
                        _texture.glTexture = pvr.parse(img);
                        break;
                    case this.t_KTX:
                        _texture.glTexture = framework.KTXParse.parse(assetmgr.webgl, img);
                        break;
                    case this.t_DDS:
                        throw new Error("暂不支持DDS");
                    // assetMgr.webgl.pixelStorei(assetMgr.webgl.UNPACK_FLIP_Y_WEBGL, 1);
                    // let textureUtil = new WebGLTextureUtil(assetMgr.webgl, true);
                    // textureUtil.loadDDS(_textureSrc, null, (texture, error, stats) =>
                    // {
                    //     let t2d = new m4m.render.glTexture2D(assetMgr.webgl);
                    //     t2d.format = m4m.render.TextureFormatEnum.PVRTC2_RGB;
                    //     t2d.texture = texture;
                    //     _texture.glTexture = t2d;
                    // });
                    // break;
                }
                return _texture;
            };
            AssetFactory_TextureDesc.prototype.needDownload = function (text) {
                var json = JSON.parse(text);
                return json.name;
            };
            AssetFactory_TextureDesc = __decorate([
                framework.assetF(framework.AssetTypeEnum.TextureDesc)
            ], AssetFactory_TextureDesc);
            return AssetFactory_TextureDesc;
        }());
        framework.AssetFactory_TextureDesc = AssetFactory_TextureDesc;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var AssetFactory_TrailRenderer = /** @class */ (function () {
            function AssetFactory_TrailRenderer() {
            }
            AssetFactory_TrailRenderer.prototype.parse = function (assetmgr, bundle, name, txt) {
                var data = framework.TrailRendererData.get(name);
                data.setData(txt);
                return data;
            };
            AssetFactory_TrailRenderer = __decorate([
                framework.assetF(framework.AssetTypeEnum.TrailRenderer)
            ], AssetFactory_TrailRenderer);
            return AssetFactory_TrailRenderer;
        }());
        framework.AssetFactory_TrailRenderer = AssetFactory_TrailRenderer;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../../io/reflect.ts" />
var m4m;
/// <reference path="../../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 动画片段资源
         * @version m4m 1.0
         */
        var animationClip = /** @class */ (function () {
            function animationClip(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 是否为默认资源
                 * @version m4m 1.0
                 */
                this.defaultAsset = false;
                this.indexDic = {};
                /**
                 * @private
                 */
                this.frames = {};
                if (!assetName) {
                    assetName = "animationClip_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取资源名称
             * @version m4m 1.0
             */
            animationClip.prototype.getName = function () {
                return this.name.getText();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取资源唯一id
             * @version m4m 1.0
             */
            animationClip.prototype.getGUID = function () {
                return this.id.getID();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 引用计数加一
             * @version m4m 1.0
             */
            animationClip.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 引用计数减一
             * @version m4m 1.0
             */
            animationClip.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 释放资源
             * @version m4m 1.0
             */
            animationClip.prototype.dispose = function () {
                this.bones.length = 0;
                this.subclips.length = 0;
                delete this.frames;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 计算资源字节大小
             * @version m4m 1.0
             */
            animationClip.prototype.caclByteLength = function () {
                var total = 0;
                for (var k in this.bones) {
                    total += m4m.math.caclStringByteLength(this.bones[k]);
                }
                for (var k in this.frames) {
                    total += this.frames[k].byteLength;
                    total += m4m.math.caclStringByteLength(k);
                }
                total += subClip.caclByteLength() * this.subclips.length;
                return total;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 解析资源
             * @param buf buffer数组
             * @version m4m 1.0
             */
            animationClip.prototype.Parse = function (buf) {
                var _this = this;
                return new Promise(function (resolve, reject) {
                    try {
                        var read = new m4m.io.binReader(buf);
                        if (read.readByte() == 0xFD) {
                            //版本3，当前版本
                            read.readStringUtf8();
                            _this.fps = read.readFloat();
                            var optimizeSize = read.readBoolean();
                            _this.hasScaled = read.readBoolean();
                            _this.loop = read.readBoolean();
                            _this.boneCount = read.readInt();
                            _this.bones = [];
                            for (var i = 0; i < _this.boneCount; i++) {
                                var bonename = read.readStringUtf8();
                                _this.bones.push(bonename);
                                _this.indexDic[bonename] = i;
                            }
                            _this.indexDic["len"] = _this.boneCount;
                            _this.subclipCount = read.readInt();
                            _this.subclips = [];
                            for (var i = 0; i < _this.subclipCount; i++) {
                                var _subClip = new subClip();
                                _subClip.name = read.readStringUtf8();
                                _subClip.loop = read.readBoolean();
                                _this.subclips.push(_subClip);
                            }
                            _this.frameCount = read.readInt();
                            _this.frames = {};
                            // byte stride
                            var bs = _this.hasScaled ? 8 : 7;
                            var minVals = [];
                            var maxVals = [];
                            if (optimizeSize) {
                                for (var i = 0; i < bs; i++) {
                                    minVals.push(read.readFloat());
                                    maxVals.push(read.readFloat());
                                }
                            }
                            for (var i = 0; i < _this.frameCount; i++) {
                                var _fid = read.readInt().toString();
                                var _key = read.readBoolean();
                                var _frame = new Float32Array(_this.boneCount * bs + 1);
                                _frame[0] = _key ? 1 : 0;
                                var _boneInfo = new PoseBoneMatrix();
                                for (var i_1 = 0; i_1 < _this.boneCount; i_1++) {
                                    _boneInfo.load(read, _this.hasScaled, optimizeSize ? { maxVals: maxVals, minVals: minVals } : null);
                                    _frame[i_1 * bs + 1] = _boneInfo.r.x;
                                    _frame[i_1 * bs + 2] = _boneInfo.r.y;
                                    _frame[i_1 * bs + 3] = _boneInfo.r.z;
                                    _frame[i_1 * bs + 4] = _boneInfo.r.w;
                                    _frame[i_1 * bs + 5] = _boneInfo.t.x;
                                    _frame[i_1 * bs + 6] = _boneInfo.t.y;
                                    _frame[i_1 * bs + 7] = _boneInfo.t.z;
                                    if (_this.hasScaled) {
                                        _frame[i_1 * bs + 8] = _boneInfo.s;
                                    }
                                }
                                _this.frames[_fid] = _frame;
                            }
                        }
                        else {
                            //重新开始读
                            read.seek(0);
                            // var _name =
                            read.readStringUtf8();
                            _this.fps = read.readFloat();
                            var magic = read.readByte();
                            var optimizeSize = false;
                            if (magic == 0) //版本1
                             {
                                _this.hasScaled = false;
                                _this.loop = false;
                            }
                            else if (magic == 1) //版本1
                             {
                                _this.hasScaled = false;
                                _this.loop = true;
                            }
                            else if (magic == 0xFA) //版本1
                             {
                                _this.hasScaled = true;
                                _this.loop = read.readBoolean();
                            }
                            else if (magic == 0xFB) //版本2
                             {
                                optimizeSize = true;
                                _this.hasScaled = false;
                                _this.loop = read.readBoolean();
                            }
                            else if (magic == 0xFC) //版本2
                             {
                                optimizeSize = true;
                                _this.hasScaled = true;
                                _this.loop = read.readBoolean();
                            }
                            _this.boneCount = read.readInt();
                            _this.bones = [];
                            for (var i = 0; i < _this.boneCount; i++) {
                                var bonename = read.readStringUtf8();
                                _this.bones.push(bonename);
                                _this.indexDic[bonename] = i;
                            }
                            _this.indexDic["len"] = _this.boneCount;
                            _this.subclipCount = read.readInt();
                            _this.subclips = [];
                            for (var i = 0; i < _this.subclipCount; i++) {
                                var _subClip = new subClip();
                                _subClip.name = read.readStringUtf8();
                                _subClip.loop = read.readBoolean();
                                _this.subclips.push(_subClip);
                            }
                            _this.frameCount = read.readInt();
                            _this.frames = {};
                            // byte stride
                            var bs = _this.hasScaled ? 8 : 7;
                            var minVals = [];
                            var maxVals = [];
                            if (optimizeSize) {
                                for (var i = 0; i < 8; i++) {
                                    minVals.push(read.readFloat());
                                    maxVals.push(read.readFloat());
                                }
                            }
                            for (var i = 0; i < _this.frameCount; i++) {
                                var _fid = read.readInt().toString();
                                var _key = read.readBoolean();
                                var _frame = new Float32Array(_this.boneCount * bs + 1);
                                _frame[0] = _key ? 1 : 0;
                                var _boneInfo = new PoseBoneMatrix();
                                for (var i_2 = 0; i_2 < _this.boneCount; i_2++) {
                                    _boneInfo.load(read, _this.hasScaled, optimizeSize ? { maxVals: maxVals, minVals: minVals } : null);
                                    _frame[i_2 * bs + 1] = _boneInfo.r.x;
                                    _frame[i_2 * bs + 2] = _boneInfo.r.y;
                                    _frame[i_2 * bs + 3] = _boneInfo.r.z;
                                    _frame[i_2 * bs + 4] = _boneInfo.r.w;
                                    _frame[i_2 * bs + 5] = _boneInfo.t.x;
                                    _frame[i_2 * bs + 6] = _boneInfo.t.y;
                                    _frame[i_2 * bs + 7] = _boneInfo.t.z;
                                    if (_this.hasScaled) {
                                        _frame[i_2 * bs + 8] = _boneInfo.s;
                                    }
                                }
                                _this.frames[_fid] = _frame;
                            }
                        }
                    }
                    catch (error) {
                        reject(error.stack);
                        return;
                    }
                    resolve(_this);
                });
            };
            Object.defineProperty(animationClip.prototype, "time", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 播放时长
                 * @version m4m 1.0
                 */
                get: function () {
                    if (!this.frameCount || !this.fps)
                        return 0;
                    return this.frameCount / this.fps;
                },
                enumerable: false,
                configurable: true
            });
            animationClip.ClassName = "animationClip";
            __decorate([
                m4m.reflect.Field("constText"),
                __metadata("design:type", framework.constText)
            ], animationClip.prototype, "name", void 0);
            animationClip = __decorate([
                m4m.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], animationClip);
            return animationClip;
        }());
        framework.animationClip = animationClip;
        /**
         * @private
         */
        var PoseBoneMatrix = /** @class */ (function () {
            function PoseBoneMatrix() {
            }
            PoseBoneMatrix_1 = PoseBoneMatrix;
            PoseBoneMatrix.caclByteLength = function () {
                var total = 12 + 16;
                return total;
            };
            PoseBoneMatrix.prototype.Clone = function () {
                var p = new PoseBoneMatrix_1();
                p.t = new m4m.math.vector3();
                p.r = new m4m.math.quaternion();
                m4m.math.vec3Clone(this.t, p.t);
                m4m.math.quatClone(this.r, p.r);
                return p;
            };
            PoseBoneMatrix.prototype.load = function (read, hasScaled, optimizeSize) {
                if (hasScaled === void 0) { hasScaled = false; }
                if (optimizeSize === void 0) { optimizeSize = null; }
                if (!optimizeSize) {
                    {
                        var x = read.readSingle();
                        var y = read.readSingle();
                        var z = read.readSingle();
                        var w = read.readSingle();
                        this.r = new m4m.math.quaternion(x, y, z, w);
                    }
                    {
                        var x = read.readSingle();
                        var y = read.readSingle();
                        var z = read.readSingle();
                        this.t = new m4m.math.vector3(x, y, z);
                    }
                    {
                        if (hasScaled) {
                            this.s = read.readSingle();
                        }
                    }
                }
                else {
                    var minVals = optimizeSize.minVals, maxVals = optimizeSize.maxVals;
                    {
                        //原始16byte优化为=》quat存储4 *（1.5 byte）12个位= 6 byte
                        var byte1 = read.readByte();
                        var byte2 = read.readByte();
                        var byte3 = read.readByte();
                        var byte4 = read.readByte();
                        var byte5 = read.readByte();
                        var byte6 = read.readByte();
                        var x_1 = minVals[0] + (byte1 + ((byte5 & 0x0f) << 8)) * (maxVals[0] - minVals[0]) / 0xfff;
                        var y_1 = minVals[1] + (byte2 + ((byte5 & 0xf0) << 4)) * (maxVals[1] - minVals[1]) / 0xfff;
                        var z_1 = minVals[2] + (byte3 + ((byte6 & 0x0f) << 8)) * (maxVals[2] - minVals[2]) / 0xfff;
                        var w_1 = minVals[3] + (byte4 + ((byte6 & 0xf0) << 4)) * (maxVals[3] - minVals[3]) / 0xfff;
                        this.r = new m4m.math.quaternion(x_1, y_1, z_1, w_1);
                    }
                    {
                        //原始12byte优化为=》translate存储3 *（1.5 byte）12个位 = 4.5 byte = 5 byte
                        var byte1 = read.readByte();
                        var byte2 = read.readByte();
                        var byte3 = read.readByte();
                        var byte4 = read.readByte();
                        var byte5 = read.readByte();
                        var x_2 = minVals[4] + (byte1 + ((byte4 & 0x0f) << 8)) * (maxVals[4] - minVals[4]) / 0xfff;
                        var y_2 = minVals[5] + (byte2 + ((byte4 & 0xf0) << 4)) * (maxVals[5] - minVals[5]) / 0xfff;
                        var z_2 = minVals[6] + (byte3 + (byte5 << 8)) * (maxVals[6] - minVals[6]) / 0xfff;
                        this.t = new m4m.math.vector3(x_2, y_2, z_2);
                    }
                    {
                        if (hasScaled) {
                            //scale.x 原始4byte优化为=》1byte
                            var byte1 = read.readByte();
                            this.s = minVals[7] + byte1 * (maxVals[7] - minVals[7]) / 0xff;
                        }
                    }
                }
            };
            PoseBoneMatrix.createDefault = function () {
                var pt = new PoseBoneMatrix_1();
                pt.r = new m4m.math.quaternion(0, 0, 0, 1);
                pt.t = new m4m.math.vector3(0, 0, 0);
                return pt;
            };
            PoseBoneMatrix.prototype.copyFrom = function (src) {
                // this.r.rawData.set(src.r.rawData);
                // this.t.rawData.set(src.t.rawData);
                m4m.math.quatClone(src.r, this.r);
                m4m.math.vec3Clone(src.t, this.t);
            };
            PoseBoneMatrix.prototype.copyFromData = function (src, seek) {
                this.r.x = src[seek + 0];
                this.r.y = src[seek + 1];
                this.r.z = src[seek + 2];
                this.r.w = src[seek + 3];
                this.t.x = src[seek + 4];
                this.t.y = src[seek + 5];
                this.t.z = src[seek + 6];
                // TODO:
                // this.s = src[seek + 7];
            };
            PoseBoneMatrix.prototype.invert = function () {
                m4m.math.quatInverse(this.r, this.r);
                m4m.math.quatTransformVector(this.r, this.t, this.t);
                this.t.x *= -1;
                this.t.y *= -1;
                this.t.z *= -1;
            };
            PoseBoneMatrix.prototype.lerpInWorld = function (_tpose, from, to, v) {
                ////预乘之后，插值奇慢
                // var tpose = new math.matrix();
                // math.matrixMakeTransformRTS(
                //     new math.vector3(_tpose.t.x, _tpose.t.y, _tpose.t.z),
                //     new math.vector3(1, 1, 1),
                //     new math.quaternion(_tpose.r.x, _tpose.r.y, _tpose.r.z, _tpose.r.w),
                //     tpose);
                var t1 = PoseBoneMatrix_1.sMultiply(from, _tpose);
                var t2 = PoseBoneMatrix_1.sMultiply(to, _tpose);
                //球插
                var outLerp = PoseBoneMatrix_1.sLerp(t1, t2, v);
                //再去掉tpose，为了加速这个过程，考虑要存一份 合并tpose的骨骼数据
                var itpose = _tpose.Clone();
                itpose.invert();
                PoseBoneMatrix_1.sMultiply(outLerp, itpose, this);
            };
            PoseBoneMatrix.prototype.lerpInWorldWithData = function (_tpose, from, todata, toseek, v) {
                ////预乘之后，插值奇慢
                // var tpose = new math.matrix();
                // math.matrixMakeTransformRTS(
                //     new math.vector3(_tpose.t.x, _tpose.t.y, _tpose.t.z),
                //     new math.vector3(1, 1, 1),
                //     new math.quaternion(_tpose.r.x, _tpose.r.y, _tpose.r.z, _tpose.r.w),
                //     tpose);
                var t1 = PoseBoneMatrix_1.sMultiply(from, _tpose);
                var t2 = PoseBoneMatrix_1.sMultiplyDataAndMatrix(todata, toseek, _tpose);
                //球插
                var outLerp = PoseBoneMatrix_1.sLerp(t1, t2, v);
                //再去掉tpose，为了加速这个过程，考虑要存一份 合并tpose的骨骼数据
                var itpose = _tpose.Clone();
                itpose.invert();
                PoseBoneMatrix_1.sMultiply(outLerp, itpose, this);
            };
            PoseBoneMatrix.sMultiply = function (left, right, target) {
                if (target === void 0) { target = null; }
                if (target == null)
                    target = PoseBoneMatrix_1.createDefault();
                var dir = m4m.math.pool.new_vector3();
                m4m.math.vec3Clone(right.t, dir);
                var dirtran = m4m.math.pool.new_vector3();
                m4m.math.quatTransformVector(left.r, dir, dirtran);
                target.t.x = dirtran.x + left.t.x;
                target.t.y = dirtran.y + left.t.y;
                target.t.z = dirtran.z + left.t.z;
                m4m.math.quatMultiply(left.r, right.r, target.r);
                m4m.math.pool.delete_vector3(dir);
                m4m.math.pool.delete_vector3(dirtran);
                return target;
            };
            PoseBoneMatrix.sMultiplytpose = function (left, right, target) {
                if (target === void 0) { target = null; }
                if (target == null)
                    target = PoseBoneMatrix_1.createDefault();
                var dir = m4m.math.pool.new_vector3();
                m4m.math.vec3Clone(right.tposep, dir);
                var dirtran = m4m.math.pool.new_vector3();
                m4m.math.quatTransformVector(left.r, dir, dirtran);
                target.t.x = dirtran.x + left.t.x;
                target.t.y = dirtran.y + left.t.y;
                target.t.z = dirtran.z + left.t.z;
                m4m.math.quatMultiply(left.r, right.tposeq, target.r);
                m4m.math.pool.delete_vector3(dir);
                m4m.math.pool.delete_vector3(dirtran);
                return target;
            };
            PoseBoneMatrix.sMultiplyDataAndMatrix = function (leftdata, leftseek, right, target) {
                if (target === void 0) { target = null; }
                if (target == null)
                    target = PoseBoneMatrix_1.createDefault();
                var dir = m4m.math.pool.new_vector3();
                m4m.math.vec3Clone(right.t, dir);
                var dirtran = m4m.math.pool.new_vector3();
                m4m.math.quatTransformVectorDataAndQuat(leftdata, leftseek + 0, dir, dirtran);
                target.t.x = dirtran.x + leftdata[leftseek + 4];
                target.t.y = dirtran.y + leftdata[leftseek + 5];
                target.t.z = dirtran.z + leftdata[leftseek + 6];
                m4m.math.quatMultiplyDataAndQuat(leftdata, leftseek + 0, right.r, target.r);
                m4m.math.pool.delete_vector3(dir);
                m4m.math.pool.delete_vector3(dirtran);
                return target;
            };
            PoseBoneMatrix.sLerp = function (left, right, v, target) {
                if (target === void 0) { target = null; }
                if (target == null)
                    target = PoseBoneMatrix_1.createDefault();
                target.t.x = left.t.x * (1 - v) + right.t.x * v;
                target.t.y = left.t.y * (1 - v) + right.t.y * v;
                target.t.z = left.t.z * (1 - v) + right.t.z * v;
                m4m.math.quatLerp(left.r, right.r, target.r, v);
                return target;
            };
            PoseBoneMatrix.recycle = function (mat) {
                this.poolmats.push(mat);
            };
            PoseBoneMatrix.create = function () {
                var item = this.poolmats.pop();
                if (item) {
                    return item;
                }
                else {
                    item = PoseBoneMatrix_1.createDefault();
                    return item;
                }
            };
            var PoseBoneMatrix_1;
            PoseBoneMatrix.ClassName = "PoseBoneMatrix";
            PoseBoneMatrix.poolmats = [];
            __decorate([
                m4m.reflect.Field("vector3"),
                __metadata("design:type", m4m.math.vector3)
            ], PoseBoneMatrix.prototype, "t", void 0);
            __decorate([
                m4m.reflect.Field("quaternion"),
                __metadata("design:type", m4m.math.quaternion)
            ], PoseBoneMatrix.prototype, "r", void 0);
            __decorate([
                m4m.reflect.Field("scale"),
                __metadata("design:type", Number)
            ], PoseBoneMatrix.prototype, "s", void 0);
            PoseBoneMatrix = PoseBoneMatrix_1 = __decorate([
                m4m.reflect.SerializeType
            ], PoseBoneMatrix);
            return PoseBoneMatrix;
        }());
        framework.PoseBoneMatrix = PoseBoneMatrix;
        /**
         * @private
         */
        var subClip = /** @class */ (function () {
            function subClip() {
            }
            subClip.caclByteLength = function () {
                var total = 0;
                total += m4m.math.caclStringByteLength(this.name);
                total += 1;
                total += 8;
                return total;
            };
            return subClip;
        }());
        framework.subClip = subClip;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 图集资源
         * @version m4m 1.0
         */
        var atlas = /** @class */ (function () {
            function atlas(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 解析得到的sprite列表 key-->name
                 * @version m4m 1.0
                 */
                this.sprites = {};
                if (!assetName) {
                    assetName = "atlas_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取资源名称
             * @version m4m 1.0
             */
            atlas.prototype.getName = function () {
                return this.name.getText();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取资源唯一id
             * @version m4m 1.0
             */
            atlas.prototype.getGUID = function () {
                return this.id.getID();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 引用计数加一
             * @version m4m 1.0
             */
            atlas.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 引用计数减一
             * @version m4m 1.0
             */
            atlas.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 释放资源
             * @version m4m 1.0
             */
            atlas.prototype.dispose = function () {
                for (var key in this.sprites) {
                    this.sprites[key].unuse();
                }
                this.texture.unuse();
                delete this.sprites;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 计算资源字节大小
             * @version m4m 1.0
             */
            atlas.prototype.caclByteLength = function () {
                var total = 0;
                for (var k in this.sprites) {
                    total += this.sprites[k].caclByteLength();
                    total += m4m.math.caclStringByteLength(k);
                }
                return total;
            };
            Object.defineProperty(atlas.prototype, "texture", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 获取当前texture
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._texture;
                },
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 设置当前texture
                 * @param value
                 * @version m4m 1.0
                 */
                set: function (value) {
                    if (this._texture != null) {
                        this._texture.unuse();
                    }
                    this._texture = value;
                    this._texture.use();
                },
                enumerable: false,
                configurable: true
            });
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 解析资源
             * @param jsonStr json数据
             * @param assetmgr 资源管理实例
             * @version m4m 1.0
             */
            atlas.prototype.Parse = function (jsonStr, assetmgr, bundleName) {
                if (bundleName === void 0) { bundleName = null; }
                var json = JSON.parse(jsonStr);
                var name = json["t"]; //name
                this.texturewidth = json["w"];
                this.textureheight = json["h"];
                var s = json["s"];
                this.texture = assetmgr.getAssetByName(name, bundleName);
                if (this.texture == null) {
                    console.log("atlas的图片名字不对");
                }
                for (var i in s) {
                    var ss = s[i];
                    var spriteName = ss[0];
                    var r = new framework.sprite(this.getName() + "_" + spriteName); //用Atlas的名字的Sprite的名字拼接
                    // r.bundle = assetmgr.name_bundles[bundleName];
                    assetmgr.use(r);
                    if (this.texture) {
                        r.texture = this.texture;
                    }
                    r.rect = new m4m.math.rect(ss[1], ss[2], ss[3], ss[4]);
                    r.border = new m4m.math.border(0, 0, 0, 0);
                    r.atlas = this.getName();
                    this.sprites[spriteName] = r;
                }
                return this;
            };
            atlas.ClassName = "atlas";
            __decorate([
                m4m.reflect.Field("constText"),
                __metadata("design:type", framework.constText)
            ], atlas.prototype, "name", void 0);
            atlas = __decorate([
                m4m.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], atlas);
            return atlas;
        }());
        framework.atlas = atlas;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../../io/reflect.ts" />
var m4m;
/// <reference path="../../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * json资源
         * @version m4m 1.0
         */
        var bin = /** @class */ (function () {
            function bin(assetName, data) {
                if (assetName === void 0) { assetName = null; }
                this.data = data;
                this.id = new framework.resID();
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 是否为默认资源
                 * @version m4m 1.0
                 */
                this.defaultAsset = false;
                if (!assetName) {
                    assetName = "json_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取资源名称
             * @version m4m 1.0
             */
            bin.prototype.getName = function () {
                return this.name.getText();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取资源唯一id
             * @version m4m 1.0
             */
            bin.prototype.getGUID = function () {
                return this.id.getID();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 引用计数加一
             * @version m4m 1.0
             */
            bin.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 引用计数减一
             * @version m4m 1.0
             */
            bin.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 释放资源
             * @version m4m 1.0
             */
            bin.prototype.dispose = function () {
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 计算资源字节大小
             * @version m4m 1.0
             */
            bin.prototype.caclByteLength = function () {
                return this.data.byteLength;
            };
            Object.defineProperty(bin.prototype, "realName", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 如果是imgdesc加载来的图片，通过这个可以获取到真实的图片名字
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._realName;
                },
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 设置图片名称
                 * @version m4m 1.0
                 */
                set: function (name) {
                    this._realName = name;
                },
                enumerable: false,
                configurable: true
            });
            bin.ClassName = "json";
            __decorate([
                m4m.reflect.Field("constText"),
                __metadata("design:type", framework.constText)
            ], bin.prototype, "name", void 0);
            bin = __decorate([
                m4m.reflect.SerializeType,
                __metadata("design:paramtypes", [String, ArrayBuffer])
            ], bin);
            return bin;
        }());
        framework.bin = bin;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var f14node = /** @class */ (function () {
            function f14node() {
            }
            return f14node;
        }());
        framework.f14node = f14node;
        var f14eff = /** @class */ (function () {
            function f14eff(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.defaultAsset = false;
                this.name = null;
                this.id = new framework.resID();
                this.assetbundle = null;
                if (!assetName) {
                    assetName = "f14eff_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            f14eff.prototype.getName = function () {
                if (this.name == undefined) {
                    return null;
                }
                return this.name.getText();
            };
            f14eff.prototype.getGUID = function () {
                return this.id.getID();
            };
            f14eff.prototype.use = function () {
            };
            f14eff.prototype.unuse = function (disposeNow) {
            };
            f14eff.prototype.dispose = function () {
            };
            f14eff.prototype.caclByteLength = function () {
                return 0;
            };
            // trans:transform;
            // f14Effect:f14EffectSystem;
            f14eff.prototype.Parse = function (jsonStr, assetmgr) {
                var json = JSON.parse(jsonStr);
                this.data = new framework.F14EffectData();
                return this.data.parsejson(json, assetmgr, this.assetbundle);
                // this.trans=new m4m.framework.transform();
                // this.f14Effect=this.trans.gameObject.addComponent("f14EffectSystem") as m4m.framework.f14EffectSystem;
                // this.f14Effect.setData(this.f14data);
            };
            // getCloneF14eff():f14node
            // {
            //     let f14node=new m4m.framework.f14node();
            //     f14node.trans=new m4m.framework.transform();
            //     f14node.f14Effect=f14node.trans.gameObject.addComponent("f14EffectSystem") as m4m.framework.f14EffectSystem;
            //     f14node.f14Effect.setData(this.f14data);
            //     return f14node;
            // }
            /** 获取依赖资源 （mesh 、material） */
            f14eff.prototype.getDependents = function () {
                if (!this.data || !this.data.layers)
                    return;
                var result = [];
                this.doSearch(this.data.layers, result);
                return result;
            };
            f14eff.prototype.doSearch = function (obj, arr) {
                var _this = this;
                if (!obj)
                    return;
                if (obj instanceof framework.material || obj instanceof framework.mesh || obj instanceof framework.texture)
                    arr.push(obj);
                if (obj instanceof Array) {
                    obj.forEach(function (element) {
                        if (element && typeof (element) == "object") {
                            _this.doSearch(element, arr);
                        }
                    });
                }
                else {
                    var keys = Reflect["ownKeys"](obj);
                    for (var i = 0; i < keys.length; i++) {
                        if (typeof (obj[keys[i]]) == "object") {
                            this.doSearch(obj[keys[i]], arr);
                        }
                    }
                }
            };
            f14eff.ClassName = "f14eff";
            f14eff = __decorate([
                m4m.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], f14eff);
            return f14eff;
        }());
        framework.f14eff = f14eff;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 字体资源
         * @version m4m 1.0
         */
        var font = /** @class */ (function () {
            function font(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                if (!assetName) {
                    assetName = "font_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取资源名称
             * @version m4m 1.0
             */
            font.prototype.getName = function () {
                return this.name.getText();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取资源唯一id
             * @version m4m 1.0
             */
            font.prototype.getGUID = function () {
                return this.id.getID();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 引用计数加一
             * @version m4m 1.0
             */
            font.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 引用计数减一
             * @version m4m 1.0
             */
            font.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 释放资源
             * @version m4m 1.0
             */
            font.prototype.dispose = function () {
                if (this.texture) {
                    this.texture.unuse();
                }
                delete this.cmap;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 计算资源字节大小
             * @version m4m 1.0
             */
            font.prototype.caclByteLength = function () {
                var total = 0;
                for (var k in this.cmap) {
                    total += m4m.math.caclStringByteLength(k);
                    total += charinfo.caclByteLength();
                }
                return total;
            };
            Object.defineProperty(font.prototype, "texture", {
                get: function () {
                    return this._texture;
                },
                set: function (value) {
                    if (this._texture != null) {
                        this._texture.unuse();
                    }
                    this._texture = value;
                    if (this._texture)
                        this._texture.use();
                },
                enumerable: false,
                configurable: true
            });
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 解析资源
             * @param jsonStr json数据
             * @param assetmgr 资源管理实例
             * @version m4m 1.0
             */
            font.prototype.Parse = function (jsonStr, assetmgr, bundleName) {
                if (bundleName === void 0) { bundleName = null; }
                // let d1 = new Date().valueOf();
                var json = JSON.parse(jsonStr);
                //parse fontinfo
                var font = json["font"];
                this.fontname = font[0];
                var picName = font[1];
                this.texture = assetmgr.getAssetByName(picName, bundleName);
                this.pointSize = font[2];
                this.padding = font[3];
                this.lineHeight = font[4];
                this.baseline = font[5];
                this.atlasWidth = font[6];
                this.atlasHeight = font[7];
                //parse char map
                this.cmap = {};
                var map = json["map"];
                for (var c in map) {
                    var finfo = new charinfo(); //ness
                    this.cmap[c] = finfo;
                    finfo.x = (map[c][0] - 0.5) / this.atlasWidth;
                    finfo.y = (map[c][1] - 0.5) / this.atlasHeight;
                    finfo.w = (map[c][2] + 1.0) / this.atlasWidth;
                    finfo.h = (map[c][3] + 1.0) / this.atlasHeight;
                    finfo.xSize = map[c][2];
                    finfo.ySize = map[c][3];
                    finfo.xOffset = map[c][4];
                    finfo.yOffset = map[c][5];
                    finfo.xAddvance = map[c][6];
                }
                map = null;
                json = null;
                return this;
            };
            font.ClassName = "font";
            font = __decorate([
                m4m.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], font);
            return font;
        }());
        framework.font = font;
        /**
         * @private
         */
        var charinfo = /** @class */ (function () {
            function charinfo() {
                /**
                 * 偏移
                 */
                this.xOffset = 0; //偏移
                /**
                 * 相对基线的偏移
                 */
                this.yOffset = 0; //相对基线的偏移
            }
            charinfo.caclByteLength = function () {
                return 36;
            };
            return charinfo;
        }());
        framework.charinfo = charinfo;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../../io/reflect.ts" />
var m4m;
/// <reference path="../../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * json资源
         * @version m4m 1.0
         */
        var gltf = /** @class */ (function () {
            function gltf(assetName, data) {
                if (assetName === void 0) { assetName = null; }
                this.data = data;
                this.id = new framework.resID();
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 是否为默认资源
                 * @version m4m 1.0
                 */
                this.defaultAsset = false;
                this.hexToRgb = function (hex) {
                    return hex === null || hex === void 0 ? void 0 : hex.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, function (m, r, g, b) { return '#' + r + r + g + g + b + b; }).substring(1).match(/.{2}/g).map(function (x) { return parseInt(x, 16) / 255; });
                };
                if (!assetName) {
                    assetName = "json_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            gltf_1 = gltf;
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取资源名称
             * @version m4m 1.0
             */
            gltf.prototype.getName = function () {
                return this.name.getText();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取资源唯一id
             * @version m4m 1.0
             */
            gltf.prototype.getGUID = function () {
                return this.id.getID();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 引用计数加一
             * @version m4m 1.0
             */
            gltf.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 引用计数减一
             * @version m4m 1.0
             */
            gltf.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 释放资源
             * @version m4m 1.0
             */
            gltf.prototype.dispose = function () {
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 计算资源字节大小
             * @version m4m 1.0
             */
            gltf.prototype.caclByteLength = function () {
                var _a, _b;
                return (_b = (_a = this.data) === null || _a === void 0 ? void 0 : _a.buffers) === null || _b === void 0 ? void 0 : _b.map(function (e) { return e.byteLength; }).reduce(function (a, b) { return a + b; }, 0);
            };
            Object.defineProperty(gltf.prototype, "realName", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 如果是imgdesc加载来的图片，通过这个可以获取到真实的图片名字
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._realName;
                },
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 设置图片名称
                 * @version m4m 1.0
                 */
                set: function (name) {
                    this._realName = name;
                },
                enumerable: false,
                configurable: true
            });
            gltf.dumpmem = function () {
                var meminfo = window.performance["memory"];
                var memsize = meminfo.usedJSHeapSize / 1024 / 1024 | 0;
                console.log("====gltf mem= " + memsize + " MB");
                //if (memsize > 2048)
                //throw "use too mush memory";
            };
            gltf.prototype.load = function (mgr, ctx, folder, brdf, env, irrSH, exposure, specFactor, irrFactor, uvChecker) {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
                if (specFactor === void 0) { specFactor = 1; }
                if (irrFactor === void 0) { irrFactor = 1; }
                return __awaiter(this, void 0, void 0, function () {
                    var load, defaltScene, extensionsUsed, hasKHR_texture_transform, extensionsRequired, i, len, key, loadImg, getImgByBin, samplers, currBufLen, glbBin, bufCount, _v, views, accessors, images, textures, sceneExtensions, gd_linfo_scene, hasLightMap, lightMapTexs, maps, extrasCfg, materials, meshes, nodes, scene, parseNode, roots;
                    var _this = this;
                    return __generator(this, function (_w) {
                        switch (_w.label) {
                            case 0:
                                if (!this.data) {
                                    console.error("load fail , data is Null.");
                                    return [2 /*return*/];
                                }
                                console.log("====gltf begin log==");
                                gltf_1.dumpmem();
                                load = function (uri) { return new Promise(function (res) {
                                    mgr.load(folder + uri, framework.AssetTypeEnum.Auto, function () {
                                        res(mgr.getAssetByName(uri.split('/').pop()));
                                    });
                                }); };
                                defaltScene = (_a = this.data.scene) !== null && _a !== void 0 ? _a : 0;
                                extensionsUsed = (_b = this.data.extensionsUsed) !== null && _b !== void 0 ? _b : [];
                                hasKHR_texture_transform = extensionsUsed.indexOf("KHR_texture_transform") != -1;
                                extensionsRequired = (_c = this.data.extensionsRequired) !== null && _c !== void 0 ? _c : [];
                                for (i = 0, len = extensionsRequired.length; i < len; i++) {
                                    key = extensionsRequired[i];
                                    if (!gltf_1.requiredSupportedMap[key]) {
                                        console.warn("extensionsRequired of \"".concat(key, "\" not suppered!"));
                                    }
                                }
                                loadImg = function (url) { return new Promise(function (res) {
                                    m4m.io.loadImg(folder + url, function (img, err) {
                                        if (!err)
                                            res(img);
                                    });
                                }); };
                                getImgByBin = function (view, mimeType) {
                                    var _a;
                                    var bufferView = new Uint8Array(view.rawBuffer, (_a = view.byteOffset) !== null && _a !== void 0 ? _a : 0, view.byteLength);
                                    var blob = new Blob([bufferView], {
                                        type: mimeType
                                    });
                                    var sourceURI = URL.createObjectURL(blob);
                                    return new Promise(function (res) {
                                        m4m.io.loadImg(sourceURI, function (img, err) {
                                            if (!err)
                                                res(img);
                                        });
                                    });
                                };
                                console.log("====gltf begin buffers==");
                                gltf_1.dumpmem();
                                samplers = (_d = this.data.samplers) !== null && _d !== void 0 ? _d : [];
                                currBufLen = 0;
                                glbBin = this.buffers ? this.buffers[0] : null;
                                bufCount = 0;
                                _v = this;
                                return [4 /*yield*/, Promise.all((_f = (_e = this.data.buffers) === null || _e === void 0 ? void 0 : _e.map(function (_a) {
                                        var byteLength = _a.byteLength, uri = _a.uri;
                                        if (uri) {
                                            return load(uri);
                                        }
                                        else if (glbBin) {
                                            var buf = glbBin.data.slice(currBufLen, currBufLen + byteLength);
                                            currBufLen += byteLength;
                                            var _bin = new framework.bin("".concat(glbBin.getName(), "_").concat(bufCount), buf);
                                            bufCount++;
                                            return _bin;
                                        }
                                    })) !== null && _f !== void 0 ? _f : [])];
                            case 1:
                                _v.buffers = _w.sent();
                                console.log("====gltf begin accessor==");
                                gltf_1.dumpmem();
                                views = (_g = this.data.bufferViews) === null || _g === void 0 ? void 0 : _g.map(function (_a) {
                                    var _b = _a.buffer, buffer = _b === void 0 ? 0 : _b, _c = _a.byteOffset, byteOffset = _c === void 0 ? 0 : _c, _d = _a.byteLength, byteLength = _d === void 0 ? 0 : _d, _e = _a.byteStride, byteStride = _e === void 0 ? 0 : _e;
                                    // return {byteStride ,dv: new DataView(this.buffers[buffer].data, byteOffset, byteLength)};
                                    return { byteOffset: byteOffset, byteLength: byteLength, byteStride: byteStride, rawBuffer: _this.buffers[buffer].data };
                                });
                                accessors = (_j = (_h = this.data) === null || _h === void 0 ? void 0 : _h.accessors) === null || _j === void 0 ? void 0 : _j.map(function (acc) {
                                    return __assign(__assign({}, acc), { bufferView: views[acc.bufferView] });
                                });
                                console.log("====gltf begin loadimage==");
                                gltf_1.dumpmem();
                                return [4 /*yield*/, Promise.all((_m = (_l = (_k = this.data) === null || _k === void 0 ? void 0 : _k.images) === null || _l === void 0 ? void 0 : _l.map(function (_a) {
                                        var uri = _a.uri, mimeType = _a.mimeType, bufferView = _a.bufferView;
                                        if (uri) {
                                            return loadImg(uri);
                                        }
                                        else {
                                            var view = views[bufferView];
                                            return getImgByBin(view, mimeType);
                                        }
                                    })) !== null && _m !== void 0 ? _m : [])];
                            case 2:
                                images = _w.sent();
                                console.log("====gltf begin loadtexture==");
                                gltf_1.dumpmem();
                                return [4 /*yield*/, Promise.all((_p = (_o = this.data.textures) === null || _o === void 0 ? void 0 : _o.map(function (_a) {
                                        var sampler = _a.sampler, source = _a.source;
                                        var img = images[source];
                                        var tex = new m4m.framework.texture(img.src);
                                        var format = m4m.render.TextureFormatEnum.RGBA;
                                        if (img.src.length > 4 && img.src.substr(img.src.length - 4) == ".jpg") {
                                            format = m4m.render.TextureFormatEnum.RGB;
                                        }
                                        var glt = new m4m.render.glTexture2D(ctx, format);
                                        var samp = __assign({ minFilter: ctx.NEAREST, magFilter: ctx.LINEAR, wrapS: ctx.REPEAT, wrapT: ctx.REPEAT }, samplers[sampler]);
                                        glt.uploadImage(img, false, false, false, false, false, false); // bind texture
                                        //额外设置
                                        ctx.bindTexture(ctx.TEXTURE_2D, glt.texture);
                                        ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MAG_FILTER, samp.magFilter);
                                        ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_MIN_FILTER, samp.minFilter);
                                        ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_S, samp.wrapS);
                                        ctx.texParameteri(ctx.TEXTURE_2D, ctx.TEXTURE_WRAP_T, samp.wrapT);
                                        if ((samp.minFilter & 0xFF00) == ctx.NEAREST_MIPMAP_NEAREST) {
                                            ctx.generateMipmap(ctx.TEXTURE_2D);
                                        }
                                        ctx.bindTexture(ctx.TEXTURE_2D, null); // unbind
                                        tex.glTexture = glt;
                                        tex.use();
                                        return tex;
                                    })) !== null && _p !== void 0 ? _p : [])];
                            case 3:
                                textures = _w.sent();
                                console.log("====gltf begin load lightmap==");
                                gltf_1.dumpmem();
                                sceneExtensions = this.data.scenes[defaltScene].extensions;
                                if (sceneExtensions) {
                                    gd_linfo_scene = sceneExtensions.gd_linfo_scene;
                                }
                                hasLightMap = extensionsUsed.indexOf("gd_linfo") != -1 && extensionsUsed.indexOf("gd_linfo_scene") != -1
                                    && gd_linfo_scene && gd_linfo_scene.maps && gd_linfo_scene.maps.length > 0;
                                if (!hasLightMap) return [3 /*break*/, 5];
                                maps = gd_linfo_scene.maps;
                                return [4 /*yield*/, Promise.all(maps.map(function (path) {
                                        var _a;
                                        var bufferViewIdx = Number.parseInt(path);
                                        if (isNaN(bufferViewIdx)) {
                                            return load(path);
                                        }
                                        else {
                                            var view = views[bufferViewIdx];
                                            var bOffset = (_a = view.byteOffset) !== null && _a !== void 0 ? _a : 0;
                                            var buffer = view.rawBuffer.slice(bOffset, bOffset + view.byteLength);
                                            // const bufferView = new Uint8Array(view.rawBuffer, view.byteOffset ?? 0, view.byteLength);
                                            var _texture = new framework.texture("Lightmap-".concat(bufferViewIdx, "_comp_light.raw"));
                                            _texture.glTexture = framework.RAWParse.parse(ctx, buffer);
                                            return _texture;
                                        }
                                    }))];
                            case 4:
                                lightMapTexs = _w.sent();
                                _w.label = 5;
                            case 5:
                                console.log("====gltf begin load material==");
                                gltf_1.dumpmem();
                                extrasCfg = (_r = (_q = this.data.extras) === null || _q === void 0 ? void 0 : _q.clayViewerConfig) === null || _r === void 0 ? void 0 : _r.materials;
                                materials = (_s = this.data.materials) === null || _s === void 0 ? void 0 : _s.map(function (m) {
                                    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
                                    var mat = new framework.material(m.name);
                                    var matCfg;
                                    var cfgs = extrasCfg === null || extrasCfg === void 0 ? void 0 : extrasCfg.filter(function (e) { return e.name === m.name; });
                                    if ((cfgs === null || cfgs === void 0 ? void 0 : cfgs.length) > 0)
                                        matCfg = cfgs[0];
                                    var pbrSH;
                                    var alphaMode = (_a = m.alphaMode) !== null && _a !== void 0 ? _a : "OPAQUE";
                                    var alphaCutoff = (_b = m.alphaCutoff) !== null && _b !== void 0 ? _b : 0.5;
                                    var doubleSided = (_c = m.doubleSided) !== null && _c !== void 0 ? _c : false;
                                    var shaderRes = "pbr";
                                    switch (alphaMode) {
                                        case "OPAQUE":
                                            alphaCutoff = 0;
                                            break;
                                        case "MASK": break;
                                        case "BLEND":
                                            shaderRes += "_blend";
                                            break;
                                    }
                                    if (doubleSided) {
                                        shaderRes += "_2sided";
                                    }
                                    // //-------test
                                    // shaderRes = `shader/def`;
                                    // //----------
                                    shaderRes += ".shader.json";
                                    pbrSH = mgr.getShader(shaderRes);
                                    mat.setShader(pbrSH);
                                    mat.setFloat("alphaCutoff", alphaCutoff);
                                    if (brdf) {
                                        mat.setTexture('brdf', brdf);
                                    }
                                    if (env) {
                                        mat.setCubeTexture('u_env', env);
                                    }
                                    if (irrSH) {
                                        mat.setCubeTexture('u_diffuse', irrSH);
                                    }
                                    // if (m.normalTexture)
                                    // {
                                    //     mat.setTexture("uv_MetallicRoughness", textures[m.normalTexture.index]);
                                    // }
                                    if (m.occlusionTexture) {
                                        mat.setTexture("uv_AO", textures[m.occlusionTexture.index]);
                                    }
                                    if (m.normalTexture) {
                                        mat.setTexture("uv_Normal", textures[m.normalTexture.index]);
                                    }
                                    if (exposure != null) {
                                        mat.setFloat("u_Exposure", exposure);
                                    }
                                    mat.setFloat("specularIntensity", specFactor);
                                    mat.setFloat("diffuseIntensity", irrFactor);
                                    var _bColor = (_e = (_d = m.pbrMetallicRoughness) === null || _d === void 0 ? void 0 : _d.baseColorFactor) !== null && _e !== void 0 ? _e : [1, 1, 1, 1];
                                    var _clayViewerColor = _this.hexToRgb(matCfg === null || matCfg === void 0 ? void 0 : matCfg.color);
                                    if (_clayViewerColor) {
                                        _bColor[0] = _clayViewerColor[0];
                                        _bColor[1] = _clayViewerColor[1];
                                        _bColor[2] = _clayViewerColor[2];
                                    }
                                    var _eColor = (_f = m.emissiveFactor) !== null && _f !== void 0 ? _f : [0, 0, 0];
                                    // //test--------
                                    // _eColor[0] = 3;
                                    // _eColor[1] = 0;
                                    // _eColor[2] = 0;
                                    // //------------
                                    //
                                    mat.setVector4('CustomBasecolor', new m4m.math.vector4(_bColor[0], _bColor[1], _bColor[2], _bColor[3]));
                                    mat.setFloat('CustomMetallic', (_j = (_g = matCfg === null || matCfg === void 0 ? void 0 : matCfg.metalness) !== null && _g !== void 0 ? _g : (_h = m.pbrMetallicRoughness) === null || _h === void 0 ? void 0 : _h.metallicFactor) !== null && _j !== void 0 ? _j : 1);
                                    mat.setFloat('CustomRoughness', (_m = (_k = matCfg === null || matCfg === void 0 ? void 0 : matCfg.roughness) !== null && _k !== void 0 ? _k : (_l = m.pbrMetallicRoughness) === null || _l === void 0 ? void 0 : _l.roughnessFactor) !== null && _m !== void 0 ? _m : 1);
                                    mat.setVector4('CustomEmissiveColor', new m4m.math.vector4(_eColor[0], _eColor[1], _eColor[2], 1));
                                    // console.log(matCfg.name);
                                    // console.table({...m.pbrMetallicRoughness});
                                    // console.table(matCfg);
                                    // if (matCfg && matCfg.length > 0) {
                                    // mat.setFloatv("uvRepeat", new Float32Array([matCfg[0]?.uvRepeat[0] ?? 1, matCfg[0]?.uvRepeat[1] ?? 1]));
                                    // mat.setFloat("uvRepeat", matCfg?.uvRepeat[0] ?? 1);
                                    // } else {
                                    // mat.setFloat("uvRepeat", 1);
                                    // }
                                    var extenKHR_tex_t;
                                    if (m.pbrMetallicRoughness) {
                                        var _t = m.pbrMetallicRoughness, baseColorFactor = _t.baseColorFactor, baseColorTexture = _t.baseColorTexture, metallicFactor = _t.metallicFactor, roughnessFactor = _t.roughnessFactor, metallicRoughnessTexture = _t.metallicRoughnessTexture;
                                        if (baseColorTexture) {
                                            mat.setTexture("uv_Basecolor", uvChecker !== null && uvChecker !== void 0 ? uvChecker : textures[baseColorTexture.index]);
                                            //extensions
                                            var bcTexExten = baseColorTexture.extensions;
                                            if (bcTexExten) {
                                                if (hasKHR_texture_transform && bcTexExten.KHR_texture_transform) {
                                                    extenKHR_tex_t = bcTexExten.KHR_texture_transform;
                                                }
                                            }
                                        }
                                        if (metallicRoughnessTexture) {
                                            mat.setTexture("uv_MetallicRoughness", textures[metallicRoughnessTexture.index]);
                                        }
                                    }
                                    if (m.occlusionTexture) {
                                        mat.setTexture("uv_AO", textures[m.occlusionTexture.index]);
                                    }
                                    if (m.emissiveTexture) {
                                        mat.setTexture("uv_Emissive", textures[m.emissiveTexture.index]);
                                    }
                                    //tex transfrom
                                    var tex_ST = new m4m.math.vector4(1, 1, 0, 0);
                                    // clay-viewer 的配置优先
                                    var cViewScale = (_o = matCfg === null || matCfg === void 0 ? void 0 : matCfg.uvRepeat[0]) !== null && _o !== void 0 ? _o : 1;
                                    if (cViewScale != 1) {
                                        tex_ST.x = cViewScale;
                                        tex_ST.y = cViewScale;
                                    }
                                    else {
                                        if (extenKHR_tex_t) {
                                            if (extenKHR_tex_t.scale) {
                                                tex_ST.x *= (_p = extenKHR_tex_t.scale[0]) !== null && _p !== void 0 ? _p : 1;
                                                tex_ST.y *= (_q = extenKHR_tex_t.scale[1]) !== null && _q !== void 0 ? _q : 1;
                                            }
                                            if (extenKHR_tex_t.offset) {
                                                tex_ST.z = (_r = extenKHR_tex_t.offset[0]) !== null && _r !== void 0 ? _r : 0;
                                                tex_ST.w = (_s = extenKHR_tex_t.offset[1]) !== null && _s !== void 0 ? _s : 0;
                                            }
                                        }
                                    }
                                    mat.setFloat("uvRepeat", tex_ST.x); //之后 用 tex_ST 代替 uvRepeat
                                    return mat;
                                });
                                console.log("====gltf begin load mesh==");
                                gltf_1.dumpmem();
                                meshes = (_t = this.data.meshes) === null || _t === void 0 ? void 0 : _t.map(function (_a) {
                                    //二了呀，一个mesh的primitives基本上就是 同一个vbo
                                    //结果未必，不一定是同一个，要检查
                                    var name = _a.name, primitives = _a.primitives;
                                    var samevbo = true;
                                    for (var i = 1; i < primitives.length; i++) {
                                        if (primitives[i].attributes != primitives[0].attributes) {
                                            samevbo = false;
                                            break;
                                        }
                                    }
                                    console.log("====same vbo?" + samevbo);
                                    if (samevbo) {
                                        //这是为大型gltf优化的,有些大型gltf文件会公用vbo
                                        console.log("====gltf begin load one mesh " + name);
                                        gltf_1.dumpmem();
                                        var mf = new framework.mesh(folder + name);
                                        gltf_1.loadgltfvbo(ctx, mf, primitives[0], accessors);
                                        var info = new meshinfo();
                                        info.mesh = mf;
                                        info.lightMapTexST = [];
                                        info.outmats = [];
                                        console.log("after uploadVertexData");
                                        gltf_1.dumpmem();
                                        gltf_1.loadgltfebo_mix(ctx, mf, primitives, accessors, materials, hasLightMap, lightMapTexs, info);
                                        console.log("====gltf end load mesh " + name);
                                        gltf_1.dumpmem();
                                        return [info];
                                    }
                                    else {
                                        console.log("====gltf begin load one mesh " + name);
                                        gltf_1.dumpmem();
                                        var infos = [];
                                        for (var i = 0; i < primitives.length; i++) {
                                            var mf = new framework.mesh(folder + name);
                                            gltf_1.loadgltfvbo(ctx, mf, primitives[i], accessors);
                                            var info = new meshinfo();
                                            info.mesh = mf;
                                            info.lightMapTexST = [];
                                            info.outmats = [];
                                            gltf_1.loadgltfebo_one(ctx, mf, primitives[i], accessors, materials, hasLightMap, lightMapTexs, info);
                                            infos.push(info);
                                        }
                                        console.log("====gltf end load mesh " + name);
                                        gltf_1.dumpmem();
                                        return infos;
                                    }
                                });
                                nodes = (_u = this.data.nodes) === null || _u === void 0 ? void 0 : _u.map(function (_a) {
                                    var name = _a.name, mesh = _a.mesh, matrix = _a.matrix, rotation = _a.rotation, scale = _a.scale, translation = _a.translation, skin = _a.skin, camera = _a.camera, children = _a.children;
                                    var n = new m4m.framework.transform();
                                    n.name = name;
                                    if (matrix != null) {
                                        n.getLocalMatrix().rawData = matrix;
                                        m4m.math.matrixDecompose(n.getLocalMatrix(), n.localScale, n.localRotate, n.localTranslate);
                                    }
                                    else {
                                        if (translation != null)
                                            m4m.math.vec3Set(n.localTranslate, translation[0], translation[1], translation[2]);
                                        if (rotation != null) {
                                            n.localRotate.x = rotation[0];
                                            n.localRotate.y = rotation[1];
                                            n.localRotate.z = rotation[2];
                                            n.localRotate.w = rotation[3];
                                        }
                                        if (scale != null)
                                            m4m.math.vec3Set(n.localScale, scale[0], scale[1], scale[2]);
                                    }
                                    n.markDirty();
                                    if (mesh != null) {
                                        var realmeshs = meshes[mesh];
                                        for (var imesh = 0; imesh < realmeshs.length; imesh++) {
                                            var realmesh = realmeshs[imesh];
                                            var submesh = new m4m.framework.transform();
                                            var mfit = submesh.gameObject.addComponent("meshFilter");
                                            mfit.mesh = realmesh.mesh;
                                            var renderer = submesh.gameObject.addComponent("meshRenderer");
                                            renderer.materials = realmesh.outmats;
                                            for (var i = 0; i < realmesh.outmats.length; i++) {
                                                if (realmesh.lightMapTexST[i] != null) {
                                                    renderer.lightmapIndex = -2; //标记该节点使用非全局lightmap
                                                    m4m.math.vec4Set(renderer.lightmapScaleOffset, realmesh.lightMapTexST[i].x, realmesh.lightMapTexST[i].y, realmesh.lightMapTexST[i].z, realmesh.lightMapTexST[i].w);
                                                }
                                            }
                                            n.addChild(submesh);
                                        }
                                        // const child = meshes[mesh].map(({ m, mat, lTexST }) => {
                                        //     const texST: number[] = lTexST;
                                        //     const submesh = new m4m.framework.transform();
                                        //     const mf = submesh.gameObject.addComponent("meshFilter") as meshFilter;
                                        //     mf.mesh = m;
                                        //     const renderer = submesh.gameObject.addComponent("meshRenderer") as meshRenderer;
                                        //     renderer.materials = [mat];
                                        //     if (texST) {
                                        //         renderer.lightmapIndex = -2;    //标记该节点使用非全局lightmap
                                        //         math.vec4Set(renderer.lightmapScaleOffset, texST[0], texST[1], texST[2], texST[3]);
                                        //     }
                                        //     // renderer.materials.push(mat);
                                        //     // renderer.materials.push(new framework.material());
                                        //     // renderer.materials[0].setShader(mgr.getShader("shader/def"));
                                        //     // renderer.materials[0].setShader(mgr.getShader("simple.shader.json"));
                                        //     return submesh;
                                        // });
                                        // child.forEach(c => n.addChild(c));
                                    }
                                    return { n: n, children: children };
                                });
                                scene = new m4m.framework.transform();
                                parseNode = function (i) {
                                    var _a = nodes[i], n = _a.n, children = _a.children;
                                    children === null || children === void 0 ? void 0 : children.forEach(function (c) {
                                        n.addChild(parseNode(c));
                                    });
                                    return n;
                                };
                                roots = this.data.scenes[defaltScene].nodes.map(parseNode);
                                roots.forEach(function (r) { return scene.addChild(r); });
                                return [2 /*return*/, scene];
                        }
                    });
                });
            };
            gltf.loadgltfebo_mix = function (ctx, mf, primitives, accessors, materials, hasLightMap, lightMapTexs, info) {
                var mdata = mf.data;
                mdata.trisindex = [];
                mf.submesh = [];
                //let { attributes, indices, material, extensions } =primitive;    
                primitives.map(function (_a) {
                    var attributes = _a.attributes, indices = _a.indices, material = _a.material, extensions = _a.extensions;
                    var eboacc = accessors[indices];
                    gltf_1.loadgltfebo(eboacc, mf, materials[material], hasLightMap, lightMapTexs, info, extensions);
                });
                mf.glMesh.addIndex(ctx, mdata.trisindex.length);
                mf.glMesh.uploadIndexData(ctx, 0, mdata.genIndexDataArray());
                mf.glMesh.initVAO();
            };
            gltf.loadgltfebo_one = function (ctx, mf, primitive, accessors, materials, hasLightMap, lightMapTexs, info) {
                var mdata = mf.data;
                mdata.trisindex = [];
                mf.submesh = [];
                var attributes = primitive.attributes, indices = primitive.indices, material = primitive.material, extensions = primitive.extensions;
                //primitives.map(({ attributes, indices, material, extensions }) => {
                var eboacc = accessors[indices];
                gltf_1.loadgltfebo(eboacc, mf, materials[material], hasLightMap, lightMapTexs, info, extensions);
                //});
                mf.glMesh.addIndex(ctx, mdata.trisindex.length);
                mf.glMesh.uploadIndexData(ctx, 0, mdata.genIndexDataArray());
                mf.glMesh.initVAO();
            };
            gltf.loadgltfebo = function (eboacc, mf, outMat, hasLightMap, lightMapTexs, info, extensions) {
                var _a;
                //let eboacc = accessors[indices] as GltfAttr;
                //let eboAcc = new Accessor(accessors[indices], "indices");
                //let ebo = eboAcc.data as Uint32Array;
                var ebo;
                if (eboacc.componentType == 5125)
                    ebo = new Uint32Array(eboacc.bufferView.rawBuffer, eboacc.bufferView.byteOffset, eboacc.count);
                if (eboacc.componentType == 5123)
                    ebo = new Uint16Array(eboacc.bufferView.rawBuffer, eboacc.bufferView.byteOffset, eboacc.count);
                if (eboacc.componentType == 5121)
                    ebo = new Uint8Array(eboacc.bufferView.rawBuffer, eboacc.bufferView.byteOffset, eboacc.count);
                console.log("ebo count=" + ebo.length);
                var indexbegin = mf.data.trisindex.length;
                var mdata = mf.data;
                for (var i = 0; i < ebo.length / 3; i++) {
                    var i0 = ebo[i * 3 + 0];
                    var i1 = ebo[i * 3 + 1];
                    var i2 = ebo[i * 3 + 2];
                    mdata.trisindex.push(i0);
                    mdata.trisindex.push(i1);
                    mdata.trisindex.push(i2);
                }
                //mdata.trisindex = Array.from(ebo);
                // mf.glMesh.addIndex(ctx, ebo.length);
                // mf.glMesh.uploadIndexData(ctx, 0, ebo, eboAcc.componentType);
                //mf.submesh = [];
                var sm = new m4m.framework.subMeshInfo();
                sm.matIndex = mf.submesh.length;
                sm.useVertexIndex = 0;
                sm.start = indexbegin;
                sm.size = ebo.length;
                sm.line = false;
                mf.submesh.push(sm);
                // mf.glMesh.uploadIndexSubData(ctx, 0, ebo);
                //light Map
                var lightMapTexST = null;
                //let outMat: material = materials[matid];
                if (hasLightMap && extensions && extensions.gd_linfo) {
                    if (extensions.gd_linfo.so) {
                        lightMapTexST = extensions.gd_linfo.so;
                    }
                    else {
                        lightMapTexST = [1, 1, 0, 0];
                    }
                    var texIdx = (_a = extensions.gd_linfo.index) !== null && _a !== void 0 ? _a : 0;
                    var lightMapTex = lightMapTexs[texIdx];
                    if (lightMapTex) {
                        if (outMat.statedMapUniforms["_LightmapTex"]) {
                            outMat = outMat.clone(); //公用材质但lightmap 不同，需要clone一个新材质
                        }
                        outMat.setTexture("_LightmapTex", lightMapTex);
                        outMat = outMat;
                    }
                }
                info.outmats.push(outMat);
                info.lightMapTexST.push(lightMapTexST);
            };
            gltf.loadgltfvbo = function (ctx, mf, primitive, accessors) {
                var mdata = mf.data = new m4m.render.meshData();
                mdata.triIndexUint32Mode = true;
                var vert = mdata.pos = [];
                var uv1 = mdata.uv = [];
                var uv2 = mdata.uv2 = [];
                var normal = mdata.normal = [];
                var tangent = mdata.tangent = [];
                var attr = {};
                for (var k in primitive.attributes) {
                    var attrview = accessors[primitive.attributes[k]];
                    attr[k] = attrview;
                }
                var vcount = attr.POSITION.count;
                var bs = +(attr.POSITION ? 3 : 0)
                    + (attr.NORMAL ? 3 : 0)
                    + (attr.COLOR ? 4 : 0)
                    + (attr.TANGENT ? 3 : 0) // 引擎里的Tangent是vec3，而不是vec4
                    + (attr.TEXCOORD_0 ? 2 : 0)
                    + (attr.TEXCOORD_1 ? 2 : 0);
                var vbo = new Float32Array(vcount * bs);
                console.log("vcount=" + vcount);
                mf.glMesh = new m4m.render.glMesh();
                var vf;
                if (attr.POSITION)
                    vf |= m4m.render.VertexFormatMask.Position;
                if (attr.NORMAL)
                    vf |= m4m.render.VertexFormatMask.Normal;
                if (attr.COLOR)
                    vf |= m4m.render.VertexFormatMask.Color;
                if (attr.TANGENT)
                    vf |= m4m.render.VertexFormatMask.Tangent;
                if (attr.TEXCOORD_0)
                    vf |= m4m.render.VertexFormatMask.UV0;
                if (attr.TEXCOORD_1)
                    vf |= m4m.render.VertexFormatMask.UV1;
                // | m4m.render.VertexFormatMask.BlendIndex4
                // | m4m.render.VertexFormatMask.BlendWeight4;
                console.log("before initBuffer");
                gltf_1.dumpmem();
                mf.glMesh.initBuffer(ctx, vf, vcount, m4m.render.MeshTypeEnum.Static);
                var uv0data = null;
                var uv1data = null;
                var posdata = null;
                var nordata = null;
                var tandata = null;
                if (attr.TEXCOORD_0 != null) {
                    uv0data = new Float32Array(attr.TEXCOORD_0.bufferView.rawBuffer, attr.TEXCOORD_0.bufferView.byteOffset);
                    console.log("attr uv0");
                    gltf_1.dumpmem();
                }
                if (attr.TEXCOORD_1 != null) {
                    uv1data = new Float32Array(attr.TEXCOORD_1.bufferView.rawBuffer, attr.TEXCOORD_1.bufferView.byteOffset);
                    console.log("attr uv1");
                    gltf_1.dumpmem();
                }
                if (attr.POSITION != null) {
                    posdata = new Float32Array(attr.POSITION.bufferView.rawBuffer, attr.POSITION.bufferView.byteOffset);
                    console.log("attr pos");
                    gltf_1.dumpmem();
                }
                if (attr.NORMAL != null) {
                    nordata = new Float32Array(attr.NORMAL.bufferView.rawBuffer, attr.NORMAL.bufferView.byteOffset);
                    console.log("attr nor");
                    gltf_1.dumpmem();
                }
                if (attr.TANGENT != null) {
                    tandata = new Float32Array(attr.TANGENT.bufferView.rawBuffer, attr.TANGENT.bufferView.byteOffset);
                    console.log("attr tan");
                    gltf_1.dumpmem();
                }
                console.log("after initBuffer");
                gltf_1.dumpmem();
                for (var i = 0; i < vcount; i++) {
                    if (uv0data != null) {
                        var uvFliped0 = uv0data[i * 2 + 0];
                        var uvFliped1 = uv0data[i * 2 + 1];
                        uv1[i] = new m4m.math.vector2(uvFliped0, uvFliped1 * -1 + 1);
                    }
                    if (uv1data != null) {
                        var uvFliped0 = uv1data[i * 2 + 0];
                        var uvFliped1 = uv1data[i * 2 + 1];
                        uv2[i] = new m4m.math.vector2(uvFliped0, uvFliped1 * -1 + 1);
                    }
                    if (posdata != null) {
                        var _pos0 = posdata[i * 3 + 0];
                        var _pos1 = posdata[i * 3 + 1];
                        var _pos2 = posdata[i * 3 + 2];
                        vert[i] = new m4m.math.vector3(_pos0, _pos1, _pos2);
                    }
                    if (nordata != null) {
                        var _pos0 = nordata[i * 3 + 0];
                        var _pos1 = nordata[i * 3 + 1];
                        var _pos2 = nordata[i * 3 + 2];
                        normal[i] = new m4m.math.vector3(_pos0, _pos1, _pos2);
                    }
                    if (tandata != null) {
                        var t = new m4m.math.vector3(tandata[i * 4 + 0], tandata[i * 4 + 1], tandata[i * 4 + 2]);
                        //处理 w 分量 , w 存入 xyz 中, w 只因为为1 或 -1 ,表示为切向方向性。
                        //将w 平移2 , 映射为 -1 -> 1 , 1 -> 3 ，这样保障 normalize 后 xyz 一致                                                                                                                                                                                                                                      
                        var w = tandata[i * 4 + 3] + 2;
                        //将w 乘入 xyz , x = x * w , y = y * w , y = y * w 
                        m4m.math.vec3ScaleByNum(t, w, t);
                        tangent[i] = t;
                    }
                    var cur = vbo.subarray(i * bs); // offset
                    var bit = 0;
                    if (attr.POSITION != null) {
                        var position = cur.subarray(bit, bit += 3);
                        position[0] = vert[i].x;
                        position[1] = vert[i].y;
                        position[2] = vert[i].z;
                    }
                    // const color = cur.subarray(3, 7);
                    if (attr.NORMAL != null) {
                        var n = cur.subarray(bit, bit += 3);
                        n[0] = normal[i].x;
                        n[1] = normal[i].y;
                        n[2] = normal[i].z;
                    }
                    if (attr.TANGENT != null) {
                        var tan = cur.subarray(bit, bit += 3);
                        var t = tangent[i];
                        tan[0] = t.x;
                        tan[1] = t.y;
                        tan[2] = t.z;
                    }
                    if (attr.TEXCOORD_0 != null) {
                        var _uv = cur.subarray(bit, bit += 2);
                        var u = uv1[i];
                        _uv[0] = u.x;
                        _uv[1] = u.y;
                    }
                    if (attr.TEXCOORD_1 != null) {
                        var _uv2 = cur.subarray(bit, bit += 2);
                        var u = uv2[i];
                        _uv2[0] = u.x;
                        _uv2[1] = u.y;
                    }
                    // const tangent = cur.subarray(7, 9);
                    // colors[i] = new m4m.math.vector4();
                }
                mf.glMesh.uploadVertexData(ctx, vbo);
            };
            /**
             * 获取实时灯光列表详细
             */
            gltf.prototype.getRealtimeLights = function () {
                var extUsed = this.data.extensionsUsed;
                if (!extUsed || extUsed.indexOf("gd_realtime_lights") == -1)
                    return;
                var scenes = this.data.scenes;
                if (!scenes || !scenes[0].extensions)
                    return;
                var gd_realtime_lights = scenes[0].extensions.gd_realtime_lights;
                if (!gd_realtime_lights || !gd_realtime_lights.lightInfos)
                    return;
                return gd_realtime_lights.lightInfos;
            };
            var gltf_1;
            gltf.ClassName = "gltf";
            /** 必要依赖 已支持 记录字典容器 */
            gltf.requiredSupportedMap = {
                "KHR_texture_transform": true,
                "gd_realtime_lights": true,
                "gd_linfo": true,
                "gd_linfo_scene": true,
            };
            __decorate([
                m4m.reflect.Field("constText"),
                __metadata("design:type", framework.constText)
            ], gltf.prototype, "name", void 0);
            gltf = gltf_1 = __decorate([
                m4m.reflect.SerializeType,
                __metadata("design:paramtypes", [String, Object])
            ], gltf);
            return gltf;
        }());
        framework.gltf = gltf;
        /** 灯光阴影质量 */
        var ShadowQualityType;
        (function (ShadowQualityType) {
            ShadowQualityType[ShadowQualityType["None"] = 0] = "None";
            ShadowQualityType[ShadowQualityType["Low"] = 1] = "Low";
            ShadowQualityType[ShadowQualityType["Medium"] = 2] = "Medium";
            ShadowQualityType[ShadowQualityType["High"] = 3] = "High";
        })(ShadowQualityType = framework.ShadowQualityType || (framework.ShadowQualityType = {}));
        var Accessor = /** @class */ (function () {
            function Accessor(_a, name) {
                var bufferView = _a.bufferView, _b = _a.byteOffset, byteOffset = _b === void 0 ? 0 : _b, componentType = _a.componentType, _c = _a.normalized, normalized = _c === void 0 ? false : _c, count = _a.count, type = _a.type, _d = _a.max, max = _d === void 0 ? [] : _d, _e = _a.min, min = _e === void 0 ? [] : _e;
                if (name === void 0) { name = ''; }
                this.attribute = name;
                this.bufferView = bufferView;
                this.byteOffset = byteOffset;
                this.componentType = componentType;
                this.normalized = normalized;
                this.count = count;
                this.max = max;
                this.min = min;
                this.size = Accessor.types[type];
            }
            Object.defineProperty(Accessor.prototype, "data", {
                get: function () {
                    if (!this._data)
                        this._data = Accessor.getData(this);
                    return this._data;
                },
                enumerable: false,
                configurable: true
            });
            Accessor.newFloat32Array = function (acc) {
                return new Float32Array(acc.bufferView.rawBuffer, acc.byteOffset + acc.bufferView.byteOffset, acc.size * acc.count);
            };
            Accessor.getSubChunks = function (acc, data) {
                var blocks = [];
                for (var i = 0; i < acc.count; i++) {
                    var offset = i * acc.size;
                    blocks.push(data.subarray(offset, offset + acc.size));
                }
                return blocks;
            };
            Accessor.getFloat32Blocks = function (acc) {
                return this.getSubChunks(acc, Accessor.newTypedArray(acc));
            };
            Accessor.newTypedArray = function (acc) {
                switch (acc.componentType) {
                    case 5120:
                        return new Int8Array(acc.bufferView.rawBuffer, acc.byteOffset + acc.bufferView.byteOffset, acc.size * acc.count);
                    case 5121:
                        return new Uint8Array(acc.bufferView.rawBuffer, acc.byteOffset + acc.bufferView.byteOffset, acc.size * acc.count);
                    case 5122:
                        return new Int16Array(acc.bufferView.rawBuffer, acc.byteOffset + acc.bufferView.byteOffset, acc.size * acc.count);
                    case 5123:
                        return new Uint16Array(acc.bufferView.rawBuffer, acc.byteOffset + acc.bufferView.byteOffset, acc.size * acc.count);
                    case 5125:
                        return new Uint32Array(acc.bufferView.rawBuffer, acc.byteOffset + acc.bufferView.byteOffset, acc.size * acc.count);
                    case 5126:
                        return new Float32Array(acc.bufferView.rawBuffer, acc.byteOffset + acc.bufferView.byteOffset, acc.size * acc.count);
                }
            };
            Accessor.getData = function (acc) {
                if (acc.size > 1) {
                    return this.getFloat32Blocks(acc);
                }
                return this.newTypedArray(acc);
            };
            Accessor.types = {
                "SCALAR": 1,
                'VEC1': 1,
                'VEC2': 2,
                'VEC3': 3,
                'VEC4': 4,
                "MAT2": 4,
                "MAT3": 9,
                "MAT4": 16,
            };
            return Accessor;
        }());
        framework.Accessor = Accessor;
        var meshinfo = /** @class */ (function () {
            function meshinfo() {
            }
            return meshinfo;
        }());
        var GltfAttr = /** @class */ (function () {
            function GltfAttr() {
            }
            return GltfAttr;
        }());
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../io/reflect.ts" />
var m4m;
/// <reference path="../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * transform类 对应unity中transform概念
         * @version m4m 1.0
         */
        var transform = /** @class */ (function () {
            function transform() {
                this.helpLRotate = new m4m.math.quaternion();
                this.helpLPos = new m4m.math.vector3();
                this.helpLScale = new m4m.math.vector3(1, 1, 1);
                // /**自己是否有组件 */
                // hasComponent: boolean = false; 
                // /**子对象是否有组件  */
                // hasComponentChild: boolean = false; 
                /** 自己是否有渲染器组件 */
                this.hasRendererComp = false;
                /** 子对象是否有渲染器组件 */
                this.hasRendererCompChild = false;
                /**自己是否有需要update方法的组件 */
                this.hasUpdateComp = false;
                /**子对象是否有需要update方法的组件 */
                this.hasUpdateCompChild = false;
                /**自己是否有需要init方法的组件 */
                this.hasInitComp = false;
                /**子对象是否有需要init方法的组件 */
                this.hasInitCompChild = false;
                /**自己是否有需要OnPlay方法的组件 */
                this.hasOnPlayComp = false;
                /**子对象是否有需要OnPlay方法的组件 */
                this.hasOnPlayCompChild = false;
                /** 需要每帧调用组件update , 设置为false 该节点以及子节点都会跳过update 函数的调用（减少消耗）*/
                this.needUpdate = true;
                /** 需要每帧筛查FillRenderer , 设置为false 该节点以及子节点都会跳过FillRenderer 函数的调用（减少消耗）*/
                this.needFillRenderer = true;
                /** 需要gpuInstanceBatcher 模式渲染 (减少渲染消耗 , 仅适合静态物)*/
                this.needGpuInstancBatcher = false;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * transform名称
                 * @version m4m 1.0
                 */
                this.name = "noname";
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * transform唯一的insid
                 * @version m4m 1.0
                 */
                this.insId = new insID();
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 当前节点依赖的prefab路径，如果不依赖，则为空
                 * @version m4m 1.0
                 */
                this.prefab = "";
                // private aabbdirty: boolean = true;
                // /**
                // * @private
                // * @language zh_CN
                // * 标记aabb已修改
                // * @version m4m 1.0
                // */
                // markAABBDirty()
                // {
                //     this.aabbdirty = true;
                //     this.markAABBChildDirty();//自己AABB变化了 整体的AABB（即包含所有子节点的AABB）肯定也需要改变
                //     //自己的AABB变化了 ，包含自己节点的总AABB也需要改变
                //     var p = this._parent;
                //     while (p != null)
                //     {
                //         p.markAABBChildDirty();
                //         p = p._parent;
                //     }
                // }
                // private aabbchilddirty: boolean = true;
                // /**
                // * @private
                // * @language zh_CN
                // * 标记aabb集合已修改
                // * @version m4m 1.0
                // */
                // markAABBChildDirty()
                // {
                //     this.aabbchilddirty = true;
                // }
                this._dirtyAABB = true;
                // private _children: transform[] = [];
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 子物体列表
                 * @version m4m 1.0
                 */
                this.children = [];
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 对象RTS有变化了,视锥剔除使用
                 * @version m4m 1.0
                 */
                this.dirtiedOfFrustumCulling = false;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 是否在任意摄像机视野内
                 * @version m4m 1.0
                 */
                this.inCameraVisible = false;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 当前物体视锥剔除开关
                 * @version m4m 1.0
                 */
                this.enableCulling = true;
                this.dirtyLocal = false;
                this.dirtyWorld = false;
                // /**
                // * @private
                // * @language zh_CN
                // * @classdesc
                // * 刷新自己的aabb集合
                // * @version m4m 1.0
                // */
                // updateAABBChild()
                // {
                //     if (this.aabbchilddirty)
                //     {
                //         if (this._children != null)
                //         {
                //             for (var i = 0; i < this._children.length; i++)
                //             {
                //                 this._children[i].updateAABBChild();
                //             }
                //         }
                //         this.caclAABBChild();
                //         this.aabbchilddirty = false;
                //     }
                // }
                this._localRotate = new m4m.math.quaternion();
                this._localTranslate = new m4m.math.vector3(0, 0, 0);
                this._localScale = new m4m.math.vector3(1, 1, 1);
                this.localMatrix = new m4m.math.matrix();
                this._localEulerAngles = new m4m.math.vector3(0, 0, 0);
                //这个是如果爹改了就要跟着算的
                this.worldMatrix = new m4m.math.matrix();
                this.worldRotate = new m4m.math.quaternion();
                this.worldTranslate = new m4m.math.vector3(0, 0, 0);
                this.worldScale = new m4m.math.vector3(1, 1, 1);
                //第一次计算世界坐标
                this.firstCalc = true;
                this._beDispose = false; //是否被释放了
                this.gameObject = new framework.gameObject();
                this.gameObject.transform = this;
            }
            transform_2 = transform;
            transform.prototype.checkLRTSChange = function () {
                if (!this.fastEqual(this.helpLPos, this._localTranslate))
                    return true;
                if (!this.fastEqual(this.helpLRotate, this._localRotate))
                    return true;
                if (!this.fastEqual(this.helpLScale, this._localScale))
                    return true;
                return false;
            };
            transform.prototype.fastEqual = function (d_0, d_1) {
                if (d_0.x != d_1.x)
                    return false;
                if (d_0.y != d_1.y)
                    return false;
                if (d_0.z != d_1.z)
                    return false;
                // if (d_0[0] != d_1[0]) return false;
                // if (d_0[1] != d_1[1]) return false;
                // if (d_0[2] != d_1[2]) return false;
                // if (d_0.length == 4 && d_0[3] != d_1[3])
                //     return false;
                return true;
            };
            Object.defineProperty(transform.prototype, "scene", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 获取所在场景
                 * @version m4m 1.0
                 */
                get: function () {
                    if (this._scene == null) {
                        if (this._parent == null)
                            return null;
                        this._scene = this._parent.scene;
                    }
                    return this._scene;
                },
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 设置所在场景实例
                 * @param value 场景实例
                 * @version m4m 1.0
                 */
                set: function (value) {
                    this._scene = value;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * [过时接口,完全弃用]
             */
            transform.prototype.updateWorldTran = function () {
            };
            /**
             * [过时接口,完全弃用]
             * @param bool
             */
            transform.prototype.updateTran = function (bool) {
            };
            Object.defineProperty(transform.prototype, "aabb", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 自己的aabb
                 * @version m4m 1.0
                 */
                get: function () {
                    if (!this._aabb) {
                        this._aabb = this._buildAABB();
                    }
                    if (this._dirtyAABB) {
                        this._aabb.update(this.getWorldMatrix());
                        this._dirtyAABB = false;
                    }
                    return this._aabb;
                },
                enumerable: false,
                configurable: true
            });
            /**
            * @private
            * @language zh_CN
            * 构建aabb
            * @version m4m 1.0
            */
            transform.prototype._buildAABB = function () {
                var minimum = new m4m.math.vector3();
                var maximum = new m4m.math.vector3();
                var _types = transform_2.aabbCareTypes;
                var len = _types.length;
                var matched = false;
                for (var i = 0; i < len; i++) {
                    var t = _types[i];
                    switch (t) {
                        case framework.meshFilter.ClassName:
                            var filter = this.gameObject.getComponent("meshFilter");
                            if (filter != null && filter.mesh != null) {
                                var m = filter.mesh;
                                if (m.maximun && m.minimun) {
                                    //mesh上自带 min max
                                    minimum = m.minimun;
                                    maximum = m.maximun;
                                    matched = true;
                                }
                                else if (filter.mesh.data != null && filter.mesh.data.getVertexCount() > 0) {
                                    var id = m.getGUID();
                                    var min_max_v3 = transform_2.aabbStoreMap[id]; //优化 每次实例化都需构建
                                    if (min_max_v3) {
                                        //取缓存数据
                                        minimum = min_max_v3[0];
                                        maximum = min_max_v3[1];
                                    }
                                    else {
                                        //根据 mesh 顶点数据生成
                                        var meshdata = m.data;
                                        m4m.math.vec3SetByFloat(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, minimum);
                                        m4m.math.vec3SetByFloat(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, maximum);
                                        // let len = meshdata.getTriIndexCount();
                                        // let pos = meshdata.pos;
                                        // for (var i = 0; i < len; i++) {
                                        //     math.vec3Max(pos[i], maximum, maximum);
                                        //     math.vec3Min(pos[i], minimum, minimum);
                                        // }
                                        meshdata.foreachVertexData(function (v, i) {
                                            var p = v.pos;
                                            m4m.math.vec3Max(p, maximum, maximum);
                                            m4m.math.vec3Min(p, minimum, minimum);
                                        });
                                        transform_2.aabbStoreMap[id] = [minimum, maximum];
                                    }
                                    matched = true;
                                }
                            }
                            break;
                        case framework.skinnedMeshRenderer.ClassName:
                            var skinmesh = this.gameObject.getComponent("skinnedMeshRenderer");
                            if (filter != null && filter.mesh != null) {
                                var m = skinmesh.mesh;
                                if (m.maximun && m.minimun) {
                                    minimum = m.minimun;
                                    maximum = m.maximun;
                                    matched = true;
                                }
                                else if (skinmesh.mesh.data != null && skinmesh.mesh.data.getVertexCount() > 0) {
                                    var id = m.getGUID();
                                    var min_max_v3 = transform_2.aabbStoreMap[id]; //优化 每次实例化都需构建
                                    if (min_max_v3) {
                                        minimum = min_max_v3[0];
                                        maximum = min_max_v3[1];
                                    }
                                    else {
                                        // NOTE: 如果当前物体有骨骼动画, 则不会使用这里的aabb进行剔除
                                        var skinmeshdata = skinmesh.mesh.data;
                                        m4m.math.vec3SetByFloat(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, minimum);
                                        m4m.math.vec3SetByFloat(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, maximum);
                                        var p0 = m4m.math.pool.new_vector3();
                                        var len_1 = skinmeshdata.getVertexCount();
                                        for (var i = 0; i < len_1; i++) {
                                            skinmesh.calActualVertexByIndex(i, p0);
                                            m4m.math.vec3Max(p0, maximum, maximum);
                                            m4m.math.vec3Min(p0, minimum, minimum);
                                        }
                                        m4m.math.pool.delete_vector3(p0);
                                        transform_2.aabbStoreMap[id] = [minimum, maximum];
                                    }
                                    matched = true;
                                }
                            }
                            break;
                        case framework.canvasRenderer.ClassName:
                            var canvasR = this.gameObject.getComponent("canvasRenderer");
                            if (canvasR && canvasR.canvas) {
                                m4m.math.vec3Set(minimum, -1, -1, 0);
                                m4m.math.vec3Set(maximum, 1, 1, 0);
                                matched = true;
                            }
                            break;
                    }
                    if (matched)
                        break;
                }
                if (!matched) {
                    minimum.x = minimum.y = minimum.z = -1;
                    maximum.x = maximum.y = maximum.z = 1;
                }
                var _aabb = new framework.aabb(minimum, maximum);
                return _aabb;
            };
            Object.defineProperty(transform.prototype, "physicsImpostor", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 物理代理对象
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._physicsImpostor;
                },
                set: function (physicsImp) {
                    this._physicsImpostor = physicsImp;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(transform.prototype, "parent", {
                get: function () {
                    return this._parent;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 添加子物体实例
             * @param node 子物体实例
             * @version m4m 1.0
             */
            transform.prototype.addChild = function (node) {
                this.addChildAt(node, this.children.length);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 添加子物体实例到索引位置
             * @param node 场景实例
             * @param index 索引位置
             * @version m4m 1.0
             */
            transform.prototype.addChildAt = function (node, index) {
                if (index < 0)
                    return;
                if (!node) {
                    console.error("node is null?? ".concat(this.name));
                    console.error(new Error().stack);
                    return;
                }
                if (node._parent != null) {
                    node._parent.removeChild(node);
                }
                if (this.children == null)
                    this.children = [];
                this.children.splice(index, 0, node);
                node.scene = this.scene;
                node._parent = this;
                framework.sceneMgr.app.markNotify(node, framework.NotifyType.AddChild);
                // if (node.hasComponent || node.hasComponentChild)
                //     this.markHaveComponent();
                if (node.hasRendererComp || node.hasRendererCompChild)
                    node.markHaveRendererComp(node.hasRendererComp);
                if (node.hasUpdateComp || node.hasUpdateCompChild)
                    node.markHaveUpdateComp(node.hasUpdateComp);
                if (node.hasInitComp || node.hasInitCompChild)
                    node.markHaveInitComp(node.hasInitComp);
                if (node.hasOnPlayComp || node.hasOnPlayCompChild)
                    node.markHaveOnplayComp(node.hasOnPlayComp);
                node.dirtify(true);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 移除所有子物体
             * @version m4m 1.0
             */
            transform.prototype.removeAllChild = function (needDispose) {
                if (needDispose === void 0) { needDispose = false; }
                if (this.children == undefined)
                    return;
                while (this.children.length > 0) {
                    if (needDispose)
                        this.children[0].dispose();
                    else
                        this.removeChild(this.children[0]);
                }
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 移除指定子物体
             * @param node 子物体实例
             * @version m4m 1.0
             */
            transform.prototype.removeChild = function (node) {
                if (node._parent != this || this.children == null || this.children.length < 1) {
                    console.warn("not my child.");
                    return;
                }
                var i = this.children.indexOf(node);
                if (i >= 0) {
                    this.children.splice(i, 1);
                    framework.sceneMgr.app.markNotify(node, framework.NotifyType.RemoveChild);
                    node._parent = null;
                }
                if (this.children.length < 1) {
                    // this.hasComponentChild = false;
                    this.hasInitCompChild = false;
                    this.hasOnPlayCompChild = false;
                    this.hasRendererCompChild = false;
                    this.hasUpdateCompChild = false;
                }
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 查找自己以及子物体中是否有指定名称的transform
             * @param name
             * @version m4m 1.0
             */
            transform.prototype.find = function (name) {
                if (this.name == name)
                    return this;
                else {
                    if (this.children != undefined) {
                        for (var i in this.children) {
                            var res = this.children[i].find(name);
                            if (res != null)
                                return res;
                            else {
                                continue;
                            }
                        }
                    }
                }
                return null;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 判断是否与给定的transform有碰撞
             * @param tran 指定的transform
             * @version m4m 1.0
             */
            transform.prototype.checkImpactTran = function (tran) {
                if (this.gameObject.collider == null)
                    return false;
                return this.gameObject.collider.intersectsTransform(tran);
            };
            //
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 返回场景中所有与当前tranform碰撞的transform
             * @version m4m 1.0
             */
            transform.prototype.checkImpact = function () {
                var trans = new Array();
                this.doImpact(this.scene.getRoot(), trans);
                return trans;
            };
            transform.prototype.doImpact = function (tran, impacted) {
                if (tran == this)
                    return;
                if (tran.gameObject != null && tran.gameObject.collider != null) {
                    if (this.checkImpactTran(tran)) {
                        impacted.push(tran);
                    }
                }
                if (tran.children != null) {
                    for (var i = 0; i < tran.children.length; i++) {
                        this.doImpact(tran.children[i], impacted);
                    }
                }
            };
            transform.prototype.dirtify = function (local) {
                if (local === void 0) { local = false; }
                this.dirtiedOfFrustumCulling = true;
                if ((!local || (local && this.dirtyLocal)) && this.dirtyWorld) {
                    return;
                }
                if (local) {
                    this.dirtyLocal = true;
                }
                if (!this.dirtyWorld) {
                    this.dirtyWorld = true;
                    var i = this.children.length;
                    while (i--) {
                        if (this.children[i].dirtyWorld) {
                            continue;
                        }
                        this.children[i].dirtify();
                    }
                }
                //----------------------------------------
                //this.markAABBDirty(); //下阶段修改
                this._dirtyAABB = true;
            };
            //同步自己的 W 、L 矩阵
            transform.prototype.sync = function () {
                if (this.dirtyLocal) {
                    m4m.math.matrixMakeTransformRTS(this._localTranslate, this._localScale, this._localRotate, this.localMatrix);
                    m4m.math.vec3Clone(this._localTranslate, this.helpLPos);
                    m4m.math.vec3Clone(this._localScale, this.helpLScale);
                    m4m.math.quatClone(this._localRotate, this.helpLRotate);
                    this.dirtyLocal = false;
                }
                if (this.dirtyWorld) {
                    if (!this._parent) {
                        m4m.math.matrixClone(this.localMatrix, this.worldMatrix);
                    }
                    else {
                        m4m.math.matrixMultiply(this._parent.worldMatrix, this.localMatrix, this.worldMatrix);
                    }
                    this.dirtyWorld = false;
                }
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * [ 过时接口,现不需要标记变化]
             * @version m4m 1.0
             */
            transform.prototype.markDirty = function () {
                // this.dirty = true;
                // var p = this._parent;
                // while (p != null)
                // {
                //     p.dirtyChild = true;
                //     p = p._parent;
                // }
            };
            // markHaveComponent()
            // {
            //     this.hasComponent = true;
            //     var p = this._parent;
            //     while (p != null)
            //     {
            //         p.hasComponentChild = true;
            //         p = p._parent;
            //     }
            // }
            transform.prototype.markHaveRendererComp = function (selfHas) {
                if (selfHas === void 0) { selfHas = true; }
                this.hasRendererComp = this.hasRendererComp || selfHas;
                var p = this._parent;
                while (p != null) {
                    p.hasRendererCompChild = true;
                    p = p._parent;
                }
            };
            transform.prototype.markHaveUpdateComp = function (selfHas) {
                if (selfHas === void 0) { selfHas = true; }
                this.hasUpdateComp = this.hasUpdateComp || selfHas;
                var p = this._parent;
                while (p != null) {
                    p.hasUpdateCompChild = true;
                    p = p._parent;
                }
            };
            transform.prototype.markHaveInitComp = function (selfHas) {
                if (selfHas === void 0) { selfHas = true; }
                this.hasInitComp = this.hasInitComp || selfHas;
                var p = this._parent;
                while (p != null && !p.hasInitCompChild) {
                    p.hasInitCompChild = true;
                    p = p._parent;
                }
            };
            transform.prototype.markHaveOnplayComp = function (selfHas) {
                if (selfHas === void 0) { selfHas = true; }
                this.hasOnPlayComp = this.hasOnPlayComp || selfHas;
                var p = this._parent;
                while (p != null && !p.hasOnPlayCompChild) {
                    p.hasOnPlayCompChild = true;
                    p = p._parent;
                }
            };
            Object.defineProperty(transform.prototype, "localRotate", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 本地旋转四元数
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._localRotate;
                },
                set: function (rotate) {
                    m4m.math.quatClone(rotate, this._localRotate);
                    if (!this.dirtyLocal) {
                        this.dirtify(true);
                    }
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(transform.prototype, "localTranslate", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 本地位移
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._localTranslate;
                },
                set: function (position) {
                    m4m.math.vec3Clone(position, this._localTranslate);
                    if (!this.dirtyLocal) {
                        this.dirtify(true);
                    }
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(transform.prototype, "localPosition", {
                /**
                * @public
                * @language zh_CN
                * @classdesc
                * 本地位移
                * @version m4m 1.0
                */
                get: function () {
                    return this._localTranslate;
                },
                set: function (position) {
                    m4m.math.vec3Clone(position, this._localTranslate);
                    if (!this.dirtyLocal) {
                        this.dirtify(true);
                    }
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(transform.prototype, "localScale", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 本地缩放
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._localScale;
                },
                set: function (scale) {
                    m4m.math.vec3Clone(scale, this._localScale);
                    if (!this.dirtyLocal) {
                        this.dirtify(true);
                    }
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(transform.prototype, "localEulerAngles", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 本地旋转的欧拉角
                 * @version m4m 1.0
                 */
                get: function () {
                    m4m.math.quatToEulerAngles(this._localRotate, this._localEulerAngles);
                    return this._localEulerAngles;
                },
                set: function (angles) {
                    m4m.math.quatFromEulerAngles(angles.x, angles.y, angles.z, this._localRotate);
                    if (!this.dirtyLocal) {
                        this.dirtify(true);
                    }
                },
                enumerable: false,
                configurable: true
            });
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取世界坐标系下的旋转
             * @version m4m 1.0
             */
            transform.prototype.getWorldRotate = function () {
                if (!this._parent || !this._parent._parent) {
                    m4m.math.quatClone(this._localRotate, this.worldRotate);
                }
                else {
                    m4m.math.matrixGetRotation(this.getWorldMatrix(), this.worldRotate);
                }
                return this.worldRotate;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 设置transform世界空间下的旋转
             *
             */
            transform.prototype.setWorldRotate = function (rotate) {
                if (!this._parent || !this._parent._parent) {
                    m4m.math.quatClone(rotate, this._localRotate);
                }
                else {
                    var tquat = transform_2.helpquat;
                    var tquat_1 = transform_2.helpquat_1;
                    m4m.math.quatClone(this._parent.getWorldRotate(), tquat);
                    m4m.math.quatInverse(tquat, tquat_1);
                    m4m.math.quatMultiply(tquat_1, rotate, this._localRotate);
                }
                if (!this.dirtyLocal) {
                    this.dirtify(true);
                }
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取世界坐标系下的位移
             * @version m4m 1.0
             */
            transform.prototype.getWorldTranslate = function () {
                if (!this.firstCalc && this.gameObject.isStatic) {
                    return this.worldTranslate;
                }
                if (!this._parent || !this._parent._parent) {
                    m4m.math.vec3Clone(this._localTranslate, this.worldTranslate);
                }
                else {
                    m4m.math.matrixGetTranslation(this.getWorldMatrix(), this.worldTranslate);
                }
                if (this.firstCalc)
                    this.firstCalc = false;
                return this.worldTranslate;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取世界坐标系下的位移
             * @version m4m 1.0
             */
            transform.prototype.getWorldPosition = function () {
                if (!this._parent || !this._parent._parent) {
                    m4m.math.vec3Clone(this._localTranslate, this.worldTranslate);
                }
                else {
                    m4m.math.matrixGetTranslation(this.getWorldMatrix(), this.worldTranslate);
                }
                return this.worldTranslate;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 设置transform世界空间下的位移
             * @param pos 世界空间下的坐标
             * @version m4m 1.0
             */
            transform.prototype.setWorldPosition = function (pos) {
                if (!this._parent || !this._parent._parent) {
                    m4m.math.vec3Clone(pos, this._localTranslate);
                }
                else {
                    var tmtx = transform_2.helpmtx;
                    m4m.math.matrixInverse(this._parent.getWorldMatrix(), tmtx);
                    m4m.math.matrixTransformVector3(pos, tmtx, this._localTranslate);
                }
                if (!this.dirtyLocal) {
                    this.dirtify(true);
                }
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取世界坐标系下的缩放
             * @version m4m 1.0
             */
            transform.prototype.getWorldScale = function () {
                if (!this._parent || !this._parent._parent) {
                    m4m.math.vec3Clone(this._localScale, this.worldScale);
                }
                else {
                    m4m.math.matrixGetScale(this.getWorldMatrix(), this.worldScale);
                }
                return this.worldScale;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 设置世界坐标系下的缩放
             * @version m4m 1.0
             */
            transform.prototype.setWorldScale = function (scale) {
                if (!this._parent || !this._parent._parent) {
                    m4m.math.vec3Clone(scale, this._localScale);
                }
                else {
                    var tv3 = transform_2.helpv3;
                    m4m.math.vec3Clone(this._parent.getWorldScale(), tv3);
                    this._localScale.x = scale.x / tv3.x;
                    this._localScale.y = scale.y / tv3.y;
                    this._localScale.z = scale.z / tv3.z;
                }
                if (!this.dirtyLocal) {
                    this.dirtify(true);
                }
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取本地矩阵
             * @version m4m 1.0
             */
            transform.prototype.getLocalMatrix = function () {
                if (this.dirtyLocal) {
                    m4m.math.matrixMakeTransformRTS(this._localTranslate, this._localScale, this._localRotate, this.localMatrix);
                    m4m.math.vec3Clone(this._localTranslate, this.helpLPos);
                    m4m.math.vec3Clone(this._localScale, this.helpLScale);
                    m4m.math.quatClone(this._localRotate, this.helpLRotate);
                    this.dirtyLocal = false;
                }
                return this.localMatrix;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取世界矩阵
             * @version m4m 1.0
             */
            transform.prototype.getWorldMatrix = function () {
                // if(!this.dirtyLocal){
                //     if(this.checkLRTSChange()){
                //         this.dirtify(true);
                //     }
                // }
                if (!this.dirtyLocal && !this.dirtyWorld) {
                    this.checkToTop();
                }
                if (!this.dirtyLocal && !this.dirtyWorld) {
                    return this.worldMatrix;
                }
                this.dirtiedOfFrustumCulling = true;
                //找dirty标记的 顶 ， 再刷新
                if (this._parent) {
                    this._parent.getWorldMatrix();
                }
                this.sync();
                return this.worldMatrix;
            };
            transform.prototype.checkToTop = function () {
                var top;
                var temp = this;
                while (true) {
                    if (temp.checkLRTSChange()) {
                        temp.dirtyLocal = true;
                        //temp.dirtify(true);
                        top = temp;
                    }
                    if (!temp._parent)
                        break;
                    temp = temp._parent;
                }
                if (top) {
                    top.dirtify(true);
                }
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取世界坐标系下当前z轴的朝向
             * @version m4m 1.0
             */
            transform.prototype.getForwardInWorld = function (out) {
                m4m.math.matrixTransformNormal(transform_2.helpFoward, this.getWorldMatrix(), out);
                m4m.math.vec3Normalize(out, out);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取世界坐标系下当前x轴的朝向
             * @version m4m 1.0
             */
            transform.prototype.getRightInWorld = function (out) {
                m4m.math.matrixTransformNormal(transform_2.helpRight, this.getWorldMatrix(), out);
                m4m.math.vec3Normalize(out, out);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取世界坐标系下y轴的朝向
             * @version m4m 1.0
             */
            transform.prototype.getUpInWorld = function (out) {
                m4m.math.matrixTransformNormal(transform_2.helpUp, this.getWorldMatrix(), out);
                m4m.math.vec3Normalize(out, out);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 设置transform的世界矩阵 通过计算得到本地矩阵实现
             * @param mat 世界空间下矩阵
             * @version m4m 1.0
             */
            transform.prototype.setWorldMatrix = function (mat) {
                if (!this._parent) {
                    m4m.math.matrixDecompose(mat, this._localScale, this._localRotate, this._localTranslate);
                }
                else {
                    var tmtx = transform_2.helpmtx;
                    m4m.math.matrixInverse(this._parent.getWorldMatrix(), tmtx);
                    m4m.math.matrixMultiply(tmtx, mat, this.localMatrix);
                    m4m.math.matrixDecompose(this.localMatrix, this._localScale, this._localRotate, this._localTranslate);
                }
                if (!this.dirtyLocal) {
                    this.dirtify(true);
                }
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 旋转当前transform到z轴指向给定transform
             * @param trans 给定的transform
             * @version m4m 1.0
             */
            transform.prototype.lookat = function (trans) {
                this.calcLookAt(trans.getWorldTranslate());
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 旋转当前transform到z轴指向给定坐标
             * @param point 给定的坐标
             * @version m4m 1.0
             */
            transform.prototype.lookatPoint = function (point) {
                this.calcLookAt(point);
            };
            transform.prototype.calcLookAt = function (point) {
                m4m.math.quatLookat(this.getWorldTranslate(), point, this.worldRotate);
                this.setWorldRotate(this.worldRotate);
            };
            // get gameObject()
            // {
            //     if (this._gameObject == null)
            //     {
            //         this._gameObject = new gameObject();
            //         this._gameObject.transform = this;
            //     }
            //     return this._gameObject;
            // }
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取当前transform的克隆
             * @version m4m 1.0
             */
            transform.prototype.clone = function () {
                return m4m.io.cloneObj(this);
            };
            Object.defineProperty(transform.prototype, "beDispose", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 获取当前transform是否被释放掉了
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._beDispose;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 释放当前transform
             * @version m4m 1.0
             */
            transform.prototype.dispose = function () {
                if (this._parent)
                    this._parent.removeChild(this);
                this._dispose();
            };
            transform.prototype._dispose = function () {
                if (this._beDispose)
                    return;
                // if (this.children)
                {
                    // for (var k in this.children)
                    // {
                    //     this.children[k]._dispose();
                    // }
                    //this.removeAllChild();
                    for (var i = 0, l = this.children.length; i < l; ++i)
                        this.children[i]._dispose();
                    this.children = [];
                }
                if (this._physicsImpostor) {
                    this._physicsImpostor.dispose();
                }
                // this._gameObject.dispose();
                this.gameObject.dispose();
                this._physicsImpostor = null;
                this._beDispose = true;
                if (this.onDispose)
                    this.onDispose();
            };
            var transform_2;
            transform.help_v3 = new m4m.math.vector3();
            transform.ClassName = "transform";
            transform.helpv2 = new m4m.math.vector2();
            transform.helpv3 = new m4m.math.vector3();
            transform.helpv3_1 = new m4m.math.vector3();
            transform.helpUp = new m4m.math.vector3(0, 1, 0);
            transform.helpRight = new m4m.math.vector3(1, 0, 0);
            transform.helpFoward = new m4m.math.vector3(0, 0, 1);
            transform.helpquat = new m4m.math.quaternion();
            transform.helpquat_1 = new m4m.math.quaternion();
            transform.helpmtx = new m4m.math.matrix();
            // private _aabbchild: aabb=new m4m.framework.aabb(math.pool.vector3_zero,math.pool.vector3_zero);
            // /**
            //  * @public
            //  * @language zh_CN
            //  * @classdesc
            //  * 包含自己和所有子物体的aabb
            //  * @version m4m 1.0
            //  */
            // get aabbchild(){
            //     return this._aabbchild;
            // }
            /**
            * @private
            * @language zh_CN
            * 计算aabb
            * @version m4m 1.0
            */
            // caclAABB()
            // {
            //     if (this.gameObject.components == null) return;
            //     if (this._aabb == null)
            //     {
            //         this._aabb = this.buildAABB();
            //         //this.aabbchild = this.aabb.clone();
            //         this._aabb.cloneTo(this._aabbchild);
            //     }
            //     this._aabb.update(this.worldMatrix);
            // }
            // /**
            // * @private
            // * @language zh_CN
            // * 计算aabb集合
            // * @version m4m 1.0
            // */
            // caclAABBChild()
            // {
            //     if (this._aabb == null) return;
            //     //this.aabbchild = this.aabb.clone();
            //     this._aabb.cloneTo(this._aabbchild);
            //     if (this._children != null)
            //     {
            //         for (var i = 0; i < this._children.length; i++)
            //         {
            //             this._aabbchild.addAABB(this._children[i]._aabbchild);
            //         }
            //     }
            // }
            /** 创建过的 aabb 缓存 ，避免每次重复构建  */
            transform.aabbStoreMap = {};
            transform.aabbCareTypes = ["meshFilter", "skinnedMeshRenderer", "canvasRenderer"];
            __decorate([
                m4m.reflect.Field("string"),
                __metadata("design:type", String)
            ], transform.prototype, "name", void 0);
            __decorate([
                m4m.reflect.Field("string"),
                __metadata("design:type", String)
            ], transform.prototype, "prefab", void 0);
            __decorate([
                m4m.reflect.Field("transform[]"),
                __metadata("design:type", Array)
            ], transform.prototype, "children", void 0);
            __decorate([
                m4m.reflect.Field("quaternion"),
                __metadata("design:type", m4m.math.quaternion),
                __metadata("design:paramtypes", [m4m.math.quaternion])
            ], transform.prototype, "localRotate", null);
            __decorate([
                m4m.reflect.Field("vector3"),
                __metadata("design:type", m4m.math.vector3),
                __metadata("design:paramtypes", [m4m.math.vector3])
            ], transform.prototype, "localTranslate", null);
            __decorate([
                m4m.reflect.Field("vector3"),
                __metadata("design:type", m4m.math.vector3),
                __metadata("design:paramtypes", [m4m.math.vector3])
            ], transform.prototype, "localScale", null);
            __decorate([
                m4m.reflect.Field("gameObject"),
                __metadata("design:type", framework.gameObject)
            ], transform.prototype, "gameObject", void 0);
            transform = transform_2 = __decorate([
                m4m.reflect.SerializeType,
                __metadata("design:paramtypes", [])
            ], transform);
            return transform;
        }());
        framework.transform = transform;
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 作为引擎实例的唯一id使用 自增
         * @version m4m 1.0
         */
        var insID = /** @class */ (function () {
            function insID() {
                this.id = insID.next();
            }
            insID.next = function () {
                var next = insID.idAll;
                insID.idAll++;
                return next;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取唯一id
             * @version m4m 1.0
             */
            insID.prototype.getInsID = function () {
                return this.id;
            };
            insID.idAll = 1;
            return insID;
        }());
        framework.insID = insID;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../io/reflect.ts" />
var m4m;
/// <reference path="../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 表示矩形碰撞盒
         * @version m4m 1.0
         */
        var boxcollider = /** @class */ (function () {
            function boxcollider() {
                /**
                * @public
                * @language zh_CN
                * @classdesc
                * 碰撞盒中心点
                * @version m4m 1.0
                */
                this.center = new m4m.math.vector3(0, 0, 0);
                /**
                * @public
                * @language zh_CN
                * @classdesc
                * 碰撞盒大小
                * @version m4m 1.0
                */
                this.size = new m4m.math.vector3(1, 1, 1);
                this.started = false;
                /**
                * @private
                */
                this._colliderVisible = false;
            }
            boxcollider_1 = boxcollider;
            /**
            * @private
            */
            boxcollider.prototype.getBound = function () {
                return this.obb;
            };
            Object.defineProperty(boxcollider.prototype, "matrix", {
                /**
                * @public
                * @language zh_CN
                * @classdesc
                * 获取该碰撞盒物体的世界矩阵
                * @version m4m 1.0
                */
                get: function () {
                    if (this.gameObject)
                        return this.gameObject.transform.getWorldMatrix();
                    m4m.math.matrixMakeIdentity(boxcollider_1._tempMatrix);
                    return boxcollider_1._tempMatrix;
                },
                enumerable: false,
                configurable: true
            });
            boxcollider.prototype.start = function () {
                this.filter = this.gameObject.getComponent("meshFilter");
                this.build();
                this.started = true;
                this.ckBuildColliderMesh();
            };
            boxcollider.prototype.onPlay = function () {
            };
            boxcollider.prototype.update = function (delta) {
                if (this.obb) {
                    this.obb.update(this.matrix);
                }
            };
            Object.defineProperty(boxcollider.prototype, "colliderVisible", {
                /**
                * @public
                * @language zh_CN
                * @classdesc
                * 碰撞盒的可见性
                * @version m4m 1.0
                */
                get: function () {
                    return this._colliderVisible;
                },
                /**
                * @public
                * @language zh_CN
                * @classdesc
                * 设置碰撞盒的可见性
                * @version m4m 1.0
                */
                set: function (value) {
                    this._colliderVisible = value;
                    this.ckBuildColliderMesh();
                    if (this.subTran) {
                        this.subTran.gameObject.visible = this._colliderVisible;
                    }
                },
                enumerable: false,
                configurable: true
            });
            /**
             * 检查创建碰撞区域 显示mesh
             */
            boxcollider.prototype.ckBuildColliderMesh = function () {
                if (this._colliderVisible && this.started) {
                    if (!this.subTran) {
                        this.buildMesh();
                    }
                }
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 检测碰撞
            * @version m4m 1.0
            */
            boxcollider.prototype.intersectsTransform = function (tran) {
                if (tran.gameObject.collider == null)
                    return false;
                if (this.obb == null || tran.gameObject.collider.getBound() == null)
                    return false;
                var _obb = tran.gameObject.collider.getBound();
                return this.obb.intersects(_obb);
            };
            /**
            * @private
            * @language zh_CN
            * @classdesc
            * 构建碰撞盒
            * @version m4m 1.0
            */
            boxcollider.prototype.build = function () {
                this.obb = new framework.obb();
                if (this.center && this.size) {
                    this.obb.buildByCenterSize(this.center, this.size);
                }
                else {
                    var minimum = m4m.poolv3();
                    var maximum = m4m.poolv3();
                    if (this.filter) {
                        // let meshdata: m4m.render.meshData = this.filter.getMeshOutput().data;
                        // m4m.math.vec3SetByFloat(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, minimum);
                        // m4m.math.vec3SetByFloat(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, maximum);
                        // for (var i = 0; i < meshdata.pos.length; i++)
                        // {
                        //     m4m.math.vec3Max(meshdata.pos[i], maximum, maximum);
                        //     m4m.math.vec3Min(meshdata.pos[i], minimum, minimum);
                        // }
                        // console.log("add obb filter " + minimum + "  " + maximum);
                        this.filter.getMeshOutput().calcVectexMinMax(minimum, maximum);
                    }
                    else {
                        minimum.x = minimum.y = minimum.z = -1;
                        maximum.x = maximum.y = maximum.z = 1;
                    }
                    this.obb.buildByMaxMin(minimum, maximum);
                    m4m.poolv3_del(minimum);
                    m4m.poolv3_del(maximum);
                }
                //this.buildMesh();
            };
            /**
            * @private
            * @language zh_CN
            * @classdesc
            * 构建碰撞盒mesh 并显示
            * @version m4m 1.0
            */
            boxcollider.prototype.buildMesh = function () {
                this.subTran = new m4m.framework.transform();
                this.subTran.gameObject.hideFlags = framework.HideFlags.DontSave | framework.HideFlags.HideInHierarchy;
                this.subTran.name = "boxcollider";
                var mesh = this.subTran.gameObject.addComponent("meshFilter");
                mesh.mesh = this.getColliderMesh();
                var renderer = this.subTran.gameObject.addComponent("meshRenderer");
                this.subTran.gameObject.visible = this._colliderVisible;
                this.gameObject.transform.addChild(this.subTran);
                this.gameObject.transform.markDirty();
                this.subTran.markDirty(); //要标记自己脏了，才会更新
                //this.gameObject.transform.updateWorldTran();
            };
            /**
            * @private
            * @language zh_CN
            * @classdesc
            * 获取碰撞盒mesh
            * @version m4m 1.0
            */
            boxcollider.prototype.getColliderMesh = function () {
                var _mesh = new framework.mesh();
                _mesh.data = m4m.render.meshData.genBoxByArray_Quad(this.obb.vectors);
                var vf = m4m.render.VertexFormatMask.Position | m4m.render.VertexFormatMask.Normal;
                var v32 = _mesh.data.genVertexDataArray(vf);
                var i16 = _mesh.data.genIndexDataArrayQuad2Line();
                var webgl = this.gameObject.getScene().webgl;
                _mesh.glMesh = new m4m.render.glMesh();
                _mesh.glMesh.initBuffer(webgl, vf, _mesh.data.getVertexCount());
                _mesh.glMesh.uploadVertexData(webgl, v32);
                _mesh.glMesh.addIndex(webgl, i16.length);
                _mesh.glMesh.uploadIndexData(webgl, 0, i16);
                _mesh.glMesh.initVAO();
                _mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.useVertexIndex = 0;
                    sm.start = 0;
                    sm.size = i16.length;
                    sm.line = true;
                    _mesh.submesh.push(sm);
                }
                return _mesh;
            };
            /**
            * @private
            */
            boxcollider.prototype.remove = function () {
                if (this.subTran) {
                    this.subTran.dispose();
                }
                if (this.obb) {
                    this.obb.dispose();
                }
            };
            /**
            * @private
            */
            boxcollider.prototype.clone = function () {
            };
            var boxcollider_1;
            boxcollider.ClassName = "boxcollider";
            boxcollider._tempMatrix = new m4m.math.matrix();
            __decorate([
                m4m.reflect.Field("vector3"),
                __metadata("design:type", m4m.math.vector3)
            ], boxcollider.prototype, "center", void 0);
            __decorate([
                m4m.reflect.Field("vector3"),
                __metadata("design:type", m4m.math.vector3)
            ], boxcollider.prototype, "size", void 0);
            boxcollider = boxcollider_1 = __decorate([
                m4m.reflect.nodeComponent,
                m4m.reflect.nodeBoxCollider
            ], boxcollider);
            return boxcollider;
        }());
        framework.boxcollider = boxcollider;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
        * @public
        * @language zh_CN
        * @classdesc
        * 碰撞组件
        * @version m4m 1.0
        */
        var meshcollider = /** @class */ (function () {
            function meshcollider() {
                /**
                * @private
                */
                this._colliderVisible = false;
                this._builded = false;
            }
            /**
            * @private
            */
            meshcollider.prototype.getBound = function () {
                return this._mesh;
            };
            meshcollider.prototype.start = function () {
                this._filter = this.gameObject.getComponent("meshFilter");
                this.ckbuildMesh();
            };
            meshcollider.prototype.onPlay = function () {
            };
            meshcollider.prototype.update = function (delta) {
            };
            Object.defineProperty(meshcollider.prototype, "colliderVisible", {
                /**
                * @public
                * @language zh_CN
                * @classdesc
                * 碰撞体的可见性
                * @version m4m 1.0
                */
                get: function () {
                    return this._colliderVisible;
                },
                /**
                * @public
                * @language zh_CN
                * @param value boolbean
                * @classdesc
                * 碰撞体的可见性
                * @version m4m 1.0
                */
                set: function (value) {
                    this._colliderVisible = value;
                    if (this.subTran) {
                        this.subTran.gameObject.visible = this._colliderVisible;
                    }
                },
                enumerable: false,
                configurable: true
            });
            /**
            * @private
            */
            meshcollider.prototype.intersectsTransform = function (tran) {
                //obb-mesh  obb-obb  mesh-mesh
                return false;
            };
            meshcollider.prototype.ckbuildMesh = function () {
                if (this._builded || !this._filter)
                    return;
                this._mesh = this._filter.getMeshOutput();
                if (!this._mesh)
                    return;
                this.subTran = new m4m.framework.transform();
                this.subTran.gameObject.hideFlags = framework.HideFlags.DontSave | framework.HideFlags.HideInHierarchy;
                this.subTran.name = "".concat(this.gameObject.getName(), "_meshcollider");
                var mesh = this.subTran.gameObject.addComponent("meshFilter");
                mesh.mesh = this.getColliderMesh();
                this.subTran.gameObject.visible = this._colliderVisible;
                this.gameObject.transform.addChild(this.subTran);
                this.gameObject.transform.markDirty();
                this.subTran.markDirty();
                this.gameObject.transform.updateWorldTran();
                this._builded = true;
            };
            meshcollider.prototype.getColliderMesh = function () {
                var _mesh = new framework.mesh();
                _mesh.data = this._mesh.data;
                var vf = m4m.render.VertexFormatMask.Position | m4m.render.VertexFormatMask.Normal;
                var v32 = _mesh.data.genVertexDataArray(vf);
                var i16 = _mesh.data.genIndexDataArrayTri2Line();
                var webgl = this.gameObject.getScene().webgl;
                _mesh.glMesh = new m4m.render.glMesh();
                _mesh.glMesh.initBuffer(webgl, vf, _mesh.data.getVertexCount());
                _mesh.glMesh.uploadVertexData(webgl, v32);
                _mesh.glMesh.addIndex(webgl, i16.length);
                _mesh.glMesh.uploadIndexData(webgl, 0, i16);
                _mesh.glMesh.initVAO();
                _mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.start = 0;
                    sm.size = i16.length;
                    sm.line = true;
                    _mesh.submesh.push(sm);
                }
                return _mesh;
            };
            /**
            * @private
            */
            meshcollider.prototype.remove = function () {
                if (this.subTran) {
                    this.subTran.dispose();
                }
                this._mesh = null;
                this._filter = null;
            };
            /**
            * @private
            */
            meshcollider.prototype.clone = function () {
            };
            meshcollider.ClassName = "meshcollider";
            __decorate([
                m4m.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], meshcollider.prototype, "_colliderVisible", void 0);
            meshcollider = __decorate([
                m4m.reflect.nodeComponent,
                m4m.reflect.nodeMeshCollider
            ], meshcollider);
            return meshcollider;
        }());
        framework.meshcollider = meshcollider;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../io/reflect.ts" />
var m4m;
/// <reference path="../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
        * @public
        * @language zh_CN
        * @classdesc
        * mesh组件
        * @version m4m 1.0
        */
        var meshFilter = /** @class */ (function () {
            function meshFilter() {
            }
            meshFilter.prototype.start = function () {
            };
            meshFilter.prototype.onPlay = function () {
            };
            meshFilter.prototype.update = function (delta) {
            };
            Object.defineProperty(meshFilter.prototype, "mesh", {
                //本意mesh filter 可以弄一点 模型处理，比如lod
                //先直进直出吧
                /**
                 * @private
                 */
                get: function () {
                    return this._mesh;
                },
                /**
                * @public
                * @language zh_CN
                * @param mesh 此组件的mesh
                * @classdesc
                * 设置mesh数据
                * @version m4m 1.0
                */
                set: function (mesh) {
                    if (this._mesh != null) {
                        this._mesh.unuse();
                    }
                    this._mesh = mesh;
                    if (this._mesh != null) {
                        this._mesh.use();
                    }
                },
                enumerable: false,
                configurable: true
            });
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 返回mesh数据
            * @version m4m 1.0
            */
            meshFilter.prototype.getMeshOutput = function () {
                return this._mesh;
            };
            /**
             * @private
             */
            meshFilter.prototype.remove = function () {
                if (this.mesh)
                    this.mesh.unuse();
            };
            /**
             * @private
             */
            meshFilter.prototype.clone = function () {
            };
            meshFilter.ClassName = "meshFilter";
            __decorate([
                m4m.reflect.Field("mesh"),
                m4m.reflect.UIStyle("WidgetDragSelect"),
                __metadata("design:type", framework.mesh),
                __metadata("design:paramtypes", [framework.mesh])
            ], meshFilter.prototype, "mesh", null);
            meshFilter = __decorate([
                m4m.reflect.nodeComponent
            ], meshFilter);
            return meshFilter;
        }());
        framework.meshFilter = meshFilter;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../io/reflect.ts" />
var m4m;
/// <reference path="../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /** meshRenderer GpuInstancing 合批类
         *
         */
        var meshGpuInsBatcher = /** @class */ (function () {
            function meshGpuInsBatcher(_glayer, _mesh, _mats) {
                /** 实例数量 */
                this.count = 0;
                this.gameLayer = _glayer;
                this.mesh = _mesh;
                this.mesh.use();
                this.materials = _mats;
                var _sh = _mats[0].getShader();
                this.passArr = [];
                this.bufferDArrs = [];
                this.passIdMap = {};
                var tempArr = _sh.passes[m4m.framework.meshRenderer.instanceDrawType()];
                for (var i = 0, len = tempArr.length; i < len; i++) {
                    var pass = tempArr[i];
                    this.passArr.push(pass);
                    this.bufferDArrs.push(new m4m.math.ExtenArray(Float32Array));
                    this.passIdMap[pass.id.getID()] = i;
                }
            }
            /** 清理 */
            meshGpuInsBatcher.prototype.dispose = function () {
                // for(let i=0 , len = this.materials.length ; i < len ;i++){
                //     let mat = this.materials[i];
                //     mat.unuse();
                // }
                for (var i = 0, len = this.bufferDArrs.length; i < len; i++) {
                    this.bufferDArrs[i].dispose();
                }
                this.passArr = null;
                this.mesh = null;
                this.materials = null;
                this.bufferDArrs = null;
                this.passIdMap = null;
            };
            return meshGpuInsBatcher;
        }());
        framework.meshGpuInsBatcher = meshGpuInsBatcher;
        /** mesh  Gpu 实例 绘制info数据类*/
        var meshGpuInstanceDrawInfo = /** @class */ (function () {
            function meshGpuInstanceDrawInfo() {
                this.attSuccess = false;
            }
            meshGpuInstanceDrawInfo.prototype.initBuffer = function (gl) {
            };
            meshGpuInstanceDrawInfo.prototype.activeAttributes = function (gl, pass, mat) {
                if (!this.instanceArray && !this.cacheBuffers)
                    return;
                var cacheBuffer;
                if (this.bufferIdMap) {
                    var idx = this.bufferIdMap[pass.id.getID()];
                    if (idx == null)
                        idx = 0;
                    cacheBuffer = this.cacheBuffers[idx];
                }
                var _mid = this.mid;
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo);
                var dataArr;
                if (cacheBuffer) {
                    dataArr = cacheBuffer.buffer;
                }
                if (!dataArr) {
                    this.helpDArray.count = 0;
                    var len = this.instanceCount;
                    for (var i = 0; i < len; i++) {
                        var mr = this.instanceArray.get(i);
                        var mat_1 = mr.materials[_mid];
                        meshRenderer.setInstanceOffsetMatrix(mr.gameObject.transform, mat_1, pass);
                        mat_1.uploadInstanceAtteribute(pass, this.helpDArray);
                    }
                    dataArr = this.helpDArray.buffer;
                }
                gl.bufferData(gl.ARRAY_BUFFER, dataArr, gl.STATIC_DRAW);
                //
                //stride(vbo 数据步长) 获取
                var strideInsAttrib = mat.getInstanceAtteributeSize(pass) * 4;
                //
                var offset = 0;
                // const attMap = pass.program.mapInstanceAttribID;
                var attMap = pass.program.mapAllAttrID;
                var valMap = mat.instanceAttribIDValMap;
                var dataType = gl.FLOAT; //缓冲区中的 数据类型
                var dataByteSize = 4; //缓冲区中的 数据字节长度
                var pointerMaxSize = 4; //vertexAttribPointer 最大尺寸
                for (var id in attMap) {
                    if (!valMap[id])
                        continue;
                    var att = attMap[id];
                    var loc = att.location;
                    if (loc == -1)
                        break;
                    var subCount = Math.ceil(att.size / pointerMaxSize); //vertexAttribPointer() 只能是 1 , 2 , 3 , 4 , 大于4 会拆分成多个地址
                    var realSize = att.size <= pointerMaxSize ? att.size : Math.ceil(att.size / subCount);
                    while (subCount > 0) {
                        subCount--;
                        gl.enableVertexAttribArray(loc);
                        // gl.vertexAttribPointer(location, att.size, gl.FLOAT, false, pass.program.strideInsAttrib, offset);
                        gl.vertexAttribPointer(loc, realSize, dataType, false, strideInsAttrib, offset);
                        gl.vertexAttribDivisor(loc, 1);
                        // offset += att.size * 4;
                        offset += realSize * dataByteSize;
                        loc++;
                    }
                }
                this.attSuccess = true;
            };
            meshGpuInstanceDrawInfo.prototype.disableAttributes = function (gl, pass, mat) {
                if (this.attSuccess) {
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.vbo);
                    // let attMap = pass.program.mapInstanceAttribID;
                    var valMap = mat.instanceAttribIDValMap;
                    var attMap = pass.program.mapAllAttrID;
                    for (var id in attMap) {
                        if (!valMap[id])
                            continue;
                        var att = attMap[id];
                        var location_1 = att.location;
                        if (location_1 == -1)
                            break;
                        gl.vertexAttribDivisor(location_1, 0);
                        gl.disableVertexAttribArray(location_1);
                    }
                    this.attSuccess = false;
                }
                //clear
                this.instanceCount = this.mid = 0;
                this.vbo = null;
                this.cacheBuffers = null;
                this.instanceArray = null;
                this.helpDArray = null;
                this.bufferIdMap = null;
                if (this.onDisableAttribute) {
                    this.onDisableAttribute(this);
                }
            };
            /** 池子中取出一个 */
            meshGpuInstanceDrawInfo.new_info = function () {
                var info = this._pool.pop();
                if (info)
                    return info;
                info = new meshGpuInstanceDrawInfo();
                return info;
            };
            /** 放回池子 */
            meshGpuInstanceDrawInfo.del_info = function (info) {
                this._pool.push(info);
            };
            meshGpuInstanceDrawInfo._pool = [];
            return meshGpuInstanceDrawInfo;
        }());
        framework.meshGpuInstanceDrawInfo = meshGpuInstanceDrawInfo;
        /**
        * @public
        * @language zh_CN
        * @classdesc
        * mesh的渲染组件
        * @version m4m 1.0
        */
        var meshRenderer = /** @class */ (function () {
            function meshRenderer() {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * mesh的材质数组
                 * @version m4m 1.0
                 */
                this.materials = [];
                /**
                 * @private
                 * 使用全局的lightMap
                 */
                this.useGlobalLightMap = true;
                /**
                 * @private
                 */
                this.lightmapIndex = -1;
                /**
                * @private
                */
                this.lightmapScaleOffset = new m4m.math.vector4(1, 1, 0, 0);
                this.lastMat0Id = -1;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 场景渲染层级（common、transparent、overlay）
                 * @version m4m 1.0
                 */
                this.layer = framework.RenderLayerEnum.Common;
                this.issetq = false;
                /**
                * @private
                */
                this._queue = 0;
            }
            Object.defineProperty(meshRenderer.prototype, "renderLayer", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 渲染mask层级（和相机相对应）
                 * @version m4m 1.0
                 */
                // @m4m.reflect.Field("number")
                // renderLayer: m4m.framework.CullingMask = CullingMask.default;
                get: function () { return this.gameObject.layer; },
                set: function (layer) {
                    this.gameObject.layer = layer;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(meshRenderer.prototype, "queue", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 返回此组件的场景渲染层级排序依据queue大小
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._queue;
                },
                set: function (value) {
                    this._queue = value;
                    this.issetq = true;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(meshRenderer.prototype, "filter", {
                /**
                 * 渲染使用 meshFilter
                 */
                get: function () {
                    if (!this._filter) {
                        this._filter = this.gameObject.getComponent("meshFilter");
                    }
                    return this._filter;
                },
                set: function (val) { this._filter = val; },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(meshRenderer, "InstanceOffsetMatrixLoc", {
                /** GPU Instance 偏移变化矩阵 */
                get: function () {
                    if (this._InstanceOffsetMatrixLoc == null) {
                        this._InstanceOffsetMatrixLoc = m4m.render.VertexLocation.InstanceOffsetMatrix_L;
                    }
                    ;
                    return this._InstanceOffsetMatrixLoc;
                },
                enumerable: false,
                configurable: true
            });
            ;
            meshRenderer.prototype.start = function () {
                this.refreshLayerAndQue();
                if (this.lightmapIndex == -2) {
                    this.useGlobalLightMap = false;
                }
            };
            meshRenderer.prototype.onPlay = function () {
            };
            /**
             * 刷新 渲染layer 和 渲染 queueId （切换了材质时需要手动刷新）
             * *优化了自动处理的消耗
             *  */
            meshRenderer.prototype.refreshLayerAndQue = function () {
                if (this.materials == null || this.materials.length == 0) {
                    //没有材质 给一个默认材质
                    this.materials = [];
                    var material_2 = new framework.material();
                    material_2.use();
                    this.materials.push(material_2);
                    this.materials[0].setShader(framework.sceneMgr.app.getAssetMgr().getShader("shader/def"));
                }
                this.layer = this.materials[0].getLayer();
                if (!this.issetq)
                    this._queue = this.materials[0].getQueue();
            };
            meshRenderer.prototype.update = function (delta) {
            };
            meshRenderer.prototype.render = function (context, assetmgr, camera) {
                framework.DrawCallInfo.inc.currentState = framework.DrawCallEnum.Meshrender;
                var go = this.gameObject;
                var tran = go.transform;
                var filter = this.filter;
                context.updateLightMask(go.layer);
                context.updateModel(tran);
                if (filter == null)
                    return;
                var mesh = filter.getMeshOutput();
                if (mesh == null || mesh.glMesh == null || mesh.submesh == null)
                    return;
                var subMeshs = mesh.submesh;
                if (subMeshs == null)
                    return;
                // mesh.glMesh.bindVboBuffer(context.webgl);
                var len = subMeshs.length;
                var scene = tran.scene;
                var lightIdx = this.lightmapIndex;
                for (var i = 0; i < len; i++) {
                    var sm = subMeshs[i];
                    var mid = subMeshs[i].matIndex; //根据这个找到使用的具体哪个材质    
                    var usemat = this.materials[mid];
                    var drawtype = scene.fog ? "base_fog" : "base";
                    context.lightmap = null;
                    if (lightIdx >= 0 && scene.lightmaps.length > 0) {
                        drawtype = scene.fog ? "lightmap_fog" : "lightmap";
                        //usemat.shaderStatus = shaderStatus.Lightmap;
                        if (scene.lightmaps.length > lightIdx) {
                            context.lightmap = scene.lightmaps[lightIdx];
                            //context.lightmap_01 = meshRenderer.getLightMap_01Img(context.lightmap);
                        }
                    }
                    else {
                        if (!this.useGlobalLightMap) {
                            drawtype = scene.fog ? "lightmap_fog" : "lightmap";
                            context.lightmap = usemat.statedMapUniforms["_LightmapTex"];
                            //if(context.lightmap.getName){}
                            //context.lightmap_01 = meshRenderer.getLightMap_01Img(context.lightmap);
                        }
                    }
                    if (context.lightmap && context.lightmap.glTexture) {
                        context.lightmapOffset = this.lightmapScaleOffset;
                        context.lightmapUV = mesh.glMesh.vertexFormat & m4m.render.VertexFormatMask.UV1 ? 1 : 0;
                        var format = context.lightmap.glTexture.format;
                        context.lightmapRGBAF16 = format == m4m.render.TextureFormatEnum.FLOAT16 ? 1 : 0;
                    }
                    // if (scene.fog)
                    // {
                    //     context.fog = scene.fog;
                    // }
                    if (usemat != null)
                        usemat.draw(context, mesh, sm, drawtype);
                }
            };
            //获取 李总修改 lightMap 第二图
            meshRenderer.getLightMap_01Img = function (lightMapImg) {
                var imgName = lightMapImg.getName();
                var srcImgName = "".concat(imgName.substr(0, imgName.length - 13), "_01.imgdesc.json");
                var srcImgBundleName = lightMapImg.bundle.name;
                var assetMgrIns = m4m.framework.assetMgr.Instance;
                var lightMapimg_01 = assetMgrIns.getAssetByName(srcImgName, srcImgBundleName);
                //没有 _LightmapTex_01 给一张默认图（纯黑色）
                if (!lightMapimg_01) {
                    lightMapimg_01 = assetMgrIns.getDefaultTexture("black");
                }
                return lightMapimg_01;
            };
            meshRenderer.onGpuInsDisableAttribute = function (info) {
                if (!info)
                    return;
                meshGpuInstanceDrawInfo.del_info(info);
            };
            meshRenderer.GpuInstancingRender = function (context, instanceArray, cacheBuffer) {
                var insLen = instanceArray.length;
                if (insLen < 1)
                    return;
                framework.DrawCallInfo.inc.currentState = framework.DrawCallEnum.Meshrender;
                // let mr = instanceArray[0] as m4m.framework.meshRenderer;
                var mr = instanceArray.get(0);
                // let go = instanceArray[0].gameObject;
                var go = mr.gameObject;
                // let tran = go.transform;
                var filter = mr.filter;
                context.updateLightMask(go.layer);
                context.updateModelByMatrix(this.helpIMatrix);
                if (filter == null)
                    return;
                var mesh = filter.getMeshOutput();
                if (mesh == null || mesh.glMesh == null || mesh.submesh == null)
                    return;
                var subMeshs = mesh.submesh;
                // mesh.glMesh.bindVboBuffer(context.webgl);
                // if (sceneMgr.scene.fog)
                // {
                //     context.fog = sceneMgr.scene.fog;
                // }
                var len = subMeshs.length;
                var drawtype = this.instanceDrawType();
                for (var i = 0; i < len; i++) {
                    var sm = subMeshs[i];
                    var mid = subMeshs[i].matIndex; //根据这个找到使用的具体哪个材质    
                    var usemat = mr.materials[mid];
                    var drawInstanceInfo = meshGpuInstanceDrawInfo.new_info();
                    drawInstanceInfo.mid = mid;
                    drawInstanceInfo.instanceCount = insLen;
                    drawInstanceInfo.vbo = this._getVBO(context.webgl);
                    drawInstanceInfo.instanceArray = instanceArray;
                    drawInstanceInfo.helpDArray = this.helpDArray;
                    drawInstanceInfo.onDisableAttribute = this.onGpuInsDisableAttribute.bind(this);
                    ///----------------------------------------------------------------
                    if (usemat != null)
                        usemat.draw(context, mesh, sm, drawtype, drawInstanceInfo);
                }
            };
            meshRenderer.GpuInstancingRenderBatcher = function (context, batcher) {
                var insLen = batcher.count;
                if (insLen < 1)
                    return;
                framework.DrawCallInfo.inc.currentState = framework.DrawCallEnum.Meshrender;
                var mesh = batcher.mesh;
                var mats = batcher.materials;
                var gameLayer = batcher.gameLayer;
                context.updateLightMask(gameLayer);
                context.updateModelByMatrix(this.helpIMatrix);
                // if (sceneMgr.scene.fog)
                // {
                //     context.fog = sceneMgr.scene.fog;
                // }
                var subMeshs = mesh.submesh;
                var len = subMeshs.length;
                for (var i = 0; i < len; i++) {
                    var sm = subMeshs[i];
                    var mid = subMeshs[i].matIndex; //根据这个找到使用的具体哪个材质    
                    var usemat = mats[mid];
                    var drawtype = this.instanceDrawType();
                    var vbo = this._getVBO(context.webgl);
                    var drawInstanceInfo = meshGpuInstanceDrawInfo.new_info();
                    drawInstanceInfo.mid = mid;
                    drawInstanceInfo.instanceCount = insLen;
                    drawInstanceInfo.vbo = this._getVBO(context.webgl);
                    drawInstanceInfo.cacheBuffers = batcher.bufferDArrs;
                    drawInstanceInfo.bufferIdMap = batcher.passIdMap;
                    drawInstanceInfo.onDisableAttribute = this.onGpuInsDisableAttribute.bind(this);
                    if (usemat != null)
                        usemat.draw(context, mesh, sm, drawtype, drawInstanceInfo);
                }
            };
            /**
             * 设置 OffsetMatrix
             * @param tran transform
             * @param mat 材质对象
             * @param pass 绘制通道对象
             * @returns 是否设置成功
             */
            meshRenderer.setInstanceOffsetMatrix = function (tran, mat, pass) {
                if (!this.hasInstanceOffsetMatrix(pass))
                    return false;
                this._setInstanceOffsetMatrix(tran, mat, pass);
                return true;
            };
            /**
             * 是否有 InstanceOffsetMatrix 定义
             * @param pass 绘制通道对象
             */
            meshRenderer.hasInstanceOffsetMatrix = function (pass) {
                var locMap = pass.program.mapAllAttrLoc;
                return locMap[this.InstanceOffsetMatrixLoc] != null;
            };
            meshRenderer._setInstanceOffsetMatrix = function (tran, mat, pass) {
                var _wmat = tran.getWorldMatrix();
                var rawdata = _wmat.rawData;
                var allLocMap = pass.program.mapAllAttrLoc;
                var valMap = mat.instanceAttribIDValMap;
                //
                var loc = this.InstanceOffsetMatrixLoc;
                var att = allLocMap[loc];
                var id = att.name;
                var arr = valMap[id];
                if (!arr)
                    arr = valMap[id] = [];
                //复制数据
                for (var i = 0, len = rawdata.length; i < len; i++) {
                    arr[i] = rawdata[i];
                }
            };
            meshRenderer.instanceDrawType = function () {
                var drawtype = "instance";
                //fog
                var _fog = m4m.framework.sceneMgr.scene.fog;
                if (_fog) {
                    drawtype = "instance_fog";
                }
                return drawtype;
            };
            meshRenderer._getVBO = function (gl) {
                for (var i = 0, n = this._vbos.length; i < n; i++) {
                    if (this._vbos[i][0] == gl)
                        return this._vbos[i][1];
                }
                var vbo = gl.createBuffer();
                this._vbos.push([gl, vbo]);
                return vbo;
            };
            meshRenderer.prototype.isGpuInstancing = function () {
                // if(!this.materials || !this.materials[0]) return false;
                if (!this.materials || this.materials.length < 1)
                    return false;
                return this.materials[0].enableGpuInstancing;
            };
            /**
            * @private
            */
            meshRenderer.prototype.remove = function () {
                this.materials.forEach(function (element) {
                    if (element)
                        element.unuse();
                });
                this.materials.length = 0;
            };
            /**
            * @private
            */
            meshRenderer.prototype.clone = function () {
            };
            meshRenderer.ClassName = "meshRenderer";
            meshRenderer.helpDArray = new m4m.math.ExtenArray(Float32Array);
            meshRenderer.helpIMatrix = new m4m.math.matrix();
            meshRenderer._vbos = [];
            __decorate([
                m4m.reflect.Field("material[]"),
                __metadata("design:type", Array)
            ], meshRenderer.prototype, "materials", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], meshRenderer.prototype, "lightmapIndex", void 0);
            __decorate([
                m4m.reflect.Field("vector4"),
                __metadata("design:type", m4m.math.vector4)
            ], meshRenderer.prototype, "lightmapScaleOffset", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], meshRenderer.prototype, "layer", void 0);
            meshRenderer = __decorate([
                m4m.reflect.nodeRender,
                m4m.reflect.nodeComponent,
                __metadata("design:paramtypes", [])
            ], meshRenderer);
            return meshRenderer;
        }());
        framework.meshRenderer = meshRenderer;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../io/reflect.ts" />
var m4m;
/// <reference path="../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 蒙皮网格渲染组件
         * @version m4m 1.0
         */
        var skinnedMeshRenderer = /** @class */ (function () {
            function skinnedMeshRenderer() {
                /**
                 * 场景渲染层级（common、transparent、overlay）
                 */
                this.layer = framework.RenderLayerEnum.Common;
                this.issetq = false;
                this._queue = 0;
                /**
                 * 最大骨骼数量
                 * @version m4m 1.0
                 */
                this.maxBoneCount = 55;
                //是否高效
                this._efficient = true;
                //这个数据是扣掉tpose之后的
                this._skeletonMatrixData = new Float32Array(8 * this.maxBoneCount);
            }
            skinnedMeshRenderer_1 = skinnedMeshRenderer;
            Object.defineProperty(skinnedMeshRenderer.prototype, "renderLayer", {
                /**
                 * 渲染mask层级（和相机相对应）
                 */
                //renderLayer: CullingMask = CullingMask.default;
                get: function () { return this.gameObject.layer; },
                set: function (layer) {
                    this.gameObject.layer = layer;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(skinnedMeshRenderer.prototype, "queue", {
                /**
                 * 返回此组件的场景渲染层级排序依据queue大小
                 */
                get: function () {
                    return this._queue;
                },
                /**
                 * 设置此组件的场景渲染层级排序number大小
                 */
                set: function (value) {
                    this._queue = value;
                    this.issetq = true;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(skinnedMeshRenderer.prototype, "player", {
                /**
                 * 返回动画播放组件
                 */
                get: function () {
                    if (this._player == null) {
                        this._player = this.gameObject.getComponentInParent("aniplayer");
                    }
                    return this._player;
                },
                set: function (p) {
                    this._player = p;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(skinnedMeshRenderer.prototype, "mesh", {
                /**
                 * 返回mesh数据
                 */
                get: function () {
                    return this._mesh;
                },
                /**
                 * 设置mesh数据
                 */
                set: function (mesh) {
                    if (this._mesh != null) {
                        this._mesh.unuse();
                    }
                    this._mesh = mesh;
                    if (this._mesh != null) {
                        this._mesh.use();
                    }
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(skinnedMeshRenderer.prototype, "aabb", {
                get: function () {
                    if (!this._aabb) {
                        // calculate aabb from bounds
                        var _a = this, size = _a.size, center = _a.center;
                        var max = m4m.math.pool.new_vector3();
                        var min = m4m.math.pool.new_vector3();
                        var temp = m4m.math.pool.new_vector3();
                        m4m.math.vec3ScaleByNum(size, 0.5, min); // temp
                        // Ensure extent
                        min.x = Math.abs(min.x);
                        min.y = Math.abs(min.y);
                        min.z = Math.abs(min.z);
                        m4m.math.vec3Add(center, min, max);
                        m4m.math.vec3Subtract(center, min, min);
                        // Apply root bone matrix
                        // 骨骼可能有旋转之类的操作, aabb默认只会计算位移
                        var rootboneMat = this.rootBone.getWorldMatrix();
                        m4m.math.matrixTransformVector3(max, rootboneMat, max);
                        m4m.math.matrixTransformVector3(min, rootboneMat, min);
                        m4m.math.vec3Max(max, min, temp);
                        m4m.math.vec3Min(max, min, min);
                        m4m.math.vec3Clone(temp, max);
                        this._aabb = new framework.aabb(max, min);
                        m4m.math.pool.delete_vector3(max);
                        m4m.math.pool.delete_vector3(min);
                        m4m.math.pool.delete_vector3(temp);
                    }
                    return this._aabb;
                },
                enumerable: false,
                configurable: true
            });
            skinnedMeshRenderer.prototype.start = function () {
            };
            skinnedMeshRenderer.prototype.onPlay = function () {
            };
            /**
             * @private
             * @param index
             */
            skinnedMeshRenderer.prototype.getMatByIndex = function (index, outMtx) {
                var data = this.mesh.data;
                var bIdx = data.blendIndex;
                var skData = this._skeletonMatrixData;
                if (bIdx[index].v0 >= this.maxBoneCount || bIdx[index].v1 >= this.maxBoneCount || bIdx[index].v2 >= this.maxBoneCount || bIdx[index].v3 >= this.maxBoneCount) {
                    return null;
                }
                var mat = outMtx;
                m4m.math.matrixMakeIdentity(mat);
                if (this._efficient) {
                    var vec40r = skinnedMeshRenderer_1.help_v4;
                    var vec30p = skinnedMeshRenderer_1.help_v3;
                    vec40r.x = skData[8 * bIdx[index].v0 + 0];
                    vec40r.y = skData[8 * bIdx[index].v0 + 1];
                    vec40r.z = skData[8 * bIdx[index].v0 + 2];
                    vec40r.w = skData[8 * bIdx[index].v0 + 3];
                    vec30p.x = skData[8 * bIdx[index].v0 + 4];
                    vec30p.y = skData[8 * bIdx[index].v0 + 5];
                    vec30p.z = skData[8 * bIdx[index].v0 + 6];
                    var vec41r = skinnedMeshRenderer_1.help_v4_1;
                    var vec31p = skinnedMeshRenderer_1.help_v3_1;
                    vec41r.x = skData[8 * bIdx[index].v1 + 0];
                    vec41r.y = skData[8 * bIdx[index].v1 + 1];
                    vec41r.z = skData[8 * bIdx[index].v1 + 2];
                    vec41r.w = skData[8 * bIdx[index].v1 + 3];
                    vec31p.x = skData[8 * bIdx[index].v1 + 4];
                    vec31p.y = skData[8 * bIdx[index].v1 + 5];
                    vec31p.z = skData[8 * bIdx[index].v1 + 6];
                    var vec42r = skinnedMeshRenderer_1.help_v4_2;
                    var vec32p = skinnedMeshRenderer_1.help_v3_2;
                    vec42r.x = skData[8 * bIdx[index].v2 + 0];
                    vec42r.y = skData[8 * bIdx[index].v2 + 1];
                    vec42r.z = skData[8 * bIdx[index].v2 + 2];
                    vec42r.w = skData[8 * bIdx[index].v2 + 3];
                    vec32p.x = skData[8 * bIdx[index].v2 + 4];
                    vec32p.y = skData[8 * bIdx[index].v2 + 5];
                    vec32p.z = skData[8 * bIdx[index].v2 + 6];
                    var vec43r = skinnedMeshRenderer_1.help_v4_3;
                    var vec33p = skinnedMeshRenderer_1.help_v3_3;
                    vec43r.x = skData[8 * bIdx[index].v3 + 0];
                    vec43r.y = skData[8 * bIdx[index].v3 + 1];
                    vec43r.z = skData[8 * bIdx[index].v3 + 2];
                    vec43r.w = skData[8 * bIdx[index].v3 + 3];
                    vec33p.x = skData[8 * bIdx[index].v3 + 4];
                    vec33p.y = skData[8 * bIdx[index].v3 + 5];
                    vec33p.z = skData[8 * bIdx[index].v3 + 6];
                    var mat0 = skinnedMeshRenderer_1.help_mtx;
                    var mat1 = skinnedMeshRenderer_1.help_mtx_1;
                    var mat2 = skinnedMeshRenderer_1.help_mtx_2;
                    var mat3 = skinnedMeshRenderer_1.help_mtx_3;
                    m4m.math.matrixMakeTransformRTS(vec30p, m4m.math.pool.vector3_one, vec40r, mat0);
                    m4m.math.matrixMakeTransformRTS(vec31p, m4m.math.pool.vector3_one, vec41r, mat1);
                    m4m.math.matrixMakeTransformRTS(vec32p, m4m.math.pool.vector3_one, vec42r, mat2);
                    m4m.math.matrixMakeTransformRTS(vec33p, m4m.math.pool.vector3_one, vec43r, mat3);
                    m4m.math.matrixScaleByNum(data.blendWeight[index].v0, mat0);
                    m4m.math.matrixScaleByNum(data.blendWeight[index].v1, mat1);
                    m4m.math.matrixScaleByNum(data.blendWeight[index].v2, mat2);
                    m4m.math.matrixScaleByNum(data.blendWeight[index].v3, mat3);
                    m4m.math.matrixAdd(mat0, mat1, mat);
                    m4m.math.matrixAdd(mat, mat2, mat);
                    m4m.math.matrixAdd(mat, mat3, mat);
                }
                else {
                    var mat0 = m4m.math.pool.new_matrix();
                    mat0.rawData = skData.slice(16 * bIdx[index].v0, 16 * bIdx[index].v0 + 16);
                    var mat1 = m4m.math.pool.new_matrix();
                    mat1.rawData = skData.slice(16 * bIdx[index].v1, 16 * bIdx[index].v1 + 16);
                    var mat2 = m4m.math.pool.new_matrix();
                    mat2.rawData = skData.slice(16 * bIdx[index].v2, 16 * bIdx[index].v2 + 16);
                    var mat3 = m4m.math.pool.new_matrix();
                    mat3.rawData = skData.slice(16 * bIdx[index].v3, 16 * bIdx[index].v3 + 16);
                    m4m.math.matrixScaleByNum(data.blendWeight[index].v0, mat0);
                    m4m.math.matrixScaleByNum(data.blendWeight[index].v1, mat1);
                    m4m.math.matrixScaleByNum(data.blendWeight[index].v2, mat2);
                    m4m.math.matrixScaleByNum(data.blendWeight[index].v3, mat3);
                    m4m.math.matrixAdd(mat0, mat1, mat);
                    m4m.math.matrixAdd(mat, mat2, mat);
                    m4m.math.matrixAdd(mat, mat3, mat);
                    m4m.math.pool.delete_matrix(mat0);
                    m4m.math.pool.delete_matrix(mat1);
                    m4m.math.pool.delete_matrix(mat2);
                    m4m.math.pool.delete_matrix(mat3);
                }
            };
            skinnedMeshRenderer.prototype.calActualVertexByIndex = function (index, t) {
                var data = this.mesh.data;
                var verindex = data.trisindex[index];
                // var p = data.pos[verindex];
                var p = t;
                data.getPosition(verindex, p);
                var mtx = skinnedMeshRenderer_1.VertexHelpMtx;
                this.getMatByIndex(verindex, mtx);
                // m4m.math.matrixMultiply(this.gameObject.transform.getLocalMatrix(), mat, mat);
                m4m.math.matrixTransformVector3(p, mtx, t);
            };
            /**
             * @public
             * @language zh_CN
             * @param ray 射线
             * @classdesc
             * 射线检测
             * @version m4m 1.0
             */
            skinnedMeshRenderer.prototype.intersects = function (ray, outInfo) {
                var ishided = false;
                var lastDistance = Number.MAX_VALUE;
                if (this.player != null && this.player.gameObject && this.mesh && this.mesh.data) {
                    var mvpmat = this.player.gameObject.transform.getWorldMatrix();
                    var data = this.mesh.data;
                    for (var i = 0; i < this.mesh.submesh.length; i++) {
                        var submesh = this.mesh.submesh[i];
                        var t0 = skinnedMeshRenderer_1.inteRayHelp_v3;
                        var t1 = skinnedMeshRenderer_1.inteRayHelp_v3_1;
                        var t2 = skinnedMeshRenderer_1.inteRayHelp_v3_2;
                        for (var index = submesh.start; index < submesh.size; index += 3) {
                            var verindex0 = data.trisindex[index];
                            var verindex1 = data.trisindex[index + 1];
                            var verindex2 = data.trisindex[index + 2];
                            // var p0 = data.pos[verindex0];
                            // var p1 = data.pos[verindex1];
                            // var p2 = data.pos[verindex2];
                            var p0 = t0;
                            var p1 = t1;
                            var p2 = t2;
                            data.getPosition(verindex0, p0);
                            data.getPosition(verindex1, p1);
                            data.getPosition(verindex2, p2);
                            var mat0 = skinnedMeshRenderer_1.inteRayHelp_mtx;
                            this.getMatByIndex(verindex0, mat0);
                            var mat1 = skinnedMeshRenderer_1.inteRayHelp_mtx_1;
                            this.getMatByIndex(verindex1, mat1);
                            var mat2 = skinnedMeshRenderer_1.inteRayHelp_mtx_2;
                            this.getMatByIndex(verindex2, mat2);
                            if (mat0 == null || mat1 == null || mat2 == null)
                                continue;
                            var mat00 = skinnedMeshRenderer_1.help_mtx;
                            m4m.math.matrixMultiply(mvpmat, mat0, mat00);
                            var mat11 = skinnedMeshRenderer_1.help_mtx_1;
                            m4m.math.matrixMultiply(mvpmat, mat1, mat11);
                            var mat22 = skinnedMeshRenderer_1.help_mtx_2;
                            m4m.math.matrixMultiply(mvpmat, mat2, mat22);
                            m4m.math.matrixTransformVector3(p0, mat00, t0);
                            m4m.math.matrixTransformVector3(p1, mat11, t1);
                            m4m.math.matrixTransformVector3(p2, mat22, t2);
                            var tempinfo = m4m.math.pool.new_pickInfo();
                            var bool = ray.intersectsTriangle(t0, t1, t2, tempinfo);
                            if (bool) {
                                if (tempinfo.distance < 0)
                                    continue;
                                if (lastDistance > tempinfo.distance) {
                                    ishided = true;
                                    outInfo.cloneFrom(tempinfo);
                                    lastDistance = outInfo.distance;
                                    outInfo.faceId = index / 3;
                                    outInfo.subMeshId = i;
                                    var tdir = skinnedMeshRenderer_1.inteRayHelp_v3_3;
                                    m4m.math.vec3ScaleByNum(ray.direction, outInfo.distance, tdir);
                                    m4m.math.vec3Add(ray.origin, tdir, outInfo.hitposition);
                                }
                            }
                            m4m.math.pool.delete_pickInfo(tempinfo);
                        }
                    }
                }
                return ishided;
            };
            skinnedMeshRenderer.prototype.update = function (delta) {
                // if (this._skeletonMatrixData == null)
                // {
                //     this.maxBoneCount = 55;
                //     this._skeletonMatrixData = new Float32Array(8 * this.maxBoneCount);
                //     //this._efficient = true;
                // }
                if (this.materials != null && this.materials.length > 0) {
                    var _mat = this.materials[0];
                    if (_mat) {
                        this.layer = _mat.getLayer();
                        if (!this.issetq)
                            this._queue = _mat.getQueue();
                    }
                }
                if (this.player != null && this.player.gameObject && this.player.frameDirty) {
                    this.player.fillPoseData(this._skeletonMatrixData, this.bones);
                }
            };
            skinnedMeshRenderer.prototype.render = function (context, assetmgr, camera) {
                framework.DrawCallInfo.inc.currentState = framework.DrawCallEnum.SKinrender;
                if (this.player != null && this.player.gameObject) {
                    context.updateLightMask(this.gameObject.layer);
                    context.updateModel(this.player.gameObject.transform);
                }
                context.vec4_bones = this._skeletonMatrixData;
                if (this._mesh && this.mesh.glMesh) {
                    // this._mesh.glMesh.bindVboBuffer(context.webgl);
                    if (this._mesh.submesh != null) {
                        for (var i = 0; i < this._mesh.submesh.length; i++) {
                            var sm = this._mesh.submesh[i];
                            var mid = this._mesh.submesh[i].matIndex; //根据这个找到使用的具体哪个材质
                            var usemat = this.materials[mid];
                            if (usemat != null) {
                                if (this.gameObject.transform.scene.fog) {
                                    // context.fog = this.gameObject.transform.scene.fog;
                                    usemat.draw(context, this._mesh, sm, "skin_fog");
                                }
                                else {
                                    usemat.draw(context, this._mesh, sm, "skin");
                                }
                            }
                        }
                    }
                }
            };
            /**
             * @private
             */
            skinnedMeshRenderer.prototype.remove = function () {
                this.materials.forEach(function (element) {
                    if (element)
                        element.unuse();
                });
                if (this.mesh)
                    this.mesh.unuse();
                this.bones.length = 0;
                this._skeletonMatrixData = null;
            };
            /**
             * @private
             */
            skinnedMeshRenderer.prototype.clone = function () {
            };
            var skinnedMeshRenderer_1;
            skinnedMeshRenderer.ClassName = "skinnedMeshRenderer";
            skinnedMeshRenderer.help_v3 = new m4m.math.vector3();
            skinnedMeshRenderer.help_v3_1 = new m4m.math.vector3();
            skinnedMeshRenderer.help_v3_2 = new m4m.math.vector3();
            skinnedMeshRenderer.help_v3_3 = new m4m.math.vector3();
            skinnedMeshRenderer.help_v4 = new m4m.math.vector4();
            skinnedMeshRenderer.help_v4_1 = new m4m.math.vector4();
            skinnedMeshRenderer.help_v4_2 = new m4m.math.vector4();
            skinnedMeshRenderer.help_v4_3 = new m4m.math.vector4();
            skinnedMeshRenderer.help_mtx = new m4m.math.matrix();
            skinnedMeshRenderer.help_mtx_1 = new m4m.math.matrix();
            skinnedMeshRenderer.help_mtx_2 = new m4m.math.matrix();
            skinnedMeshRenderer.help_mtx_3 = new m4m.math.matrix();
            skinnedMeshRenderer.VertexHelpMtx = new m4m.math.matrix();
            skinnedMeshRenderer.inteRayHelp_v3 = new m4m.math.vector3();
            skinnedMeshRenderer.inteRayHelp_v3_1 = new m4m.math.vector3();
            skinnedMeshRenderer.inteRayHelp_v3_2 = new m4m.math.vector3();
            skinnedMeshRenderer.inteRayHelp_v3_3 = new m4m.math.vector3();
            skinnedMeshRenderer.inteRayHelp_mtx = new m4m.math.matrix();
            skinnedMeshRenderer.inteRayHelp_mtx_1 = new m4m.math.matrix();
            skinnedMeshRenderer.inteRayHelp_mtx_2 = new m4m.math.matrix();
            __decorate([
                m4m.reflect.Field("material[]"),
                __metadata("design:type", Array)
            ], skinnedMeshRenderer.prototype, "materials", void 0);
            __decorate([
                m4m.reflect.Field("mesh"),
                __metadata("design:type", framework.mesh),
                __metadata("design:paramtypes", [framework.mesh])
            ], skinnedMeshRenderer.prototype, "mesh", null);
            __decorate([
                m4m.reflect.Field("transform[]"),
                __metadata("design:type", Array)
            ], skinnedMeshRenderer.prototype, "bones", void 0);
            __decorate([
                m4m.reflect.Field("transform"),
                __metadata("design:type", framework.transform)
            ], skinnedMeshRenderer.prototype, "rootBone", void 0);
            __decorate([
                m4m.reflect.Field("vector3"),
                __metadata("design:type", m4m.math.vector3)
            ], skinnedMeshRenderer.prototype, "center", void 0);
            __decorate([
                m4m.reflect.Field("vector3"),
                __metadata("design:type", m4m.math.vector3)
            ], skinnedMeshRenderer.prototype, "size", void 0);
            skinnedMeshRenderer = skinnedMeshRenderer_1 = __decorate([
                m4m.reflect.nodeRender,
                m4m.reflect.nodeComponent,
                __metadata("design:paramtypes", [])
            ], skinnedMeshRenderer);
            return skinnedMeshRenderer;
        }());
        framework.skinnedMeshRenderer = skinnedMeshRenderer;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../../io/reflect.ts" />
/// <reference path="../../transform/transform.ts" />
/// <reference path="../../component/boxcollider.ts" />
/// <reference path="../../component/meshcollider.ts" />
/// <reference path="../../component/meshfilter.ts" />
/// <reference path="../../component/meshrenderer.ts" />
/// <reference path="../../component/skinnedmeshrenderer.ts" />
var m4m;
/// <reference path="../../../io/reflect.ts" />
/// <reference path="../../transform/transform.ts" />
/// <reference path="../../component/boxcollider.ts" />
/// <reference path="../../component/meshcollider.ts" />
/// <reference path="../../component/meshfilter.ts" />
/// <reference path="../../component/meshrenderer.ts" />
/// <reference path="../../component/skinnedmeshrenderer.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        var Interpolation;
        (function (Interpolation) {
            Interpolation[Interpolation["Linear"] = 0] = "Linear";
            Interpolation[Interpolation["Step"] = 1] = "Step";
            Interpolation[Interpolation["Curve"] = 2] = "Curve"; // 曲线插值
        })(Interpolation = framework.Interpolation || (framework.Interpolation = {}));
        var WrapMode;
        (function (WrapMode) {
            WrapMode[WrapMode["Default"] = 0] = "Default";
            WrapMode[WrapMode["Once"] = 1] = "Once";
            WrapMode[WrapMode["Clamp"] = 1] = "Clamp";
            WrapMode[WrapMode["Loop"] = 2] = "Loop";
            WrapMode[WrapMode["PingPong"] = 4] = "PingPong";
            WrapMode[WrapMode["ClampForever"] = 8] = "ClampForever";
        })(WrapMode = framework.WrapMode || (framework.WrapMode = {}));
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 关键帧动画片段资源
         * @version m4m 1.0
         */
        var keyFrameAniClip = /** @class */ (function () {
            function keyFrameAniClip(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 是否为默认资源
                 * @version m4m 1.0
                 */
                this.defaultAsset = false;
                //总时长 /s
                this.length = 0;
                this.frameRate = 0;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 属性变化曲线数组
                 * @version m4m 1.0
                 */
                this.curves = [];
                this._interpolation = Interpolation.Linear;
                if (!assetName) {
                    assetName = "keyFrameAniClip_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取资源名称
             * @version m4m 1.0
             */
            keyFrameAniClip.prototype.getName = function () {
                return this.name.getText();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取资源唯一id
             * @version m4m 1.0
             */
            keyFrameAniClip.prototype.getGUID = function () {
                return this.id.getID();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 引用计数加一
             * @version m4m 1.0
             */
            keyFrameAniClip.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 引用计数减一
             * @version m4m 1.0
             */
            keyFrameAniClip.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 释放资源
             * @version m4m 1.0
             */
            keyFrameAniClip.prototype.dispose = function () {
                this.curves.length = 0;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 计算资源字节大小
             * @version m4m 1.0
             */
            keyFrameAniClip.prototype.caclByteLength = function () {
                var total = 0;
                // for (let k in this.bones)
                // {
                //     total += math.caclStringByteLength(this.bones[k]);
                // }
                // for (let k in this.frames)
                // {
                //     total += this.frames[k].byteLength;
                //     total += math.caclStringByteLength(k);
                // }
                // total += subClip.caclByteLength() * this.subclips.length;
                return total;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 解析资源
             * @param jsonStr 动画json数据
             * @version m4m 1.0
             */
            keyFrameAniClip.prototype.Parse = function (jsonStr) {
                var obj = JSON.parse(jsonStr);
                var tag = obj["tag"];
                this.length = obj["length"];
                this._wrapMode = obj["wrapMode"];
                this.frameRate = obj["frameRate"];
                this._interpolation = obj["interpolation"] || Interpolation.Linear;
                var curves_o = obj["curves"];
                for (var i = 0; i < curves_o.length; i++) {
                    var curve = new AnimationCurve();
                    var curve_o = curves_o[i];
                    var kfs_o = curve_o["keyFrames"];
                    curve.path = curve_o["path"];
                    //curve.propertyName = curve_o["propertyName"];
                    curve.propertyName = kFAniClipUtil.converUnityTypeProperty(curve_o["type"], curve_o["propertyName"]);
                    //curve.type = curve_o["type"];
                    curve.type = kFAniClipUtil.converUnityType(curve_o["type"]);
                    for (var j = 0; j < kfs_o.length; j++) {
                        var kf_o = kfs_o[j];
                        var kf = new keyFrame();
                        if (typeof (kf_o["inTangent"]) === "string")
                            kf.inTangent = Number(kf_o["inTangent"]);
                        else
                            kf.inTangent = kf_o["inTangent"];
                        if (typeof (kf_o["outTangent"]) === "string")
                            kf.outTangent = Number(kf_o["outTangent"]);
                        else
                            kf.outTangent = kf_o["outTangent"];
                        kf.tangentMode = kf_o["tangentMode"];
                        kf.time = kf_o["time"];
                        kf.value = kf_o["value"];
                        curve.keyFrames.push(kf);
                    }
                    this.curves.push(curve);
                }
                return this;
            };
            Object.defineProperty(keyFrameAniClip.prototype, "wrapMode", {
                /**
                 * @public
                 * @language zh_CN
                 * 循环模式
                 * @version m4m 1.0
                 */
                get: function () { return this._wrapMode; },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(keyFrameAniClip.prototype, "fps", {
                /**
                 * @public
                 * @language zh_CN
                 * 动画片段的帧率
                 * @version m4m 1.0
                 */
                get: function () {
                    return this.frameRate;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(keyFrameAniClip.prototype, "time", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 播放时长
                 * @version m4m 1.0
                 */
                get: function () {
                    return this.length;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(keyFrameAniClip.prototype, "frameCount", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 最大帧数
                 * @version m4m 1.0
                 */
                get: function () { return Math.floor(this.frameRate * this.length); },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(keyFrameAniClip.prototype, "interpolation", {
                get: function () {
                    return this._interpolation;
                },
                enumerable: false,
                configurable: true
            });
            keyFrameAniClip.ClassName = "keyFrameAniClip";
            __decorate([
                m4m.reflect.Field("constText"),
                __metadata("design:type", framework.constText)
            ], keyFrameAniClip.prototype, "name", void 0);
            keyFrameAniClip = __decorate([
                m4m.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], keyFrameAniClip);
            return keyFrameAniClip;
        }());
        framework.keyFrameAniClip = keyFrameAniClip;
        var AnimationCurve = /** @class */ (function () {
            function AnimationCurve() {
                this.keyFrames = []; //曲线上的 关键帧
            }
            return AnimationCurve;
        }());
        framework.AnimationCurve = AnimationCurve;
        var keyFrame = /** @class */ (function () {
            function keyFrame() {
            }
            return keyFrame;
        }());
        framework.keyFrame = keyFrame;
        var kFAniClipUtil = /** @class */ (function () {
            function kFAniClipUtil() {
            }
            Object.defineProperty(kFAniClipUtil, "typePair", {
                get: function () {
                    if (!kFAniClipUtil._typePair)
                        kFAniClipUtil._typePair = kFAniClipUtil.regType();
                    return kFAniClipUtil._typePair;
                },
                enumerable: false,
                configurable: true
            });
            kFAniClipUtil.isUnityExp = function (tag) {
                if (framework.StringUtil.isNullOrEmptyObject(tag))
                    return false;
                return tag.indexOf("unity") != -1;
            };
            kFAniClipUtil.converUnityType = function (tyep) {
                var result = "";
                if (framework.StringUtil.isNullOrEmptyObject(tyep))
                    return result;
                if (tyep.indexOf("UnityEngine") == -1)
                    return tyep; //非unity 内建组件
                var strs = tyep.split(".");
                if (strs.length < 1 || !strs[strs.length - 1])
                    return result;
                var tempT = strs[strs.length - 1];
                var obj = kFAniClipUtil._typePair[tempT];
                if (obj != null) {
                    result = obj["type"];
                }
                return result;
            };
            kFAniClipUtil.converUnityTypeProperty = function (tyep, propertyName) {
                var result = propertyName;
                if (framework.StringUtil.isNullOrEmptyObject(propertyName))
                    return "";
                if (tyep.indexOf("UnityEngine") != -1) {
                    var strs = tyep.split(".");
                    tyep = strs[strs.length - 1];
                }
                var obj = kFAniClipUtil._typePair[tyep];
                var cgProperty = propertyName;
                if (propertyName.lastIndexOf(".") != -1) {
                    cgProperty = propertyName.substr(0, propertyName.lastIndexOf("."));
                }
                if (obj && obj[kFAniClipUtil.propTag] && obj[kFAniClipUtil.propTag][cgProperty]) {
                    var str = obj[kFAniClipUtil.propTag][cgProperty];
                    result = propertyName.replace(cgProperty, str);
                }
                return result;
            };
            //注册转换 类型
            kFAniClipUtil.regType = function () {
                var result = {};
                result["Transform"] = { "type": framework.transform["name"] };
                result["BoxCollider"] = { "type": framework.boxcollider["name"] };
                result["MeshRenderer"] = { "type": framework.meshRenderer["name"] };
                result["MeshFilter"] = { "type": framework.meshFilter["name"] };
                result["SkinnedMeshRenderer"] = { "type": framework.skinnedMeshRenderer["name"] };
                kFAniClipUtil.regProperty(result);
                return result;
            };
            //注册转换 具体属性
            kFAniClipUtil.regProperty = function (obj) {
                //Transform
                kFAniClipUtil.assemblyProp(obj, "Transform", "m_LocalPosition", "localTranslate");
                kFAniClipUtil.assemblyProp(obj, "Transform", "m_LocalScale", "localScale");
                kFAniClipUtil.assemblyProp(obj, "Transform", "m_LocalRotation", "localRotate");
            };
            kFAniClipUtil.assemblyProp = function (obj, Type, prop, replaceProp) {
                if (!obj["Transform"][kFAniClipUtil.propTag])
                    obj["Transform"][kFAniClipUtil.propTag] = {};
                obj["Transform"][kFAniClipUtil.propTag][prop] = replaceProp;
            };
            kFAniClipUtil.propTag = "__prop__";
            kFAniClipUtil._typePair = kFAniClipUtil.regType();
            return kFAniClipUtil;
        }());
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../../io/reflect.ts" />
var m4m;
/// <reference path="../../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @private
         */
        var UniformData = /** @class */ (function () {
            function UniformData(type, value, defaultValue) {
                if (defaultValue === void 0) { defaultValue = null; }
                this.type = type;
                this.value = value;
                this.defaultValue = defaultValue;
            }
            __decorate([
                m4m.reflect.Field("number"),
                m4m.reflect.UIStyle("UniformTypeEnum"),
                __metadata("design:type", Number)
            ], UniformData.prototype, "type", void 0);
            __decorate([
                m4m.reflect.Field("any"),
                __metadata("design:type", Object)
            ], UniformData.prototype, "value", void 0);
            UniformData = __decorate([
                m4m.reflect.SerializeType,
                __metadata("design:paramtypes", [Number, Object, Object])
            ], UniformData);
            return UniformData;
        }());
        framework.UniformData = UniformData;
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 材质资源
         * @param buf buffer数组
         * @version m4m 1.0
         */
        var material = /** @class */ (function () {
            function material(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.name = null;
                this.id = new framework.resID();
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 是否为默认资源
                 * @version m4m 1.0
                 */
                this.defaultAsset = false;
                this._enableGpuInstancing = false;
                //
                this._shaderGUID = "";
                this._textureGUID = "";
                /** gpuInstancing 材质唯一ID */
                this.gpuInstancingGUID = "";
                /** GPUinstance Attrib ID 数据 map  */
                this.instanceAttribIDValMap = {};
                this.queue = 0;
                this.statedMapUniforms = {};
                this.uniformDirtyMap = {}; //值变化标记map
                if (!assetName) {
                    assetName = "material_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
                m4m.io.enumMgr.enumMap["UniformTypeEnum"] = m4m.render.UniformTypeEnum;
                // this.mapUniformTemp = {};
            }
            material_3 = material;
            Object.defineProperty(material.prototype, "enableGpuInstancing", {
                get: function () { return this._enableGpuInstancing; },
                set: function (enable) {
                    this._enableGpuInstancing = enable;
                    if (enable) {
                        this.getTexGuid(this); //贴图使用唯一标识ID，gupInstance 使用
                        this.getShaderGuid(this.shader);
                        this.refreshGpuInstancingGUID();
                    }
                },
                enumerable: false,
                configurable: true
            });
            ;
            ;
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取资源名称
             * @version m4m 1.0
             */
            material.prototype.getName = function () {
                if (this.name == undefined) {
                    return null;
                }
                return this.name.getText();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取资源唯一id
             * @version m4m 1.0
             */
            material.prototype.getGUID = function () {
                return this.id.getID();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 释放资源
             * @version m4m 1.0
             */
            material.prototype.dispose = function () {
                for (var id in this.statedMapUniforms) {
                    switch (this.defaultMapUniform[id].type) {
                        case m4m.render.UniformTypeEnum.Texture:
                        case m4m.render.UniformTypeEnum.CubeTexture:
                            if (this.statedMapUniforms[id] != null)
                                this.statedMapUniforms[id].unuse();
                            break;
                    }
                }
                delete this.statedMapUniforms;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 引用计数加一
             * @version m4m 1.0
             */
            material.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 引用计数减一
             * @version m4m 1.0
             */
            material.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 计算资源字节大小
             * @version m4m 1.0
             */
            material.prototype.caclByteLength = function () {
                var total = 0;
                if (this.shader) {
                    total += this.shader.caclByteLength();
                }
                for (var k in this.statedMapUniforms) {
                    var type = this.defaultMapUniform[k].type;
                    var value = this.statedMapUniforms[k].value;
                    var defaultValue = this.defaultMapUniform[k].value;
                    switch (type) {
                        case m4m.render.UniformTypeEnum.Float:
                            total += 4;
                            break;
                        case m4m.render.UniformTypeEnum.Floatv:
                            total += value.byteLength;
                            break;
                        case m4m.render.UniformTypeEnum.Float4:
                            total += 16;
                            break;
                        case m4m.render.UniformTypeEnum.Float4v:
                            total += value.byteLength;
                            break;
                        case m4m.render.UniformTypeEnum.Float4x4:
                            total += 64;
                            break;
                        case m4m.render.UniformTypeEnum.Float4x4v:
                            total += value.byteLength;
                            break;
                        case m4m.render.UniformTypeEnum.Texture:
                        case m4m.render.UniformTypeEnum.CubeTexture:
                            if (value != null) {
                                total += value.caclByteLength();
                            }
                            else if (defaultValue != null) {
                                total += defaultValue.caclByteLength();
                            }
                            break;
                    }
                }
                return total;
            };
            material.prototype.uploadUnifoms = function (pass, context, lastMatSame) {
                if (lastMatSame === void 0) { lastMatSame = false; }
                m4m.render.shaderUniform.texindex = 0;
                var udMap = this.uniformDirtyMap;
                var uTEnum = m4m.render.UniformTypeEnum;
                for (var key in pass.mapuniforms) {
                    var unifom = pass.mapuniforms[key];
                    if (lastMatSame && !material_3.sameMatPassMap[unifom.name] && !udMap[unifom.name]) {
                        if (uTEnum.Texture == unifom.type || uTEnum.CubeTexture == unifom.type) {
                            m4m.render.shaderUniform.texindex++;
                        }
                        continue;
                    }
                    udMap[unifom.name] = false; //标记为 没有 变化
                    var func = m4m.render.shaderUniform.applyuniformFunc[unifom.type];
                    var unifomValue = void 0;
                    if (framework.uniformSetter.autoUniformDic[unifom.name] != null) {
                        var autoFunc = framework.uniformSetter.autoUniformDic[unifom.name];
                        unifomValue = autoFunc(context);
                    }
                    else {
                        if (this.statedMapUniforms[unifom.name] != null) {
                            unifomValue = this.statedMapUniforms[unifom.name];
                        }
                        else if (this.defaultMapUniform[unifom.name]) {
                            unifomValue = this.defaultMapUniform[unifom.name].value;
                        }
                        else {
                            console.error("Uniform don't be setted or have def value. uniform:" + unifom.name + "mat:" + this.getName());
                        }
                    }
                    if (unifomValue == null) {
                        framework.error.push(new Error("material [".concat(this.name.getText(), "], unifrom [").concat(unifom.name, "] uploadunifrom fail! unifom Value is null!! ")));
                        continue;
                    }
                    if (unifom.type == m4m.render.UniformTypeEnum.Texture && !unifomValue.glTexture) {
                        framework.error.push(new Error("material [".concat(this.name.getText(), "] uploadunifrom fail! glTexture is null!! ")));
                        continue;
                    }
                    func(unifom.location, unifomValue);
                }
            };
            /**
             * 上传InstanceAtteribute 数据
             * @param pass 绘制通道
             * @param darr 数组对象
             */
            material.prototype.uploadInstanceAtteribute = function (pass, darr) {
                // let attmap = pass.program.mapInstanceAttribID;
                var attmap = pass.program.mapAllAttrID;
                for (var id in attmap) {
                    //通过地址获取 ID
                    var arr = this.instanceAttribIDValMap[id];
                    if (!arr)
                        continue;
                    // let att = attmap[id];
                    // if (!arr) {
                    //     for (let i = 0, len = att.size; i < len; i++) {
                    //         darr.push(0);
                    //     }
                    // } else {
                    //     InsSize += att.size;
                    //     for (let i = 0, len = arr.length; i < len; i++) {
                    //         darr.push(arr[i]);
                    //     }
                    // }
                    for (var i = 0, len = arr.length; i < len; i++) {
                        darr.push(arr[i]);
                    }
                }
            };
            /**
             * 获取InstanceAtteribute 上传数据的大小
             * @param pass 绘制通道
             */
            material.prototype.getInstanceAtteributeSize = function (pass) {
                // let attmap = pass.program.mapInstanceAttribID;
                var attmap = pass.program.mapAllAttrID;
                var InsSize = 0;
                for (var id in attmap) {
                    //通过地址获取 ID
                    var arr = this.instanceAttribIDValMap[id];
                    if (!arr)
                        continue;
                    var att = attmap[id];
                    InsSize += att.size;
                }
                return InsSize;
            };
            // private setInstanceAttribValue(id:string,arr:number[]){
            //     if(!id) return;
            //     this.instanceAttribValMap[id] = arr;
            // }
            material.prototype.getInstanceAttribValue = function (id) {
                if (this.instanceAttribIDValMap[id] == null) {
                    this.instanceAttribIDValMap[id] = [];
                }
                return this.instanceAttribIDValMap[id];
            };
            // private isNotBuildinAttribId(id: string) {
            //     return !render.glProgram.isBuildInAttrib(id);
            // }
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 设置shader 不保留原有数据
             * @param shader shader实例
             * @version m4m 1.0
             */
            material.prototype.setShader = function (shader) {
                this.shader = shader;
                this.defaultMapUniform = shader.defaultMapUniform;
                if (this._enableGpuInstancing) {
                    this.getShaderGuid(shader);
                    this.refreshGpuInstancingGUID();
                }
            };
            // private _changeShaderMap: { [name: string]: material } = {};
            // /**
            //  * @public
            //  * @language zh_CN
            //  * @classdesc
            //  * 修改shader 保留原有数据
            //  * @param shader shader实例
            //  * @version m4m 1.0
            //  */
            // changeShader(shader: shader)
            // {
            //     let map: { [id: string]: UniformData };
            //     if (this._changeShaderMap[shader.getName()] != undefined)
            //     {
            //         map = this._changeShaderMap[shader.getName()].mapUniform;
            //     }
            //     else
            //     {
            //         let mat: material = this.clone();
            //         map = mat.mapUniform;
            //         this._changeShaderMap[shader.getName()] = mat;
            //     }
            //     this.setShader(shader);
            //     for (let key in map)
            //     {
            //         if (this.mapUniform[key] != undefined)
            //         {
            //             this.mapUniform[key] = map[key];
            //         }
            //     }
            // }
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取shader的layer
             * @version m4m 1.0
             */
            material.prototype.getLayer = function () {
                return this.shader.layer;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取shader的queue
             * @version m4m 1.0
             */
            material.prototype.getQueue = function () {
                return this.queue;
            };
            material.prototype.setQueue = function (queue) {
                this.queue = queue;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取shader
             * @version m4m 1.0
             */
            material.prototype.getShader = function () {
                return this.shader;
            };
            //private mapUniformTemp: {[id: string]: UniformData}={};
            /**
             * @private
             */
            material.prototype.setFloat = function (_id, _number) {
                if (this.defaultMapUniform[_id] != null && this.defaultMapUniform[_id].type == m4m.render.UniformTypeEnum.Float) {
                    if (this.statedMapUniforms[_id] != _number) {
                        this.uniformDirtyMap[_id] = true;
                    }
                    this.statedMapUniforms[_id] = _number;
                }
                else {
                    console.log("Set wrong uniform value. Mat Name: " + this.getName() + " Unifom :" + _id);
                }
                // if (this._enableGpuInstancing && this.isNotBuildinAttribId(_id)) {
                if (this._enableGpuInstancing) {
                    var arr = this.getInstanceAttribValue(_id);
                    arr[0] = _number !== null && _number !== void 0 ? _number : 0;
                }
            };
            material.prototype.setInt = function (_id, _number) {
                if (this.defaultMapUniform[_id] != null && this.defaultMapUniform[_id].type == m4m.render.UniformTypeEnum.Int) {
                    if (this.statedMapUniforms[_id] != _number) {
                        this.uniformDirtyMap[_id] = true;
                    }
                    this.statedMapUniforms[_id] = _number;
                }
                else {
                    console.log("Set wrong uniform value. Mat Name: " + this.getName() + " Unifom :" + _id);
                }
                // if (this._enableGpuInstancing && this.isNotBuildinAttribId(_id)) {
                if (this._enableGpuInstancing) {
                    var arr = this.getInstanceAttribValue(_id);
                    arr[0] = _number !== null && _number !== void 0 ? _number : 0;
                }
            };
            /**
             * @private
             */
            material.prototype.setFloatv = function (_id, _numbers) {
                if (this.defaultMapUniform[_id] != null && this.defaultMapUniform[_id].type == m4m.render.UniformTypeEnum.Floatv) {
                    this.statedMapUniforms[_id] = _numbers;
                    this.uniformDirtyMap[_id] = true;
                }
                else {
                    console.log("Set wrong uniform value. Mat Name: " + this.getName() + " Unifom :" + _id);
                }
                // if (this._enableGpuInstancing && this.isNotBuildinAttribId(_id)) {
                if (this._enableGpuInstancing && _numbers) {
                    this.setInsAttribVal(_id, _numbers.length, _numbers);
                }
            };
            /**
             * @private
             */
            material.prototype.setVector4 = function (_id, _vector4) {
                if (this.defaultMapUniform[_id] != null && this.defaultMapUniform[_id].type == m4m.render.UniformTypeEnum.Float4) {
                    this.statedMapUniforms[_id] = _vector4;
                    this.uniformDirtyMap[_id] = true;
                }
                else {
                    console.log("Set wrong uniform value. Mat Name: " + this.getName() + " Unifom :" + _id);
                }
                // if (this._enableGpuInstancing && this.isNotBuildinAttribId(_id)) {
                if (this._enableGpuInstancing) {
                    var arr = this.getInstanceAttribValue(_id);
                    if (_vector4) {
                        arr[0] = _vector4.x;
                        arr[1] = _vector4.y;
                        arr[2] = _vector4.z;
                        arr[3] = _vector4.w;
                    }
                    else {
                        for (var i = 0; i < 4; i++)
                            arr[i] = 0;
                    }
                }
            };
            /**
             * @private
             */
            material.prototype.setVector4v = function (_id, _vector4v) {
                if (this.defaultMapUniform[_id] != null && this.defaultMapUniform[_id].type == m4m.render.UniformTypeEnum.Float4v) {
                    this.statedMapUniforms[_id] = _vector4v;
                    this.uniformDirtyMap[_id] = true;
                    _vector4v.length;
                }
                else {
                    console.log("Set wrong uniform value. Mat Name: " + this.getName() + " Unifom :" + _id);
                }
                // if (this._enableGpuInstancing && this.isNotBuildinAttribId(_id)) {
                if (this._enableGpuInstancing) {
                    this.setInsAttribVal(_id, 4, _vector4v);
                }
            };
            /**
             * @private
             */
            material.prototype.setMatrix = function (_id, _matrix) {
                if (this.defaultMapUniform[_id] != null && this.defaultMapUniform[_id].type == m4m.render.UniformTypeEnum.Float4x4) {
                    this.statedMapUniforms[_id] = _matrix;
                    this.uniformDirtyMap[_id] = true;
                }
                else {
                    console.log("Set wrong uniform value. Mat Name: " + this.getName() + " Unifom :" + _id);
                }
                if (this._enableGpuInstancing) {
                    var data = _matrix ? _matrix.rawData : null;
                    this.setInsAttribVal(_id, 16, data);
                }
            };
            /**
             * @private
             */
            material.prototype.setMatrixv = function (_id, _matrixv) {
                if (this.defaultMapUniform[_id] != null && this.defaultMapUniform[_id].type == m4m.render.UniformTypeEnum.Float4x4v) {
                    this.statedMapUniforms[_id] = _matrixv;
                    this.uniformDirtyMap[_id] = true;
                }
                else {
                    console.log("Set wrong uniform value. Mat Name: " + this.getName() + " Unifom :" + _id);
                }
                if (this._enableGpuInstancing) {
                    this.setInsAttribVal(_id, 16, _matrixv);
                }
            };
            /**
             * @private
             */
            material.prototype.setTexture = function (_id, _texture, resname) {
                if (resname === void 0) { resname = ""; }
                // if((this.defaultMapUniform[_id] != null && this.defaultMapUniform[_id].type == render.UniformTypeEnum.Texture) || _id == "_LightmapTex"){
                if (!(this.defaultMapUniform[_id] != null && this.defaultMapUniform[_id].type == m4m.render.UniformTypeEnum.Texture) && _id != "_LightmapTex") {
                    console.log("Set wrong uniform value. Mat Name: " + this.getName() + " Unifom :" + _id);
                    return;
                }
                var oldTex = this.statedMapUniforms[_id];
                if (oldTex != null) {
                    if (oldTex == _texture)
                        return;
                    if (this.statedMapUniforms[_id].defaultAsset) {
                        oldTex = null;
                        // this.statedMapUniforms[_id].unuse();
                    }
                }
                // let old;
                this.statedMapUniforms[_id] = _texture;
                if (_texture != null) {
                    if (!_texture.defaultAsset) {
                        _texture.use();
                    }
                    //图片的尺寸信息(1/width,1/height,width,height)
                    var _texelsizeName = _id + "_TexelSize";
                    var _gltexture = _texture.glTexture;
                    if (_gltexture != null && this.defaultMapUniform[_texelsizeName] != null) {
                        this.setVector4(_texelsizeName, new m4m.math.vector4(1.0 / _gltexture.width, 1.0 / _gltexture.height, _gltexture.width, _gltexture.height));
                    }
                    this.uniformDirtyMap[_id] = true;
                    if (this._enableGpuInstancing) {
                        this.getTexGuid(this); //贴图使用唯一标识ID，gupInstance 使用
                        this.refreshGpuInstancingGUID();
                    }
                }
                else {
                    console.log("Set wrong uniform value. Mat Name: " + this.getName() + " Unifom :" + _id);
                }
                if (oldTex)
                    oldTex.unuse();
                // if ((this.defaultMapUniform[_id] != null && this.defaultMapUniform[_id].type == render.UniformTypeEnum.Texture) || _id == "_LightmapTex")
                // {
                // } else
                // {
                //     console.log("Set wrong uniform value. Mat Name: " + this.getName() + " Unifom :" + _id);
                // }
            };
            /** 设置 GPU instance attribute 的值 */
            material.prototype.setInsAttribVal = function (id, len, data) {
                var _a;
                var arr = this.getInstanceAttribValue(id);
                if (data) {
                    for (var i = 0; i < len; i++)
                        arr[i] = (_a = data[i]) !== null && _a !== void 0 ? _a : 0;
                }
                else {
                    for (var i = 0; i < len; i++)
                        arr[i] = 0;
                }
            };
            //贴图使用唯一标识ID，gupInstance 使用
            material.prototype.getTexGuid = function (mat) {
                var staMap = mat.statedMapUniforms;
                this._textureGUID = "";
                for (var key in staMap) {
                    var val = staMap[key];
                    if (val.getGUID == null)
                        continue;
                    var guid = val.getGUID();
                    this._textureGUID += "_".concat(guid);
                }
            };
            material.prototype.getShaderGuid = function (sh) {
                if (!sh)
                    return;
                if (!sh.passes["instance"] && !sh.passes["instance_fog"]) {
                    console.warn("shader ".concat(sh.getName(), " , has not \"instance\" pass when enable gpuInstance on the material ").concat(this.getName(), "."));
                }
                else {
                    this._shaderGUID = "" + sh.getGUID();
                }
            };
            material.prototype.refreshGpuInstancingGUID = function () {
                if (!this._shaderGUID) {
                    this.gpuInstancingGUID = "";
                    return;
                }
                this.gpuInstancingGUID = "".concat(this._shaderGUID, "_").concat(this._textureGUID);
            };
            material.prototype.setCubeTexture = function (_id, _texture) {
                if (this.defaultMapUniform[_id] != null && this.defaultMapUniform[_id].type == m4m.render.UniformTypeEnum.CubeTexture) {
                    if (this.statedMapUniforms[_id] != null && (!this.statedMapUniforms[_id].defaultAsset)) {
                        this.statedMapUniforms[_id].unuse();
                    }
                    this.statedMapUniforms[_id] = _texture;
                    if (_texture != null) {
                        if (!_texture.defaultAsset) {
                            _texture.use();
                        }
                        //图片的尺寸信息(1/width,1/height,width,height)
                        var _texelsizeName = _id + "_TexelSize";
                        var _gltexture = _texture.glTexture;
                        if (_gltexture != null && this.defaultMapUniform[_texelsizeName] != null) {
                            this.setVector4(_texelsizeName, new m4m.math.vector4(1.0 / _gltexture.width, 1.0 / _gltexture.height, _gltexture.width, _gltexture.height));
                        }
                    }
                    this.uniformDirtyMap[_id] = true;
                }
                else {
                    console.log("Set wrong uniform value. Mat Name: " + this.getName() + " Unifom :" + _id);
                }
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 绘制
             * @param context 渲染上下文
             * @param mesh 渲染的mesh
             * @param sm 渲染的submesh信息
             *
             * @param instanceCount 批量渲染时绘制数量
             * @version m4m 1.0
             */
            material.prototype.draw = function (context, mesh, sm, basetype, drawInstanceInfo) {
                if (basetype === void 0) { basetype = "base"; }
                if (drawInstanceInfo === void 0) { drawInstanceInfo = undefined; }
                var matGUID = this.getGUID();
                var meshGUID = mesh.getGUID();
                var LastMatSame = matGUID == material_3.lastDrawMatID;
                var LastMeshSame = meshGUID == material_3.lastDrawMeshID;
                var drawPasses = this.shader.passes[basetype + context.drawtype];
                if (drawPasses == undefined) {
                    basetype = basetype.indexOf("fog") != -1 ? "base_fog" : "base";
                    drawPasses = this.shader.passes[basetype + context.drawtype];
                    if (drawPasses == undefined) {
                        drawPasses = this.shader.passes["base" + context.drawtype];
                        if (drawPasses == undefined)
                            return;
                    }
                }
                var instanceCount = (drawInstanceInfo && drawInstanceInfo.instanceCount) || 1;
                for (var i = 0, l = drawPasses.length; i < l; i++) {
                    //渲染状态 和 gl程序启用
                    var pass = drawPasses[i];
                    pass.use(context.webgl);
                    //顶点状态绑定
                    //模型的状态属性绑定
                    // mesh.glMesh.bindVboBuffer(context.webgl);
                    // if (!LastMatSame || !LastMeshSame) mesh.glMesh.bind(context.webgl, pass.program, sm.useVertexIndex);
                    mesh.glMesh.onVAO();
                    //drawInstance 的状态属性绑定
                    drawInstanceInfo && drawInstanceInfo.initBuffer(context.webgl);
                    drawInstanceInfo && drawInstanceInfo.activeAttributes(context.webgl, pass, this);
                    //unifoms 数据上传
                    this.uploadUnifoms(pass, context, LastMatSame);
                    //绘制call
                    framework.DrawCallInfo.inc.add();
                    if (sm.useVertexIndex < 0) { //判断是否走 EBO
                        if (sm.line) {
                            mesh.glMesh.drawArrayLines(context.webgl, sm.start, sm.size, instanceCount);
                        }
                        else {
                            mesh.glMesh.drawArrayTris(context.webgl, sm.start, sm.size, instanceCount);
                        }
                    }
                    else {
                        if (sm.line) {
                            mesh.glMesh.drawElementLines(context.webgl, sm.start, sm.size, instanceCount);
                        }
                        else {
                            mesh.glMesh.drawElementTris(context.webgl, sm.start, sm.size, instanceCount);
                        }
                    }
                    //顶点状态解绑 （drawInstance 的修改放置在中间 ，这样它不会影响 我们模型的VAO ）
                    drawInstanceInfo && drawInstanceInfo.disableAttributes(context.webgl, pass, this);
                    mesh.glMesh.offVAO();
                }
                material_3.lastDrawMatID = matGUID;
                material_3.lastDrawMeshID = meshGUID;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 解析资源
             * @param assetmgr 资源管理实例
             * @param json json数据
             * @version m4m 1.0
             */
            material.prototype.Parse = function (assetmgr, json, bundleName) {
                if (bundleName === void 0) { bundleName = null; }
                var shaderName = json["shader"];
                var shader = assetmgr.getShader(shaderName);
                if (shader == null) {
                    //                 let shaders = [];
                    //                 for(let k in assetmgr.mapShader)
                    //                 {
                    //                     shaders.push(k);
                    //                 }
                    //                 console.error(` 
                    // #######当前shader#######:
                    //                 ${shaders.join("\n")}`);
                    throw new Error("mat解析错误:" + this.name + "  shader 为空！shadername：" + shaderName + " bundleName: " + bundleName);
                }
                this.setShader(shader);
                var queue = json["queue"];
                if (queue) {
                    this.queue = queue;
                }
                var mapUniform = json["mapUniform"];
                for (var i in mapUniform) {
                    var jsonChild = mapUniform[i];
                    var _uniformType = jsonChild["type"];
                    if (_uniformType == null)
                        continue;
                    switch (_uniformType) {
                        case m4m.render.UniformTypeEnum.Texture:
                        case m4m.render.UniformTypeEnum.CubeTexture:
                            var _value = jsonChild["value"];
                            var _texture = assetmgr.getAssetByName(_value, bundleName);
                            if (_texture == null) {
                                console.error("Material Mapuniform Texture 无效(" + _value + ")！shadername：" + shaderName + " bundleName: " + bundleName);
                                //_texture = assetmgr.getDefaultTexture("grid");
                            }
                            else {
                                this.setTexture(i, _texture, _value);
                            }
                            break;
                        case m4m.render.UniformTypeEnum.Float:
                            var _value = jsonChild["value"];
                            this.setFloat(i, parseFloat(_value));
                            break;
                        case m4m.render.UniformTypeEnum.Float4:
                            var tempValue = jsonChild["value"];
                            try {
                                var values = tempValue.match(framework.RegexpUtil.vector4Regexp);
                                if (values != null) {
                                    var _float4 = new m4m.math.vector4(parseFloat(values[1]), parseFloat(values[2]), parseFloat(values[3]), parseFloat(values[4]));
                                    this.setVector4(i, _float4);
                                }
                            }
                            catch (e) {
                                //数据不合法就不提交了
                                console.error("Material Mapuniform float4 无效:value (" + tempValue + ")！shadername：" + shaderName + " bundleName: " + bundleName);
                            }
                            break;
                        default:
                            console.error("Material Mapuniform 无效: 未识别类型(" + jsonChild["type"] + ")！shadername：" + shaderName + " bundleName: " + bundleName);
                            break;
                    }
                }
                return this;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 克隆
             * @version m4m 1.0
             */
            material.prototype.clone = function () {
                var mat = new material_3(this.getName());
                mat.setShader(this.shader);
                mat._enableGpuInstancing = this._enableGpuInstancing;
                mat.defaultMapUniform = this.defaultMapUniform;
                mat.queue = this.queue;
                for (var key in this.uniformDirtyMap) {
                    mat.uniformDirtyMap[key] = this.uniformDirtyMap[key];
                }
                for (var i in this.statedMapUniforms) {
                    var srcSta = this.statedMapUniforms[i];
                    if (srcSta == null)
                        continue;
                    var typeStr = typeof (srcSta);
                    if (typeStr != "object") {
                        mat.statedMapUniforms[i] = srcSta;
                    }
                    else {
                        if (srcSta.use != null) {
                            //是资源、texture
                            mat.statedMapUniforms[i] = srcSta;
                        }
                        else if (srcSta.length != null) {
                            //arry
                            mat.statedMapUniforms[i] = new Float32Array(srcSta);
                        }
                        else if (srcSta.x != null) {
                            //vec4
                            mat.statedMapUniforms[i] = new m4m.math.vector4();
                            m4m.math.vec4Clone(srcSta, mat.statedMapUniforms[i]);
                        }
                        else if (srcSta.rawData != null) {
                            //matrix
                            mat.statedMapUniforms[i] = new m4m.math.matrix();
                            m4m.math.matrixClone(srcSta, mat.statedMapUniforms[i]);
                        }
                    }
                }
                if (mat._enableGpuInstancing) {
                    for (var key in this.instanceAttribIDValMap) {
                        var arr = this.instanceAttribIDValMap[key];
                        mat.instanceAttribIDValMap[key] = arr.concat(); //copy
                    }
                }
                return mat;
            };
            material.prototype.save = function () {
                var obj = {};
                obj["shader"] = this.shader.getName();
                obj["srcshader"] = "";
                obj["mapUniform"] = {};
                for (var item in this.statedMapUniforms) {
                    var __type = this.defaultMapUniform[item].type;
                    var val = this.statedMapUniforms;
                    var jsonValue = {};
                    jsonValue["type"] = __type;
                    switch (__type) {
                        case m4m.render.UniformTypeEnum.CubeTexture:
                        case m4m.render.UniformTypeEnum.Texture:
                            jsonValue["value"] = "".concat(val[item].name.name);
                            break;
                        case m4m.render.UniformTypeEnum.Float4:
                            jsonValue["value"] = "(".concat(val[item].x, ",").concat(val[item].y, ",").concat(val[item].z, ",").concat(val[item].w, ")");
                            break;
                        case m4m.render.UniformTypeEnum.Float:
                            jsonValue["value"] = val[item];
                            break;
                        default:
                            console.warn("\u65E0\u6CD5\u5B58\u50A8\u672A\u89E3\u6790\u7C7B\u578B:".concat(__type, ",").concat(item));
                            continue;
                    }
                    obj["mapUniform"][item] = jsonValue;
                }
                return JSON.stringify(obj);
            };
            var material_3;
            material.ClassName = "material";
            //状态去重忽略列表
            material.sameMatPassMap = {
                glstate_matrix_model: true,
                glstate_matrix_world2object: true,
                glstate_matrix_modelview: true,
                glstate_matrix_it_modelview: true,
                glstate_matrix_mvp: true,
                glstate_vec4_bones: true,
                glstate_matrix_bones: true,
                boneSampler: true,
                glstate_lightmapOffset: true,
                _LightmapTex: true,
                glstate_lightmapUV: true,
                glstate_lightmapRGBAF16: true
            };
            material.lastDrawMatID = -1;
            material.lastDrawMeshID = -1;
            __decorate([
                m4m.reflect.Field("constText"),
                __metadata("design:type", framework.constText)
            ], material.prototype, "name", void 0);
            __decorate([
                m4m.reflect.Field("number")
                /**
                 * 开启使用Gpu Instance 渲染模式
                 */
                ,
                __metadata("design:type", Boolean),
                __metadata("design:paramtypes", [Boolean])
            ], material.prototype, "enableGpuInstancing", null);
            __decorate([
                m4m.reflect.Field("shader"),
                __metadata("design:type", framework.shader)
            ], material.prototype, "shader", void 0);
            material = material_3 = __decorate([
                m4m.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], material);
            return material;
        }());
        framework.material = material;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * mesh资源
         * @version m4m 1.0
         */
        var mesh = /** @class */ (function () {
            function mesh(assetName, isObject) {
                if (assetName === void 0) { assetName = null; }
                if (isObject === void 0) { isObject = false; }
                this.id = new framework.resID();
                this.defaultAsset = false;
                this.szContent = "";
                this.bObjRes = false;
                this.updateByEffect = false;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * submesh信息列表
                 * @version m4m 1.0
                 */
                this.submesh = [];
                // //分片加载状态变量
                this.reading = false;
                if (!assetName) {
                    assetName = "mesh_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
                if (isObject)
                    this.bObjRes = true;
            }
            mesh_1 = mesh;
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取资源名称
             * @version m4m 1.0
             */
            mesh.prototype.getName = function () {
                if (!this.name) {
                    return null;
                }
                return this.name.getText();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取资源唯一id
             * @version m4m 1.0
             */
            mesh.prototype.getGUID = function () {
                return this.id.getID();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 引用计数加一
             * @version m4m 1.0
             */
            mesh.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 引用计数减一
             * @version m4m 1.0
             */
            mesh.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 释放资源
             * @version m4m 1.0
             */
            mesh.prototype.dispose = function () {
                this.glMesh.dispose();
                this.data = null;
                delete this.submesh;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 计算资源字节大小
             * @version m4m 1.0
             */
            mesh.prototype.caclByteLength = function () {
                var total = 0;
                total += this.glMesh.caclByteLength();
                if (this.data) {
                    total += this.data.caclByteLength();
                }
                return total;
            };
            // //分片加载器
            mesh.prototype.readProcess = function (read, data, objVF, vcount, vec10tpose, callback) {
                var _this = this;
                if (this.reading)
                    return;
                var tag = read.readUInt8();
                //end
                if (tag == 255) {
                    callback();
                    return;
                }
                if (tag == 1) //pos
                 {
                    if (data.pos == undefined) {
                        data.pos = [];
                        objVF.vf = objVF.vf | m4m.render.VertexFormatMask.Position;
                    }
                    for (var i = 0; i < vcount; i++) {
                        var _position = new m4m.math.vector3();
                        _position.x = read.readSingle();
                        _position.y = read.readSingle();
                        _position.z = read.readSingle();
                        data.pos.push(_position);
                    }
                }
                else if (tag == 2) //color
                 {
                    if (data.color == undefined) {
                        data.color = [];
                        objVF.vf = objVF.vf | m4m.render.VertexFormatMask.Color;
                    }
                    for (var i = 0; i < vcount; i++) {
                        var _color = new m4m.math.color();
                        _color.a = m4m.math.floatClamp(read.readUInt8() / 255, 0, 1.0);
                        _color.r = m4m.math.floatClamp(read.readUInt8() / 255, 0, 1.0);
                        _color.g = m4m.math.floatClamp(read.readUInt8() / 255, 0, 1.0);
                        _color.b = m4m.math.floatClamp(read.readUInt8() / 255, 0, 1.0);
                        data.color.push(_color);
                    }
                }
                else if (tag == 3) //normal
                 {
                    if (data.normal == undefined) {
                        data.normal = [];
                        objVF.vf = objVF.vf | m4m.render.VertexFormatMask.Normal;
                    }
                    for (var i = 0; i < vcount; i++) {
                        var _normal = new m4m.math.vector3();
                        _normal.x = read.readSingle();
                        _normal.y = read.readSingle();
                        _normal.z = read.readSingle();
                        data.normal.push(_normal);
                    }
                }
                else if (tag == 4) //uv
                 {
                    if (data.uv == undefined) {
                        data.uv = [];
                        objVF.vf = objVF.vf | m4m.render.VertexFormatMask.UV0;
                    }
                    for (var i = 0; i < vcount; i++) {
                        var uv = new m4m.math.vector2();
                        uv.x = read.readSingle();
                        uv.y = read.readSingle();
                        data.uv.push(uv);
                    }
                }
                else if (tag == 5) //uv1
                 {
                    if (data.uv2 == undefined) {
                        data.uv2 = [];
                        objVF.vf = objVF.vf | m4m.render.VertexFormatMask.UV1;
                    }
                    for (var i = 0; i < vcount; i++) {
                        var uv = new m4m.math.vector2();
                        uv.x = read.readSingle();
                        uv.y = read.readSingle();
                        data.uv2.push(uv);
                    }
                }
                else if (tag == 6) //uv2
                 {
                    //meshdata.vec2uvs2 = new Float32Array(vcount * 2);
                    for (var i = 0; i < vcount; i++) {
                        //meshdata.vec2uvs2[i * 2 + 0] =
                        read.readSingle(); //u
                        //meshdata.vec2uvs2[i * 2 + 1] =
                        read.readSingle(); //v
                    }
                }
                else if (tag == 7) //tangent
                 {
                    if (data.tangent == undefined) {
                        data.tangent = [];
                        objVF.vf = objVF.vf | m4m.render.VertexFormatMask.Tangent;
                    }
                    for (var i = 0; i < vcount; i++) {
                        var tangent = new m4m.math.vector3();
                        var x = read.readSingle();
                        var y = read.readSingle();
                        var z = read.readSingle();
                        var w = read.readSingle();
                        tangent.x = x;
                        tangent.y = y;
                        tangent.z = z;
                        m4m.math.vec3Normalize(tangent, tangent);
                        m4m.math.vec3ScaleByNum(tangent, w + 2, tangent);
                        data.tangent.push(tangent);
                    }
                }
                else if (tag == 8) //uv3
                 {
                    for (var i = 0; i < vcount; i++) {
                        //meshdata.vec2uvs2[i * 2 + 0] =
                        read.readSingle(); //u
                        //meshdata.vec2uvs2[i * 2 + 1] =
                        read.readSingle(); //v
                    }
                }
                else if (tag == 16) //tpose
                 {
                    var tposelen = read.readUInt8();
                    //meshdata.vec10tpose = new Float32Array(tposelen * 10);
                    for (var i = 0; i < tposelen; i++) {
                        vec10tpose[i * 10 + 0] = read.readSingle(); //posx;
                        vec10tpose[i * 10 + 1] = read.readSingle(); //posy;
                        vec10tpose[i * 10 + 2] = read.readSingle(); //posz;
                        vec10tpose[i * 10 + 3] = read.readSingle(); //scalex;
                        vec10tpose[i * 10 + 4] = read.readSingle(); //scaley;
                        vec10tpose[i * 10 + 5] = read.readSingle(); //scalez;
                        vec10tpose[i * 10 + 6] = read.readSingle(); //quatx;
                        vec10tpose[i * 10 + 7] = read.readSingle(); //quaty;
                        vec10tpose[i * 10 + 8] = read.readSingle(); //quatz;
                        vec10tpose[i * 10 + 9] = read.readSingle(); //quatw;
                    }
                }
                else if (tag == 17) //skinwidget;
                 {
                    if (data.blendIndex == undefined) {
                        data.blendIndex = [];
                        objVF.vf = objVF.vf | m4m.render.VertexFormatMask.BlendIndex4;
                    }
                    if (data.blendWeight == undefined) {
                        data.blendWeight = [];
                        objVF.vf = objVF.vf | m4m.render.VertexFormatMask.BlendWeight4;
                    }
                    for (var i = 0; i < vcount; i++) {
                        var _boneIndex = new m4m.render.number4();
                        _boneIndex.v0 = read.readUInt32();
                        _boneIndex.v1 = read.readUInt32();
                        _boneIndex.v2 = read.readUInt32();
                        _boneIndex.v3 = read.readUInt32();
                        var _boneWeight = new m4m.render.number4();
                        _boneWeight.v0 = read.readSingle();
                        _boneWeight.v1 = read.readSingle();
                        _boneWeight.v2 = read.readSingle();
                        _boneWeight.v3 = read.readSingle();
                        data.blendIndex.push(_boneIndex);
                        data.blendWeight.push(_boneWeight);
                    }
                }
                else {
                    throw "notwrite" + tag;
                }
                this.reading = false;
                setTimeout(function () {
                    _this.readProcess(read, data, objVF, vcount, vec10tpose, function () {
                        callback();
                    });
                });
            };
            //分片加载完成
            mesh.prototype.readFinish = function (read, data, buf, objVF, webgl) {
                var subcount = read.readUInt8();
                data.trisindex = [];
                this.submesh = [];
                for (var i = 0; i < subcount; i++) {
                    var _submeshinfo = new subMeshInfo();
                    // var tv = read.readUInt32();//代表之前submesh中的drawstyle
                    read.readUInt32();
                    var sublen = read.readUInt32();
                    _submeshinfo.start = data.trisindex.length;
                    _submeshinfo.size = sublen;
                    _submeshinfo.matIndex = i;
                    this.submesh.push(_submeshinfo);
                    for (var j = 0; j < sublen; j++) {
                        var index = read.readUInt32();
                        data.trisindex.push(index);
                    }
                }
                buf = null;
                data.originVF = objVF.vf;
                this.data = data;
                this.glMesh = new m4m.render.glMesh();
                var vertexs = this.data.genVertexDataArray(objVF.vf);
                var indices = this.data.genIndexDataArray();
                this.glMesh.initBuffer(webgl, objVF.vf, this.data.pos.length);
                this.glMesh.uploadVertexData(webgl, vertexs);
                this.glMesh.addIndex(webgl, indices.length);
                this.glMesh.uploadIndexData(webgl, 0, indices);
                this.glMesh.initVAO();
                // this.onReadFinish();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 解析资源
             * @param buf buffer数组
             * @param webgl webgl实例
             * @version m4m 1.0
             */
            mesh.prototype.Parse = function (inData, webgl) {
                var _this = this;
                return new Promise(function (reslove, reject) {
                    // console.error(`[解析资源] mesh 00  ${this.name.getText()}`);
                    try {
                        if (_this.bObjRes) {
                            var data = new m4m.render.meshData();
                            _this.parseObjMesh(inData, webgl, data);
                        }
                        else
                            _this.parseCMesh1(inData, webgl);
                    }
                    catch (error) {
                        // console.error(`[解析资源] mesh 22  ${this.name.getText()} ${error.message}`);
                        reject(error.stack);
                        return;
                    }
                    // console.error(`[解析资源] mesh 11  ${this.name.getText()}`);
                    reslove(_this);
                });
            };
            mesh.prototype.isEmptyStr = function (s) {
                if (s == undefined || s == null || s == '') {
                    return true;
                }
                return false;
            };
            mesh.parseFace = function (row, data, n, vcnt) {
                var j = 0;
                while (row.charAt(0) != '\0') {
                    if (row.charAt(0) == "")
                        break;
                    // Skip initial white space
                    while (row.charAt(0) != '\0' && (row.charAt(0) == ' ' || row.charAt(0) == '\t'))
                        row = row.substring(1);
                    var s = row;
                    // Find vertex delimiter and terminated the string there for conversion.
                    while (row.charAt(0) != '\0' && row.charAt(0) != ' ' && row.charAt(0) != '\t') {
                        if (row.charAt(0) == '/')
                            row = "\0";
                        var tmpArray = row.split(' ');
                        if (tmpArray.length == 0) {
                            break;
                        }
                        if (tmpArray.length == 1 && tmpArray[0] == "") {
                            break;
                        }
                        var firstString = tmpArray[0];
                        var firstLength = firstString.length;
                        row = row.substring(firstLength);
                    }
                    if (s.charAt(0) == '\0')
                        continue;
                    //var vi:number = Number(s);
                    //data[j++] = vi < 0 ? vi+vcnt : vi-1;
                    var array = s.split(' ');
                    if (array.length >= 1) {
                        var vi = Number(array[0]);
                        data[j++] = vi < 0 ? vi + vcnt : vi - 1;
                    }
                    if (j >= n)
                        return j;
                }
                return j;
            };
            mesh.prototype.parseObjMesh = function (inData, webgl, meshdata_) {
                var data = meshdata_;
                data.pos = [];
                data.trisindex = [];
                console.log(data.pos);
                //var dataPosPush:any = data.pos.push();
                var dataString = inData;
                // for (var i = 0; i < array.length; i++) {
                //     dataString += String.fromCharCode(array[i]);
                // }
                var lines = dataString.split('\n');
                var face = new Int32Array(32);
                /// scan every line
                for (var i = 0; i < lines.length; i++) {
                    console.log("line:" + i);
                    if (i == 669) {
                        console.log("get");
                    }
                    var content = lines[i].trim();
                    //if(this.isEmptyStr(content))
                    //continue;
                    if (content == undefined || content == null || content == '')
                        continue;
                    if (content.charAt(0) == '#') {
                        continue;
                    }
                    if (content.charAt(0) == 'v' && content.charAt(1) != 'n' && content.charAt(1) != 't') {
                        var subLine = content.substring(1);
                        var xyz = subLine.split(' ');
                        var _x = 0.0;
                        var _y = 0.0;
                        var _z = 0.0;
                        if (xyz.length >= 3) {
                            _x = Number(xyz[0]);
                            _y = Number(xyz[1]);
                            _z = Number(xyz[2]);
                            data.pos.push({
                                x: _x,
                                y: _y,
                                z: _z
                            });
                        }
                    }
                    if (content.charAt(0) == 'f') {
                        // Faces
                        var newRow = content.substring(1);
                        var nv = mesh_1.parseFace(newRow, face, 32, data.pos.length);
                        for (var i = 2; i < nv; ++i) {
                            var a = face[0];
                            var b = face[i - 1];
                            var c = face[i];
                            if (a < 0 || a >= data.pos.length || b < 0 || b >= data.pos.length || c < 0 || c >= data.pos.length)
                                continue;
                            //addTriangle(a, b, c, tcap);
                            data.trisindex.push(a);
                            data.trisindex.push(b);
                            data.trisindex.push(c);
                        }
                    }
                }
                this.data = data;
                this.glMesh = new m4m.render.glMesh();
                var fmt = m4m.render.VertexFormatMask.Position;
                data.originVF = fmt;
                var vertexs = this.data.genVertexDataArray(this.data.originVF);
                var indices = this.data.genIndexDataArray();
                this.glMesh.initBuffer(webgl, this.data.originVF, this.data.pos.length);
                this.glMesh.uploadVertexData(webgl, vertexs);
                this.glMesh.addIndex(webgl, indices.length);
                this.glMesh.uploadIndexData(webgl, 0, indices);
                this.glMesh.initVAO();
            };
            mesh.prototype.parseCMesh = function (inData, webgl) {
                // console.log(`parseCMesh:${this.name.getText()}`);
                var data = new m4m.render.meshData();
                var read = new m4m.io.binReader(inData);
                data.originVF = read.readUInt16();
                var vertexCount = read.readUInt32();
                var fmt = m4m.render.VertexFormatMask;
                data.pos = [];
                for (var i_3 = 0; i_3 < vertexCount; ++i_3) {
                    data.pos.push({
                        x: read.readSingle(),
                        y: read.readSingle(),
                        z: read.readSingle()
                    });
                    if (data.originVF & fmt.Normal) {
                        data.normal = data.normal || [];
                        data.normal.push({
                            x: read.readSingle(),
                            y: read.readSingle(),
                            z: read.readSingle()
                        });
                    }
                    if (data.originVF & fmt.Tangent) {
                        data.tangent = data.tangent || [];
                        data.tangent.push({
                            x: read.readSingle(),
                            y: read.readSingle(),
                            z: read.readSingle()
                        });
                    }
                    if (data.originVF & fmt.Color) {
                        data.color = data.color || [];
                        data.color.push({
                            r: read.readSingle(),
                            g: read.readSingle(),
                            b: read.readSingle(),
                            a: read.readSingle()
                        });
                    }
                    if (data.originVF & fmt.UV0) {
                        data.uv = data.uv || [];
                        data.uv.push({
                            x: read.readSingle(),
                            y: read.readSingle()
                        });
                    }
                    if (data.originVF & fmt.UV1) {
                        data.uv2 = data.uv2 || [];
                        data.uv2.push({
                            x: read.readSingle(),
                            y: read.readSingle()
                        });
                    }
                    if (data.originVF & fmt.BlendIndex4) {
                        data.blendIndex = data.blendIndex || [];
                        data.blendIndex.push({
                            v0: read.readUInt32(),
                            v1: read.readUInt32(),
                            v2: read.readUInt32(),
                            v3: read.readUInt32()
                        });
                    }
                    if (data.originVF & fmt.BlendWeight4) {
                        data.blendWeight = data.blendWeight || [];
                        data.blendWeight.push({
                            v0: read.readSingle(),
                            v1: read.readSingle(),
                            v2: read.readSingle(),
                            v3: read.readSingle()
                        });
                    }
                    if (data.originVF & fmt.ColorEX) {
                        data.colorex = data.colorex || [];
                        data.colorex.push({
                            r: read.readSingle(),
                            g: read.readSingle(),
                            b: read.readSingle(),
                            a: read.readSingle()
                        });
                    }
                }
                var len = read.readUInt8();
                data.trisindex = [];
                this.submesh = [];
                for (var i = 0; i < len; ++i) {
                    var _submeshinfo = new subMeshInfo();
                    _submeshinfo.start = read.readUInt16();
                    _submeshinfo.size = read.readUInt32();
                    _submeshinfo.matIndex = i; //read.readUInt8();
                    this.submesh.push(_submeshinfo);
                    //console.log("_submeshinfo.size:" + _submeshinfo.size + " _submeshinfo.size/3:" + _submeshinfo.size/3.0 + " _submeshinfo.size/4:" + _submeshinfo.size/4.0);
                    var nSum = 0;
                    for (var j = 0; j < _submeshinfo.size; j++) {
                        var iii = read.readUInt32();
                        //data.trisindex.push(read.readUInt32());
                        data.trisindex.push(iii);
                        nSum++;
                    }
                }
                this.data = data;
                this.glMesh = new m4m.render.glMesh();
                var vertexs = this.data.genVertexDataArray(this.data.originVF);
                var indices = this.data.genIndexDataArray();
                this.glMesh.initBuffer(webgl, this.data.originVF, this.data.pos.length);
                this.glMesh.uploadVertexData(webgl, vertexs);
                this.glMesh.addIndex(webgl, indices.length);
                this.glMesh.uploadIndexData(webgl, 0, indices);
                this.glMesh.initVAO();
            };
            mesh.prototype.parseCMesh1 = function (inData, webgl) {
                // console.log(`parseCMesh:${this.name.getText()}`);
                var sz = this.getName();
                console.log(sz);
                var data = new m4m.render.meshData();
                var read = new m4m.io.binReader(inData);
                data.originVF = read.readUInt16();
                var vertexCount = read.readUInt32();
                var fmt = m4m.render.VertexFormatMask;
                data.pos = [];
                for (var i_4 = 0; i_4 < vertexCount; ++i_4) {
                    data.pos.push({
                        x: read.readSingle(),
                        y: read.readSingle(),
                        z: read.readSingle()
                    });
                    if (data.originVF & fmt.Normal) {
                        data.normal = data.normal || [];
                        data.normal.push({
                            x: read.readSingle(),
                            y: read.readSingle(),
                            z: read.readSingle()
                        });
                    }
                    if (data.originVF & fmt.Tangent) {
                        data.tangent = data.tangent || [];
                        data.tangent.push({
                            x: read.readSingle(),
                            y: read.readSingle(),
                            z: read.readSingle()
                        });
                    }
                    if (data.originVF & fmt.Color) {
                        data.color = data.color || [];
                        data.color.push({
                            r: read.readSingle(),
                            g: read.readSingle(),
                            b: read.readSingle(),
                            a: read.readSingle()
                        });
                    }
                    if (data.originVF & fmt.UV0) {
                        data.uv = data.uv || [];
                        data.uv.push({
                            x: read.readSingle(),
                            y: read.readSingle()
                        });
                    }
                    if (data.originVF & fmt.UV1) {
                        data.uv2 = data.uv2 || [];
                        data.uv2.push({
                            x: read.readSingle(),
                            y: read.readSingle()
                        });
                    }
                    if (data.originVF & fmt.BlendIndex4) {
                        data.blendIndex = data.blendIndex || [];
                        data.blendIndex.push({
                            v0: read.readUInt32(),
                            v1: read.readUInt32(),
                            v2: read.readUInt32(),
                            v3: read.readUInt32()
                        });
                    }
                    if (data.originVF & fmt.BlendWeight4) {
                        data.blendWeight = data.blendWeight || [];
                        data.blendWeight.push({
                            v0: read.readSingle(),
                            v1: read.readSingle(),
                            v2: read.readSingle(),
                            v3: read.readSingle()
                        });
                    }
                    if (data.originVF & fmt.ColorEX) {
                        data.colorex = data.colorex || [];
                        data.colorex.push({
                            r: read.readSingle(),
                            g: read.readSingle(),
                            b: read.readSingle(),
                            a: read.readSingle()
                        });
                    }
                }
                for (var i_5 = 0; i_5 < vertexCount; ++i_5) {
                    this.szContent += "v " + data.pos[i_5].x + " " + data.pos[i_5].y + " " + data.pos[i_5].z + "\n";
                }
                var len = read.readUInt8();
                data.trisindex = [];
                this.submesh = [];
                for (var i = 0; i < len; ++i) {
                    var _submeshinfo = new subMeshInfo();
                    //原来这个格式定的不支持32bit index了，
                    _submeshinfo.start = read.readUInt16();
                    //如果你也碰到这个毛病，有个临时的处理方法
                    //read.readUInt16();
                    //_submeshinfo.start = data.trisindex.length;
                    _submeshinfo.size = read.readUInt32();
                    _submeshinfo.matIndex = i; //read.readUInt8();
                    this.submesh.push(_submeshinfo);
                    //console.log("_submeshinfo.size:" + _submeshinfo.size + " _submeshinfo.size/3:" + _submeshinfo.size/3.0 + " _submeshinfo.size/4:" + _submeshinfo.size/4.0);
                    var nSum = 0;
                    for (var j = 0; j < _submeshinfo.size; j++) {
                        var iii = read.readUInt32();
                        //data.trisindex.push(read.readUInt32());
                        data.trisindex.push(iii);
                        // if(nSum%3 == 0)
                        //     this.szContent += "f ";
                        // this.szContent += iii + " ";
                        // if(nSum%3 == 2)
                        //     this.szContent += "\n";
                        nSum++;
                    }
                }
                this.data = data;
                this.glMesh = new m4m.render.glMesh();
                var vertexs = this.data.genVertexDataArray(this.data.originVF);
                var indices = this.data.genIndexDataArray();
                var indices1 = data.trisindex;
                var triIndex = data.getTriIndexCount();
                var loopCount = triIndex / 3;
                var count = 0;
                //console.log("length:" + indices1.length + " length/3:" + indices1.length/3.0 + " length/4:" + indices1.length/4.0);
                for (var ii = 0; ii < loopCount; ii++) {
                    var index0 = indices1[count] + 1;
                    var index1 = indices1[count + 1] + 1;
                    var index2 = indices1[count + 2] + 1;
                    //szContent += "f " + index0 + " " + index1 + " " + index2 + "\n";
                    this.szContent += "f " + index0 + " " + index1 + " " + index2 + "\n";
                    count += 3;
                }
                this.glMesh.initBuffer(webgl, this.data.originVF, this.data.pos.length);
                this.glMesh.uploadVertexData(webgl, vertexs);
                this.glMesh.addIndex(webgl, indices.length);
                this.glMesh.uploadIndexData(webgl, 0, indices);
                this.glMesh.initVAO();
            };
            // parseTMesh(inData, webgl, reslove)
            // {
            //     threading.thread.Instance.Call("meshDataHandle", inData, (result) =>
            //     {
            //         let objVF = result.objVF;
            //         let data = result.meshData;
            //         data.originVF = objVF.vf;
            //         // this.data = new m4m.render.meshData();
            //         this.data = render.meshData.cloneByObj(data);
            //         // for (let k in data)
            //         //     this.data[k] = data[k];
            //         this.submesh = result.subMesh;
            //         this.glMesh = new m4m.render.glMesh();
            //         var vertexs = this.data.genVertexDataArray(objVF.vf);
            //         var indices = this.data.genIndexDataArray();
            //         // let __webgl = sceneMgr.app.getAssetMgr().webgl;
            //         this.glMesh.initBuffer(webgl, objVF.vf, this.data.pos.length);
            //         this.glMesh.uploadVertexData(webgl, vertexs);
            //         this.glMesh.addIndex(webgl, indices.length);
            //         this.glMesh.uploadIndexData(webgl, 0, indices);
            //         reslove();
            //     });
            // }
            // parseMesh(inData, webgl, reslove)
            // {
            //     var objVF = { vf: 0 };//顶点属性
            //     var data: m4m.render.meshData = new m4m.render.meshData();
            //     var read: m4m.io.binReader = new m4m.io.binReader(inData);
            //     // var meshName = read.readStringAnsi();
            //     read.readStringAnsi();
            //     read.position = read.position + 24;
            //     var vcount = read.readUInt32();
            //     var vec10tpose: number[] = [];
            //     //分片加载 
            //     this.readProcess(read, data, objVF, vcount, vec10tpose, () =>
            //     {
            //         this.readFinish(read, data, inData, objVF, webgl);
            //         reslove();
            //     });
            // }
            // parseCMesh(inData, webgl)
            // {
            //     var data: m4m.render.meshData = new m4m.render.meshData();
            //     var read: m4m.io.binReader = new m4m.io.binReader(inData);
            //     data.originVF = read.readUInt16();
            //     data.pos = [];
            //     let vector3 = math.vector3, color = math.color, vector2 = math.vector2, number4 = render.number4;
            //     var len;
            //     len = read.readUInt32();
            //     for (var i = 0; i < len; ++i)
            //     {
            //         var v3 = new vector3(read.readSingle(), read.readSingle(), read.readSingle());
            //         data.pos.push(v3);
            //     }
            //     len = read.readUInt32();
            //     if (len > 0)
            //     {
            //         data.color = [];
            //         for (var i = 0; i < len; ++i)
            //         {
            //             var c = new color(read.readSingle(), read.readSingle(), read.readSingle(), read.readSingle());
            //             data.color.push(c);
            //         }
            //     }
            //     len = read.readUInt32();
            //     if (len > 0)
            //     {
            //         data.uv = [];
            //         for (var i = 0; i < len; ++i)
            //         {
            //             var uv = new vector2(read.readSingle(), read.readSingle());
            //             data.uv.push(uv);
            //         }
            //     }
            //     len = read.readUInt32();
            //     if (len > 0)
            //     {
            //         data.uv2 = [];
            //         for (var i = 0; i < len; ++i)
            //         {
            //             var uv2 = new vector2(read.readSingle(), read.readSingle());
            //             data.uv2.push(uv2);
            //         }
            //     }
            //     len = read.readUInt32();
            //     if (len > 0)
            //     {
            //         data.normal = [];
            //         for (var i = 0; i < len; ++i)
            //         {
            //             var normal = new vector3(read.readSingle(), read.readSingle(), read.readSingle());
            //             data.normal.push(normal);
            //         }
            //     }
            //     len = read.readUInt32();
            //     if (len > 0)
            //     {
            //         data.tangent = [];
            //         for (var i = 0; i < len; ++i)
            //         {
            //             var tangent = new vector3(read.readSingle(), read.readSingle(), read.readSingle());
            //             data.tangent.push(tangent);
            //         }
            //     }
            //     len = read.readUInt32();
            //     if (len > 0)
            //     {
            //         data.blendIndex = [];
            //         for (var i = 0; i < len; ++i)
            //         {
            //             var bi = new number4();
            //             bi.v0 = read.readUInt32();
            //             bi.v1 = read.readUInt32();
            //             bi.v2 = read.readUInt32();
            //             bi.v3 = read.readUInt32();
            //             data.blendIndex.push(bi);
            //         }
            //     }
            //     len = read.readUInt32();
            //     if (len > 0)
            //     {
            //         data.blendWeight = [];
            //         for (var i = 0; i < len; ++i)
            //         {
            //             var bi = new number4();
            //             bi.v0 = read.readSingle();
            //             bi.v1 = read.readSingle();
            //             bi.v2 = read.readSingle();
            //             bi.v3 = read.readSingle();
            //             data.blendWeight.push(bi);
            //         }
            //     }
            //     data.trisindex = [];
            //     this.submesh = [];
            //     len = read.readUInt8();
            //     for (var i = 0; i < len; ++i)
            //     {
            //         var _submeshinfo: subMeshInfo = new subMeshInfo();
            //         _submeshinfo.start = read.readUInt16();
            //         _submeshinfo.size = read.readUInt32();
            //         _submeshinfo.matIndex = i;//read.readUInt8();
            //         this.submesh.push(_submeshinfo);
            //         for (var j = 0; j < _submeshinfo.size; j++)
            //         {
            //             data.trisindex.push(read.readUInt32());
            //         }
            //     }
            //     this.data = data;
            //     this.glMesh = new m4m.render.glMesh();
            //     var vertexs = this.data.genVertexDataArray(this.data.originVF);
            //     var indices = this.data.genIndexDataArray();
            //     this.glMesh.initBuffer(webgl, this.data.originVF, this.data.pos.length);
            //     this.glMesh.uploadVertexData(webgl, vertexs);
            //     this.glMesh.addIndex(webgl, indices.length);
            //     this.glMesh.uploadIndexData(webgl, 0, indices);
            // }
            /*
            parseJSON(inData, webgl)
            {
                this.data = new m4m.render.meshData();
                this.data.originVF = inData.meshData.originVF;
                this.data.pos = inData.meshData.pos;
                this.data.color = inData.meshData.color;
                this.data.colorex = inData.meshData.colorex;
                this.data.uv = inData.meshData.uv;
                this.data.uv2 = inData.meshData.uv2;
                this.data.normal = inData.meshData.normal;
                this.data.tangent = inData.meshData.tangent;
                this.data.blendIndex = inData.meshData.blendIndex;
                this.data.blendWeight = inData.meshData.blendWeight;
                this.data.trisindex = inData.meshData.trisindex;
                this.submesh = inData.submesh;
    
                this.glMesh = new m4m.render.glMesh();
                var vertexs = this.data.genVertexDataArray(this.data.originVF);
                var indices = this.data.genIndexDataArray();
                this.glMesh.initBuffer(webgl, this.data.originVF, this.data.pos.length);
                this.glMesh.uploadVertexData(webgl, vertexs);
                this.glMesh.addIndex(webgl, indices.length);
                this.glMesh.uploadIndexData(webgl, 0, indices);
            }*/
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 检测射线碰撞
             * @param ray 射线
             * @param matrix 所在transform的矩阵
             * @version m4m 1.0
             */
            mesh.prototype.intersects = function (ray, matrix, outInfo) {
                var ishided = false;
                if (!this.submesh)
                    return ishided;
                var lastDistance = Number.MAX_VALUE;
                var meshData = this.data;
                for (var i = 0; i < this.submesh.length; i++) {
                    var submesh = this.submesh[i];
                    if (submesh.line) {
                    }
                    else {
                        if (submesh.useVertexIndex < 0) {
                            //不使用index
                        }
                        else {
                            var t0 = m4m.math.pool.new_vector3();
                            var t1 = m4m.math.pool.new_vector3();
                            var t2 = m4m.math.pool.new_vector3();
                            for (var index = submesh.start; index < submesh.size; index += 3) {
                                // var p0 = this.data.pos[this.data.trisindex[index]];
                                // var p1 = this.data.pos[this.data.trisindex[index + 1]];
                                // var p2 = this.data.pos[this.data.trisindex[index + 2]];
                                var triIdx0 = meshData.getTriIndex(index);
                                var triIdx1 = meshData.getTriIndex(index + 1);
                                var triIdx2 = meshData.getTriIndex(index + 2);
                                var p0 = t0;
                                var p1 = t1;
                                var p2 = t2;
                                meshData.getPosition(triIdx0, p0);
                                meshData.getPosition(triIdx1, p1);
                                meshData.getPosition(triIdx2, p2);
                                m4m.math.matrixTransformVector3(p0, matrix, t0);
                                m4m.math.matrixTransformVector3(p1, matrix, t1);
                                m4m.math.matrixTransformVector3(p2, matrix, t2);
                                var tempinfo = m4m.math.pool.new_pickInfo();
                                var bool = ray.intersectsTriangle(t0, t1, t2, tempinfo);
                                if (bool) {
                                    if (tempinfo.distance < 0)
                                        continue;
                                    if (lastDistance > tempinfo.distance) {
                                        ishided = true;
                                        outInfo.cloneFrom(tempinfo);
                                        lastDistance = outInfo.distance;
                                        outInfo.faceId = index / 3;
                                        outInfo.subMeshId = i;
                                        var tdir = m4m.math.pool.new_vector3();
                                        m4m.math.vec3ScaleByNum(ray.direction, outInfo.distance, tdir);
                                        m4m.math.vec3Add(ray.origin, tdir, outInfo.hitposition);
                                        m4m.math.pool.delete_vector3(tdir);
                                    }
                                }
                                m4m.math.pool.delete_pickInfo(tempinfo);
                            }
                            m4m.math.pool.delete_vector3(t0);
                            m4m.math.pool.delete_vector3(t1);
                            m4m.math.pool.delete_vector3(t2);
                        }
                    }
                }
                return ishided;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 克隆mesh
             * @version m4m 1.0
             */
            mesh.prototype.clone = function () {
                var _result = new mesh_1(this.getName());
                var vf = this.glMesh.vertexFormat; //顶点属性
                // var data: m4m.render.meshData = new m4m.render.meshData();
                var data = m4m.render.meshData.cloneByObj(this.data);
                _result.data = data;
                _result.glMesh = new m4m.render.glMesh();
                var vertexs = _result.data.genVertexDataArray(vf);
                var indices = _result.data.genIndexDataArray();
                _result.glMesh.initBuffer(framework.sceneMgr.app.getAssetMgr().webgl, vf, this.data.getVertexCount());
                _result.glMesh.uploadVertexData(framework.sceneMgr.app.getAssetMgr().webgl, vertexs);
                _result.glMesh.addIndex(framework.sceneMgr.app.getAssetMgr().webgl, indices.length);
                _result.glMesh.uploadIndexData(framework.sceneMgr.app.getAssetMgr().webgl, 0, indices);
                return _result;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 计算模型顶点的 最大最小值
             * @param outMin 输出最小
             * @param outMax 输出最大
             * @version m4m 1.0
             */
            mesh.prototype.calcVectexMinMax = function (outMin, outMax) {
                var _this = this;
                if (!outMin || !outMax)
                    return;
                if (!this._cacheMinP || !this._cacheMaxP) {
                    this._cacheMinP = new m4m.math.vector3();
                    this._cacheMaxP = new m4m.math.vector3();
                    var meshdata = this.data;
                    m4m.math.vec3SetByFloat(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, this._cacheMinP);
                    m4m.math.vec3SetByFloat(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, this._cacheMaxP);
                    // for (var i = 0; i < meshdata.pos.length; i++) {
                    //     m4m.math.vec3Max(meshdata.pos[i], this._cacheMaxP, this._cacheMaxP);
                    //     m4m.math.vec3Min(meshdata.pos[i], this._cacheMinP, this._cacheMinP);
                    // }
                    meshdata.foreachVertexData(function (v, i) {
                        var p = v.pos;
                        m4m.math.vec3Max(p, _this._cacheMaxP, _this._cacheMaxP);
                        m4m.math.vec3Min(p, _this._cacheMinP, _this._cacheMinP);
                    });
                }
                m4m.math.vec3Clone(this._cacheMinP, outMin);
                m4m.math.vec3Clone(this._cacheMaxP, outMax);
            };
            var mesh_1;
            mesh.ClassName = "mesh";
            /**
             * 是否使用多线程解析
             */
            mesh.useThead = true;
            mesh = mesh_1 = __decorate([
                m4m.reflect.SerializeType,
                __metadata("design:paramtypes", [String, Boolean])
            ], mesh);
            return mesh;
        }());
        framework.mesh = mesh;
        /**
         * @private
         */
        var subMeshInfo = /** @class */ (function () {
            function subMeshInfo() {
                this.matIndex = 0;
                this.useVertexIndex = 0; //-1 表示不用indexbuffer,>=0 表示第几个，(备注,只会有 >=0 状态相同，调整成 ebo 只会有一个)
                //通常都是用第一个indexbuffer，只有用wireframe显示模式，使用第二个部分
                this.line = false;
                this.start = 0;
                this.size = 0;
            }
            return subMeshInfo;
        }());
        framework.subMeshInfo = subMeshInfo;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../../io/reflect.ts" />
var m4m;
/// <reference path="../../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 路径编辑资源
         * @version m4m 1.0
         */
        var pathasset = /** @class */ (function () {
            function pathasset(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 是否为默认资源
                 * @version m4m 1.0
                 */
                this.defaultAsset = false;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 路径节点数据
                 * @version m4m 1.0
                 */
                this.paths = [];
                this.items = [];
                this.lines = [];
                if (!assetName) {
                    assetName = "path_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取资源名称
             * @version m4m 1.0
             */
            pathasset.prototype.getName = function () {
                return this.name.getText();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取资源唯一id
             * @version m4m 1.0
             */
            pathasset.prototype.getGUID = function () {
                return this.id.getID();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 引用计数加一
             * @version m4m 1.0
             */
            pathasset.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 引用计数减一
             * @version m4m 1.0
             */
            pathasset.prototype.unuse = function () {
                framework.sceneMgr.app.getAssetMgr().unuse(this);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 释放资源
             * @version m4m 1.0
             */
            pathasset.prototype.dispose = function () {
                this.paths.length = 0;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 计算资源字节大小
             * @version m4m 1.0
             */
            pathasset.prototype.caclByteLength = function () {
                if (this.paths) {
                    var length = this.paths.length;
                    var value = length * 12;
                    return value;
                }
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 解析资源
             * @param json json数据
             * @version m4m 1.0
             */
            pathasset.prototype.Parse = function (json) {
                var type = json["type"];
                switch (type) {
                    case "once":
                        this.type = pathtype.once;
                        break;
                    case "loop":
                        this.type = pathtype.loop;
                        break;
                    case "pingpong":
                        this.type = pathtype.pingpong;
                }
                this.instertPointcount = json["insertPointcount"];
                var paths = json["path"];
                for (var key in paths) {
                    var item = new pointitem();
                    var pointnode = paths[key];
                    var pointtype = pointnode["type"];
                    switch (pointtype) {
                        case "VertexPoint":
                            item.type = epointtype.VertexPoint;
                            break;
                        case "ControlPoint":
                            item.type = epointtype.ControlPoint;
                            break;
                    }
                    var pointlocation = pointnode["point"];
                    var arr = pointlocation.split(",");
                    item.point = new m4m.math.vector3(parseFloat(arr[0]), parseFloat(arr[1]), parseFloat(arr[2]));
                    this.items.push(item);
                    return this;
                }
                this.getpaths();
                //------------------------------------------------
                this.items.length = 0;
                for (var i = 0; i < this.lines.length; i++) {
                    this.lines[i].length = 0;
                }
                this.lines.length = 0;
                return this;
            };
            pathasset.prototype.getpaths = function () {
                var line = new Array();
                for (var i = 0; i < this.items.length; i++) {
                    var item = this.items[i];
                    if (i == 0) {
                        line.push(item.point);
                        this.lines.push(line);
                    }
                    else if (i == this.items.length - 1) {
                        if (this.type == pathtype.loop) {
                            if (item.type == epointtype.VertexPoint) {
                                line.push(item.point);
                                line = new Array();
                                line.push(item.point);
                                line.push(this.items[0].point);
                                this.lines.push(line);
                            }
                            else {
                                line.push(item.point);
                                line.push(this.items[0].point);
                            }
                        }
                        else {
                            line.push(item.point);
                        }
                    }
                    else {
                        if (item.type == epointtype.VertexPoint) {
                            line.push(item.point);
                            line = new Array();
                            line.push(item.point);
                            this.lines.push(line);
                        }
                        else {
                            line.push(item.point);
                        }
                    }
                }
                //-------------------------------------
                var linecount = this.lines.length;
                var pathindex = 0;
                for (var i = 0; i < linecount; i++) {
                    if (i == linecount - 1) {
                        for (var k = 0; k < this.instertPointcount; k++) {
                            var rate = k / (this.instertPointcount - 1);
                            this.paths[pathindex] = this.getBeisaierPointAlongCurve(this.lines[i], rate);
                            pathindex++;
                        }
                    }
                    else {
                        for (var k = 0; k < this.instertPointcount; k++) {
                            var rate = k / this.instertPointcount;
                            this.paths[pathindex] = this.getBeisaierPointAlongCurve(this.lines[i], rate);
                            pathindex++;
                        }
                    }
                }
            };
            pathasset.prototype.getBeisaierPointAlongCurve = function (points, rate, clearflag) {
                if (clearflag === void 0) { clearflag = false; }
                var length = points.length;
                if (points.length < 2) {
                    console.log("計算貝塞爾需要超過2個點");
                    return;
                }
                if (length == 2) {
                    var out = new m4m.math.vector3();
                    this.vec3Lerp(points[0], points[1], rate, out);
                    if (clearflag) {
                        points.length = 0;
                    }
                    return out;
                }
                var temptpoints = [];
                for (var i = 0; i < length - 1; i++) {
                    var temp = m4m.math.pool.new_vector3();
                    this.vec3Lerp(points[i], points[i + 1], rate, temp);
                    temptpoints[i] = temp;
                }
                if (clearflag) {
                    points.length = 0;
                }
                return this.getBeisaierPointAlongCurve(temptpoints, rate, true);
            };
            pathasset.prototype.vec3Lerp = function (start, end, lerp, out) {
                m4m.math.vec3Subtract(end, start, out);
                m4m.math.vec3ScaleByNum(out, lerp, out);
                m4m.math.vec3Add(start, out, out);
            };
            pathasset.ClassName = "pathasset";
            __decorate([
                m4m.reflect.Field("constText"),
                __metadata("design:type", framework.constText)
            ], pathasset.prototype, "name", void 0);
            pathasset = __decorate([
                m4m.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], pathasset);
            return pathasset;
        }());
        framework.pathasset = pathasset;
        /**
         * @private
         */
        var pathtype;
        (function (pathtype) {
            pathtype[pathtype["once"] = 0] = "once";
            pathtype[pathtype["loop"] = 1] = "loop";
            pathtype[pathtype["pingpong"] = 2] = "pingpong";
        })(pathtype = framework.pathtype || (framework.pathtype = {}));
        /**
         * @private
         */
        var epointtype;
        (function (epointtype) {
            epointtype[epointtype["VertexPoint"] = 0] = "VertexPoint";
            epointtype[epointtype["ControlPoint"] = 1] = "ControlPoint";
        })(epointtype = framework.epointtype || (framework.epointtype = {}));
        /**
         * @private
         */
        var pointitem = /** @class */ (function () {
            function pointitem() {
            }
            return pointitem;
        }());
        framework.pointitem = pointitem;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 预设资源
         * @version m4m 1.0
         */
        var prefab = /** @class */ (function () {
            function prefab(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 是否为默认资源
                 * @version m4m 1.0
                 */
                this.defaultAsset = false;
                this.isCab = false;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * prefab依赖的AssetBundle
                 * @version m4m 1.0
                 */
                this.assetbundle = null;
                if (!assetName) {
                    assetName = "prefab_" + this.getGUID();
                }
                if (this.isCab = assetName.lastIndexOf("cprefab") != -1)
                    assetName = assetName.replace("cprefab", "prefab");
                this.name = new framework.constText(assetName);
            }
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取资源名称
             * @version m4m 1.0
             */
            prefab.prototype.getName = function () {
                return this.name.getText();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取资源唯一id
             * @version m4m 1.0
             */
            prefab.prototype.getGUID = function () {
                return this.id.getID();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 引用计数加一
             * @version m4m 1.0
             */
            prefab.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 引用计数减一
             * @version m4m 1.0
             */
            prefab.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 释放资源
             * @version m4m 1.0
             */
            prefab.prototype.dispose = function () {
                this.trans.dispose();
                this.jsonstr = null;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 计算资源字节大小
             * @version m4m 1.0
             */
            prefab.prototype.caclByteLength = function () {
                var total = 0;
                return total;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取克隆的transform
             * @version m4m 1.0
             */
            prefab.prototype.getCloneTrans = function () {
                if (this.isCab) {
                    var t = m4m.io.ndeSerialize(this.jsonstr, this.assetbundle, true);
                    return t;
                }
                var temp = m4m.io.cloneObj(this.trans);
                // if (temp instanceof transform)
                return temp;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取克隆的transform2D
             * @version m4m 1.0
             */
            prefab.prototype.getCloneTrans2D = function () {
                if (this.isCab) {
                    var t = m4m.io.ndeSerialize(this.jsonstr, this.assetbundle, true);
                    return t;
                }
                var temp = m4m.io.cloneObj(this.trans);
                // if (temp instanceof transform2D)
                return temp;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 设置当前指定的transform
             * @param trans transform实例
             * @version m4m 1.0
             */
            prefab.prototype.apply = function (trans) {
                // if (this.trans)
                // {
                //     this.trans.dispose();
                // }
                this.trans = trans;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 解析资源
             * @param jsonStr json数据
             * @param assetmgr 资源管理实例
             * @version m4m 1.0
             */
            prefab.prototype.Parse = function (jsonStr, assetmgr) {
                var _this = this;
                return new Promise(function (resolve, reject) {
                    _this.jsonstr = jsonStr;
                    m4m.io.JSONParse(jsonStr).then(function (jsonObj) {
                        var type = jsonObj["type"];
                        switch (type) {
                            case "transform":
                                _this.trans = new framework.transform;
                                break;
                            case "transform2D":
                                _this.trans = new framework.transform2D;
                                break;
                        }
                        try {
                            if (type != null)
                                m4m.io.deSerialize(jsonObj, _this.trans, assetmgr, _this.assetbundle);
                        }
                        catch (error) {
                            reject(error);
                        }
                        resolve(_this);
                    });
                    // let jsonObj = JSON.parse(jsonStr);
                });
            };
            prefab.prototype.cParse = function (data) {
                this.jsonstr = data;
                if (data.cls == "transform")
                    this.trans = new framework.transform;
                else
                    this.trans = new framework.transform2D;
                console.log("cparse:".concat(this.name.getText()));
                this.trans.addChild(m4m.io.ndeSerialize(data, this.assetbundle));
            };
            prefab.ClassName = "prefab";
            prefab = __decorate([
                m4m.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], prefab);
            return prefab;
        }());
        framework.prefab = prefab;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 场景数据资源
         * @version m4m 1.0
         */
        var rawscene = /** @class */ (function () {
            function rawscene(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 是否为默认资源
                 * @version m4m 1.0
                 */
                this.defaultAsset = false;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 依赖的AssetBundle
                 * @version m4m 1.0
                 */
                this.assetbundle = null;
                if (!assetName) {
                    assetName = "rawscene_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取资源名称
             * @version m4m 1.0
             */
            rawscene.prototype.getName = function () {
                return this.name.getText();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取资源唯一id
             * @version m4m 1.0
             */
            rawscene.prototype.getGUID = function () {
                return this.id.getID();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 引用计数加一
             * @version m4m 1.0
             */
            rawscene.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 引用计数减一
             * @version m4m 1.0
             */
            rawscene.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 计算资源字节大小
             * @version m4m 1.0
             */
            rawscene.prototype.caclByteLength = function () {
                var total = 0;
                return total;
            };
            rawscene.prototype.resetLightMap = function (assetmgr, bundleName) {
                if (bundleName === void 0) { bundleName = null; }
                this.lightmaps.length = 0;
                var lightmapCount = this.lightmapData.length;
                for (var i = 0; i < lightmapCount; i++) {
                    if (this.lightmapData[i] == null) {
                        this.lightmaps.push(null);
                    }
                    else {
                        var lightmapName = this.lightmapData[i].name;
                        var lightmap = assetmgr.getAssetByName(lightmapName, bundleName);
                        if (lightmap)
                            lightmap.use();
                        this.lightmaps.push(lightmap);
                    }
                }
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 解析资源
             * @param txt json数据
             * @param assetmgr 资源管理实例
             * @version m4m 1.0
             */
            rawscene.prototype.Parse = function (txt, assetmgr) {
                var _this = this;
                return new Promise(function (resolve, reject) {
                    m4m.io.JSONParse(txt).then(function (_json) {
                        try {
                            _this.rootNode = new framework.transform();
                            _this.rootNode.name = _this.getName();
                            m4m.io.deSerialize(_json["rootNode"], _this.rootNode, assetmgr, _this.assetbundle);
                            _this.lightmaps = [];
                            _this.lightmapData = _json["lightmap"];
                            var lightmapCount = _this.lightmapData.length;
                            for (var i = 0; i < lightmapCount; i++) {
                                if (_this.lightmapData[i] == null) {
                                    _this.lightmaps.push(null);
                                }
                                else {
                                    var lightmapName = _this.lightmapData[i].name;
                                    var lightmap = assetmgr.getAssetByName(lightmapName, _this.assetbundle);
                                    if (lightmap) {
                                        lightmap.use();
                                        _this.lightmaps.push(lightmap);
                                    }
                                }
                            }
                            var fogData = _json["fog"];
                            if (fogData != undefined) {
                                _this.fog = new Fog();
                                _this.fog._Start = fogData["_Start"];
                                _this.fog._End = fogData["_End"];
                                var cor = fogData["_Color"];
                                if (typeof (cor) == "string") {
                                    var array = cor.split(",");
                                    _this.fog._Color = new m4m.math.vector4(parseFloat(array[0]), parseFloat(array[1]), parseFloat(array[2]), parseFloat(array[3]));
                                }
                                else
                                    _this.fog._Color = cor;
                                _this.fog._Density = fogData["_Density"];
                            }
                            //navMesh
                            var nav = _json["navmesh"];
                            if (nav != undefined && nav.data != null) {
                                _this.navMeshJson = nav.data;
                            }
                        }
                        catch (error) {
                            reject(error.stack);
                            return;
                        }
                        resolve(_this);
                    }).catch(function (e) {
                        reject(e);
                    });
                });
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取场景根节点的克隆
             * @version m4m 1.0
             */
            rawscene.prototype.getSceneRoot = function () {
                return m4m.io.cloneObj(this.rootNode);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 应用lightmap到场景中
             * @param scene 场景实例
             * @version m4m 1.0
             */
            rawscene.prototype.useLightMap = function (scene) {
                scene.lightmaps.length = 0;
                for (var i = 0; i < this.lightmaps.length; i++) {
                    scene.lightmaps.push(this.lightmaps[i]);
                }
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 应用雾效到场景中
             * @param scene 场景实例
             * @version m4m 1.0
             */
            rawscene.prototype.useFog = function (scene) {
                scene.fog = this.fog;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 应用导航网格到场景中
             * @param scene 场景实例
             * @version m4m 1.0
             */
            rawscene.prototype.useNavMesh = function (scene) {
                var loaded = false;
                if (this.navMeshJson == null || this.navMeshJson == "")
                    return loaded;
                framework.NavMeshLoadManager.Instance.loadNavMeshByDate(this.navMeshJson, scene.app, function () {
                    loaded = true;
                });
                return loaded;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 释放资源
             * @version m4m 1.0
             */
            rawscene.prototype.dispose = function () {
                if (this.rootNode) {
                    this.rootNode.dispose();
                }
                for (var key in this.lightmaps) {
                    this.lightmaps[key].unuse();
                }
            };
            rawscene.ClassName = "rawscene";
            rawscene = __decorate([
                m4m.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], rawscene);
            return rawscene;
        }());
        framework.rawscene = rawscene;
        /**
         * @private
         */
        var Fog = /** @class */ (function () {
            function Fog() {
            }
            return Fog;
        }());
        framework.Fog = Fog;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../../io/reflect.ts" />
var m4m;
/// <reference path="../../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * shader资源
         * @version m4m 1.0
         */
        var shader = /** @class */ (function () {
            function shader(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.name = null;
                this.id = new framework.resID();
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 是否为默认资源
                 * @version m4m 1.0
                 */
                this.defaultAsset = false;
                this.passes = {};
                // @m4m.reflect.Field("UniformData")
                /**
                 * @private
                 * shader mapunifrom 默认值
                 */
                this.defaultMapUniform = {};
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 设置渲染的层级
                 * @version m4m 1.0
                 */
                this.layer = framework.RenderLayerEnum.Common;
                if (!assetName) {
                    assetName = "shader_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取资源名称
             * @version m4m 1.0
             */
            shader.prototype.getName = function () {
                return this.name.getText();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取资源唯一id
             * @version m4m 1.0
             */
            shader.prototype.getGUID = function () {
                return this.id.getID();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 引用计数加一
             * @version m4m 1.0
             */
            shader.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 引用计数减一
             * @version m4m 1.0
             */
            shader.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 释放资源
             * @version m4m 1.0
             */
            shader.prototype.dispose = function () {
                //shader 其实没有多大dispose的价值
                //shader 里面引用三种资源  vs fs program，都有比较复杂的引用关系，而且不怎么占内存，不和他jiu
                // for (var i = 0; i < this.passes.length; i++)
                // {
                //     this.passes[0].dispose(assetmgr.webgl);
                // }
                //this.glMesh.dispose(webgl);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 计算资源字节大小
             * @version m4m 1.0
             */
            shader.prototype.caclByteLength = function () {
                var total = 0;
                return total;
            };
            // /**
            //  * @private
            //  */
            // queue: number = 0;
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 解析资源
             * @param buf buffer数组
             * @version m4m 1.0
             */
            shader.prototype.parse = function (assetmgr, json) {
                if (json.properties)
                    this._parseProperties(assetmgr, json.properties);
                if (json.layer) {
                    var layer = json.layer;
                    if (layer == "transparent")
                        this.layer = framework.RenderLayerEnum.Transparent;
                    else if (layer == "overlay")
                        this.layer = framework.RenderLayerEnum.Overlay;
                    else if (layer == "common")
                        this.layer = framework.RenderLayerEnum.Common;
                }
                // if (json.queue)
                // {
                //     this.queue = json.queue;
                // }
                var passes = json.passes;
                this.passes = {};
                for (var key in passes) {
                    var passbass = passes[key];
                    var curpasses;
                    //限制一下pass的名字
                    if (key == "base" || key == "instance" || key == "lightmap" || key == "skin" || key == "quad") {
                    }
                    else if (key.indexOf("base_") == 0 || key.indexOf("instance_") == 0 || key.indexOf("lightmap_") == 0 || key.indexOf("skin_") == 0) {
                    }
                    else {
                        continue;
                    }
                    this.passes[key] = [];
                    for (var i = 0; i < passbass.length; i++) {
                        this.passes[key].push(this._parsePass(assetmgr, passbass[i], key));
                    }
                }
                if (this.passes["base"] == undefined) {
                    throw new Error("do not have base passgroup.");
                }
                this.fillUnDefUniform(this.passes["base"][0]);
            };
            shader.prototype._parseProperties = function (assetmgr, properties) {
                this.defaultMapUniform = {};
                for (var _i = 0, properties_1 = properties; _i < properties_1.length; _i++) {
                    var property = properties_1[_i];
                    //检测字符串格式有无错误
                    var words = property.match(framework.RegexpUtil.floatRegexp);
                    if (words == null)
                        words = property.match(framework.RegexpUtil.rangeRegexp);
                    if (words == null)
                        words = property.match(framework.RegexpUtil.vectorRegexp);
                    if (words == null)
                        words = property.match(framework.RegexpUtil.textureRegexp);
                    if (words == null) {
                        console.error(this.getName() + " property error! info:\n" + property);
                        return;
                    }
                    if (words != null && words.length >= 4) {
                        var key = words[1];
                        var showName = words[2];
                        var type = words[3].toLowerCase();
                        switch (type) {
                            case "float":
                                this.defaultMapUniform[key] = { type: m4m.render.UniformTypeEnum.Float, value: parseFloat(words[4]) };
                                break;
                            case "range":
                                //this.defaultValue[key] = { type: render.UniformTypeEnum.Float, min: parseFloat(words[4]), max: parseFloat(words[5]), value: parseFloat(words[6]) };
                                this.defaultMapUniform[key] = { type: m4m.render.UniformTypeEnum.Float, value: parseFloat(words[6]), min: parseFloat(words[4]), max: parseFloat(words[5]) };
                                break;
                            case "vector":
                                var _vector = new m4m.math.vector4(parseFloat(words[4]), parseFloat(words[5]), parseFloat(words[6]), parseFloat(words[7]));
                                this.defaultMapUniform[key] = { type: m4m.render.UniformTypeEnum.Float4, value: _vector };
                                break;
                            case "color":
                                var _color = new m4m.math.vector4(parseFloat(words[4]), parseFloat(words[5]), parseFloat(words[6]), parseFloat(words[7]));
                                this.defaultMapUniform[key] = { type: m4m.render.UniformTypeEnum.Float4, value: _color, becolor: true };
                                break;
                            case "texture":
                                this.defaultMapUniform[key] = { type: m4m.render.UniformTypeEnum.Texture, value: assetmgr.getDefaultTexture(words[4]) };
                                break;
                            default:
                                console.error(this.getName() + " property error! unknown type : " + type);
                                break;
                        }
                    }
                }
            };
            shader.prototype._parsePass = function (assetmgr, json, type) {
                var pass = new m4m.render.glDrawPass();
                var vs = json["vs"];
                var fs = json["fs"];
                switch (json["showface"]) {
                    case "cw":
                        pass.state_showface = m4m.render.ShowFaceStateEnum.CW;
                        break;
                    case "ccw":
                        pass.state_showface = m4m.render.ShowFaceStateEnum.CCW;
                        break;
                    default:
                        pass.state_showface = m4m.render.ShowFaceStateEnum.ALL;
                        break;
                }
                var blendmode = m4m.render.BlendModeEnum.Close;
                switch (json["zwrite"]) {
                    case "off":
                        pass.state_zwrite = false;
                        break;
                    case "on":
                    default:
                        pass.state_zwrite = true;
                        break;
                }
                pass.state_ztest = true;
                switch (json["ztest"]) {
                    case "greater":
                        pass.state_ztest_method = m4m.render.webglkit.GREATER;
                        break;
                    case "gequal":
                        pass.state_ztest_method = m4m.render.webglkit.GEQUAL;
                        break;
                    case "less":
                        pass.state_ztest_method = m4m.render.webglkit.LESS;
                        break;
                    case "equal":
                        pass.state_ztest_method = m4m.render.webglkit.EQUAL;
                        break;
                    case "notequal":
                        pass.state_ztest_method = m4m.render.webglkit.NOTEQUAL;
                        break;
                    case "always":
                    case "off":
                        pass.state_ztest = false;
                        break;
                    case "never":
                        pass.state_ztest_method = m4m.render.webglkit.NEVER;
                        break;
                    case "lequal":
                    default:
                        pass.state_ztest_method = m4m.render.webglkit.LEQUAL;
                        break;
                }
                switch (json["blendmode"]) {
                    case "add":
                        blendmode = m4m.render.BlendModeEnum.Add;
                        break;
                    case "addpremult":
                        blendmode = m4m.render.BlendModeEnum.Add_PreMultiply;
                        break;
                    case "blend":
                        blendmode = m4m.render.BlendModeEnum.Blend;
                        break;
                    case "blendpremult":
                        blendmode = m4m.render.BlendModeEnum.Blend_PreMultiply;
                        break;
                }
                pass.setAlphaBlend(blendmode);
                //var program = assetmgr.shaderPool.linkProgram(assetmgr.webgl, vs, fs);
                var program = assetmgr.shaderPool.linkProgrambyPassType(assetmgr.webgl, type, vs, fs, assetmgr.app.globalMacros);
                pass.setProgram(program);
                if (this.layer == framework.RenderLayerEnum.Overlay) {
                    pass.state_ztest = true;
                    pass.state_zwrite = true;
                    pass.state_ztest_method = m4m.render.webglkit.ALWAYS;
                }
                return pass;
            };
            shader.prototype.fillUnDefUniform = function (pass) {
                for (var key in pass.mapuniforms) {
                    var item = pass.mapuniforms[key];
                    if (framework.uniformSetter.autoUniformDic[item.name] == null && this.defaultMapUniform[item.name] == null) {
                        switch (item.type) {
                            case m4m.render.UniformTypeEnum.Float:
                                this.defaultMapUniform[item.name] = { type: m4m.render.UniformTypeEnum.Float, value: 0 };
                                break;
                            case m4m.render.UniformTypeEnum.Int:
                                this.defaultMapUniform[item.name] = { type: m4m.render.UniformTypeEnum.Int, value: 0 };
                                break;
                            case m4m.render.UniformTypeEnum.Floatv:
                                this.defaultMapUniform[item.name] = { type: m4m.render.UniformTypeEnum.Float4x4v, value: null };
                                break;
                            case m4m.render.UniformTypeEnum.Float4:
                                if (item.name.indexOf("_ST") >= 0 || item.name.indexOf("_st") >= 0) {
                                    this.defaultMapUniform[item.name] = { type: m4m.render.UniformTypeEnum.Float4, value: new m4m.math.vector4(1, 1, 0, 0) };
                                }
                                else {
                                    this.defaultMapUniform[item.name] = { type: m4m.render.UniformTypeEnum.Float4, value: new m4m.math.vector4(1, 1, 1, 1) };
                                }
                                break;
                            case m4m.render.UniformTypeEnum.Float4v:
                                this.defaultMapUniform[item.name] = { type: m4m.render.UniformTypeEnum.Float4v, value: null };
                                break;
                            case m4m.render.UniformTypeEnum.Float4x4:
                                this.defaultMapUniform[item.name] = { type: m4m.render.UniformTypeEnum.Float4x4, value: null };
                                break;
                            case m4m.render.UniformTypeEnum.Float4x4v:
                                this.defaultMapUniform[item.name] = { type: m4m.render.UniformTypeEnum.Float4x4v, value: null };
                                break;
                            case m4m.render.UniformTypeEnum.Texture:
                                var tex = framework.sceneMgr.app.getAssetMgr().getDefaultTexture("white");
                                this.defaultMapUniform[item.name] = { type: m4m.render.UniformTypeEnum.Texture, value: tex };
                                break;
                            case m4m.render.UniformTypeEnum.CubeTexture:
                                var cubetex = framework.sceneMgr.app.getAssetMgr().getDefaultCubeTexture("white");
                                this.defaultMapUniform[item.name] = { type: m4m.render.UniformTypeEnum.CubeTexture, value: cubetex };
                                break;
                        }
                    }
                }
            };
            shader.ClassName = "shader";
            __decorate([
                m4m.reflect.Field("constText"),
                __metadata("design:type", framework.constText)
            ], shader.prototype, "name", void 0);
            shader = __decorate([
                m4m.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], shader);
            return shader;
        }());
        framework.shader = shader;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * sprite资源
         * @version m4m 1.0
         */
        var sprite = /** @class */ (function () {
            function sprite(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 边距
                 * @version m4m 1.0
                 */
                this.border = new m4m.math.border();
                if (!assetName) {
                    assetName = "sprite_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取资源名称
             * @version m4m 1.0
             */
            sprite.prototype.getName = function () {
                return this.name.getText();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取资源唯一id
             * @version m4m 1.0
             */
            sprite.prototype.getGUID = function () {
                return this.id.getID();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 引用计数加一
             * @version m4m 1.0
             */
            sprite.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 引用计数减一
             * @version m4m 1.0
             */
            sprite.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 释放资源
             * @version m4m 1.0
             */
            sprite.prototype.dispose = function () {
                if (this.texture != null) {
                    this.texture.unuse();
                }
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 计算资源字节大小
             * @version m4m 1.0
             */
            sprite.prototype.caclByteLength = function () {
                var total = 0;
                if (this._texture) {
                    total += this._texture.caclByteLength();
                }
                return total;
            };
            Object.defineProperty(sprite.prototype, "texture", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 获取当前texture
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._texture;
                },
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 设置texture
                 * @param value texture实例
                 * @version m4m 1.0
                 */
                set: function (value) {
                    if (this._texture != null) {
                        this._texture.unuse();
                    }
                    this._texture = value;
                    this._texture.use();
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(sprite.prototype, "urange", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * uv的u范围
                 * @version m4m 1.0
                 */
                get: function () {
                    if (this._urange == null) {
                        this._urange = new m4m.math.vector2();
                        this._urange.x = this.rect.x / this._texture.glTexture.width;
                        this._urange.y = (this.rect.x + this.rect.w) / this._texture.glTexture.width;
                    }
                    return this._urange;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(sprite.prototype, "vrange", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * uv的v范围
                 * @version m4m 1.0
                 */
                get: function () {
                    if (this._vrange == null) {
                        this._vrange = new m4m.math.vector2();
                        this._vrange.x = this.rect.y / this._texture.glTexture.height;
                        this._vrange.y = (this.rect.y + this.rect.h) / this._texture.glTexture.height;
                    }
                    return this._vrange;
                },
                enumerable: false,
                configurable: true
            });
            sprite.ClassName = "sprite";
            sprite = __decorate([
                m4m.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], sprite);
            return sprite;
        }());
        framework.sprite = sprite;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../../io/reflect.ts" />
var m4m;
/// <reference path="../../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 文本资源
         * @version m4m 1.0
         */
        var textasset = /** @class */ (function () {
            function textasset(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 是否为默认资源
                 * @version m4m 1.0
                 */
                this.defaultAsset = false;
                if (!assetName) {
                    assetName = "texture_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取资源名称
             * @version m4m 1.0
             */
            textasset.prototype.getName = function () {
                return this.name.getText();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取资源唯一id
             * @version m4m 1.0
             */
            textasset.prototype.getGUID = function () {
                return this.id.getID();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 引用计数加一
             * @version m4m 1.0
             */
            textasset.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 引用计数减一
             * @version m4m 1.0
             */
            textasset.prototype.unuse = function () {
                framework.sceneMgr.app.getAssetMgr().unuse(this);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 释放资源
             * @version m4m 1.0
             */
            textasset.prototype.dispose = function () {
                this.content == null;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 计算资源字节大小
             * @version m4m 1.0
             */
            textasset.prototype.caclByteLength = function () {
                if (this.content) {
                    return m4m.math.caclStringByteLength(this.content);
                }
            };
            textasset.ClassName = "textasset";
            __decorate([
                m4m.reflect.Field("constText"),
                __metadata("design:type", framework.constText)
            ], textasset.prototype, "name", void 0);
            textasset = __decorate([
                m4m.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], textasset);
            return textasset;
        }());
        framework.textasset = textasset;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../../io/reflect.ts" />
var m4m;
/// <reference path="../../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * texture资源
         * @version m4m 1.0
         */
        var texture = /** @class */ (function () {
            function texture(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.id = new framework.resID();
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 是否为默认资源
                 * @version m4m 1.0
                 */
                this.defaultAsset = false;
                if (!assetName) {
                    assetName = "texture_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取资源名称
             * @version m4m 1.0
             */
            texture.prototype.getName = function () {
                return this.name.getText();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取资源唯一id
             * @version m4m 1.0
             */
            texture.prototype.getGUID = function () {
                return this.id.getID();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 引用计数加一
             * @version m4m 1.0
             */
            texture.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 引用计数减一
             * @version m4m 1.0
             */
            texture.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 释放资源
             * @version m4m 1.0
             */
            texture.prototype.dispose = function () {
                if (this && this.glTexture) {
                    this.glTexture.dispose(framework.sceneMgr.app.getAssetMgr().webgl);
                }
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 计算资源字节大小
             * @version m4m 1.0
             */
            texture.prototype.caclByteLength = function () {
                if (this.glTexture) {
                    return this.glTexture.caclByteLength();
                }
            };
            Object.defineProperty(texture.prototype, "realName", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 如果是imgdesc加载来的图片，通过这个可以获取到真实的图片名字
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._realName;
                },
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 设置图片名称
                 * @version m4m 1.0
                 */
                set: function (name) {
                    this._realName = name;
                },
                enumerable: false,
                configurable: true
            });
            texture.ClassName = "texture";
            __decorate([
                m4m.reflect.Field("constText"),
                __metadata("design:type", framework.constText)
            ], texture.prototype, "name", void 0);
            texture = __decorate([
                m4m.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], texture);
            return texture;
        }());
        framework.texture = texture;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var AudioEx = /** @class */ (function () {
            function AudioEx() {
                try {
                    var _AudioContext = window["AudioContext"] || window["webkitAudioContext"] || window["mozAudioContext"] || window["msAudioContext"];
                    this.audioContext = new _AudioContext();
                    console.log("audio Context inited");
                }
                catch (e) {
                    // throw new Error("!Your browser does not support AudioContext");
                    console.error("!Your browser does not support AudioContext");
                }
            }
            AudioEx.instance = function () {
                if (AudioEx.g_this == null)
                    AudioEx.g_this = new AudioEx();
                return AudioEx.g_this;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 初始化声音api，注意：在ios上面必须手动点击某个按钮来调用初始化，否则无法播放声音
             * @version m4m 1.0
             */
            AudioEx.prototype.clickInit = function () {
                if (!this.isAvailable())
                    return;
                // create empty buffer
                if (this.audioContext != null) {
                    var buffer = this.audioContext.createBuffer(1, 1, 22050);
                    var source = this.audioContext.createBufferSource();
                    source.buffer = buffer;
                    // connect to output (your speakers)
                    source.connect(this.audioContext.destination);
                    // play the file
                    source.start();
                }
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 从arraybuffer转成audiobuffer
             * @version m4m 1.0
             * @param ab  二进制声音数据
             * @param fun
             */
            AudioEx.prototype.loadAudioBufferFromArrayBuffer = function (ab, fun) {
                this.audioContext.decodeAudioData(ab, function (audiobuffer) {
                    fun(audiobuffer, null);
                });
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 从本地文件加载音频数据，返回audiobuffer
             * @version m4m 1.0
             * @param url  文件地址
             * @param fun
             */
            AudioEx.prototype.loadAudioBuffer = function (url, fun) {
                var _this = this;
                AudioEx.loadArrayBuffer(url, function (_ab, __err) {
                    if (__err != null)
                        fun(null, __err);
                    else {
                        _this.audioContext.decodeAudioData(_ab, function (audiobuffer) {
                            fun(audiobuffer, null);
                        });
                    }
                });
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 初始化声音api，注意：在ios上面必须手动点击某个按钮来调用初始化，否则无法播放声音
            * @version m4m 1.0
            */
            AudioEx.prototype.isAvailable = function () {
                return this.audioContext ? true : false;
            };
            AudioEx.prototype.createAudioChannel = function (be3DSound) {
                if (!this.audioContext)
                    return;
                var cc = new AudioChannel();
                cc.source = this.audioContext.createBufferSource();
                cc.gainNode = this.audioContext.createGain();
                // var filterNode = this.audioContext.createBiquadFilter();
                // let controlFrequency = function (value)
                // {
                //     filterNode.frequency.value = value;
                // }
                // // 音频为1000变调
                // controlFrequency(1500);
                // cc.source.connect(filterNode);
                // filterNode.connect(cc.gainNode);
                cc.source.connect(cc.gainNode);
                if (be3DSound) {
                    //3d音效
                    cc.pannerNode = this.audioContext.createPanner();
                    cc.gainNode.connect(cc.pannerNode);
                    cc.pannerNode.connect(this.audioContext.destination);
                }
                else {
                    cc.gainNode.connect(this.audioContext.destination);
                }
                //声音调节
                cc.gainNode.gain.value = 1;
                return cc;
            };
            AudioEx.loadArrayBuffer = function (url, fun) {
                var req = new XMLHttpRequest(); //ness
                req.open("GET", url);
                req.responseType = "arraybuffer"; //ie 一定要在open之后修改responseType
                req.onreadystatechange = function () {
                    if (req.readyState == 4) {
                        if (req.status == 404)
                            fun(null, new Error("onerr 404"));
                        else
                            fun(req.response, null);
                    }
                };
                req.onerror = function () {
                    fun(null, new Error("onerr in req:")); //ness
                };
                req.send();
            };
            return AudioEx;
        }());
        framework.AudioEx = AudioEx;
        var AudioChannel = /** @class */ (function () {
            function AudioChannel() {
            }
            Object.defineProperty(AudioChannel.prototype, "volume", {
                /**
                * @public
                * @language zh_CN
                * @classdesc
                * 获取音量大小
                * @version m4m 1.0
                */
                get: function () {
                    return this.gainNode.gain.value;
                },
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 设置音量大小
                 * @param value 音量值
                 * @version m4m 1.0
                 */
                set: function (val) {
                    val = val > 1 ? 1 : val;
                    val = val <= 0 ? 0 : val;
                    this.gainNode.gain.value = val;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 停止播放声音
             * @version m4m 1.0
             */
            AudioChannel.prototype.stop = function () {
                if (this.source != null) {
                    this.source.stop();
                    this.source = null;
                }
                this.isplay = false;
            };
            return AudioChannel;
        }());
        framework.AudioChannel = AudioChannel;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../io/reflect.ts" />
var m4m;
/// <reference path="../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 动画播放器
         * @version m4m 1.0
         */
        var aniplayer = /** @class */ (function () {
            function aniplayer() {
                this.clips = [];
                this.autoplay = true;
                this._playClip = null;
                //这里面放加载好的动画
                this.clipnames = {};
                this.bePlay = false;
                this.speed = 1.0;
                this.beCross = false;
                this.beRevert = false;
                this._playTimer = 0;
                this._playFrameid = 0;
                this._playCount = 0;
                this.crossTotalTime = 0;
                this.crossRestTimer = 0;
                this.crossPercentage = 0;
                //private lastframee:Float32Array;
                //private lastIndexDic:{[boneName:string]:number};
                this.carelist = {};
                this.careBoneMat = {};
                this.inversTpos = {};
                //private Tpos: { [key: string]: tPoseInfo} = {};
                //tpose: { [key: string]: math.matrix } = {};
                this.startepose = {};
                this._awaitClips = [];
                this._allClipNames = [];
                this.collected = false;
                this.temptMat = m4m.math.pool.new_matrix();
                this.frameDirty = true;
                this.playEndDic = {};
                this.beActivedEndFrame = false;
                this.endFrame = 0;
                this.beActived = false; //是否play过动画
                this.boneCache = {};
            }
            Object.defineProperty(aniplayer.prototype, "hasBoneMap", {
                get: function () {
                    if (!this._hasBoneMap) {
                        var _map = this._hasBoneMap = {};
                        for (var i = 0; i < this.bones.length; i++) {
                            _map[this.bones[i].name] = true;
                        }
                    }
                    return this._hasBoneMap;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(aniplayer.prototype, "PlayFrameID", {
                get: function () {
                    return this._playFrameid;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(aniplayer.prototype, "currentAniclipName", {
                get: function () {
                    if (this._playClip) {
                        return this._playClip.getName();
                    }
                    else {
                        return null;
                    }
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(aniplayer.prototype, "currentAniclip", {
                get: function () {
                    return this._playClip;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(aniplayer.prototype, "playCount", {
                /**
                 * 动画循环播放次数
                 */
                get: function () { return this._playCount; },
                enumerable: false,
                configurable: true
            });
            aniplayer.prototype.init = function () {
                for (var i = 0; i < this.bones.length; i++) {
                    var _info = this.bones[i];
                    var name_2 = _info.name;
                    var nb = framework.PoseBoneMatrix.create();
                    nb.r = _info.tposeq;
                    nb.t = _info.tposep;
                    nb.invert();
                    this.inversTpos[name_2] = nb;
                    //this.Tpos[name]=_info;
                    // let bindpose=math.pool.new_matrix();
                    // math.matrixMakeTransformRTS(_info.tposep,math.pool.vector3_one,_info.tposeq,bindpose);
                    // math.matrixInverse(bindpose,bindpose);
                    // this.tpose[name] = bindpose;
                    this.startepose[name_2] = this.startPos[i];
                }
                // let asbones: asbone[] = this.gameObject.getComponentsInChildren("asbone") as asbone[];
                // for (let key in asbones)
                // {
                //     let trans = asbones[key].gameObject.transform;
                //     this.carelist[trans.name] = trans;
                //     this.careBoneMat[trans.name] = PoseBoneMatrix.create();
                //     this.careBoneMat[trans.name].r = math.pool.new_quaternion();
                //     this.careBoneMat[trans.name].t = math.pool.new_vector3();
                //     this.careBoneMat[trans.name].s = 1;
                // }
                this.allAsboneToCareList();
            };
            /**
             * 收集所有的 asbone 到 更新列表
             */
            aniplayer.prototype.allAsboneToCareList = function () {
                var asbones = this.gameObject.getComponentsInChildren("asbone");
                for (var i = 0, len = asbones.length; i < len; i++) {
                    var trans = asbones[i].gameObject.transform;
                    this.addToCareList(trans);
                }
            };
            /**
             * 添加 到 更新骨骼节点列表
             * @param bone 骨骼节点
             */
            aniplayer.prototype.addToCareList = function (bone) {
                if (!bone)
                    return;
                var _map = this.hasBoneMap;
                if (!_map[bone.name]) {
                    console.info("aniplayer [".concat(this.gameObject.getName(), "] node [").concat(bone.name, "] is not a valid bone!"));
                    return;
                }
                this.carelist[bone.name] = bone;
                this.careBoneMat[bone.name] = framework.PoseBoneMatrix.create();
                this.careBoneMat[bone.name].r = m4m.math.pool.new_quaternion();
                this.careBoneMat[bone.name].t = m4m.math.pool.new_vector3();
                this.careBoneMat[bone.name].s = 1;
            };
            /** 获取待加载的 动画片段名 列表 */
            aniplayer.prototype.awaitLoadClipNames = function () {
                this.collectClipNames();
                return this._awaitClips;
            };
            /** 所有的动画片段名列表，包含待加载的列表 */
            aniplayer.prototype.allClipNames = function () {
                this.collectClipNames();
                return this._allClipNames;
            };
            aniplayer.prototype.collectClipNames = function () {
                var _this = this;
                if (this.collected)
                    return;
                if (this.clips) {
                    this.clips.forEach(function (clip) {
                        if (clip) {
                            var cname = clip.getName();
                            _this._allClipNames.push(cname);
                            if (!_this.haveClip(cname)) {
                                _this._awaitClips.push(cname);
                            }
                        }
                    });
                }
                this.collected = true;
            };
            /** 添加动画片段 通过名字加载 */
            aniplayer.prototype.addClipByNameLoad = function (_assetMgr, resPath, clipName, callback) {
                var _this = this;
                var url = "".concat(resPath, "/").concat(clipName);
                _assetMgr.load(url, m4m.framework.AssetTypeEnum.Aniclip, function (sta) {
                    if (sta.isfinish) {
                        var clip = sta.resstateFirst.res;
                        _this.addClip(clip);
                    }
                    if (callback) {
                        callback(sta, clipName);
                    }
                });
            };
            /** 添加动画片段 */
            aniplayer.prototype.addClip = function (clip) {
                if (clip != null) {
                    this.clipnames[clip.getName()] = clip;
                }
            };
            /** 是否有装载指定动画判断 */
            aniplayer.prototype.haveClip = function (name) {
                return this.clipnames[name] != null;
            };
            /** 获取动画片段 */
            aniplayer.prototype.getClip = function (name) {
                return this.clipnames[name];
            };
            aniplayer.prototype.start = function () {
                if (!this.bones)
                    return;
                this.init();
                var len = this.clips.length;
                for (var i = 0; i < len; i++) {
                    var clip = this.clips[i];
                    if (!clip.frames || Object.keys(clip.frames).length < 1)
                        continue;
                    this.addClip(clip);
                }
                var firstClip = this.clips[0];
                if (this.autoplay && firstClip && firstClip.frames && Object.keys(firstClip.frames).length >= 1) {
                    this.playAniclip(firstClip);
                }
            };
            aniplayer.prototype.onPlay = function () {
            };
            aniplayer.prototype.update = function (delta) {
                if (!this.bePlay)
                    return;
                this.checkFrameId(delta);
                if (!this.bePlay)
                    return;
                if (this.beCross) {
                    this.crossRestTimer -= delta * this.speed;
                    this.crossPercentage = this.crossRestTimer / this.crossTotalTime;
                    if (this.crossRestTimer <= 0) {
                        this.beCross = false;
                    }
                }
                var lastFdata = this.curFrame;
                this.frameDirty = false;
                var currFdata = this._playClip.frames[this._playFrameid];
                if (currFdata == lastFdata)
                    return;
                this.frameDirty = true;
                this.curFrame = currFdata;
                var bs = this._playClip.hasScaled
                    ? 8 // TODO: 8
                    : 7;
                if (!this.curFrame) {
                    console.error("frames of null on aniplayer.update() , framesIsNull :".concat(this._playClip.frames == null, " , GameObjectName: ").concat(this.gameObject.getName(), " , _playFrameid:").concat(this._playFrameid, " , clipName : ").concat(this._playClip.getName()));
                    return;
                }
                if (this._playClip.indexDic.len)
                    for (var bonename in this.carelist) {
                        var trans = this.carelist[bonename];
                        var transMat = this.careBoneMat[bonename];
                        var index = this._playClip.indexDic[bonename];
                        if (index != null) {
                            if (this.beCross && this.lastFrame) {
                                transMat.lerpInWorldWithData(this.inversTpos[bonename], this.lastFrame[bonename], this.curFrame, index * 7 + 1, 1 - this.crossPercentage);
                            }
                            else {
                                transMat.r.x = this.curFrame[index * bs + 1];
                                transMat.r.y = this.curFrame[index * bs + 2];
                                transMat.r.z = this.curFrame[index * bs + 3];
                                transMat.r.w = this.curFrame[index * bs + 4];
                                transMat.t.x = this.curFrame[index * bs + 5];
                                transMat.t.y = this.curFrame[index * bs + 6];
                                transMat.t.z = this.curFrame[index * bs + 7];
                                if (this._playClip.hasScaled) {
                                    transMat.s = this.curFrame[index * bs + 8];
                                }
                            }
                            //------------todo 待优化
                            var fmat = framework.PoseBoneMatrix.sMultiply(transMat, this.inversTpos[bonename]);
                            m4m.math.matrixMakeTransformRTS(fmat.t, m4m.math.pool.vector3_one, fmat.r, this.temptMat);
                            m4m.math.matrixMultiply(this.gameObject.transform.getWorldMatrix(), this.temptMat, this.temptMat);
                            trans.setWorldMatrix(this.temptMat);
                            //trans.updateTran(false);
                            // let _matrix: math.matrix = math.pool.new_matrix();
                            // math.matrixMakeTransformRTS(transMat.t,math.pool.vector3_one,transMat.r,_matrix);
                            // math.matrixMultiply(_matrix,this.tpose[bonename],_matrix);
                            // math.matrixMultiply(this.gameObject.transform.getWorldMatrix(), _matrix, _matrix);
                            // trans.setWorldMatrix(_matrix);
                            // let i=0;
                            // trans.updateTran(false);
                        }
                        else {
                            console.error("Bone: " + bonename + " Not Record in Aniclip(" + this._playClip.getName() + ").");
                        }
                    }
                this.recyclecache();
            };
            /**
             * @public
             * @language zh_CN
             * @param animName 动画片段名字
             * @param speed 播放速度
             * @param beRevert 是否倒播
             * @classdesc
             * 根据动画片段名字播放动画
             * @version m4m 1.0
             */
            aniplayer.prototype.play = function (animName, onPlayEnd, speed, beRevert) {
                if (onPlayEnd === void 0) { onPlayEnd = null; }
                if (speed === void 0) { speed = 1.0; }
                if (beRevert === void 0) { beRevert = false; }
                var clip = this.clipnames[animName];
                if (clip == null) {
                    console.error("animclip " + this.gameObject.transform.name + "  " + animName + " is not exist");
                    return;
                }
                if (this.bePlay) {
                    this.OnClipPlayEnd();
                }
                this.beCross = false;
                this.beActivedEndFrame = false;
                this.playAniclip(clip, onPlayEnd, speed, beRevert);
            };
            /**
             * @public
             * @language zh_CN
             * @param animName 动画片段名字
             * @param crosstimer 融合时间
             * @param speed 播放速度
             * @param beRevert 是否倒播
             * @classdesc
             * 根据动画片段名字播放动画
             * @version m4m 1.0
             */
            aniplayer.prototype.playCross = function (animName, crosstimer, onPlayEnd, speed, beRevert) {
                if (onPlayEnd === void 0) { onPlayEnd = null; }
                if (speed === void 0) { speed = 1.0; }
                if (beRevert === void 0) { beRevert = false; }
                var clip = this.clipnames[animName];
                if (clip == null) {
                    console.error("animclip " + this.gameObject.transform.name + "  " + animName + " is not exist");
                    return;
                }
                if (this.bePlay) //正在播放其他动画
                 {
                    if (crosstimer > 0 && this.curFrame) {
                        this.recordeLastFrameData();
                        this.beCross = true;
                        this.crossTotalTime = crosstimer;
                        this.crossRestTimer = crosstimer;
                    }
                    else {
                        this.beCross = false;
                    }
                    this.OnClipPlayEnd();
                }
                this.beActivedEndFrame = false;
                this.playAniclip(clip, onPlayEnd, speed, beRevert);
            };
            aniplayer.prototype.playToXFrame = function (animName, endframe, crosstimer, onPlayEnd, speed) {
                if (crosstimer === void 0) { crosstimer = 0; }
                if (onPlayEnd === void 0) { onPlayEnd = null; }
                if (speed === void 0) { speed = 1.0; }
                var clip = this.clipnames[animName];
                if (clip == null) {
                    console.error("animclip " + this.gameObject.transform.name + "  " + animName + " is not exist");
                    return;
                }
                if (this.bePlay) //正在播放其他动画
                 {
                    if (crosstimer > 0 && this.curFrame) {
                        this.recordeLastFrameData();
                        this.beCross = true;
                        this.crossTotalTime = crosstimer;
                        this.crossRestTimer = crosstimer;
                    }
                    else {
                        this.beCross = false;
                    }
                    this.OnClipPlayEnd();
                }
                if (endframe >= 0) {
                    this.beActivedEndFrame = true;
                    this.endFrame = endframe;
                }
                else {
                    this.beActivedEndFrame = false;
                }
                this.playAniclip(clip, onPlayEnd, speed, false);
            };
            //private tempPoseMat:PoseBoneMatrix=PoseBoneMatrix.createDefault();
            // private tempPoseMat1:PoseBoneMatrix=PoseBoneMatrix.createDefault();
            aniplayer.prototype.recordeLastFrameData = function () {
                if (this.lastFrame == null)
                    this.lastFrame = {};
                for (var key in this._playClip.bones) {
                    var bonename = this._playClip.bones[key];
                    if (!this.lastFrame[bonename]) {
                        this.lastFrame[bonename] = framework.PoseBoneMatrix.create();
                    }
                    var index = this._playClip.indexDic[bonename];
                    this.lastFrame[bonename].copyFromData(this.curFrame, index * 7 + 1);
                }
            };
            aniplayer.prototype.playAniclip = function (aniclip, onPlayEnd, speed, beRevert) {
                if (onPlayEnd === void 0) { onPlayEnd = null; }
                if (speed === void 0) { speed = 1.0; }
                if (beRevert === void 0) { beRevert = false; }
                this.beActived = true;
                this.bePlay = true;
                this._playTimer = 0;
                this._playFrameid = 0;
                this._playCount = 0;
                this._playClip = aniclip;
                this.playEndDic[aniclip.getName()] = onPlayEnd;
                this.speed = speed;
                this.beRevert = beRevert;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 停止播放动画
             * @version m4m 1.0
             */
            aniplayer.prototype.stop = function () {
                if (this.bePlay) {
                    this.OnClipPlayEnd();
                }
            };
            aniplayer.prototype.pause = function () {
                if (this.bePlay) {
                    this.bePlay = false;
                }
                else if (!this.bePlay && this._playClip) {
                    this.bePlay = true;
                }
            };
            /**
             * 是否在播放动画
             */
            aniplayer.prototype.isPlay = function () {
                return this.bePlay;
            };
            /**
             * 是否在停止动画
             */
            aniplayer.prototype.isStop = function () {
                return !this.bePlay;
            };
            /**
             * @private
             */
            aniplayer.prototype.remove = function () {
                if (this.clips)
                    this.clips.forEach(function (temp) {
                        if (temp)
                            temp.unuse();
                    });
                for (var key in this.lastFrame) {
                    framework.PoseBoneMatrix.recycle(this.lastFrame[key]);
                }
                for (var key in this.careBoneMat) {
                    framework.PoseBoneMatrix.recycle(this.careBoneMat[key]);
                }
                for (var key in this.boneCache) {
                    framework.PoseBoneMatrix.recycle(this.boneCache[key]);
                }
                this.clips.length = 0;
                this.bones.length = 0;
                this.startPos.length = 0;
                this.startepose = null;
                this._playClip = null;
                this.curFrame = null;
                this.lastFrame = null;
                this.careBoneMat = null;
                this.boneCache = null;
                delete this.inversTpos;
                delete this.carelist;
            };
            /**
             * @private
             */
            aniplayer.prototype.clone = function () {
            };
            aniplayer.prototype.checkFrameId = function (delay) {
                var lastFid = this._playFrameid;
                this._playTimer += delay * this.speed;
                this._playFrameid = (this._playClip.fps * this._playTimer) | 0;
                var clipFrameCount = this._playClip.frameCount;
                if (this.beActivedEndFrame && this._playFrameid > this.endFrame) {
                    this._playFrameid = this.endFrame;
                    if (lastFid == this.endFrame) {
                        this.OnClipPlayEnd();
                    }
                }
                else if (this._playClip.loop) //加上循环与非循环动画的分别控制
                 {
                    this._playCount = Math.floor(this._playFrameid / clipFrameCount);
                    this._playFrameid %= clipFrameCount;
                }
                else if (this._playFrameid > clipFrameCount - 1) {
                    this._playFrameid = clipFrameCount - 1;
                    //-------------------OnPlayEnd
                    this.OnClipPlayEnd();
                }
                if (this.beRevert) {
                    this._playFrameid = clipFrameCount - this._playFrameid - 1;
                }
                //避免 _playFrameid 为负
                this._playFrameid = this._playFrameid < 0 ? 0 : this._playFrameid;
            };
            aniplayer.prototype.OnClipPlayEnd = function () {
                var Clipame = this._playClip ? this._playClip.getName() : "";
                this._playClip = null;
                // this.lastFrame=null;
                this.bePlay = false;
                this.beCross = false;
                var endFunc = this.playEndDic[Clipame];
                if (endFunc) {
                    endFunc();
                }
            };
            aniplayer.prototype.recyclecache = function () {
                for (var key in this.boneCache) {
                    framework.PoseBoneMatrix.recycle(this.boneCache[key]);
                }
                this.boneCache = {};
            };
            aniplayer.prototype.fillPoseData = function (data, bones) {
                if (!bones || !data)
                    return;
                if (!this.bePlay) {
                    if (this.beActived)
                        return;
                    for (var i = 0, len = bones.length; i < len; i++) {
                        var bonename = bones[i].name;
                        var boneMat = this.startepose[bonename];
                        data[i * 8 + 0] = boneMat.r.x;
                        data[i * 8 + 1] = boneMat.r.y;
                        data[i * 8 + 2] = boneMat.r.z;
                        data[i * 8 + 3] = boneMat.r.w;
                        data[i * 8 + 4] = boneMat.t.x;
                        data[i * 8 + 5] = boneMat.t.y;
                        data[i * 8 + 6] = boneMat.t.z;
                        data[i * 8 + 7] = boneMat.s ? boneMat.s : 1;
                    }
                    return;
                }
                if (!this.curFrame)
                    return;
                if (this._playClip.indexDic.len)
                    for (var i = 0, len = bones.length; i < len; i++) {
                        var bonename = bones[i].name;
                        var index = this._playClip.indexDic[bonename];
                        if (index != null) {
                            if (this.beCross && this.lastFrame) {
                                // let lastindex=this.lastIndexDic[bonename];
                                var boneMat = void 0;
                                if (this.careBoneMat[bonename]) {
                                    boneMat = this.careBoneMat[bonename];
                                }
                                else if (this.boneCache[bonename]) {
                                    boneMat = this.boneCache[bonename];
                                }
                                else {
                                    var mat = framework.PoseBoneMatrix.create();
                                    mat.lerpInWorldWithData(this.inversTpos[bonename], this.lastFrame[bonename], this.curFrame, index * 7 + 1, 1 - this.crossPercentage);
                                    this.boneCache[bonename] = mat;
                                }
                                data[i * 8 + 0] = boneMat.r.x;
                                data[i * 8 + 1] = boneMat.r.y;
                                data[i * 8 + 2] = boneMat.r.z;
                                data[i * 8 + 3] = boneMat.r.w;
                                data[i * 8 + 4] = boneMat.t.x;
                                data[i * 8 + 5] = boneMat.t.y;
                                data[i * 8 + 6] = boneMat.t.z;
                                // data[i * 8 + 7] = 1;
                                data[i * 8 + 7] = boneMat.s ? boneMat.s : 1;
                            }
                            else {
                                var bs = this._playClip.hasScaled
                                    ? 8
                                    : 7;
                                data[i * 8 + 0] = this.curFrame[index * bs + 1];
                                data[i * 8 + 1] = this.curFrame[index * bs + 2];
                                data[i * 8 + 2] = this.curFrame[index * bs + 3];
                                data[i * 8 + 3] = this.curFrame[index * bs + 4];
                                data[i * 8 + 4] = this.curFrame[index * bs + 5];
                                data[i * 8 + 5] = this.curFrame[index * bs + 6];
                                data[i * 8 + 6] = this.curFrame[index * bs + 7];
                                data[i * 8 + 7] = this._playClip.hasScaled
                                    ? this.curFrame[index * bs + 8]
                                    : 1;
                                // data[i * 8 + 7] = 1;
                            }
                        }
                        else {
                            // console.error("Bone: " + bonename + " Not Record in Aniclip(" + this._playClip.getName() + ").");
                        }
                        //----------------------
                    }
            };
            aniplayer.ClassName = "aniplayer";
            __decorate([
                m4m.reflect.Field("animationClip[]"),
                __metadata("design:type", Array)
            ], aniplayer.prototype, "clips", void 0);
            __decorate([
                m4m.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], aniplayer.prototype, "autoplay", void 0);
            __decorate([
                m4m.reflect.Field("tPoseInfo[]"),
                __metadata("design:type", Array)
            ], aniplayer.prototype, "bones", void 0);
            __decorate([
                m4m.reflect.Field("PoseBoneMatrix[]"),
                __metadata("design:type", Array)
            ], aniplayer.prototype, "startPos", void 0);
            aniplayer = __decorate([
                m4m.reflect.nodeComponent
            ], aniplayer);
            return aniplayer;
        }());
        framework.aniplayer = aniplayer;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../io/reflect.ts" />
var m4m;
/// <reference path="../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        // /**
        //  * @public
        //  * @language zh_CN
        //  * @classdesc
        //  * 动画播放器
        //  * @version m4m 1.0
        //  */
        // @reflect.nodeComponent
        // export class aniplayer implements INodeComponent
        // {
        //     /**
        //      * @public
        //      * @language zh_CN
        //      * @classdesc
        //      * 挂载的gameobject
        //      * @version m4m 1.0
        //      */
        //     gameObject: gameObject;
        //     private _clipnameCount = 0;
        //     private _clipnames: { [key: string]: number } = null;
        //     /**
        //      * @public
        //      * @language zh_CN
        //      * @classdesc
        //      * 返回动画数组（clips）所有动画的名字
        //      * @version m4m 1.0
        //      */
        //     get clipnames()
        //     {
        //         if (this._clipnames == null || this._clipnameCount != this.clips.length)
        //         {
        //             this._clipnameCount = this.clips.length;
        //             this._clipnames = {};
        //             for (let key in this.clips)
        //             {
        //                 if (this.clips[key])
        //                     this.clipnames[this.clips[key].getName()] = parseInt(key);
        //             }
        //         }
        //         return this._clipnames;
        //     }
        //     /**
        //      * @public
        //      * @language zh_CN
        //      * @classdesc
        //      * 动画数组
        //      * @version m4m 1.0
        //      */
        //     @reflect.Field("animationClip[]")
        //     clips: animationClip[];
        //     /**
        //      * @public
        //      * @language zh_CN
        //      * @classdesc
        //      * 是否自动播放
        //      * @version m4m 1.0
        //      */
        //     @reflect.Field("boolean")
        //     public autoplay: boolean = true;
        //     private playIndex: number = 0;
        //     private _playClip: animationClip = null;
        //     /**
        //      * 当前播放 动画片段名
        //      */
        //     get playingClip(){
        //         if(!this._playClip) return "";
        //         return this._playClip.getName();
        //     }
        //     /**
        //      * @public
        //      * @language zh_CN
        //      * @classdesc
        //      * 骨骼数组
        //      * @version m4m 1.0
        //      */
        //     @reflect.Field("tPoseInfo[]")
        //     bones: tPoseInfo[];
        //     /**
        //      * @public
        //      * @language zh_CN
        //      * @classdesc
        //      * 初始位置
        //      * @version m4m 1.0
        //      */
        //     @reflect.Field("PoseBoneMatrix[]")
        //     startPos: PoseBoneMatrix[];
        //     /**
        //      * @private
        //      */
        //     tpose: { [key: string]: PoseBoneMatrix } = {};
        //     /**
        //      * @private
        //      */
        //     nowpose: { [key: string]: PoseBoneMatrix } = {};
        //     /**
        //      * @private
        //      */
        //     lerppose: { [key: string]: PoseBoneMatrix } = {};
        //     /**
        //      * @private
        //      */
        //     carelist: { [id: string]: transform } = {};
        //     private _playFrameid: number = 0;
        //     public get PlayFrameID(): number
        //     {
        //         return this._playFrameid;
        //     }
        //     /**
        //     * @private
        //     */
        //     private _playTimer: number = 0;
        //     /**
        //      * @public
        //      * @language zh_CN
        //      * @classdesc
        //      * 播放速度
        //      * @version m4m 1.0
        //      */
        //     speed: number = 1.0;
        //     /**
        //     * @private
        //     */
        //     crossdelta: number = 0;
        //     /**
        //     * @private
        //     */
        //     crossspeed: number = 0;
        //     private beRevert: boolean = false;
        //     private playStyle: PlayStyle = PlayStyle.NormalPlay;
        //     private percent: number = 0;
        //     /**
        //      * @public
        //      * @language zh_CN
        //      * @classdesc
        //      * 是否动画融合
        //      * @version m4m 1.0
        //      */
        //     public mix: boolean = false;
        //     public isCache: boolean = false;
        //     public static playerCaches: { key: string, data: aniplayer }[] = [];
        //     private _playCount = 0;
        //     /**
        //      * @public
        //      * @language zh_CN
        //      * @classdesc
        //      * 动画循环播放次数
        //      * @version m4m 1.0
        //      */
        //     public get playCount() { return this._playCount; }
        //     /**
        //      * @public
        //      * @language zh_CN
        //      * @classdesc
        //      * 返回当前播放帧数
        //      * @version m4m 1.0
        //      */
        //     get cacheKey()
        //     {
        //         if (this._playClip)
        //             return this._playClip.getGUID() + "_" + this._playFrameid;
        //         return this._playFrameid;
        //     }
        //     private init()
        //     {
        //         for (let i = 0; i < this.bones.length; i++)
        //         {
        //             let _info = this.bones[i];
        //             let name = _info.name;
        //             var nb = new PoseBoneMatrix();
        //             nb.r = _info.tposeq;
        //             nb.t = _info.tposep;
        //             nb.invert();
        //             this.tpose[name] = nb;
        //             this.nowpose[name] = this.startPos[i].Clone();
        //         }
        //         let asbones: asbone[] = this.gameObject.getComponentsInChildren("asbone") as asbone[];
        //         for (let key in asbones)
        //         {
        //             this.care(asbones[key].gameObject.transform);
        //         }
        //         if (this.autoplay && this.clips != null && this.clips.length > 0)
        //         {
        //             this.playByIndex(this.playIndex);
        //         }
        //     }
        //     start()
        //     {
        //         if (this.bones != null)
        //         {
        //             this.init();
        //         }
        //     }
        //     onPlay()
        //     {
        //     }
        //     /** 片段有播放 */
        //     private clipHasPlay = false;
        //     update(delta: number)
        //     {
        //         if (this._playClip == null)
        //             return;
        //         this.checkFrameId(delta);
        //         if(!this._playClip) return;
        //         this.clipHasPlay = true;
        //         this.mix = false;
        //         if (this.crossdelta > 0)
        //         {
        //             this.crossdelta -= delta / this.speed * this.crossspeed;
        //             this.mix = true;
        //         }
        //         let cached = false;
        //         if (this.isCache && !this.mix && aniplayer.playerCaches[this.cacheKey])
        //         {
        //             cached = true;
        //             if (StringUtil.isNullOrEmptyObject(this.carelist))
        //                 return;
        //         }
        //         for (var i = 0; i < this._playClip.boneCount; i++)
        //         {
        //             var bone = this._playClip.bones[i];
        //             if (cached && !this.carelist[bone])
        //                 continue;
        //             var frame;
        //             if (this._playClip != null && this._playClip.frames != null)
        //             {
        //                 frame = this._playClip.frames[this._playFrameid];
        //             } else
        //             {
        //                 console.warn("is null of animationclip.frames! ");
        //                 return;
        //             }
        //             var nextseek = i * 7 + 1;// this._playClip.frames[this._playFrameid];//.boneInfos[i];
        //             var outb = this.nowpose[bone];
        //             var tpose = this.tpose[bone];
        //             if (outb != undefined || frame == null)
        //             {
        //                 if (this.mix)
        //                 {
        //                     var last = this.lerppose[bone];
        //                     if (last != undefined)
        //                     {
        //                         //把恶心的计算集中提纯到一起去，有空再修改
        //                         //outb.lerpInWorld(tpose, last, next, 1 - this.crossdelta);
        //                         outb.lerpInWorldWithData(tpose, last, frame, nextseek, 1 - this.crossdelta);
        //                     }
        //                     else
        //                     {
        //                         outb.copyFromData(frame, nextseek);
        //                     }
        //                 }
        //                 else
        //                 {
        //                     outb.copyFromData(frame, nextseek);
        //                 }
        //             }
        //             var careobj = this.carelist[bone];
        //             if (careobj != undefined)
        //             {
        //                 //tbone ,一串算出最终坐标
        //                 //把恶心的计算集中提纯到一起去，有空再修改
        //                 let fmat = PoseBoneMatrix.sMultiply(outb, tpose);
        //                 let _matrix: math.matrix = math.pool.new_matrix();
        //                 math.matrixMakeTransformRTS(fmat.t, math.pool.vector3_one, fmat.r, _matrix);
        //                 let _newmatrix: math.matrix = math.pool.new_matrix();
        //                 math.matrixMultiply(this.gameObject.transform.getWorldMatrix(), _matrix, _newmatrix);
        //                 careobj.setWorldMatrix(_newmatrix);
        //                 careobj.updateTran(false);
        //                 math.pool.delete_matrix(_matrix);
        //                 math.pool.delete_matrix(_newmatrix);
        //             }
        //         }
        //         if (!cached)
        //         {
        //             aniplayer.playerCaches[this.cacheKey] = this;
        //         }
        //     }
        //     /**
        //      * @public
        //      * @language zh_CN
        //      * @param animIndex 动画片段索引
        //      * @param speed 播放速度
        //      * @param beRevert 是否倒播
        //      * @classdesc
        //      * 根据动画片段索引播放普通动画
        //      * @version m4m 1.0
        //      */
        //     playByIndex(animIndex: number, speed: number = 1.0, beRevert: boolean = false)
        //     {
        //         this.playIndex = animIndex;
        //         if (this.clips.length <= animIndex)
        //         {
        //             console.error("animIndex out Array of clips");
        //             return;
        //         }
        //         this.playAniamtion(animIndex.toString(), speed, beRevert);
        //         this.crossdelta = 0;
        //     }
        //     /**
        //      * @public
        //      * @language zh_CN
        //      * @param animIndex 动画片段索引
        //      * @param crosstimer 融合时间
        //      * @param speed 播放速度
        //      * @param beRevert 是否倒播
        //      * @classdesc
        //      * 根据动画片段索引播放动画
        //      * @version m4m 1.0
        //      */
        //     playCrossByIndex(animIndex: number, crosstimer: number, speed: number = 1.0, beRevert: boolean = false)
        //     {
        //         this.playIndex = animIndex;
        //         if (this.clips.length <= animIndex)
        //         {
        //             console.error("animIndex out Array of clips");
        //             return;
        //         }
        //         this.playAniamtion(animIndex.toString(), speed, beRevert);
        //         this.crossspeed = 1.0 / crosstimer;
        //         this.crossdelta = 1;
        //     }
        //     /**
        //      * @public
        //      * @language zh_CN
        //      * @param animName 动画片段名字
        //      * @param speed 播放速度
        //      * @param beRevert 是否倒播
        //      * @classdesc
        //      * 根据动画片段名字播放动画
        //      * @version m4m 1.0
        //      */
        //     play(animName: string, speed: number = 1.0, beRevert: boolean = false)
        //     {
        //         // if (animName.indexOf(this.getPlayName()) >= 0 && !this.isStop()){
        //         //     return;
        //         // }
        //         if (this.clipnames[animName] == null)
        //         {
        //             console.error("animclip " + this.gameObject.transform.name + "  " + animName + " is not exist");
        //             return;
        //         }
        //         this.playByIndex(this.clipnames[animName], speed, beRevert);
        //     }
        //     getPlayName()
        //     {
        //         if (this.isPlay())
        //             return this._playClip.getName();
        //     }
        //     /**
        //      * @public
        //      * @language zh_CN
        //      * @param animName 动画片段名字
        //      * @param crosstimer 融合时间
        //      * @param speed 播放速度
        //      * @param beRevert 是否倒播
        //      * @classdesc
        //      * 根据动画片段名字播放动画
        //      * @version m4m 1.0
        //      */
        //     playCross(animName: string, crosstimer: number, speed: number = 1.0, beRevert: boolean = false)
        //     {
        //         // if (animName.indexOf(this.getPlayName()) >= 0 && !this.isStop()){
        //         //     return;
        //         // }
        //         if (this.clipnames[animName] == null)
        //         {
        //             console.error("animclip " + this.gameObject.transform.name + "  " + animName + " is not exist");
        //             return;
        //         }
        //         if (crosstimer <= 0)
        //         {
        //             this.playByIndex(this.clipnames[animName], speed, beRevert);
        //         }
        //         else
        //         {
        //             this.playCrossByIndex(this.clipnames[animName], crosstimer, speed, beRevert);
        //         }
        //     }
        //     /**
        //      * @public
        //      * @language zh_CN
        //      * @param animName 动画片段名字
        //      * @param speed 播放速度
        //      * @param beRevert 是否倒播
        //      * @classdesc
        //      * 根据动画片段索引播放动画
        //      * @version m4m 1.0
        //      */
        //     private playAniamtion(index: string, speed: number = 1.0, beRevert: boolean = false)
        //     {
        //         if (this.clips[index] == undefined) return;
        //         let isp = this.isPlay();
        //         let cname = isp ? this._playClip.getName(): "";
        //         this._playClip = null;
        //         if(this.onPlayEnd && isp){
        //             this.clipHasPlay = false;
        //             this.onPlayEnd(cname);
        //         }
        //         this._playClip = this.clips[index];
        //         this._playTimer = 0;
        //         this._playFrameid = 0;
        //         this._playCount;
        //         this.speed = speed;
        //         this.beRevert = beRevert;
        //         this.playStyle = PlayStyle.NormalPlay;
        //         this.speed = speed;
        //         this.lerppose = {};
        //         for (var key in this.nowpose)
        //         {
        //             var src = this.nowpose[key];
        //             this.lerppose[key] = src.Clone();
        //         }
        //         this.clipHasPlay = false; //reset
        //     }
        //     public updateAnimation(animIndex: number, _frame: number)
        //     {
        //         if (!this.clips)
        //             return;
        //         if (animIndex >= this.clips.length)
        //             return;
        //         let _clip = this.clips[animIndex];
        //         if (!_clip)
        //             return;
        //         for (var i = 0; i < _clip.boneCount; i++)
        //         {
        //             var bone = _clip.bones[i];
        //             var frame = _clip.frames[_frame];
        //             var nextseek = i * 7 + 1;
        //             var outb = this.nowpose[bone];
        //             var tpose = this.tpose[bone];
        //             if (outb != undefined)
        //             {
        //                 outb.copyFromData(frame, nextseek);
        //             }
        //             var careobj = this.carelist[bone];
        //             if (careobj != undefined)
        //             {
        //                 //tbone ,一串算出最终坐标
        //                 //把恶心的计算集中提纯到一起去，有空再修改
        //                 let fmat = PoseBoneMatrix.sMultiply(outb, tpose);
        //                 let _matrix: math.matrix = math.pool.new_matrix();
        //                 math.matrixMakeTransformRTS(fmat.t, math.pool.vector3_one, fmat.r, _matrix);
        //                 let _newmatrix: math.matrix = math.pool.new_matrix();
        //                 math.matrixMultiply(this.gameObject.transform.getWorldMatrix(), _matrix, _newmatrix);
        //                 careobj.setWorldMatrix(_newmatrix);
        //                 careobj.updateTran(false);
        //                 math.pool.delete_matrix(_matrix);
        //                 math.pool.delete_matrix(_newmatrix);
        //             }
        //         }
        //         let renders = this.gameObject.getComponentsInChildren(StringUtil.COMPONENT_SKINMESHRENDER) as m4m.framework.skinnedMeshRenderer[];
        //         for (let key in renders)
        //         {
        //             let _render = renders[key];
        //             _render.update(0);
        //         }
        //     }
        //     /**
        //      * @public
        //      * @language zh_CN
        //      * @classdesc
        //      * 停止播放动画
        //      * @version m4m 1.0
        //      */
        //     stop(): void
        //     {
        //         let isp = this.isPlay();
        //         let cname = isp ? this._playClip.getName(): "";
        //         this._playClip = null;
        //         if(this.onPlayEnd && isp)
        //             this.onPlayEnd(cname);
        //     }
        //     /**
        //      * @public
        //      * @language zh_CN
        //      * @classdesc
        //      * 是否在播放动画
        //      * @version m4m 1.0
        //      */
        //     isPlay(): boolean
        //     {
        //         return this._playClip && this.clipHasPlay;
        //     }
        //     /**
        //      * @public
        //      * @language zh_CN
        //      * @classdesc
        //      * 是否在停止动画
        //      * @version m4m 1.0
        //      */
        //     isStop(): boolean
        //     {
        //         if (this._playClip == null) return true;
        //         if (this.playStyle != PlayStyle.NormalPlay) return false;
        //         if (this._playClip.loop) return false;
        //         if (this._playFrameid == this._playClip.frameCount - 1)
        //             return true;
        //         return false;
        //     }
        //     /**
        //      * @private
        //      */
        //     remove()
        //     {
        //         if (this.clips)
        //             this.clips.forEach(temp =>
        //             {
        //                 if (temp) temp.unuse();
        //             });
        //         this.clips.length = 0;
        //         this.bones.length = 0;
        //         this.startPos.length = 0;
        //         this._playClip = null;
        //         delete this.tpose;
        //         delete this.nowpose;
        //         delete this.lerppose;
        //         delete this.carelist;
        //         delete this._clipnames;
        //     }
        //     /**
        //      * @private
        //      */
        //     clone()
        //     {
        //     }
        //     private finishCallBack: Function;
        //     private thisObject: any;
        //     /**
        //      * @public
        //      * @language zh_CN
        //      * @param finishCallBack 事件
        //      * @param thisObject 对象
        //      * @classdesc
        //      * 给动画添加结束事件
        //      * @version m4m 1.0
        //      */
        //     public addFinishedEventListener(finishCallBack: Function, thisObject: any): void
        //     {
        //         this.finishCallBack = finishCallBack;
        //         this.thisObject = thisObject;
        //     }
        //     /**
        //      * @public
        //      * @language zh_CN
        //      * clip播放end
        //      * @param clipname 动画片段名
        //      */
        //     onPlayEnd:(clipname:string)=>any;
        //     private checkFrameId(delay: number): void 
        //     {
        //         if (this.playStyle == PlayStyle.NormalPlay)
        //         {
        //             this._playTimer += delay * this.speed;
        //             this._playFrameid = (this._playClip.fps * this._playTimer) | 0;
        //             if (this._playClip.loop)//加上循环与非循环动画的分别控制
        //             {
        //                 this._playCount += Math.floor(this._playFrameid / this._playClip.frameCount);
        //                 this._playFrameid %= this._playClip.frameCount;
        //             }
        //             else if (this._playFrameid > this._playClip.frameCount - 1)
        //             {
        //                 this._playFrameid = this._playClip.frameCount - 1;
        //             }
        //             if (this.beRevert)
        //             {
        //                 this._playFrameid = this._playClip.frameCount - this._playFrameid - 1;
        //             }
        //         } else if (this.playStyle == PlayStyle.FramePlay)
        //         {
        //             //使用传进来的百分比计算当前播放帧
        //             this._playFrameid = (this._playClip.frameCount * this.percent) - 1;
        //             this._playFrameid = Math.round(this._playFrameid);
        //         }
        //         if (this._playFrameid < 0)
        //         {
        //             this._playFrameid = 0;
        //         }
        //         if (this._playFrameid > this._playClip.frameCount - 1)
        //         {
        //             this._playFrameid = this._playClip.frameCount - 1;
        //         }
        //         if (this.isStop())
        //         {
        //             let isp = this.isPlay();
        //             let cname = isp ? this._playClip.getName(): "";
        //             this._playClip = null;
        //             if(this.onPlayEnd && isp)
        //                 this.onPlayEnd(cname);
        //             if (this.finishCallBack)
        //             {
        //                 this.finishCallBack(this.thisObject);
        //                 this.finishCallBack = null;
        //                 this.thisObject = null;
        //             }
        //         }
        //     }
        //     /**
        //      * @private
        //      */
        // fillPoseData(data: Float32Array, bones: transform[], efficient: boolean = true): void
        // {
        //     var seek: number = 0;
        //     for (var i in bones)
        //     {
        //         var key: string = bones[i].name;
        //         var obj = this.nowpose[key];
        //         if (obj == undefined)
        //         {
        //             if (efficient)
        //             {
        //                 data[seek * 8 + 0] = 0;
        //                 data[seek * 8 + 1] = 0;
        //                 data[seek * 8 + 2] = 0;
        //                 data[seek * 8 + 3] = 1;
        //                 data[seek * 8 + 4] = 0;
        //                 data[seek * 8 + 5] = 0;
        //                 data[seek * 8 + 6] = 0;
        //                 data[seek * 8 + 7] = 1;
        //             }
        //             else
        //             {
        //                 data[seek * 16 + 0] = 1;
        //                 data[seek * 16 + 1] = 0;
        //                 data[seek * 16 + 2] = 0;
        //                 data[seek * 16 + 3] = 0;
        //                 data[seek * 16 + 4] = 0;
        //                 data[seek * 16 + 5] = 1;
        //                 data[seek * 16 + 6] = 0;
        //                 data[seek * 16 + 7] = 0;
        //                 data[seek * 16 + 8] = 0;
        //                 data[seek * 16 + 9] = 0;
        //                 data[seek * 16 + 10] = 1;
        //                 data[seek * 16 + 11] = 0;
        //                 data[seek * 16 + 12] = 0;
        //                 data[seek * 16 + 13] = 0;
        //                 data[seek * 16 + 14] = 0;
        //                 data[seek * 16 + 15] = 1;
        //             }
        //         }
        //         else
        //         {
        //             let _mat = math.pool.new_matrix();
        //             if (efficient)
        //             {
        //                 data[seek * 8 + 0] = obj.r.x;
        //                 data[seek * 8 + 1] = obj.r.y;
        //                 data[seek * 8 + 2] = obj.r.z;
        //                 data[seek * 8 + 3] = obj.r.w;
        //                 data[seek * 8 + 4] = obj.t.x;
        //                 data[seek * 8 + 5] = obj.t.y;
        //                 data[seek * 8 + 6] = obj.t.z;
        //                 data[seek * 8 + 7] = 1;
        //             }
        //             else
        //             {
        //                 math.matrixMakeTransformRTS(obj.t, math.pool.vector3_one, obj.r, _mat);
        //                 for (var j = 0; j < 16; j++)
        //                 {
        //                     data[seek * 16 + j] = _mat.rawData[j];
        //                 }
        //             }
        //             math.pool.delete_matrix(_mat);
        //         }
        //         seek++;
        //     }
        // }
        //     /**
        //      * @private
        //      */
        //     care(node: transform)
        //     {
        //         var pnode = node;
        //         while (true)
        //         {
        //             if (this.nowpose[pnode.name] != undefined)
        //             {
        //                 this.carelist[pnode.name] = pnode;
        //                 return;
        //             }
        //             if (pnode.parent)
        //                 pnode = pnode.parent;
        //             else
        //                 return;
        //             // if (pnode instanceof transform)
        //             // {
        //             // }
        //             // else
        //             // {
        //             //     break;
        //             // }
        //         }
        //     }
        // }
        /**
         * @private
         */
        var tPoseInfo = /** @class */ (function () {
            function tPoseInfo() {
            }
            tPoseInfo.ClassName = "tPoseInfo";
            __decorate([
                m4m.reflect.Field("string"),
                __metadata("design:type", String)
            ], tPoseInfo.prototype, "name", void 0);
            __decorate([
                m4m.reflect.Field("vector3"),
                __metadata("design:type", m4m.math.vector3)
            ], tPoseInfo.prototype, "tposep", void 0);
            __decorate([
                m4m.reflect.Field("quaternion"),
                __metadata("design:type", m4m.math.quaternion)
            ], tPoseInfo.prototype, "tposeq", void 0);
            tPoseInfo = __decorate([
                m4m.reflect.SerializeType
            ], tPoseInfo);
            return tPoseInfo;
        }());
        framework.tPoseInfo = tPoseInfo;
        var PlayStyle;
        (function (PlayStyle) {
            PlayStyle[PlayStyle["NormalPlay"] = 0] = "NormalPlay";
            PlayStyle[PlayStyle["FramePlay"] = 1] = "FramePlay";
            PlayStyle[PlayStyle["PingPang"] = 2] = "PingPang";
        })(PlayStyle = framework.PlayStyle || (framework.PlayStyle = {}));
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 骨骼组件
         * @version m4m 1.0
         */
        var asbone = /** @class */ (function () {
            function asbone() {
            }
            asbone.prototype.start = function () {
            };
            asbone.prototype.onPlay = function () {
            };
            asbone.prototype.update = function (delta) {
            };
            /**
             * @private
             */
            asbone.prototype.remove = function () {
            };
            /**
             * @private
             */
            asbone.prototype.clone = function () {
            };
            asbone.ClassName = "asbone";
            asbone = __decorate([
                m4m.reflect.nodeComponent,
                __metadata("design:paramtypes", [])
            ], asbone);
            return asbone;
        }());
        framework.asbone = asbone;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../io/reflect.ts" />
var m4m;
/// <reference path="../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        var AudioListener = /** @class */ (function () {
            function AudioListener() {
                this.lastX = 0;
                this.lastY = 0;
                this.lastZ = 0;
            }
            AudioListener.prototype.start = function () {
                this.listener = framework.AudioEx.instance().audioContext.listener;
            };
            AudioListener.prototype.onPlay = function () {
            };
            AudioListener.prototype.update = function (delta) {
                this.curPos = this.gameObject.transform.getWorldTranslate();
                if (this.curPos.x != this.lastX || this.curPos.y != this.lastY || this.curPos.z != this.lastZ) {
                    this.listener.setPosition(this.curPos.x, this.curPos.y, this.curPos.z);
                    this.lastX = this.curPos.x;
                    this.lastY = this.curPos.y;
                    this.lastZ = this.curPos.z;
                }
            };
            AudioListener.prototype.remove = function () {
            };
            AudioListener.prototype.clone = function () {
            };
            AudioListener.ClassName = "AudioListener";
            AudioListener = __decorate([
                m4m.reflect.nodeComponent
            ], AudioListener);
            return AudioListener;
        }());
        framework.AudioListener = AudioListener;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../io/reflect.ts" />
var m4m;
/// <reference path="../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        var AudioPlayer = /** @class */ (function () {
            function AudioPlayer() {
                this.be3DSound = true;
                this.lastX = 0;
                this.lastY = 0;
                this.lastZ = 0;
            }
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 播放声音
             * @param buffer 音源缓冲对象
             * @param beLoop 是循环播放
             * @param volume 音量 0-1
             * @param onended 音源播放结束回调
             */
            AudioPlayer.prototype.play = function (buffer, beLoop, volume, onended) {
                if (beLoop === void 0) { beLoop = false; }
                if (volume === void 0) { volume = 0; }
                if (this.audioChannel != null) {
                    if (this.audioChannel.isplay) {
                        this.stop();
                    }
                    this.audioChannel = null;
                }
                if (!(this.audioChannel = framework.AudioEx.instance().createAudioChannel(this.be3DSound)))
                    return;
                this.buffer = buffer;
                this.volume = volume;
                var c = this.audioChannel;
                c.source.loop = this.beLoop;
                c.source.buffer = this.buffer;
                c.volume = this.volume;
                c.source.start();
                c.isplay = true;
                if (!this.beLoop) {
                    c.source.onended = function () {
                        c.isplay = false;
                        c.source = null;
                        if (onended != undefined)
                            onended();
                    };
                }
                // //郭加的
                // if(this.beLoop)
                // {   
                //     c.source.onended=()=>
                //     {
                //         this.play(buffer, beLoop, volume);
                //     }
                // }
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 停止播放
            * @version m4m 1.0
            */
            AudioPlayer.prototype.stop = function () {
                if (this.audioChannel != null) {
                    this.audioChannel.stop();
                }
            };
            Object.defineProperty(AudioPlayer.prototype, "volume", {
                /**
                * @public
                * @language zh_CN
                * @classdesc
                * 获取音量大小
                * @version m4m 1.0
                */
                get: function () {
                    return this.audioChannel == null ? -1 : this.audioChannel.volume;
                },
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 设置音量大小
                 * @param value 音量值
                 * @version m4m 1.0
                 */
                set: function (val) {
                    this.audioChannel == null ? 0 : this.audioChannel.volume = val;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获得当前音频播放器是否在播放
             * @version m4m 1.0
             */
            AudioPlayer.prototype.isPlaying = function () {
                return this.audioChannel == undefined ? false : this.audioChannel.isplay;
            };
            AudioPlayer.prototype.start = function () {
                this.audioChannel = framework.AudioEx.instance().createAudioChannel(this.be3DSound);
            };
            AudioPlayer.prototype.onPlay = function () {
            };
            AudioPlayer.prototype.update = function (delta) {
                this.curPos = this.gameObject.transform.getWorldTranslate();
                if (this.audioChannel && (this.curPos.x != this.lastX || this.curPos.y != this.lastY || this.curPos.z != this.lastZ)) {
                    this.audioChannel.pannerNode.setPosition(this.curPos.x, this.curPos.y, this.curPos.z);
                    this.lastX = this.curPos.x;
                    this.lastY = this.curPos.y;
                    this.lastZ = this.curPos.z;
                }
            };
            AudioPlayer.prototype.remove = function () {
            };
            AudioPlayer.prototype.clone = function () {
            };
            AudioPlayer.ClassName = "AudioPlayer";
            AudioPlayer = __decorate([
                m4m.reflect.nodeComponent
            ], AudioPlayer);
            return AudioPlayer;
        }());
        framework.AudioPlayer = AudioPlayer;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var BeBillboard = /** @class */ (function () {
            function BeBillboard() {
                this.beActive = true;
                this.target = null;
            }
            BeBillboard.prototype.start = function () {
            };
            BeBillboard.prototype.onPlay = function () {
            };
            BeBillboard.prototype.update = function (delta) {
                if (!this.beActive || this.target == null)
                    return;
                this.gameObject.transform.lookat(this.target);
            };
            BeBillboard.prototype.remove = function () {
            };
            BeBillboard.prototype.clone = function () {
            };
            BeBillboard.prototype.setActive = function (active) {
                this.beActive = active;
            };
            BeBillboard.prototype.setTarget = function (trans) {
                this.target = trans;
            };
            BeBillboard.ClassName = "BeBillboard";
            BeBillboard = __decorate([
                m4m.reflect.nodeComponent
            ], BeBillboard);
            return BeBillboard;
        }());
        framework.BeBillboard = BeBillboard;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 脚本行文类
         * @version m4m 1.0
         */
        var behaviour = /** @class */ (function () {
            function behaviour() {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 组件启用
                 * @version m4m 1.0
                 */
                // @reflect.Field("boolean")  //有问题 ，待处理组件继承后 开启
                this.enabled = true;
            }
            /** 初始化使用 */
            behaviour.prototype.start = function () {
            };
            /** 初始化使用 在start 之后 */
            behaviour.prototype.onPlay = function () {
            };
            /** 每帧调用一次 */
            behaviour.prototype.update = function (delta) {
            };
            /**
             * @private
             */
            behaviour.prototype.remove = function () {
            };
            /**
             * @private
             */
            behaviour.prototype.clone = function () {
            };
            return behaviour;
        }());
        framework.behaviour = behaviour;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../io/reflect.ts" />
var m4m;
/// <reference path="../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * Bloom后期效果 控制器
         * @version m4m 1.0
         */
        var bloomctr = /** @class */ (function () {
            function bloomctr() {
                this._bloomIntensity = 1.4; //rang
                this._bloomThreshold = 0.5; //rang 0-1
                this._blurSpread = 3;
                this.tag = "__bloomtag__";
                this._init = false;
            }
            Object.defineProperty(bloomctr.prototype, "bloomThreshold", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 发光阈值 - 图像中亮度高于该阈值的区域将产生泛光效果
                 * @version m4m 1.0
                 */
                get: function () { return this._bloomThreshold; },
                set: function (value) {
                    this._bloomThreshold = value;
                    if (!this.material || !this.material_1 || !this.material_2)
                        return;
                    this.material.setFloat("_bloomThreshold", this._bloomThreshold);
                },
                enumerable: false,
                configurable: true
            });
            ;
            Object.defineProperty(bloomctr.prototype, "bloomIntensity", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 强度 - 附加光（影响到该特效的光源）的全局光强
                 * @version m4m 1.0
                 */
                get: function () { return this._bloomIntensity; },
                set: function (value) {
                    this._bloomIntensity = value;
                    if (!this.material || !this.material_3)
                        return;
                    //this.material.setFloat("_bloomIntensity", this._bloomIntensity);
                    this.material_3.setFloat("_bloomIntensity", this._bloomIntensity);
                },
                enumerable: false,
                configurable: true
            });
            ;
            Object.defineProperty(bloomctr.prototype, "blurSpread", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 模糊扩散 - Frag down sample 的偏移距离
                 * @version m4m 1.0
                 */
                get: function () { return this._blurSpread; },
                set: function (value) {
                    this._blurSpread = value;
                    if (!this.material_1 || !this.material_2)
                        return;
                    var v4_1 = m4m.math.pool.new_vector4();
                    var v4_2 = m4m.math.pool.new_vector4();
                    v4_1.x = value;
                    v4_1.y = 0;
                    v4_2.x = 0;
                    v4_2.y = value;
                    this.material_1.setVector4("_blurSpread", v4_1);
                    this.material_2.setVector4("_blurSpread", v4_2);
                    //m4m.math.pool.delete_vector4(v4_1);
                    //m4m.math.pool.delete_vector4(v4_2);
                },
                enumerable: false,
                configurable: true
            });
            ;
            bloomctr.prototype.init = function () {
                var sh = this.scene.app.getAssetMgr().getShader("bloom.shader.json");
                if (!sh) {
                    console.warn("bloom.shader.json not find");
                    return;
                }
                var psize = 1024;
                var color = new framework.cameraPostQueue_Color();
                color[this.tag] = true;
                color.renderTarget = new m4m.render.glRenderTarget(this.scene.webgl, psize, psize, true, false);
                if (!this.camera.postQueues)
                    this.camera.postQueues = [];
                this.camera.postQueues.push(color);
                var textcolor = new framework.texture("_color");
                textcolor.glTexture = color.renderTarget;
                // Stage 1 - threshold and fragdown sample (based on main texture)
                var post0 = new framework.cameraPostQueue_Quad();
                post0.renderTarget = new m4m.render.glRenderTarget(this.scene.webgl, psize, psize, true, false);
                post0[this.tag] = true;
                this.material = post0.material;
                this.material.use();
                post0.material.setShader(sh);
                post0.material.setTexture("_MainTex", textcolor); // based on main texture
                post0.material.setTexture("_BlurTex", textcolor); // NOTE: useless
                post0.material.setFloat("_bloomIntensity", 1.2);
                post0.material.setFloat("_bloomThreshold", this._bloomThreshold);
                post0.material.setVector4("_blurSpread", new m4m.math.vector4(0, 0, 0, 0)); // NOTE: offset value must be 0 during filter stage
                post0.material.setVector4("_MainTex_TexelSize", new m4m.math.vector4(1 / psize, 1 / psize, psize, psize));
                this.camera.postQueues.push(post0);
                // Generate threshold texture:
                var threTex = new framework.texture("_threshold");
                threTex.glTexture = post0.renderTarget;
                // Stage 2 - horizontal blur (based on threshold texture)
                var post0 = new framework.cameraPostQueue_Quad();
                post0.renderTarget = new m4m.render.glRenderTarget(this.scene.webgl, psize, psize, true, false);
                post0[this.tag] = true;
                this.material_1 = post0.material;
                this.material_1.use();
                post0.material.setShader(sh);
                post0.material.setTexture("_MainTex", threTex); // based on threshold texture
                post0.material.setTexture("_BlurTex", threTex); // NOTE: useless
                post0.material.setFloat("_bloomIntensity", this._bloomIntensity);
                post0.material.setFloat("_bloomThreshold", 1.0); // NOTE: blur frag, must be 1.0 during blur stage
                post0.material.setVector4("_blurSpread", new m4m.math.vector4(this._blurSpread, 0, 0, 0));
                post0.material.setVector4("_MainTex_TexelSize", new m4m.math.vector4(1 / psize, 1 / psize, psize, psize));
                this.camera.postQueues.push(post0);
                // Generate blur texture
                var hBlur = new framework.texture("_blur0");
                hBlur.glTexture = post0.renderTarget;
                // Stage 3 - vertical blur (based on horizontal blur texture)
                var post0 = new framework.cameraPostQueue_Quad();
                post0.renderTarget = new m4m.render.glRenderTarget(this.scene.webgl, psize, psize, true, false);
                post0[this.tag] = true;
                this.material_2 = post0.material;
                this.material_2.use();
                post0.material.setShader(sh);
                post0.material.setTexture("_MainTex", hBlur); // based on horizontal blur texture
                post0.material.setTexture("_BlurTex", hBlur); // NOTE: useless
                post0.material.setFloat("_bloomIntensity", this._bloomIntensity);
                post0.material.setFloat("_bloomThreshold", 1.0); // NOTE: blur frag
                post0.material.setVector4("_blurSpread", new m4m.math.vector4(0, this._blurSpread, 0, 0)); // NOTE: Empty offset value
                post0.material.setVector4("_MainTex_TexelSize", new m4m.math.vector4(1 / psize, 1 / psize, psize, psize));
                this.camera.postQueues.push(post0);
                // Generate threshold texture:
                var hvBlur = new framework.texture("_blur1");
                hvBlur.glTexture = post0.renderTarget;
                // Stage 4 - Composition - render final effect
                var post0 = new framework.cameraPostQueue_Quad();
                post0[this.tag] = true;
                this.material_3 = post0.material;
                post0.material.use();
                post0.material.setShader(sh);
                post0.material.setTexture("_MainTex", textcolor);
                post0.material.setTexture("_BlurTex", hvBlur);
                post0.material.setFloat("_bloomIntensity", this._bloomIntensity);
                post0.material.setFloat("_bloomThreshold", 0.5); // NOTE: threshold != 1.0 during final render
                post0.material.setVector4("_blurSpread", new m4m.math.vector4(0.5, 0.5, 0, 0)); // NOTE: spread != 0.0
                post0.material.setVector4("_MainTex_TexelSize", new m4m.math.vector4(1 / psize, 1 / psize, psize, psize));
                this.camera.postQueues.push(post0);
                this._init = true;
            };
            bloomctr.prototype.start = function () {
                this.app = this.gameObject.transform.scene.app;
                this.scene = this.app.getScene();
            };
            bloomctr.prototype.onPlay = function () {
            };
            bloomctr.prototype.update = function (delta) {
                if (this._init)
                    return;
                if (!this.camera)
                    this.camera = this.gameObject.getComponent("camera");
                if (this.camera)
                    this.init();
            };
            /**
             * @private
             */
            bloomctr.prototype.remove = function () {
                this._init = false;
                if (this.camera) {
                    var arr_1 = this.camera.postQueues;
                    var dArr = [];
                    for (var i = 0; i < arr_1.length; i++) {
                        var temp = arr_1[i];
                        if (temp[this.tag]) {
                            dArr.push(temp);
                        }
                    }
                    dArr.forEach(function (element) {
                        if (element) {
                            var idx = arr_1.indexOf(element);
                            if (idx != -1) {
                                arr_1.splice(idx, 1);
                            }
                        }
                    });
                }
                if (this.material) {
                    this.material.unuse();
                    this.material = null;
                }
                if (this.material_1) {
                    this.material_1.unuse();
                    this.material_1 = null;
                }
                if (this.material_2) {
                    this.material_2.unuse();
                    this.material_2 = null;
                }
                if (this.material_3) {
                    this.material_3.unuse();
                    this.material_3 = null;
                }
            };
            /**
             * @private
             */
            bloomctr.prototype.clone = function () {
            };
            bloomctr.ClassName = "bloomctr";
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], bloomctr.prototype, "bloomThreshold", null);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], bloomctr.prototype, "bloomIntensity", null);
            bloomctr = __decorate([
                m4m.reflect.nodeComponent
            ], bloomctr);
            return bloomctr;
        }());
        framework.bloomctr = bloomctr;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../io/reflect.ts" />
var m4m;
/// <reference path="../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @private
         */
        var cameraPostQueue_Depth = /** @class */ (function () {
            function cameraPostQueue_Depth() {
                this.renderTarget = null;
            }
            cameraPostQueue_Depth.prototype.render = function (scene, context, camera) {
                //最后一个参数true 表示不用camera的clear 配置
                camera._targetAndViewport(this.renderTarget, scene, context, true);
                context.webgl.depthMask(true); //zwrite 會影響clear depth，這個查了好一陣
                m4m.render.glDrawPass.lastZWrite = true;
                context.webgl.clearColor(0, 0, 0, 0);
                context.webgl.clearDepth(1.0);
                context.webgl.clear(context.webgl.COLOR_BUFFER_BIT | context.webgl.DEPTH_BUFFER_BIT);
                camera._renderOnce(scene, context, "_depth");
                m4m.render.glRenderTarget.useNull(context.webgl);
            };
            return cameraPostQueue_Depth;
        }());
        framework.cameraPostQueue_Depth = cameraPostQueue_Depth;
        /**
         * @private
         */
        var cameraPostQueue_Quad = /** @class */ (function () {
            function cameraPostQueue_Quad() {
                this.renderTarget = null;
                this.material = new framework.material();
            }
            cameraPostQueue_Quad.prototype.render = function (scene, context, camera) {
                camera._targetAndViewport(this.renderTarget, scene, context, true);
                context.webgl.depthMask(true); //zwrite 會影響clear depth，這個查了好一陣
                m4m.render.glDrawPass.lastZWrite = true;
                context.webgl.clearColor(0, 0.3, 0, 0);
                context.webgl.clearDepth(1.0);
                context.webgl.clear(context.webgl.COLOR_BUFFER_BIT | context.webgl.DEPTH_BUFFER_BIT);
                var mesh = scene.app.getAssetMgr().getDefaultMesh("quad");
                //画四边形
                context.drawtype = "";
                // mesh.glMesh.bindVboBuffer(context.webgl);
                this.material.draw(context, mesh, mesh.submesh[0], "quad");
                m4m.render.glRenderTarget.useNull(context.webgl);
            };
            return cameraPostQueue_Quad;
        }());
        framework.cameraPostQueue_Quad = cameraPostQueue_Quad;
        /**
         * @private
         */
        var cameraPostQueue_Color = /** @class */ (function () {
            function cameraPostQueue_Color() {
                this.renderTarget = null;
            }
            cameraPostQueue_Color.prototype.render = function (scene, context, camera) {
                camera._targetAndViewport(this.renderTarget, scene, context, false);
                camera._renderOnce(scene, context, "");
                m4m.render.glRenderTarget.useNull(context.webgl);
            };
            return cameraPostQueue_Color;
        }());
        framework.cameraPostQueue_Color = cameraPostQueue_Color;
        /**
        * @public
        * @language zh_CN
        * @classdesc
        * 视锥剔除组件，作为标记存在
        * @version m4m 1.0
        */
        var camera = /** @class */ (function () {
            function camera() {
                this.projectMatrixDirty = true;
                /**
                 * 后处理渲染颜色清理优先使用雾颜色
                 */
                this.postClearUseFogColor = true;
                /**
                 * 相机剔除时，计算 z 轴上的平面 （far & near plane）
                 */
                this.cullZPlane = true;
                this._near = 0.01;
                this._far = 1000;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 相机渲染剔除mask
                 * @version m4m 1.0
                 */
                this.CullingMask = framework.CullingMask.everything ^ framework.CullingMask.editor;
                this._contextIdx = -1;
                this.isEditorCam = false;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 是否清除颜色缓冲区
                 * @version m4m 1.0
                 */
                this.clearOption_Color = true;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 是否清除深度缓冲区
                 * @version m4m 1.0
                 */
                this.clearOption_Depth = true;
                // backgroundColor: m4m.math.color = new m4m.math.color(0.11, 0.11, 0.11, 1.0);
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 背景色
                 * @version m4m 1.0
                 */
                this.backgroundColor = new m4m.math.color(0.5, 0.8, 1, 1);
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 相机视窗
                 * @version m4m 1.0
                 */
                // @m4m.reflect.Field("rect")
                this.viewport = new m4m.math.rect(0, 0, 1, 1);
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 渲染目标
                 * @version m4m 1.0
                 */
                this.renderTarget = null;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * camera 渲染排序标记
                 * @version m4m 1.0
                 */
                this.order = 0; //camera 渲染顺序
                this.overlays = [];
                this.LastCamWorldMtx = new m4m.math.matrix();
                /**
                 * 当前的相机视口像素rect
                 */
                this.currViewPixelRect = new m4m.math.rect();
                /**
                 * 当前相机视口像素asp
                 */
                this.currViewPixelASP = 1;
                this.lastAsp = -1;
                this.lastCamMtx = new m4m.math.matrix();
                this.lastCamRect = new m4m.math.rect();
                this.paraArr = [NaN, NaN, NaN, NaN, NaN]; // [fov,near,far,opvalue,size]
                this.viewMatrix = new m4m.math.matrix;
                this.matProjP = new m4m.math.matrix;
                this.matProjO = new m4m.math.matrix;
                this.projectMatrix = new m4m.math.matrix;
                this.viewProjectMatrix = new m4m.math.matrix;
                this.InverseViewProjectMatrix = new m4m.math.matrix;
                this.frameVecs = [];
                this._fov = 60 * Math.PI / 180; //透视投影的fov
                this._size = 2; //正交投影的竖向size
                this._opvalue = 1;
                // 裁剪状态列表
                this.cullingMap = {};
                this.isLastCamera = false; // 场景渲染列表的最后一个相机, 用来清除物体frustumDirty
                this.needUpdateWpos = false;
                this.fruMap = {
                    farLD: 0,
                    nearLD: 1,
                    farRD: 2,
                    nearRD: 3,
                    farLT: 4,
                    nearLT: 5,
                    farRT: 6,
                    nearRT: 7,
                };
                this._vec3cache = new m4m.math.vector3();
                this._edge1 = new m4m.math.vector3();
                this._edge2 = new m4m.math.vector3();
                /**
                * @private
                */
                this.postQueues = [];
                for (var i = 0; i < 8; i++) {
                    this.frameVecs.push(new m4m.math.vector3());
                }
            }
            camera_1 = camera;
            Object.defineProperty(camera.prototype, "near", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 相机到近裁剪面距离
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._near;
                },
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 设置相机到近裁剪面距离
                 * @version m4m 1.0
                 */
                set: function (val) {
                    if (this._opvalue > 0) {
                        if (val < 0.01)
                            val = 0.01;
                    }
                    if (val >= this._far)
                        val = this._far - 0.01;
                    this._near = val;
                    this.projectMatrixDirty = true;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(camera.prototype, "far", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 相机到远裁剪面距离
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._far;
                },
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 设置相机到远裁剪面距离
                 * @version m4m 1.0
                 */
                set: function (val) {
                    if (val <= this._near)
                        val = this._near + 0.01;
                    this._far = val;
                    this.projectMatrixDirty = true;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(camera.prototype, "CurrContextIndex", {
                //CullingMask: CullingMask = CullingMask.everything;
                /**
                 * 当前RenderContext 的 Index
                 */
                get: function () { return this._contextIdx; },
                enumerable: false,
                configurable: true
            });
            /**
             * @private
             */
            camera.prototype.markDirty = function () {
            };
            camera.prototype.start = function () {
                this.isEditorCam = this.gameObject.transform.name.toLowerCase().indexOf("editor") >= 0;
            };
            camera.prototype.onPlay = function () {
            };
            camera.prototype.update = function (delta) {
                this._updateOverLays(delta);
                var _scene = framework.sceneMgr.scene;
                if (_scene.autoCollectlightCamera) {
                    // //收集摄像机
                    // var c = this;
                    // if (c.gameObject.visibleInScene)
                    // {
                    //     _scene.renderCameras.push(c);
                    // }
                    // var cl = _scene.renderCameras.length;
                    // while (_scene.renderContext.length < cl)
                    // {
                    //     _scene.renderContext.push(new renderContext(_scene.webgl));
                    // }
                    if (this.gameObject.visibleInScene)
                        _scene.addCamera(this);
                }
            };
            /** overLays update */
            camera.prototype._updateOverLays = function (delta) {
                for (var i = 0; i < this.overlays.length; i++) {
                    if (!this.overlays[i].init) {
                        this.overlays[i].start(this);
                        this.overlays[i].init = true;
                    }
                    this.overlays[i].update(delta);
                }
            };
            /**
             * @public
             * @language zh_CN
             * @param overlay 2d组件
             * @classdesc
             * 添加2d渲染组件
             * @version m4m 1.0
             */
            camera.prototype.addOverLay = function (overLay) {
                // if (overLay instanceof overlay2D)
                // {
                //     let lay = overLay as overlay2D;
                //     if (lay.camera != null)
                //     {
                //         lay.camera.removeOverLay(lay);
                //     }
                // }
                this.overlays.push(overLay);
                this.sortOverLays(this.overlays);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 返回此相机上的overlays数组
             * @version m4m 1.0
             */
            camera.prototype.getOverLays = function () {
                return this.overlays;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 移除相机上的所有overly
             * @version m4m 1.0
             */
            camera.prototype.removeOverLay = function (overLay) {
                if (this.overlays == null)
                    return;
                var index = this.overlays.indexOf(overLay);
                if (index >= 0)
                    this.overlays.splice(index, 1);
                this.sortOverLays(this.overlays);
            };
            //overlays 排序
            camera.prototype.sortOverLays = function (lays) {
                if (!lays || lays.length < 1)
                    return;
                lays.sort(function (a, b) {
                    return a.sortOrder - b.sortOrder;
                });
            };
            /**
            * @public
            * @language zh_CN
            * 计算视矩阵, return 是否有变化
            * @param outMatrix 返回的视矩阵
            * @classdesc
            * 计算相机的viewmatrix（视矩阵）
            * @version m4m 1.0
            */
            camera.prototype.calcViewMatrix = function (outMatrix) {
                var wMtx = this.gameObject.transform.getWorldMatrix();
                var dirty = !m4m.math.matrixEqual(wMtx, this.LastCamWorldMtx, 0.000001);
                if (dirty) {
                    m4m.math.matrixClone(wMtx, this.LastCamWorldMtx);
                    //视矩阵刚好是摄像机世界矩阵的逆
                    m4m.math.matrixInverse(wMtx, this.viewMatrix);
                }
                if (outMatrix)
                    m4m.math.matrixClone(this.viewMatrix, outMatrix);
                return true;
            };
            /**
             * @public
             * @language zh_CN
             * @param app 主程序
             * @param viewportpixel 视口rect
             * @classdesc
             * 计算相机视口像素rect
             * @version m4m 1.0
             */
            camera.prototype.calcViewPortPixel = function (app, viewPortPixel) {
                var w;
                var h;
                if (this.renderTarget == null) {
                    w = app.width;
                    h = app.height;
                }
                else {
                    w = this.renderTarget.width;
                    h = this.renderTarget.height;
                }
                var vp = this.viewport;
                var cvpr = this.currViewPixelRect;
                cvpr.x = w * vp.x;
                cvpr.y = h * vp.y;
                cvpr.w = w * vp.w;
                cvpr.h = h * vp.h;
                if (viewPortPixel) {
                    m4m.math.rectClone(this.currViewPixelRect, viewPortPixel);
                }
                this.currViewPixelASP = cvpr.w / cvpr.h;
            };
            /**
             * @public
             * @language zh_CN
             * 计算投影矩阵, return 是否有变化
             * @param asp
             * @param outMatrix projectmatrix（投影矩阵）
             * @classdesc
             * 计算相机投影矩阵
             * @version m4m 1.0
             */
            camera.prototype.calcProjectMatrix = function (asp, outMatrix) {
                if (this.projectMatrixDirty || this.lastAsp != asp) {
                    if (this._opvalue > 0)
                        m4m.math.matrixProject_PerspectiveLH(this._fov, asp, this._near, this._far, this.matProjP);
                    if (this._opvalue < 1)
                        m4m.math.matrixProject_OrthoLH(this._size * asp, this._size, this._near, this._far, this.matProjO);
                    if (this._opvalue == 0)
                        m4m.math.matrixClone(this.matProjO, this.projectMatrix);
                    else if (this._opvalue == 1)
                        m4m.math.matrixClone(this.matProjP, this.projectMatrix);
                    else
                        m4m.math.matrixLerp(this.matProjO, this.matProjP, this._opvalue, this.projectMatrix);
                }
                this.projectMatrixDirty = false;
                this.lastAsp = asp;
                //投影矩阵函数缺一个
                if (outMatrix)
                    m4m.math.matrixClone(this.projectMatrix, outMatrix);
                return true;
            };
            /**
             * 计算视窗投影矩阵,return 是否有变化
             * @param app
             * @param outViewProjectMatrix
             * @param outViewMatrix
             * @param outProjectMatrix
             */
            camera.prototype.calcViewProjectMatrix = function (app, outViewProjectMatrix, outViewMatrix, outProjectMatrix) {
                var vd = this.calcViewMatrix(outViewMatrix);
                // let vpp = camera.helprect;
                // this.calcViewPortPixel(app, vpp);
                // let asp = vpp.w / vpp.h;
                var asp = this.currViewPixelASP;
                var pd = this.calcProjectMatrix(asp, outProjectMatrix);
                if (vd || pd) {
                    m4m.math.matrixMultiply(this.projectMatrix, this.viewMatrix, this.viewProjectMatrix);
                    if (outViewProjectMatrix)
                        m4m.math.matrixClone(this.viewProjectMatrix, outViewProjectMatrix);
                }
                return vd || pd;
            };
            /**
             * @public
             * @language zh_CN
             * @param screenpos 屏幕坐标
             * @param app 主程序
             * @param shareRayCache 返回ray 实例 共用一个缓存射线对象 ，默认开启
             * @classdesc
             * 由屏幕坐标发射射线
             * @version m4m 1.0
             */
            camera.prototype.creatRayByScreen = function (screenpos, app, shareRayCache) {
                if (shareRayCache === void 0) { shareRayCache = true; }
                var src1 = camera_1.helpv3;
                m4m.math.vec3Set(src1, screenpos.x, screenpos.y, 0);
                var src2 = camera_1.helpv3_1;
                m4m.math.vec3Set(src2, screenpos.x, screenpos.y, 1);
                var dest1 = camera_1.helpv3_2;
                var dest2 = camera_1.helpv3_3;
                this.calcModelPosFromScreenPos(app, src1, dest1);
                this.calcModelPosFromScreenPos(app, src2, dest2);
                var dir = camera_1.helpv3_4;
                m4m.math.vec3Subtract(dest2, dest1, dir);
                m4m.math.vec3Normalize(dir, dir);
                var ray;
                if (shareRayCache) {
                    if (!camera_1._shareRay) {
                        camera_1._shareRay = new m4m.framework.ray(dest1, dir);
                    }
                    ray = camera_1._shareRay;
                    ray.set(dest1, dir);
                }
                else {
                    ray = new m4m.framework.ray(dest1, dir);
                }
                return ray;
            };
            /**
             * @public
             * @language zh_CN
             * @param app 主程序
             * @param screenpos 屏幕坐标
             * @param outWorldPos model空间坐标
             * @classdesc
             * 由屏幕坐标得到model空间坐标
             * @version m4m 1.0
             */
            camera.prototype.calcModelPosFromScreenPos = function (app, screenPos, outModelPos) {
                // let vpp = camera.helprect;
                var vpp = this.currViewPixelRect;
                // this.calcViewPortPixel(app, vpp);
                var matinv = this.InverseViewProjectMatrix;
                var vpd = this.calcViewProjectMatrix(app);
                if (vpd) {
                    m4m.math.matrixInverse(this.viewProjectMatrix, matinv);
                }
                var src1 = camera_1.helpv3;
                src1.x = screenPos.x / vpp.w * 2 - 1;
                src1.y = 1 - screenPos.y / vpp.h * 2;
                src1.z = screenPos.z;
                // new math.vector3(vppos.x, vppos.y, screenPos.z);
                m4m.math.matrixTransformVector3(src1, matinv, outModelPos);
            };
            /**
             * @public
             * @language zh_CN
             * @param app 主程序
             * @param worldPos 世界坐标
             * @param outScreenPos 屏幕坐标
             * @classdesc
             * 由世界坐标得到屏幕坐标
             * @version m4m 1.0
             */
            camera.prototype.calcScreenPosFromWorldPos = function (app, worldPos, outScreenPos) {
                // let vpp = camera.helprect;
                var vpp = this.currViewPixelRect;
                // this.calcViewPortPixel(app, vpp);
                // let matrixView = camera.helpmtx;
                // let matrixProject = camera.helpmtx_1;
                // let asp = vpp.w / vpp.h;
                // this.calcViewMatrix(matrixView);
                // this.calcProjectMatrix(asp, matrixProject);
                // let matrixViewProject = camera.helpmtx_2;
                // m4m.math.matrixMultiply(matrixProject, matrixView, matrixViewProject);
                this.calcViewProjectMatrix(app);
                var ndcPos = camera_1.helpv3;
                // m4m.math.matrixTransformVector3(worldPos, matrixViewProject, ndcPos);
                m4m.math.matrixTransformVector3(worldPos, this.viewProjectMatrix, ndcPos);
                outScreenPos.x = (ndcPos.x + 1) * vpp.w * 0.5;
                outScreenPos.y = (1 - ndcPos.y) * vpp.h * 0.5;
            };
            /**
             * @public
             * @language zh_CN
             * @param app 主程序
             * @param worldPos 世界坐标
             * @param outScreenPos 屏幕坐标
             * @classdesc
             * 由世界坐标得到屏幕坐标
             * @version m4m 1.0
             */
            /**
             * @public
             * @language zh_CN
             * @param app application
             * @param worldPos 世界空间坐标
             * @param outClipPos 计算返回裁剪空间坐标
             * @classdesc
             * 由世界坐标得到裁剪空间坐标
             * @version m4m 1.0
             */
            camera.prototype.calcClipPosFromWorldPos = function (app, worldPos, outClipPos) {
                this.calcViewProjectMatrix(app);
                m4m.math.matrixTransformVector3(worldPos, this.viewProjectMatrix, outClipPos);
            };
            /**
             * @private 计算相机框
             * @param app
             */
            camera.prototype.calcCameraFrame = function (app) {
                var matrix = this.gameObject.transform.getWorldMatrix();
                var _vpp = camera_1.helprect;
                this.calcViewPortPixel(app, _vpp);
                var tOpval = Math.ceil(this._opvalue);
                //检查是否需要更新
                if (m4m.math.matrixEqual(this.lastCamMtx, matrix) && m4m.math.rectEqul(this.lastCamRect, _vpp) &&
                    this.paraArr[0] == this._fov && this.paraArr[1] == this._near && this.paraArr[2] == this._far) {
                    //opvalue
                    if (this.paraArr[3] == tOpval && (tOpval == 1 || this.paraArr[4] == this._size)) {
                        return;
                    }
                }
                var needSize = tOpval == 0;
                //同步last
                m4m.math.matrixClone(matrix, this.lastCamMtx);
                m4m.math.rectClone(_vpp, this.lastCamRect);
                this.paraArr[0] = this._fov;
                this.paraArr[1] = this._near;
                this.paraArr[2] = this._far;
                this.paraArr[3] = this._opvalue;
                this.paraArr[4] = this._size;
                var tanFov = Math.tan(this._fov * 0.5);
                var nearSize = this._near * tanFov;
                var farSize = this._far * tanFov;
                //set size
                if (needSize) {
                    nearSize = farSize = this._size * 0.5;
                }
                var near_h = nearSize;
                var asp = _vpp.w / _vpp.h;
                var near_w = near_h * asp;
                var nearLT = camera_1.helpv3;
                var nearLD = camera_1.helpv3_1;
                var nearRT = camera_1.helpv3_2;
                var nearRD = camera_1.helpv3_3;
                m4m.math.vec3Set(nearLT, -near_w, near_h, this._near);
                m4m.math.vec3Set(nearLD, -near_w, -near_h, this._near);
                m4m.math.vec3Set(nearRT, near_w, near_h, this._near);
                m4m.math.vec3Set(nearRD, near_w, -near_h, this._near);
                var far_h = farSize;
                var far_w = far_h * asp;
                var farLT = camera_1.helpv3_4;
                var farLD = camera_1.helpv3_5;
                var farRT = camera_1.helpv3_6;
                var farRD = camera_1.helpv3_7;
                m4m.math.vec3Set(farLT, -far_w, far_h, this._far);
                m4m.math.vec3Set(farLD, -far_w, -far_h, this._far);
                m4m.math.vec3Set(farRT, far_w, far_h, this._far);
                m4m.math.vec3Set(farRD, far_w, -far_h, this._far);
                m4m.math.matrixTransformVector3(farLD, matrix, farLD);
                m4m.math.matrixTransformVector3(nearLD, matrix, nearLD);
                m4m.math.matrixTransformVector3(farRD, matrix, farRD);
                m4m.math.matrixTransformVector3(nearRD, matrix, nearRD);
                m4m.math.matrixTransformVector3(farLT, matrix, farLT);
                m4m.math.matrixTransformVector3(nearLT, matrix, nearLT);
                m4m.math.matrixTransformVector3(farRT, matrix, farRT);
                m4m.math.matrixTransformVector3(nearRT, matrix, nearRT);
                m4m.math.vec3Clone(farLD, this.frameVecs[0]);
                m4m.math.vec3Clone(nearLD, this.frameVecs[1]);
                m4m.math.vec3Clone(farRD, this.frameVecs[2]);
                m4m.math.vec3Clone(nearRD, this.frameVecs[3]);
                m4m.math.vec3Clone(farLT, this.frameVecs[4]);
                m4m.math.vec3Clone(nearLT, this.frameVecs[5]);
                m4m.math.vec3Clone(farRT, this.frameVecs[6]);
                m4m.math.vec3Clone(nearRT, this.frameVecs[7]);
            };
            Object.defineProperty(camera.prototype, "fov", {
                get: function () {
                    return this._fov;
                },
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 透视投影的fov
                 * @version m4m 1.0
                 */
                set: function (val) {
                    this._fov = val;
                    this.projectMatrixDirty = true;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(camera.prototype, "size", {
                get: function () {
                    return this._size;
                },
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 正交投影的竖向size
                 * @version m4m 1.0
                 */
                set: function (val) {
                    this._size = val;
                    this.projectMatrixDirty = true;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(camera.prototype, "opvalue", {
                get: function () {
                    return this._opvalue;
                },
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 0=正交， 1=透视 中间值可以在两种相机间过度
                 * @version m4m 1.0
                 */
                set: function (val) {
                    if (val > 0 && this._near < 0.01) {
                        this.near = 0.01;
                        if (this._far <= this._near)
                            this.far = this._near + 0.01;
                    }
                    this._opvalue = val;
                    this.projectMatrixDirty = true;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * @private
             */
            camera.prototype.getPosAtXPanelInViewCoordinateByScreenPos = function (screenPos, app, z, out) {
                var vpp = this.currViewPixelRect;
                // let vpp = camera.helprect;
                // this.calcViewPortPixel(app, vpp);
                var nearpos = camera_1.helpv3;
                nearpos.z = -this._near;
                nearpos.x = screenPos.x - vpp.w * 0.5;
                nearpos.y = vpp.h * 0.5 - screenPos.y;
                var farpos = camera_1.helpv3_1;
                farpos.z = -this._far;
                farpos.x = this._far * nearpos.x / this._near;
                farpos.y = this._far * nearpos.y / this._near;
                ;
                var rate = (nearpos.z - z) / (nearpos.z - farpos.z);
                out.x = nearpos.x - (nearpos.x - farpos.x) * rate;
                out.y = nearpos.y - (nearpos.y - farpos.y) * rate;
            };
            /**
            * @private
            */
            camera.prototype.fillRenderer = function (scene) {
                scene.renderList.clear();
                if (scene.app.isFrustumCulling)
                    this.calcCameraFrame(scene.app);
                var fID = scene.app.frameID;
                if (camera_1.lastFID != fID) {
                    this.needUpdateWpos = true;
                    camera_1.lastFID = fID;
                }
                // this._fillRenderer1(scene, scene.getRoot());
                this._fillRenderer(scene, scene.getRoot());
                this.needUpdateWpos = false;
                camera_1.lastFID = fID;
                if (this.gameObject.transform.dirtiedOfFrustumCulling)
                    this.gameObject.transform.dirtiedOfFrustumCulling = false;
            };
            camera.prototype._fillRenderer = function (scene, node, _isStatic) {
                if (_isStatic === void 0) { _isStatic = false; }
                if (!node.needFillRenderer)
                    return; //强制不fill 
                var go = node.gameObject;
                if (!go || !go.visible || (node.hasRendererComp == false && node.hasRendererCompChild == false))
                    return; //自己没有渲染组件 且 子物体也没有 return
                // if (scene.app.isFrustumCulling && !this.testFrustumCulling(scene, node)) return;//视锥测试不通过 直接return
                go.isStatic = _isStatic || go.isStatic;
                var id = node.insId.getInsID();
                var renderer = go.renderer;
                var islayerPass = renderer != null ? this.CullingMask & (1 << renderer.renderLayer) : false;
                if (node.dirtiedOfFrustumCulling || this.gameObject.transform.dirtiedOfFrustumCulling) {
                    if (this.needUpdateWpos) { // 更新世界坐标
                        node.getWorldTranslate();
                        node.inCameraVisible = false;
                    }
                    this.cullingMap[id] = false;
                    if (islayerPass && node.enableCulling && scene.app.isFrustumCulling) {
                        this.cullingMap[id] = this.isCulling(node);
                        node.inCameraVisible = node.inCameraVisible || !this.cullingMap[id];
                    }
                    if (this.isLastCamera)
                        node.dirtiedOfFrustumCulling = false;
                }
                if (islayerPass && !this.cullingMap[id]) //判断加入到渲染列表
                 {
                    scene.renderList.addRenderer(renderer, scene.webgl);
                }
                if (node.children) {
                    for (var i = 0, l = node.children.length; i < l; ++i)
                        this._fillRenderer(scene, node.children[i], go.isStatic);
                }
                // if (node.children != null)
                // {
                //     for (var i = 0; i < node.children.length; i++)
                //     {
                //         this._fillRenderer(scene, node.children[i]);
                //     }
                // }
            };
            camera.prototype.isCulling = function (node) {
                if (node.gameObject.hideFlags & framework.HideFlags.DontFrustumCulling)
                    return false;
                var vec3cache = this._vec3cache;
                var aabb = node.aabb;
                //var skinmesh = node.gameObject.getComponent("skinnedMeshRenderer") as m4m.framework.skinnedMeshRenderer;
                var skinmesh = node.gameObject.renderer; //skinnedMeshRenderer noly
                if (skinmesh != null && skinmesh.size && skinmesh.aabb) {
                    // 有些模型没有size, 会报错
                    // 如果有骨骼动画, 使用unity导出的aabb
                    // if (skinmesh.aabb != null)
                    aabb = skinmesh.aabb;
                }
                m4m.math.vec3Subtract(aabb.maximum, aabb.minimum, vec3cache);
                var radius = m4m.math.vec3Length(vec3cache) * 0.5;
                var center = node.aabb.center;
                return this.cullTest(radius, center);
            };
            /**
             * 剔除测试 ，返回 ture 确认为剔除
             * @param radius
             * @param center
             */
            camera.prototype.cullTest = function (radius, center) {
                // Left
                if (this.isRight(this.frameVecs[this.fruMap.nearLD], this.frameVecs[this.fruMap.farLD], this.frameVecs[this.fruMap.farLT], center, radius))
                    return true;
                // Right
                if (this.isRight(this.frameVecs[this.fruMap.nearRT], this.frameVecs[this.fruMap.farRT], this.frameVecs[this.fruMap.farRD], center, radius))
                    return true;
                // Top
                if (this.isRight(this.frameVecs[this.fruMap.nearLT], this.frameVecs[this.fruMap.farLT], this.frameVecs[this.fruMap.farRT], center, radius))
                    return true;
                // Bottom
                if (this.isRight(this.frameVecs[this.fruMap.nearRD], this.frameVecs[this.fruMap.farRD], this.frameVecs[this.fruMap.farLD], center, radius))
                    return true;
                if (!this.cullZPlane)
                    return false;
                // Front
                if (this.isRight(this.frameVecs[this.fruMap.nearLT], this.frameVecs[this.fruMap.nearRT], this.frameVecs[this.fruMap.nearRD], center, radius))
                    return true;
                // Back
                if (this.isRight(this.frameVecs[this.fruMap.farRT], this.frameVecs[this.fruMap.farLT], this.frameVecs[this.fruMap.farLD], center, radius))
                    return true;
                return false;
            };
            camera.prototype.isRight = function (v0, v1, v2, pos, radius) {
                var edge1 = this._edge1;
                var edge2 = this._edge2;
                var vec3cache = this._vec3cache;
                m4m.math.vec3Subtract(v1, v0, edge1);
                m4m.math.vec3Subtract(v2, v0, edge2);
                // direction
                m4m.math.vec3Cross(edge1, edge2, vec3cache);
                m4m.math.vec3Normalize(vec3cache, vec3cache);
                // distance
                m4m.math.vec3Subtract(pos, v0, edge1);
                var dis = m4m.math.vec3Dot(edge1, vec3cache) - radius;
                return dis > 0;
            };
            /**
             * [过时接口,完全弃用]
            * @private
            */
            camera.prototype.testFrustumCulling = function (scene, node) {
                if (!node.gameObject.getComponent("frustumculling"))
                    return true; //没挂识别组件即为通过测试
                var spherecol = node.gameObject.getComponent("spherecollider");
                // let worldPos = node.getWorldTranslate();
                if (!spherecol.caclPlaneInDir(this.frameVecs[0], this.frameVecs[1], this.frameVecs[5]))
                    return false;
                if (!spherecol.caclPlaneInDir(this.frameVecs[1], this.frameVecs[3], this.frameVecs[7]))
                    return false;
                if (!spherecol.caclPlaneInDir(this.frameVecs[3], this.frameVecs[2], this.frameVecs[6]))
                    return false;
                if (!spherecol.caclPlaneInDir(this.frameVecs[2], this.frameVecs[0], this.frameVecs[4]))
                    return false;
                if (!spherecol.caclPlaneInDir(this.frameVecs[5], this.frameVecs[7], this.frameVecs[6]))
                    return false;
                if (!spherecol.caclPlaneInDir(this.frameVecs[0], this.frameVecs[2], this.frameVecs[3]))
                    return false;
                return true;
            };
            /**
            * @private
            */
            camera.prototype._targetAndViewport = function (target, scene, context, withoutClear) {
                {
                    var w = void 0;
                    var h = void 0;
                    if (target == null) {
                        w = scene.app.width;
                        h = scene.app.height;
                        // render.glRenderTarget.useNull(context.webgl);
                    }
                    else {
                        w = target.width;
                        h = target.height;
                        target.use(context.webgl);
                    }
                    //viewport 管不到clear的区域？
                    context.webgl.viewport(w * this.viewport.x, h * this.viewport.y, w * this.viewport.w, h * this.viewport.h);
                    context.webgl.depthRange(0, 1);
                    if (withoutClear == false) {
                        //clear
                        if (this.clearOption_Color && this.clearOption_Depth) {
                            context.webgl.depthMask(true); //zwrite 會影響clear depth，這個查了好一陣
                            m4m.render.glDrawPass.lastZWrite = true;
                            if (this.postClearUseFogColor && scene.fog) {
                                context.webgl.clearColor(scene.fog._Color.x, scene.fog._Color.y, scene.fog._Color.z, scene.fog._Color.w);
                            }
                            else {
                                context.webgl.clearColor(this.backgroundColor.r, this.backgroundColor.g, this.backgroundColor.b, this.backgroundColor.a);
                            }
                            //context.webgl.clearColor(this.backgroundColor.r, this.backgroundColor.g, this.backgroundColor.b, this.backgroundColor.a);
                            context.webgl.clearDepth(1.0);
                            context.webgl.clear(context.webgl.COLOR_BUFFER_BIT | context.webgl.DEPTH_BUFFER_BIT);
                        }
                        else if (this.clearOption_Depth) {
                            context.webgl.depthMask(true);
                            m4m.render.glDrawPass.lastZWrite = true;
                            context.webgl.clearDepth(1.0);
                            context.webgl.clear(context.webgl.DEPTH_BUFFER_BIT);
                        }
                        else if (this.clearOption_Color) {
                            if (this.postClearUseFogColor && scene.fog) {
                                context.webgl.clearColor(scene.fog._Color.x, scene.fog._Color.y, scene.fog._Color.z, scene.fog._Color.w);
                            }
                            else {
                                context.webgl.clearColor(this.backgroundColor.r, this.backgroundColor.g, this.backgroundColor.b, this.backgroundColor.a);
                            }
                            //context.webgl.clearColor(this.backgroundColor.r, this.backgroundColor.g, this.backgroundColor.b, this.backgroundColor.a);
                            context.webgl.clear(context.webgl.COLOR_BUFFER_BIT);
                        }
                        else {
                        }
                    }
                }
            };
            /**
            * @private
            */
            camera.prototype._renderOnce = function (scene, context, drawtype) {
                context.drawtype = drawtype;
                var assetmgr = scene.app.getAssetMgr();
                // for (let layer of scene.renderList.renderLayers)
                var rlayers = scene.renderList.renderLayers;
                for (var i = 0, l = rlayers.length; i < l; ++i) {
                    var ls = rlayers[i].list;
                    var len = ls.length;
                    for (var j = 0; j < len; ++j) 
                    // for (let item of layer.list)
                    {
                        var item = ls[j];
                        item.render(context, assetmgr, this); //过滤判断 _fillRenderer 过程几经做了
                        // if (item.gameObject.visible == true && this.CullingMask & (1 << item.renderLayer))
                        // {
                        //     if (item.gameObject && item.gameObject.visible == true)
                        //         item.render(context, assetmgr, this);
                        // }
                    }
                    //gpu instancing process
                    var rmap = rlayers[i].gpuInstanceMap;
                    for (var key in rmap) {
                        var gpuList = rmap[key];
                        if (!gpuList)
                            continue;
                        framework.meshRenderer.GpuInstancingRender(context, gpuList);
                    }
                    // Batcher gpu instancing process
                    var bRmap = rlayers[i].gpuInstanceBatcherMap;
                    for (var key in bRmap) {
                        var obj = bRmap[key];
                        if (!obj)
                            continue;
                        framework.meshRenderer.GpuInstancingRenderBatcher(context, obj);
                    }
                }
                // for (var i = 0; i < scene.renderList.renderLayers.length; i++)
                // {
                //     var layer = scene.renderList.renderLayers[i];
                //     var list = layer.list;
                //     for (var j = 0; j < list.length; j++)
                //     {
                //         if (this.CullingMask & (1 << list[j].renderLayer))
                //         {
                //             list[j].render(context, assetmgr, this);
                //         }
                //     }
                // }
            };
            /**
            * @private
            */
            camera.prototype.renderScene = function (scene, context, contextIdx) {
                this._contextIdx = contextIdx; // scene.renderContext.indexOf(context);
                var rlayers = scene.renderList.renderLayers;
                for (var i = 0, l = rlayers.length; i < l; ++i) {
                    var layer = rlayers[i];
                    var list = layer.list;
                    if (layer.needSort) {
                        if (list.length > 1) {
                            list.sort(function (a, b) {
                                if (a.queue != b.queue) {
                                    return a.queue - b.queue;
                                }
                                else if (a instanceof framework.ParticleSystem && b instanceof framework.ParticleSystem) {
                                    return b.sortingFudge - a.sortingFudge;
                                }
                                else {
                                    // var matrixView = math.pool.new_matrix();
                                    // this.calcViewMatrix(matrixView);
                                    var matrixView = context.matrixView;
                                    var az = camera_1.helpv3;
                                    var bz = camera_1.helpv3_1;
                                    // m4m.math.matrixTransformVector3(a.gameObject.transform.getWorldTranslate(), matrixView, az);
                                    // m4m.math.matrixTransformVector3(b.gameObject.transform.getWorldTranslate(), matrixView, bz);
                                    // m4m.math.matrixTransformVector3(a.gameObject.transform['worldTranslate'], matrixView, az);
                                    // m4m.math.matrixTransformVector3(b.gameObject.transform['worldTranslate'], matrixView, bz);
                                    m4m.math.matrixTransformVector3(a.gameObject.transform.worldTranslate, matrixView, az);
                                    m4m.math.matrixTransformVector3(b.gameObject.transform.worldTranslate, matrixView, bz);
                                    return bz.z - az.z;
                                }
                            });
                        }
                    }
                }
                if (this.postQueues.length == 0) {
                    this._targetAndViewport(this.renderTarget, scene, context, false);
                    this._renderOnce(scene, context, "");
                }
                else {
                    // for (let item of this.postQueues)
                    for (var i_6 = 0, l_1 = this.postQueues.length; i_6 < l_1; ++i_6) {
                        this.postQueues[i_6].render(scene, context, this);
                    }
                    context.webgl.flush();
                }
            };
            /**
            * @private
            */
            camera.prototype.remove = function () {
            };
            /**
            * @private
            */
            camera.prototype.clone = function () {
            };
            var camera_1;
            camera.ClassName = "camera";
            camera.helpv3 = new m4m.math.vector3();
            camera.helpv3_1 = new m4m.math.vector3();
            camera.helpv3_2 = new m4m.math.vector3();
            camera.helpv3_3 = new m4m.math.vector3();
            camera.helpv3_4 = new m4m.math.vector3();
            camera.helpv3_5 = new m4m.math.vector3();
            camera.helpv3_6 = new m4m.math.vector3();
            camera.helpv3_7 = new m4m.math.vector3();
            camera.helpmtx = new m4m.math.matrix();
            camera.helpmtx_1 = new m4m.math.matrix();
            camera.helpmtx_2 = new m4m.math.matrix();
            camera.helpmtx_3 = new m4m.math.matrix();
            camera.helprect = new m4m.math.rect();
            camera.lastFID = -1;
            __decorate([
                m4m.reflect.UIStyle("rangeFloat", 1, 1000, 2) //加上这个标记，编辑器就能读取这个显示ui了
                ,
                m4m.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], camera.prototype, "near", null);
            __decorate([
                m4m.reflect.UIStyle("rangeFloat", 1, 1000, 999),
                m4m.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], camera.prototype, "far", null);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], camera.prototype, "CullingMask", void 0);
            __decorate([
                m4m.reflect.compCall({ "use": "dirty", "display": "刷新camera" }),
                __metadata("design:type", Function),
                __metadata("design:paramtypes", []),
                __metadata("design:returntype", void 0)
            ], camera.prototype, "markDirty", null);
            __decorate([
                m4m.reflect.Field("IOverLay[]"),
                __metadata("design:type", Array)
            ], camera.prototype, "overlays", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], camera.prototype, "fov", null);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], camera.prototype, "size", null);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], camera.prototype, "opvalue", null);
            camera = camera_1 = __decorate([
                m4m.reflect.nodeComponent,
                m4m.reflect.nodeCamera,
                __metadata("design:paramtypes", [])
            ], camera);
            return camera;
        }());
        framework.camera = camera;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * UI画布容器组件
         * @version m4m 1.0
         */
        var canvascontainer = /** @class */ (function () {
            function canvascontainer() {
                this.isCanvasinit = false;
                this._lastMode = canvasRenderMode.ScreenSpaceOverlay;
                this._renderMode = canvasRenderMode.ScreenSpaceOverlay;
            }
            Object.defineProperty(canvascontainer.prototype, "canvas", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * UI canvas
                 * @version m4m 1.0
                 */
                get: function () {
                    if (this._overlay2d && this._overlay2d.canvas)
                        return this._overlay2d.canvas;
                },
                enumerable: false,
                configurable: true
            });
            canvascontainer.prototype.setOverLay = function (lay) {
                this._overlay2d = lay;
                this.canvasInit();
            };
            canvascontainer.prototype.getOverLay = function () {
                return this._overlay2d;
            };
            Object.defineProperty(canvascontainer.prototype, "sortOrder", {
                //渲染排序
                get: function () {
                    return this._overlay2d ? this._overlay2d.sortOrder : 0;
                },
                set: function (order) {
                    if (this._overlay2d)
                        this._overlay2d.sortOrder = order;
                },
                enumerable: false,
                configurable: true
            });
            canvascontainer.prototype.canvasInit = function () {
                if (!this.gameObject || !this.gameObject.transform || !this.gameObject.transform.scene)
                    return;
                if (!this._overlay2d || !this._overlay2d.canvas)
                    return;
                this._overlay2d.canvas.scene = this.gameObject.transform.scene;
                this._overlay2d.canvas.assetmgr = this._overlay2d.canvas.scene.app.getAssetMgr();
                this.isCanvasinit = true;
            };
            Object.defineProperty(canvascontainer.prototype, "renderMode", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * renderMode UI render模式
                 * @version m4m 1.0
                 */
                get: function () { return this._renderMode; },
                set: function (mode) {
                    if (this._renderMode == mode)
                        return;
                    this._lastMode = this._renderMode;
                    this._renderMode = mode;
                    this.styleToMode();
                },
                enumerable: false,
                configurable: true
            });
            canvascontainer.prototype.styleToMode = function () {
                switch (this._renderMode) {
                    case canvasRenderMode.ScreenSpaceOverlay:
                        if (!this._overlay2d)
                            return;
                        var scene_2 = this.gameObject.getScene();
                        scene_2.addScreenSpaceOverlay(this._overlay2d);
                        break;
                    case canvasRenderMode.ScreenSpaceOverlay:
                        console.warn("not support now of ".concat(canvasRenderMode[canvasRenderMode.ScreenSpaceOverlay], " mode"));
                        break;
                    case canvasRenderMode.WorldSpace:
                        console.warn("not support now of ".concat(canvasRenderMode[canvasRenderMode.WorldSpace], " mode"));
                        break;
                }
            };
            canvascontainer.prototype.start = function () {
                this.styleToMode();
            };
            canvascontainer.prototype.onPlay = function () {
            };
            canvascontainer.prototype.update = function (delta) {
                if (!this.isCanvasinit)
                    this.canvasInit();
            };
            /**
             * @private
             */
            canvascontainer.prototype.remove = function () {
                if (this.gameObject.getScene())
                    this.gameObject.getScene().removeScreenSpaceOverlay(this._overlay2d);
            };
            /**
             * @private
             */
            canvascontainer.prototype.clone = function () {
            };
            canvascontainer.ClassName = "canvascontainer";
            __decorate([
                m4m.reflect.Field("reference"),
                __metadata("design:type", framework.overlay2D)
            ], canvascontainer.prototype, "_overlay2d", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], canvascontainer.prototype, "renderMode", null);
            canvascontainer = __decorate([
                m4m.reflect.nodeComponent,
                __metadata("design:paramtypes", [])
            ], canvascontainer);
            return canvascontainer;
        }());
        framework.canvascontainer = canvascontainer;
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * UI画布容器RenderMode
         * @version m4m 1.0
         */
        var canvasRenderMode;
        (function (canvasRenderMode) {
            canvasRenderMode[canvasRenderMode["ScreenSpaceOverlay"] = 0] = "ScreenSpaceOverlay";
            canvasRenderMode[canvasRenderMode["ScreenSpaceCamera"] = 1] = "ScreenSpaceCamera";
            canvasRenderMode[canvasRenderMode["WorldSpace"] = 2] = "WorldSpace";
        })(canvasRenderMode = framework.canvasRenderMode || (framework.canvasRenderMode = {}));
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 特效组件
         * @version m4m 1.0
         */
        var effectSystem = /** @class */ (function () {
            // @reflect.selfClone
            function effectSystem() {
                this.layer = framework.RenderLayerEnum.Transparent;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 同层级渲染排序依据
                 * @version m4m 1.0
                 */
                this.queue = 0;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 自动播放
                 * @version m4m 1.0
                 */
                this.autoplay = true;
                /**
                * @private
                */
                this.state = framework.EffectPlayStateEnum.None;
                this.curFrameId = -1;
                this.playTimer = 0;
                this.speed = 1;
                // private time: number = 0;
                this.parser = new m4m.framework.EffectParser();
                /**
                * @private
                */
                this.vf = m4m.render.VertexFormatMask.Position | m4m.render.VertexFormatMask.Normal | m4m.render.VertexFormatMask.Tangent | m4m.render.VertexFormatMask.Color | m4m.render.VertexFormatMask.UV0;
                /**
                * @private
                */
                //public particleVF=m4m.render.VertexFormatMask.Position | render.VertexFormatMask.Color | render.VertexFormatMask.UV0;//法线切线不要
                this.effectBatchers = [];
                this.matDataGroups = [];
                this.particleElementDic = {};
                this.delayElements = [];
                this.refElements = [];
                this.beExecuteNextFrame = true;
            }
            effectSystem_1 = effectSystem;
            Object.defineProperty(effectSystem.prototype, "renderLayer", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 渲染层级
                 * @version m4m 1.0
                 */
                //renderLayer: CullingMask = CullingMask.default;
                get: function () { return this.gameObject.layer; },
                set: function (layer) {
                    this.gameObject.layer = layer;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(effectSystem.prototype, "jsonData", {
                get: function () {
                    return this._textasset;
                },
                set: function (text) {
                    this._textasset = text;
                    //this.setJsonData(this._textasset);
                    this.setJsonDataStr(this.jsonData.content);
                },
                enumerable: false,
                configurable: true
            });
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 设置特效数据 textasset
             * @version m4m 1.0
             */
            effectSystem.prototype.setJsonData = function (_jsonData) {
                this._textasset = _jsonData;
                this.setJsonDataStr(this.jsonData.content);
            };
            effectSystem.prototype.setJsonDataStr = function (_jsonStr) {
                this.webgl = m4m.framework.sceneMgr.app.webgl;
                this.data = this.parser.Parse(_jsonStr, m4m.framework.sceneMgr.app.getAssetMgr());
                //this.init();
            };
            /**
             * 更新特效数据
             * @param _jsonData
             */
            effectSystem.prototype.updateJsonData = function (_jsonData) {
                this.jsonData = _jsonData;
                this.updateJsonDataStr(this.jsonData.content);
            };
            effectSystem.prototype.updateJsonDataStr = function (_jsonStr) {
                this.remove();
                this.data = this.parser.Parse(_jsonStr, m4m.framework.sceneMgr.app.getAssetMgr());
                console.warn("开始解析特效");
                //this.init();
            };
            Object.defineProperty(effectSystem.prototype, "data", {
                /**
                * @private
                */
                get: function () {
                    return this._data;
                },
                /**
                * @private
                */
                set: function (value) {
                    this._data = value;
                },
                enumerable: false,
                configurable: true
            });
            /**
            * @private
            */
            effectSystem.prototype.init = function () {
                if (this._data) {
                    this.addElements();
                }
            };
            Object.defineProperty(effectSystem.prototype, "totalFrameCount", {
                /**
                * @private
                */
                get: function () {
                    return this.data.life * effectSystem_1.fps;
                },
                enumerable: false,
                configurable: true
            });
            effectSystem.prototype.start = function () {
                this.init();
            };
            effectSystem.prototype.onPlay = function () {
            };
            effectSystem.prototype.update = function (delta) {
                if (this.gameObject.getScene() == null || this.gameObject.getScene() == undefined)
                    return;
                if (this.state == framework.EffectPlayStateEnum.Play || this.state == framework.EffectPlayStateEnum.Pause) {
                    if (this.state == framework.EffectPlayStateEnum.Play)
                        this.playTimer += delta * this.speed;
                    if (!this.beLoop) {
                        if (this.playTimer >= this.data.life) {
                            this.stop();
                        }
                    }
                    this._update(delta);
                }
                else if (this.state == framework.EffectPlayStateEnum.BeReady) {
                    if (this.autoplay) {
                        this.play();
                        this._update(delta);
                    }
                    else {
                        this.gameObject.visible = false;
                        this.gameObject.transform.markDirty();
                    }
                }
            };
            /**
             * 更新特效数据
             *
             * @private
             * @param {number} delta
             *
             * @memberof effectSystem
             */
            effectSystem.prototype._update = function (delta) {
                if (this.delayElements.length > 0) {
                    if (this.refElements.length > 0)
                        this.refElements = [];
                    for (var i = this.delayElements.length - 1; i >= 0; i--) {
                        var data = this.delayElements[i];
                        if (data.delayTime <= this.playTimer) {
                            this.addElement(this.delayElements[i]);
                            this.delayElements.splice(i, 1);
                        }
                    }
                }
                if (this.particles != undefined) {
                    this.particles.updateForEmission(delta);
                }
                if (this.checkFrameId()) {
                    for (var i in this.effectBatchers) {
                        var subEffectBatcher = this.effectBatchers[i];
                        for (var key in subEffectBatcher.effectElements) {
                            var element = subEffectBatcher.effectElements[key];
                            if (element.delayTime == undefined || element.delayTime <= this.playTimer) {
                                //没有延时或者延时已经结束
                                subEffectBatcher.mesh.submesh[0].size = element.endEboIndex;
                            }
                            else {
                                if (subEffectBatcher.mesh.submesh[0].size > element.startEboIndex)
                                    subEffectBatcher.mesh.submesh[0].size = element.startEboIndex;
                            }
                            // let frameId = this.curFrameId % element.loopFrame;
                            var frameId = (this.curFrameId - this.getDelayFrameCount(element.delayTime)) % element.loopFrame;
                            frameId = Math.floor(frameId);
                            if (element.active) {
                                element.actionActive = false;
                                this.mergeLerpAttribData(element.curAttrData, element.timelineFrame[frameId]);
                                if (element.actions != undefined) {
                                    element.actionActive = true;
                                    for (var j in element.actions) {
                                        element.actions[j].update(frameId);
                                    }
                                }
                            }
                            element.update();
                            if (element.isCurFrameNeedRefresh(frameId)) {
                                this.updateEffectBatcher(element.effectBatcher, element.curAttrData, element.data.initFrameData, element.startVboIndex);
                            }
                        }
                    }
                    if (this.particles != undefined) {
                        this.particles.update(1 / effectSystem_1.fps);
                    }
                }
            };
            /**
             * 将插值信息合并到当前帧数据
             *
             * @param {EffectAttrsData} realUseCurFrameData
             * @param {EffectFrameData} curFrameData
             * @returns
             *
             * @memberof effectSystem
             */
            effectSystem.prototype.mergeLerpAttribData = function (realUseCurFrameData, curFrameData) {
                if (curFrameData == undefined)
                    return;
                if (realUseCurFrameData == undefined) //这里可能是个bug
                    return;
                for (var key in curFrameData.attrsData) {
                    if (curFrameData.attrsData[key] != undefined && realUseCurFrameData[key] != undefined) {
                        var val = curFrameData.attrsData.getAttribute(key);
                        if (val == null)
                            continue;
                        if (val instanceof m4m.math.vector3 || val instanceof m4m.math.vector2 || typeof (val) === 'number') {
                            if (key != "renderModel")
                                realUseCurFrameData[key] = val;
                        }
                    }
                }
            };
            /**
             * 根据当前帧的数据更新EffectBatcher中的vbo，ebo信息
             *
             * @private
             * @param {EffectBatcher} effectBatcher
             * @param {EffectAttrsData} curAttrsData
             * @param {EffectFrameData} initFrameData
             * @param {number} vertexStartIndex
             * @param {number} delta
             * @returns
             *
             * @memberof effectSystem
             */
            effectSystem.prototype.updateEffectBatcher = function (effectBatcher, curAttrsData, initFrameData, vertexStartIndex) {
                var mesh = curAttrsData.mesh;
                if (mesh == undefined) {
                    mesh = initFrameData.attrsData.mesh;
                }
                if (mesh == undefined)
                    return;
                if (curAttrsData.meshdataVbo == undefined) {
                    curAttrsData.meshdataVbo = mesh.data.genVertexDataArray(this.vf);
                }
                var vertexCount = mesh.data.getVertexCount(); //顶点数量
                var vertexArr = curAttrsData.meshdataVbo;
                var vertexSize = effectBatcher.vertexSize;
                for (var i = 0; i < vertexCount; i++) {
                    { //postion
                        var vertex = m4m.math.pool.new_vector3();
                        vertex.x = vertexArr[i * vertexSize + 0];
                        vertex.y = vertexArr[i * vertexSize + 1];
                        vertex.z = vertexArr[i * vertexSize + 2];
                        m4m.math.matrixTransformVector3(vertex, curAttrsData.matrix, vertex);
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 0] = vertex.x;
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 1] = vertex.y;
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 2] = vertex.z;
                        m4m.math.pool.delete_vector3(vertex);
                    }
                    { //color
                        //处理一下颜色，以防灰度值 > 1
                        var r = vertexArr[i * vertexSize + 9];
                        var g = vertexArr[i * vertexSize + 10];
                        var b = vertexArr[i * vertexSize + 11];
                        var a = vertexArr[i * vertexSize + 12];
                        if (curAttrsData.color != undefined) {
                            r = curAttrsData.color.x;
                            g = curAttrsData.color.y;
                            b = curAttrsData.color.z;
                        }
                        if (curAttrsData.alpha != undefined)
                            a = a * curAttrsData.alpha; //配置的alpha作为整体的百分比使用 源alpha依然是具体顶点的
                        if (curAttrsData.colorRate != undefined) {
                            r *= curAttrsData.colorRate;
                            g *= curAttrsData.colorRate;
                            b *= curAttrsData.colorRate;
                            a *= curAttrsData.colorRate;
                        }
                        r = m4m.math.floatClamp(r, 0, 3);
                        g = m4m.math.floatClamp(g, 0, 3);
                        b = m4m.math.floatClamp(b, 0, 3);
                        a = m4m.math.floatClamp(a, 0, 3);
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * 15 + 9] = r;
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * 15 + 10] = g;
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * 15 + 11] = b;
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * 15 + 12] = a;
                    }
                    {
                        //uv
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 13] = vertexArr[i * vertexSize + 13] * curAttrsData.tilling.x + curAttrsData.uv.x;
                        effectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 14] = vertexArr[i * vertexSize + 14] * curAttrsData.tilling.y + curAttrsData.uv.y;
                    }
                }
            };
            /**
             * 提交各个EffectBatcher中的数据进行渲染
             *
             * @param {renderContext} context
             * @param {assetMgr} assetmgr
             * @param {m4m.framework.camera} camera
             *
             * @memberof effectSystem
             */
            effectSystem.prototype.render = function (context, assetmgr, camera) {
                if (!(camera.CullingMask & (1 << this.renderLayer)))
                    return;
                if (this.state == framework.EffectPlayStateEnum.Play || this.state == framework.EffectPlayStateEnum.Pause) {
                    context.updateModel(this.gameObject.transform);
                    for (var i in this.effectBatchers) {
                        var subEffectBatcher = this.effectBatchers[i];
                        var mesh_2 = subEffectBatcher.mesh;
                        if (subEffectBatcher.state === framework.EffectBatcherState.NotInitedStateType) {
                            mesh_2.glMesh.initBuffer(context.webgl, this.vf, subEffectBatcher.curTotalVertexCount);
                            if (!mesh_2.glMesh.ebo) {
                                mesh_2.glMesh.addIndex(context.webgl, subEffectBatcher.dataForEbo.length);
                                mesh_2.glMesh.initVAO();
                            }
                            else {
                                mesh_2.glMesh.resetEboSize(context.webgl, 0, subEffectBatcher.dataForEbo.length);
                            }
                            // mesh.glMesh.uploadIndexSubData(context.webgl, 0, subEffectBatcher.dataForEbo);
                            mesh_2.glMesh.uploadIndexData(context.webgl, 0, subEffectBatcher.dataForEbo);
                            mesh_2.submesh[0].size = subEffectBatcher.dataForEbo.length;
                            subEffectBatcher.state = framework.EffectBatcherState.InitedStateType;
                        }
                        else if (subEffectBatcher.state === framework.EffectBatcherState.ResizeCapacityStateType) {
                            mesh_2.glMesh.resetEboSize(context.webgl, 0, subEffectBatcher.dataForEbo.length); //动态修正掉mesh中的ebo大小
                            mesh_2.submesh[0].size = subEffectBatcher.dataForEbo.length;
                            //mesh.glMesh.uploadIndexSubData(context.webgl, 0, subEffectBatcher.dataForEbo);
                            mesh_2.glMesh.uploadIndexData(context.webgl, 0, subEffectBatcher.dataForEbo);
                            mesh_2.glMesh.resetVboSize(context.webgl, subEffectBatcher.curTotalVertexCount * subEffectBatcher.vertexSize); //动态修正mesh中的vbo大小
                            subEffectBatcher.state = framework.EffectBatcherState.InitedStateType;
                        }
                        //mesh.glMesh.uploadVertexSubData(context.webgl, subEffectBatcher.dataForVbo);
                        mesh_2.glMesh.uploadVertexData(context.webgl, subEffectBatcher.dataForVbo);
                        if (this.gameObject.getScene().fog) {
                            // context.fog = this.gameObject.getScene().fog;
                            subEffectBatcher.mat.draw(context, mesh_2, mesh_2.submesh[0], "base_fog"); //只有一个submesh
                        }
                        else {
                            subEffectBatcher.mat.draw(context, mesh_2, mesh_2.submesh[0], "base"); //只有一个submesh
                        }
                    }
                    if (this.particles != undefined) {
                        this.particles.render(context, assetmgr, camera);
                    }
                }
            };
            /**
             * @private
             */
            effectSystem.prototype.clone = function () {
                var effect = new effectSystem_1();
                if (this.jsonData)
                    effect.jsonData = this.jsonData;
                if (this.data)
                    effect.data = this.data.clone();
                effect.autoplay = this.autoplay;
                effect.beLoop = this.beLoop;
                return effect;
            };
            /**
             * @public
             * @language zh_CN
             * @param speed 播放速度
             * @classdesc
             * 播放特效
             * @version m4m 1.0
             */
            effectSystem.prototype.play = function (speed) {
                if (speed === void 0) { speed = 1; }
                if (this.state != framework.EffectPlayStateEnum.Pause)
                    this.stop();
                this.speed = speed;
                this.state = framework.EffectPlayStateEnum.Play;
                this.gameObject.visible = true;
                this.gameObject.transform.markDirty();
            };
            /**
             * @public
             * @language zh_CN
             * @param speed 播放速度
             * @classdesc
             * 暂停播放
             * @version m4m 1.0
             */
            effectSystem.prototype.pause = function () {
                this.state = framework.EffectPlayStateEnum.Pause;
            };
            /**
             * @public
             * @language zh_CN
             * @param speed 播放速度
             * @classdesc
             * 停止播放
             * @version m4m 1.0
             */
            effectSystem.prototype.stop = function () {
                this.reset();
                this.state = framework.EffectPlayStateEnum.Stop;
            };
            /**
             * @public
             * @language zh_CN
             * @param speed 播放速度
             * @classdesc
             * 重置到初始状态
             * @version m4m 1.0
             */
            effectSystem.prototype.reset = function (restSinglemesh, resetParticle) {
                if (restSinglemesh === void 0) { restSinglemesh = true; }
                if (resetParticle === void 0) { resetParticle = true; }
                this.state = framework.EffectPlayStateEnum.BeReady;
                this.gameObject.visible = false;
                this.playTimer = 0;
                this.resetSingleMesh();
                this.resetparticle();
            };
            effectSystem.prototype.resetSingleMesh = function () {
                for (var i in this.effectBatchers) {
                    var subEffectBatcher = this.effectBatchers[i];
                    for (var key in subEffectBatcher.effectElements) {
                        var element = subEffectBatcher.effectElements[key];
                        element.setActive(true);
                        if (element.data.initFrameData != undefined) //引用问题还没处理
                            element.curAttrData = element.data.initFrameData.attrsData.copyandinit();
                    }
                }
            };
            effectSystem.prototype.resetparticle = function () {
                if (this.particles != undefined)
                    this.particles.dispose();
                for (var name_3 in this.particleElementDic) {
                    var data = this.data.elementDic[name_3];
                    if (data.delayTime > 0) {
                        this.delayElements.push(data);
                        continue;
                    }
                    if (data.refFrom == undefined) {
                        if (this.particles == undefined) {
                            this.particles = new framework.Particles(this);
                        }
                        this.particles.addEmission(data);
                    }
                    else {
                        this.refElements.push(data);
                    }
                }
            };
            /**
             * 向特效中增加元素
             */
            effectSystem.prototype.addElements = function () {
                for (var name_4 in this.data.elementDic) {
                    var data = this.data.elementDic[name_4];
                    if (data.delayTime > 0) {
                        this.delayElements.push(data);
                        continue;
                    }
                    this.addElement(data);
                }
                this.state = framework.EffectPlayStateEnum.BeReady;
                this.beLoop = this.data.beLoop;
            };
            effectSystem.prototype.addElement = function (data) {
                if (data.type == framework.EffectElementTypeEnum.EmissionType) {
                    if (this.particles == undefined) {
                        this.particles = new framework.Particles(this);
                    }
                    this.particles.addEmission(data);
                    this.particleElementDic[data.name] = data;
                }
                else if (data.type == framework.EffectElementTypeEnum.SingleMeshType) {
                    this.addInitFrame(data);
                }
            };
            /**
            * 根据初始化帧的数据，初始effectbatcher。根据mesh的材质增加或者合并mesh。同材质的就合并。
            */
            effectSystem.prototype.addInitFrame = function (elementData) {
                var element = new framework.EffectElement(elementData);
                element.transform = this.gameObject.transform;
                var _initFrameData = element.data.initFrameData;
                if (_initFrameData == undefined || _initFrameData.attrsData == undefined || _initFrameData.attrsData.mesh == undefined) //初始化帧如果不存在,或者没有设置mesh信息，就不处理这个元素
                    return;
                var index = -1;
                if (_initFrameData.attrsData.mat != null) {
                    for (var i_7 = 0; i_7 < this.matDataGroups.length; i_7++) {
                        if (framework.EffectMatData.beEqual(this.matDataGroups[i_7], _initFrameData.attrsData.mat)) {
                            index = i_7;
                            break;
                        }
                    }
                }
                var vertexStartIndex = 0;
                var vertexCount = _initFrameData.attrsData.mesh.data.getVertexCount(); //顶点数量
                var indexCount = _initFrameData.attrsData.mesh.data.genIndexDataArray;
                var subEffectBatcher = null;
                if (index >= 0) {
                    subEffectBatcher = this.effectBatchers[index];
                    vertexStartIndex = subEffectBatcher.curTotalVertexCount;
                    subEffectBatcher.curTotalVertexCount += vertexCount;
                    if (subEffectBatcher.state == framework.EffectBatcherState.InitedStateType)
                        subEffectBatcher.state = framework.EffectBatcherState.ResizeCapacityStateType;
                }
                else {
                    subEffectBatcher = new framework.EffectBatcher(this.vf);
                    subEffectBatcher.curTotalVertexCount = vertexCount;
                    subEffectBatcher.mesh = new framework.mesh();
                    subEffectBatcher.mesh.data = new m4m.render.meshData();
                    subEffectBatcher.mesh.glMesh = new m4m.render.glMesh();
                    subEffectBatcher.mat = new framework.material();
                    subEffectBatcher.mesh.submesh = [];
                    {
                        var sm = new framework.subMeshInfo();
                        sm.matIndex = 0;
                        sm.start = 0;
                        sm.size = 0;
                        sm.line = false;
                        subEffectBatcher.mesh.submesh.push(sm);
                    }
                    vertexStartIndex = 0;
                    index = 0;
                    if (_initFrameData.attrsData.mat.shader == null) {
                        subEffectBatcher.mat.setShader(framework.sceneMgr.app.getAssetMgr().getShader("diffuse.shader.json"));
                        console.error("特效{0}shader为空", elementData.name);
                    }
                    else {
                        subEffectBatcher.mat.setShader(_initFrameData.attrsData.mat.shader);
                    }
                    if (_initFrameData.attrsData.mat.alphaCut != undefined)
                        subEffectBatcher.mat.setFloat("_AlphaCut", _initFrameData.attrsData.mat.alphaCut);
                    if (_initFrameData.attrsData.mat.diffuseTexture != null)
                        subEffectBatcher.mat.setTexture("_MainTex", _initFrameData.attrsData.mat.diffuseTexture);
                    if (_initFrameData.attrsData.mat.alphaTexture != null)
                        subEffectBatcher.mat.setTexture("_AlphaTex", _initFrameData.attrsData.mat.alphaTexture);
                    this.effectBatchers.push(subEffectBatcher);
                    this.matDataGroups.push(_initFrameData.attrsData.mat);
                }
                element.effectBatcher = subEffectBatcher;
                element.startVboIndex = vertexStartIndex;
                // element.endEboIndex = ;vertexStartIndex + vertexCount;
                element.curAttrData = elementData.initFrameData.attrsData.copyandinit();
                var vertexSize = subEffectBatcher.vertexSize;
                var vertexArr = _initFrameData.attrsData.mesh.data.genVertexDataArray(this.vf);
                // if (_initFrameData.attrsData.startEuler)
                //  {
                //     _initFrameData.attrsData.startRotation = new m4m.math.quaternion();
                //     m4m.math.quatFromEulerAngles(_initFrameData.attrsData.startEuler.x, _initFrameData.attrsData.startEuler.y, _initFrameData.attrsData.startEuler.z, _initFrameData.attrsData.startRotation);
                // }
                element.update();
                subEffectBatcher.effectElements.push(element);
                for (var i_8 = 0; i_8 < vertexCount; i_8++) {
                    { //postion
                        var vertex = m4m.math.pool.new_vector3();
                        vertex.x = vertexArr[i_8 * vertexSize + 0];
                        vertex.y = vertexArr[i_8 * vertexSize + 1];
                        vertex.z = vertexArr[i_8 * vertexSize + 2];
                        m4m.math.matrixTransformVector3(vertex, element.curAttrData.matrix, vertex);
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_8) * vertexSize + 0] = vertex.x;
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_8) * vertexSize + 1] = vertex.y;
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_8) * vertexSize + 2] = vertex.z;
                        m4m.math.pool.delete_vector3(vertex);
                    }
                    { //normal
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_8) * vertexSize + 3] = vertexArr[i_8 * vertexSize + 3];
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_8) * vertexSize + 4] = vertexArr[i_8 * vertexSize + 4];
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_8) * vertexSize + 5] = vertexArr[i_8 * vertexSize + 5];
                    }
                    { //tangent
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_8) * vertexSize + 6] = vertexArr[i_8 * vertexSize + 6];
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_8) * vertexSize + 7] = vertexArr[i_8 * vertexSize + 7];
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_8) * vertexSize + 8] = vertexArr[i_8 * vertexSize + 8];
                    }
                    { //color
                        //处理一下颜色，以防灰度值 > 1\
                        var r = m4m.math.floatClamp(element.curAttrData.color.x, 0, 1);
                        var g = m4m.math.floatClamp(element.curAttrData.color.y, 0, 1);
                        var b = m4m.math.floatClamp(element.curAttrData.color.z, 0, 1);
                        var a = m4m.math.floatClamp(vertexArr[i_8 * vertexSize + 12] * element.curAttrData.alpha, 0, 1);
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_8) * 15 + 9] = r;
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_8) * 15 + 10] = g;
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_8) * 15 + 11] = b;
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_8) * 15 + 12] = a;
                    }
                    { //uv
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_8) * vertexSize + 13] = vertexArr[i_8 * vertexSize + 13] * element.curAttrData.tilling.x;
                        subEffectBatcher.dataForVbo[(vertexStartIndex + i_8) * vertexSize + 14] = vertexArr[i_8 * vertexSize + 14] * element.curAttrData.tilling.y;
                        //  this.dataForVbo[(this._vercount + i) * total + 13] = vertexArr[i * total + 13] * materialData.tiling.x + materialData.offset.x;
                        // this.dataForVbo[(this._vercount + i) * total + 14] = vertexArr[i * total + 14] * materialData.tiling.y + materialData.offset.y;
                    }
                }
                //index
                var indexArray = _initFrameData.attrsData.mesh.data.genIndexDataArray();
                var _startIndex = subEffectBatcher.indexStartIndex;
                element.startEboIndex = _startIndex;
                subEffectBatcher.indexStartIndex += indexArray.length;
                element.endEboIndex = subEffectBatcher.indexStartIndex;
                for (var i = 0; i < indexArray.length; i++) {
                    subEffectBatcher.dataForEbo[_startIndex + i] = indexArray[i] + vertexStartIndex;
                }
            };
            /**
            * @private
            */
            effectSystem.prototype.setFrameId = function (id) {
                if (this.state == framework.EffectPlayStateEnum.Pause && id >= 0 && id < this.totalFrameCount)
                    this.curFrameId = id;
            };
            /**
            * @private
            */
            effectSystem.prototype.getDelayFrameCount = function (delayTime) {
                return delayTime * effectSystem_1.fps;
            };
            /**
             * 计算当前的frameid
             *
             * @private
             *
             * @memberof effectSystem
             */
            effectSystem.prototype.checkFrameId = function () {
                // if(this.state == EffectPlayStateEnum.Pause)
                //     return true;
                var curid = (effectSystem_1.fps * this.playTimer) | 0;
                if (curid != this.curFrameId) {
                    if (this.state == framework.EffectPlayStateEnum.Play)
                        this.curFrameId = curid;
                    this.beExecuteNextFrame = true;
                    return true;
                }
                return false;
            };
            /**
            * @private
            */
            effectSystem.prototype.remove = function () {
                this.state = framework.EffectPlayStateEnum.Dispose;
                if (this.data)
                    this.data.dispose();
                while (this.effectBatchers.length > 0) {
                    this.effectBatchers[0].dispose();
                    this.effectBatchers.splice(0, 1);
                }
                while (this.matDataGroups.length > 0) {
                    this.matDataGroups.splice(0, 1);
                }
                if (this.particles)
                    this.particles.dispose();
                this.curFrameId = -1;
                this.playTimer = 0;
            };
            Object.defineProperty(effectSystem.prototype, "leftLifeTime", {
                /**
                * @private
                * 临时测试时显示使用
                * @readonly
                * @type {number}
                * @memberof effectSystem
                */
                get: function () {
                    if (this.data != null) {
                        return this.data.life - this.playTimer;
                    }
                    else
                        return 9999999999;
                },
                enumerable: false,
                configurable: true
            });
            var effectSystem_1;
            effectSystem.ClassName = "effectSystem";
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 特效播放速度
             * @version m4m 1.0
             */
            effectSystem.fps = 30;
            __decorate([
                m4m.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], effectSystem.prototype, "autoplay", void 0);
            __decorate([
                m4m.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], effectSystem.prototype, "beLoop", void 0);
            __decorate([
                m4m.reflect.Field("textasset"),
                __metadata("design:type", framework.textasset),
                __metadata("design:paramtypes", [framework.textasset])
            ], effectSystem.prototype, "jsonData", null);
            effectSystem = effectSystem_1 = __decorate([
                m4m.reflect.nodeRender,
                m4m.reflect.nodeComponent
                // @reflect.selfClone
            ], effectSystem);
            return effectSystem;
        }());
        framework.effectSystem = effectSystem;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
// namespace m4m.framework
// {
//     /**
//      * @public
//      * @language zh_CN
//      * @classdesc
//      * 特效组件
//      * @version m4m 1.0
//      */
//     @reflect.nodeRender
//     @reflect.nodeComponent
//     @reflect.selfClone
//     export class effectSystemNew implements IRenderer
//     {
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 挂载的gameobject
//          * @version m4m 1.0
//          */
//         gameObject: gameObject;
//         layer: RenderLayerEnum = RenderLayerEnum.Transparent;
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 渲染层级
//          * @version m4m 1.0
//          */
//         renderLayer: CullingMask = CullingMask.default;
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 同层级渲染排序依据
//          * @version m4m 1.0
//          */
//         queue: number = 0;
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 自动播放
//          * @version m4m 1.0
//          */
//         @m4m.reflect.Field("boolean")
//         autoplay: boolean = true;
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 特效是否循环
//          * @version m4m 1.0
//          */
//         @m4m.reflect.Field("boolean")
//         beLoop: boolean;
//         /**
//         * @private
//         */
//         state: EffectPlayStateEnum = EffectPlayStateEnum.None;
//         private curFrameId: number = -1;
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 特效播放速度
//          * @version m4m 1.0
//          */
//         public static fps: number = 30;
//         private playTimer: number = 0;
//         private speed: number = 1;
//         /**
//         * @private
//         */
//         public webgl: WebGL2RenderingContext;
//         // private time: number = 0;
//         private parser = new m4m.framework.EffectParser();
//         /**
//         * @private
//         */
//         public vf = m4m.render.VertexFormatMask.Position | render.VertexFormatMask.Normal | render.VertexFormatMask.Tangent | render.VertexFormatMask.Color | render.VertexFormatMask.UV0;
//         /**
//         * @private
//         */
//         //public particleVF=m4m.render.VertexFormatMask.Position | render.VertexFormatMask.Color | render.VertexFormatMask.UV0;//法线切线不要
//         private effectBatchers: EffectBatcherNew[] = [];
//         private matDataGroups: EffectMatData[] = [];
//         private particles: Particles;//粒子系统 发射器统一管理
//         private particleElementDic: { [name: string]: EffectElementData } = {};
//         /**
//         * @private
//         */
//         @m4m.reflect.Field("textasset")
//         jsonData: textasset;
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 设置特效数据 textasset
//          * @version m4m 1.0
//          */
//         setJsonData(_jsonData: textasset)
//         {
//             this.webgl = m4m.framework.sceneMgr.app.webgl;
//             this.jsonData = _jsonData;
//             this.data = this.parser.Parse(this.jsonData.content, m4m.framework.sceneMgr.app.getAssetMgr());
//         }
//         /**
//         * @private
//         */
//         set data(value: EffectSystemData)
//         {
//             this._data = value;
//         }
//         /**
//         * @private
//         */
//         get data(): EffectSystemData
//         {
//             return this._data;
//         }
//         /**
//         * @private
//         */
//         init()
//         {
//         }
//         private _data: EffectSystemData;
//         /**
//         * @private
//         */
//         get totalFrameCount(): number
//         {
//             return this.data.life * effectSystem.fps;
//         }
//         start()
//         {
//             this.init();
//         }
//         update(delta: number)
//         {
//             if (this.gameObject.getScene() == null || this.gameObject.getScene() == undefined)
//                 return;
//             if (this.state == EffectPlayStateEnum.Play || this.state == EffectPlayStateEnum.Pause)
//             {
//                 if (this.state == EffectPlayStateEnum.Play)
//                     this.playTimer += delta * this.speed;
//                 if (!this.beLoop)
//                 {
//                     if (this.playTimer >= this.data.life)
//                     {
//                         this.stop();
//                     }
//                 }
//                 this._update(delta);
//             }
//             else if (this.state == EffectPlayStateEnum.BeReady)
//             {
//                 if (this.autoplay)
//                 {
//                     this.play();
//                     this._update(delta);
//                 }
//                 else
//                 {
//                     this.gameObject.visible = false;
//                     this.gameObject.transform.markDirty();
//                 }
//             }
//         }
//         /**
//          * 更新特效数据
//          * 
//          * @private
//          * @param {number} delta 
//          * 
//          * @memberof effectSystem
//          */
//         private _update(delta: number)
//         {
//             // if (this.delayElements.length > 0)
//             // {
//             //     if (this.refElements.length > 0)
//             //         this.refElements = [];
//             //     for (let i = this.delayElements.length - 1; i >= 0; i--)
//             //     {
//             //         let data = this.delayElements[i];
//             //         if (data.delayTime <= this.playTimer)
//             //         {
//             //             this.addElement(this.delayElements[i]);
//             //             this.delayElements.splice(i, 1);
//             //         }
//             //     }
//             // }
//             if (this.checkFrameId())
//             {
//                 for (let i in this.effectBatchers)
//                 {
//                     let subEffectBatcher = this.effectBatchers[i];
//                     for (let key in subEffectBatcher.effectElements)
//                     {
//                         let element = subEffectBatcher.effectElements[key];
//                         if (element.delayTime == undefined || element.delayTime <= this.playTimer)
//                         {
//                             //没有延时或者延时已经结束
//                             subEffectBatcher.mesh.submesh[0].size = element.endEboIndex;
//                         } else
//                         {
//                             if (subEffectBatcher.mesh.submesh[0].size > element.startEboIndex)
//                                 subEffectBatcher.mesh.submesh[0].size = element.startEboIndex;
//                         }
//                         // let frameId = this.curFrameId % element.loopFrame;
//                         let frameId = (this.curFrameId - this.getDelayFrameCount(element.delayTime)) % element.loopFrame;
//                         if (element.active)
//                         {
//                             element.actionActive = false;
//                             this.mergeLerpAttribData(element.curAttrData, element, frameId);
//                             if (element.actions != undefined)
//                             {
//                                 element.actionActive = true;
//                                 for (let j in element.actions)
//                                 {
//                                     element.actions[j].update(frameId);
//                                 }
//                             }
//                         }
//                         element.update();
//                         if (element.isCurFrameNeedRefresh(frameId))
//                         {
//                             this.updateEffectBatcher(element.effectBatcher, element.curAttrData, element.mesh, element.startVboIndex);
//                         }
//                     }
//                 }
//                 // if (this.particles != undefined)
//                 // {
//                 //     this.particles.update(1 / effectSystem.fps);
//                 // }
//             }
//         }
//         /**
//          * 将插值信息合并到当前帧数据
//          * 
//          * @param {EffectAttrsData} realUseCurFrameData 
//          * @param {EffectFrameData} curFrameData 
//          * @returns 
//          * 
//          * @memberof effectSystem
//          */
//         private mergeLerpAttribData(realUseCurFrameData: EffectAttrsData, effect: EffectElementSingleMesh, frameId: number)
//         {
//             let timeLinePos = effect.timelineFrames[AttributeType.PositionType];
//             if (timeLinePos[frameId] != undefined)
//                 realUseCurFrameData.pos = timeLinePos[frameId];
//             let timeLineEuler = effect.timelineFrames[AttributeType.EulerType];
//             if (timeLineEuler[frameId] != undefined)
//                 realUseCurFrameData.euler = timeLineEuler[frameId];
//             let timeLineScale = effect.timelineFrames[AttributeType.ScaleType];
//             if (timeLineScale[frameId] != undefined)
//                 realUseCurFrameData.scale = timeLineScale[frameId];
//             let timeLineColor = effect.timelineFrames[AttributeType.ColorType];
//             if (timeLineColor[frameId] != undefined)
//                 realUseCurFrameData.color = timeLineColor[frameId];
//             let timeLineAlpha = effect.timelineFrames[AttributeType.AlphaType];
//             if (timeLineAlpha[frameId] != undefined)
//                 realUseCurFrameData.alpha = timeLineAlpha[frameId];
//             let timeLineTilling = effect.timelineFrames[AttributeType.TillingType];
//             if (timeLineTilling[frameId] != undefined)
//                 realUseCurFrameData.tilling = timeLineTilling[frameId];
//         }
//         /**
//          * 根据当前帧的数据更新EffectBatcher中的vbo，ebo信息
//          * 
//          * @private
//          * @param {EffectBatcher} effectBatcher 
//          * @param {EffectAttrsData} curAttrsData 
//          * @param {EffectFrameData} initFrameData 
//          * @param {number} vertexStartIndex 
//          * @param {number} delta 
//          * @returns 
//          * 
//          * @memberof effectSystem
//          */
//         private updateEffectBatcher(effectBatcher: EffectBatcherNew, curAttrsData: EffectAttrsData, mesh: m4m.framework.mesh, vertexStartIndex: number)
//         {
//             // let mesh = curAttrsData.mesh;
//             // if (mesh == undefined)
//             // {
//             //     mesh = initFrameData.attrsData.mesh;
//             // }
//             if (mesh == undefined)
//                 return;
//             if (curAttrsData.meshdataVbo == undefined)
//             {
//                 curAttrsData.meshdataVbo = mesh.data.genVertexDataArray(this.vf);
//             }
//             let vertexCount = mesh.data.pos.length;//顶点数量
//             let vertexArr = curAttrsData.meshdataVbo;
//             let vertexSize = effectBatcher.vertexSize;
//             for (let i = 0; i < vertexCount; i++)
//             {
//                 {//postion
//                     let vertex = m4m.math.pool.new_vector3();
//                     vertex.x = vertexArr[i * vertexSize + 0];
//                     vertex.y = vertexArr[i * vertexSize + 1];
//                     vertex.z = vertexArr[i * vertexSize + 2];
//                     m4m.math.matrixTransformVector3(vertex, curAttrsData.matrix, vertex);
//                     effectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 0] = vertex.x;
//                     effectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 1] = vertex.y;
//                     effectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 2] = vertex.z;
//                     m4m.math.pool.delete_vector3(vertex);
//                 }
//                 {//color
//                     //处理一下颜色，以防灰度值 > 1
//                     let r = vertexArr[i * vertexSize + 9];
//                     let g = vertexArr[i * vertexSize + 10];
//                     let b = vertexArr[i * vertexSize + 11];
//                     let a = vertexArr[i * vertexSize + 12];
//                     if (curAttrsData.color != undefined)
//                     {
//                         r = curAttrsData.color.x;
//                         g = curAttrsData.color.y;
//                         b = curAttrsData.color.z;
//                     }
//                     if (curAttrsData.alpha != undefined)
//                         a = a * curAttrsData.alpha;//配置的alpha作为整体的百分比使用 源alpha依然是具体顶点的
//                     if (curAttrsData.colorRate != undefined)
//                     {
//                         r *= curAttrsData.colorRate;
//                         g *= curAttrsData.colorRate;
//                         b *= curAttrsData.colorRate;
//                         a *= curAttrsData.colorRate;
//                     }
//                     r = math.floatClamp(r, 0, 3);
//                     g = math.floatClamp(g, 0, 3);
//                     b = math.floatClamp(b, 0, 3);
//                     a = math.floatClamp(a, 0, 3);
//                     effectBatcher.dataForVbo[(vertexStartIndex + i) * 15 + 9] = r;
//                     effectBatcher.dataForVbo[(vertexStartIndex + i) * 15 + 10] = g;
//                     effectBatcher.dataForVbo[(vertexStartIndex + i) * 15 + 11] = b;
//                     effectBatcher.dataForVbo[(vertexStartIndex + i) * 15 + 12] = a;
//                 }
//                 {
//                     //uv
//                     effectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 13] = vertexArr[i * vertexSize + 13] * curAttrsData.tilling.x + curAttrsData.uv.x;
//                     effectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 14] = vertexArr[i * vertexSize + 14] * curAttrsData.tilling.y + curAttrsData.uv.y;
//                 }
//             }
//         }
//         /**
//          * 提交各个EffectBatcher中的数据进行渲染
//          * 
//          * @param {renderContext} context 
//          * @param {assetMgr} assetmgr 
//          * @param {m4m.framework.camera} camera 
//          * 
//          * @memberof effectSystem
//          */
//         render(context: renderContext, assetmgr: assetMgr, camera: m4m.framework.camera)
//         {
//             if (!(camera.CullingMask & this.renderLayer)) return;
//             if (this.state == EffectPlayStateEnum.Play)
//             {
//                 context.updateModel(this.gameObject.transform);
//                 for (let i in this.effectBatchers)
//                 {
//                     let subEffectBatcher = this.effectBatchers[i];
//                     let mesh = subEffectBatcher.mesh;
//                     if (subEffectBatcher.state === EffectBatcherState.NotInitedStateType)
//                     {
//                         mesh.glMesh.initBuffer(context.webgl, this.vf, subEffectBatcher.curTotalVertexCount);
//                         if (mesh.glMesh.ebos.length == 0)
//                         {
//                             mesh.glMesh.addIndex(context.webgl, subEffectBatcher.dataForEbo.length);
//                         }
//                         else
//                         {
//                             mesh.glMesh.resetEboSize(context.webgl, 0, subEffectBatcher.dataForEbo.length);
//                         }
//                         mesh.glMesh.uploadIndexSubData(context.webgl, 0, subEffectBatcher.dataForEbo);
//                         mesh.submesh[0].size = subEffectBatcher.dataForEbo.length;
//                         subEffectBatcher.state = EffectBatcherState.InitedStateType;
//                     }
//                     else if (subEffectBatcher.state === EffectBatcherState.ResizeCapacityStateType)
//                     {
//                         mesh.glMesh.resetEboSize(context.webgl, 0, subEffectBatcher.dataForEbo.length);//动态修正掉mesh中的ebo大小
//                         mesh.submesh[0].size = subEffectBatcher.dataForEbo.length;
//                         mesh.glMesh.uploadIndexSubData(context.webgl, 0, subEffectBatcher.dataForEbo);
//                         mesh.glMesh.resetVboSize(context.webgl, subEffectBatcher.curTotalVertexCount * subEffectBatcher.vertexSize);//动态修正mesh中的vbo大小
//                         subEffectBatcher.state = EffectBatcherState.InitedStateType;
//                     }
//                     mesh.glMesh.uploadVertexSubData(context.webgl, subEffectBatcher.dataForVbo);
//                     if (this.gameObject.getScene().fog)
//                     {
//                         context.fog = this.gameObject.getScene().fog;
//                         subEffectBatcher.mat.draw(context, mesh, mesh.submesh[0], "base_fog");//只有一个submesh
//                     } else
//                     {
//                         subEffectBatcher.mat.draw(context, mesh, mesh.submesh[0], "base");//只有一个submesh
//                     }
//                 }
//                 if (this.particles != undefined)
//                 {
//                     this.particles.render(context, assetmgr, camera);
//                 }
//             }
//         }
//         /**
//          * @private
//          */
//         clone()
//         {
//             let effect = new effectSystem();
//             effect.data = this.data.clone();
//             return effect;
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * @param speed 播放速度
//          * @classdesc
//          * 播放特效
//          * @version m4m 1.0
//          */
//         play(speed: number = 1)
//         {
//             this.speed = speed;
//             this.state = EffectPlayStateEnum.Play;
//             this.gameObject.visible = true;
//             this.gameObject.transform.markDirty();
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * @param speed 播放速度
//          * @classdesc
//          * 暂停播放
//          * @version m4m 1.0
//          */
//         pause()
//         {
//             this.state = EffectPlayStateEnum.Pause;
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * @param speed 播放速度
//          * @classdesc
//          * 停止播放
//          * @version m4m 1.0
//          */
//         stop()
//         {
//             this.reset();
//             this.state = EffectPlayStateEnum.Stop;
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * @param speed 播放速度
//          * @classdesc
//          * 重置到初始状态
//          * @version m4m 1.0
//          */
//         reset(restSinglemesh: boolean = true, resetParticle: boolean = true)
//         {
//             this.state = EffectPlayStateEnum.BeReady;
//             this.gameObject.visible = false;
//             this.playTimer = 0;
//             this.resetSingleMesh();
//             // this.resetparticle();
//         }
//         private resetSingleMesh()
//         {
//             // for (let i in this.effectBatchers)
//             // {
//             //     let subEffectBatcher = this.effectBatchers[i];
//             //     for (let key in subEffectBatcher.effectElements)
//             //     {
//             //         let element = subEffectBatcher.effectElements[key];
//             //         element.setActive(true);
//             //         if (element.data.initFrameData != undefined)//引用问题还没处理
//             //             element.curAttrData = element.data.initFrameData.attrsData.copyandinit();
//             //     }
//             // }
//         }
//         private delayElements: EffectElementData[] = [];
//         private refElements: EffectElementData[] = [];
//         /**
//         * @private
//         */
//         public setFrameId(id: number)
//         {
//             if (this.state == EffectPlayStateEnum.Pause && id >= 0 && id < this.totalFrameCount)
//                 this.curFrameId = id;
//         }
//         /**
//         * @private
//         */
//         public getDelayFrameCount(delayTime: number)
//         {
//             return delayTime * effectSystem.fps;
//         }
//         private beExecuteNextFrame: boolean = true;
//         /**
//          * 计算当前的frameid
//          * 
//          * @private
//          * 
//          * @memberof effectSystem
//          */
//         private checkFrameId(): boolean
//         {
//             // if(this.state == EffectPlayStateEnum.Pause)
//             //     return true;
//             let curid = (effectSystem.fps * this.playTimer) | 0;
//             if (curid != this.curFrameId)
//             {
//                 if (this.state == EffectPlayStateEnum.Play)
//                     this.curFrameId = curid;
//                 this.beExecuteNextFrame = true;
//                 return true;
//             }
//             return false;
//         }
//         /**
//         * @private
//         */
//         remove()
//         {
//             this.state = EffectPlayStateEnum.Dispose;
//             if (this.data)
//                 this.data.dispose();
//             for (let key in this.effectBatchers)
//             {
//                 this.effectBatchers[key].dispose();
//             }
//             if (this.particles)
//                 this.particles.dispose();
//         }
//         /**
//         * @private
//         * 临时测试时显示使用
//         * @readonly
//         * @type {number}
//         * @memberof effectSystem
//         */
//         public get leftLifeTime(): number
//         {
//             if (this.data != null)
//             {
//                 return this.data.life - this.playTimer;
//             } else
//                 return 9999999999;
//         }
//         /**
//          * /////////////////////////////////////////////////////代码重构///////////////////////////////////////////////////////
//          */
//         @m4m.reflect.Field("IEffectElement[]")
//         public effectElements: IEffectElement[];
//         public addEffectElement(type: m4m.framework.EffectElementTypeEnum): IEffectElement
//         {
//             if (this.effectElements == undefined)
//                 this.effectElements = [];
//             let effe: IEffectElement;
//             if (type == m4m.framework.EffectElementTypeEnum.SingleMeshType)
//             {
//                 effe = new m4m.framework.EffectElementSingleMesh(this.gameObject.getScene().app.getAssetMgr(), this);
//                 effe.name = "singlemesh" + this.effectElements.length;
//                 let singleMeshElement = effe as m4m.framework.EffectElementSingleMesh;
//                 singleMeshElement.transform = this.gameObject.transform;
//                 this.addInitFrameNew(singleMeshElement);
//                 this.state = EffectPlayStateEnum.BeReady;
//                 // this.beLoop = this.data.beLoop;
//             }
//             else if (type == m4m.framework.EffectElementTypeEnum.EmissionType)
//             {
//                 //effe = new m4m.framework.EffectElementEmission();
//                 effe.name = "emission" + this.effectElements.length;
//             }
//             this.effectElements.push(effe);
//             return effe;
//         }
//         private addInitFrameNew(effect: EffectElementSingleMesh)
//         {
//             if (effect == undefined || effect.mesh == undefined || effect.mat == undefined)//初始化帧如果不存在,或者没有设置mesh信息，就不处理这个元素
//                 return;
//             // let index = -1;
//             // for (let i = 0; i < this.matDataGroups.length; i++)
//             // {
//             //     if (EffectMatData.beEqual(this.matDataGroups[i], effect.mat))
//             //     {
//             //         index = i;
//             //         break;
//             //     }
//             // }
//             let vertexStartIndex = 0;
//             let vertexCount = effect.mesh.data.pos.length;//顶点数量
//             let indexCount = effect.mesh.data.genIndexDataArray();
//             // let subEffectBatcher: EffectBatcher = null;
//             // if (index >= 0)
//             // {
//             //     subEffectBatcher = this.effectBatchers[index];
//             //     vertexStartIndex = subEffectBatcher.curTotalVertexCount;
//             //     subEffectBatcher.curTotalVertexCount += vertexCount;
//             //     if (subEffectBatcher.state == EffectBatcherState.InitedStateType)
//             //         subEffectBatcher.state = EffectBatcherState.ResizeCapacityStateType;
//             // } else
//             // {
//             let subEffectBatcher = new EffectBatcherNew(this.vf);
//             subEffectBatcher.curTotalVertexCount = vertexCount;
//             subEffectBatcher.mesh = new mesh();
//             subEffectBatcher.mesh.data = new render.meshData();
//             subEffectBatcher.mesh.glMesh = new render.glMesh();
//             subEffectBatcher.mat = new material();
//             subEffectBatcher.mesh.submesh = [];
//             {
//                 var sm = new subMeshInfo();
//                 sm.matIndex = 0;
//                 sm.start = 0;
//                 sm.size = 0;
//                 sm.line = false;
//                 subEffectBatcher.mesh.submesh.push(sm);
//             }
//             vertexStartIndex = 0;
//             // index = 0;
//             this.effectBatchers.push(subEffectBatcher);
//             // this.matDataGroups.push(_initFrameData.attrsData.mat);
//             // }
//             effect.effectBatcher = subEffectBatcher;
//             effect.startVboIndex = vertexStartIndex;
//             // element.endEboIndex = ;vertexStartIndex + vertexCount;
//             // element.curAttrData = elementData.initFrameData.attrsData.copyandinit();
//             let vertexSize = subEffectBatcher.vertexSize;
//             let vertexArr = effect.mesh.data.genVertexDataArray(this.vf);
//             effect.curAttrData = effect.copyandinit();
//             effect.update();
//             subEffectBatcher.effectElements.push(effect);
//             for (let i = 0; i < vertexCount; i++)
//             {
//                 {//postion
//                     let vertex = m4m.math.pool.new_vector3();
//                     vertex.x = vertexArr[i * vertexSize + 0];
//                     vertex.y = vertexArr[i * vertexSize + 1];
//                     vertex.z = vertexArr[i * vertexSize + 2];
//                     m4m.math.matrixTransformVector3(vertex, effect.curAttrData.matrix, vertex);
//                     subEffectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 0] = vertex.x;
//                     subEffectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 1] = vertex.y;
//                     subEffectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 2] = vertex.z;
//                     m4m.math.pool.delete_vector3(vertex);
//                 }
//                 {//normal
//                     subEffectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 3] = vertexArr[i * vertexSize + 3];
//                     subEffectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 4] = vertexArr[i * vertexSize + 4];
//                     subEffectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 5] = vertexArr[i * vertexSize + 5];
//                 }
//                 {//tangent
//                     subEffectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 6] = vertexArr[i * vertexSize + 6];
//                     subEffectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 7] = vertexArr[i * vertexSize + 7];
//                     subEffectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 8] = vertexArr[i * vertexSize + 8];
//                 }
//                 {//color
//                     //处理一下颜色，以防灰度值 > 1\
//                     let color = effect.getFrameVal(AttributeType.ColorType, 0) as m4m.math.vector3;
//                     let r = math.floatClamp(color.x, 0, 1);
//                     let g = math.floatClamp(color.y, 0, 1);
//                     let b = math.floatClamp(color.z, 0, 1);
//                     let alpha = <number>effect.getFrameVal(AttributeType.AlphaType, 0);
//                     let a = math.floatClamp(vertexArr[i * vertexSize + 12] * alpha, 0, 1);
//                     subEffectBatcher.dataForVbo[(vertexStartIndex + i) * 15 + 9] = r;
//                     subEffectBatcher.dataForVbo[(vertexStartIndex + i) * 15 + 10] = g;
//                     subEffectBatcher.dataForVbo[(vertexStartIndex + i) * 15 + 11] = b;
//                     subEffectBatcher.dataForVbo[(vertexStartIndex + i) * 15 + 12] = a;
//                 }
//                 {//uv
//                     let tilling = effect.getFrameVal(AttributeType.TillingType, 0);
//                     subEffectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 13] = vertexArr[i * vertexSize + 13] * tilling.x;
//                     subEffectBatcher.dataForVbo[(vertexStartIndex + i) * vertexSize + 14] = vertexArr[i * vertexSize + 14] * tilling.y;
//                     //  this.dataForVbo[(this._vercount + i) * total + 13] = vertexArr[i * total + 13] * materialData.tiling.x + materialData.offset.x;
//                     // this.dataForVbo[(this._vercount + i) * total + 14] = vertexArr[i * total + 14] * materialData.tiling.y + materialData.offset.y;
//                 }
//             }
//             //index
//             var indexArray = effect.mesh.data.genIndexDataArray();
//             let _startIndex = subEffectBatcher.indexStartIndex;
//             effect.startEboIndex = _startIndex;
//             subEffectBatcher.indexStartIndex += indexArray.length;
//             effect.endEboIndex = subEffectBatcher.indexStartIndex;
//             for (var i = 0; i < indexArray.length; i++)
//             {
//                 subEffectBatcher.dataForEbo[_startIndex + i] = indexArray[i] + vertexStartIndex;
//             }
//         }
//     }
//     /**
//     * @private
//     */
//     export class EffectBatcherNew
//     {
//         public mesh: mesh;
//         public mat: material;
//         public state: EffectBatcherState = EffectBatcherState.NotInitedStateType;
//         public dataForVbo: Float32Array;
//         public dataForEbo: Uint16Array;
//         public effectElements: EffectElementSingleMesh[] = [];
//         /**
//          * 当前总的顶点数量
//          * 
//          * @private
//          * @type {number}
//          * @memberof effect
//          */
//         private _totalVertexCount: number = 0;
//         public get curTotalVertexCount(): number
//         {
//             return this._totalVertexCount;
//         }
//         public set curTotalVertexCount(val: number)
//         {
//             this._totalVertexCount = val;
//             this.resizeVboSize(this._totalVertexCount * this.vertexSize);
//         }
//         private _indexStartIndex = 0;
//         public get indexStartIndex()
//         {
//             return this._indexStartIndex;
//         }
//         public set indexStartIndex(value: number)
//         {
//             this._indexStartIndex = value;
//             if (this.dataForEbo != null)
//             {
//                 let ebo = new Uint16Array(this._indexStartIndex);
//                 ebo.set(this.dataForEbo, 0);
//                 this.dataForEbo = ebo;
//             } else
//             {
//                 this.dataForEbo = new Uint16Array(this._indexStartIndex);
//             }
//         }
//         private _vbosize: number = 0;
//         /**
//          * 动态设定vbo大小
//          * 
//          * @param {number} value 
//          * @returns 
//          * 
//          * @memberof effect
//          */
//         public resizeVboSize(value: number)
//         {
//             if (this._vbosize > value) return;
//             this._vbosize = value;
//             if (this.dataForVbo != null)
//             {
//                 let vbo = new Float32Array(this._vbosize);
//                 vbo.set(this.dataForVbo, 0);
//                 this.dataForVbo = vbo;
//             } else
//             {
//                 this.dataForVbo = new Float32Array(this._vbosize);
//             }
//         }
//         public dispose()
//         {
//             this.mesh.dispose();
//             this.mat.dispose();
//             this.dataForVbo = null;
//             this.dataForEbo = null;
//             for (let key in this.effectElements)
//             {
//                 this.effectElements[key].dispose();
//             }
//         }
//         /**
//          * 顶点大小
//          * @public
//          * @type {number}
//          * @memberof effect
//          */
//         public vertexSize: number = 0;
//         constructor(formate: number)
//         {
//             this.vertexSize = m4m.render.meshData.calcByteSize(formate) / 4;
//         }
//     }
// }
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 特效组件
         * @version m4m 1.0
         */
        var TestEffectSystem = /** @class */ (function () {
            function TestEffectSystem() {
                this.layer = framework.RenderLayerEnum.Transparent;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 同层级渲染排序依据
                 * @version m4m 1.0
                 */
                this.queue = 0;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 自动播放
                 * @version m4m 1.0
                 */
                this.autoplay = true;
                /**
                * @private
                */
                this.state = framework.EffectPlayStateEnum.None;
                this.curFrameId = -1;
                this.playTimer = 0;
                this.speed = 1;
                // private time: number = 0;
                this.parser = new m4m.framework.EffectParser();
                /**
                * @private
                */
                this.vf = m4m.render.VertexFormatMask.Position | m4m.render.VertexFormatMask.Normal | m4m.render.VertexFormatMask.Tangent | m4m.render.VertexFormatMask.Color | m4m.render.VertexFormatMask.UV0;
                this.effectBatchers = [];
                this.matDataGroups = [];
                this.particleElementDic = {};
                // private resetparticle()
                // {
                //     if (this.particles != undefined)
                //         this.particles.dispose();
                //     for (let name in this.particleElementDic)
                //     {
                //         let data = this.data.elementDic[name];
                //         if (data.delayTime > 0)
                //         {
                //             this.delayElements.push(data);
                //             continue;
                //         }
                //         if (data.refFrom == undefined)
                //         {
                //             if (this.particles == undefined)
                //             {
                //                 this.particles = new Particles(this);
                //             }
                //             this.particles.addEmission(data);
                //         } else
                //         {
                //             this.refElements.push(data);
                //         }
                //     }
                // }
                this.delayElements = [];
                this.refElements = [];
                this.beExecuteNextFrame = true;
            }
            Object.defineProperty(TestEffectSystem.prototype, "renderLayer", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 渲染层级
                 * @version m4m 1.0
                 */
                //renderLayer: CullingMask = CullingMask.default;
                get: function () { return this.gameObject.layer; },
                set: function (layer) {
                    this.gameObject.layer = layer;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 设置特效数据 textasset
             * @version m4m 1.0
             */
            TestEffectSystem.prototype.setJsonData = function (_jsonData) {
                this.webgl = m4m.framework.sceneMgr.app.webgl;
                this.jsonData = _jsonData;
                this.data = this.parser.Parse(this.jsonData.content, m4m.framework.sceneMgr.app.getAssetMgr());
            };
            Object.defineProperty(TestEffectSystem.prototype, "data", {
                /**
                * @private
                */
                get: function () {
                    return this._data;
                },
                /**
                * @private
                */
                set: function (value) {
                    this._data = value;
                },
                enumerable: false,
                configurable: true
            });
            /**
            * @private
            */
            TestEffectSystem.prototype.init = function () {
                if (this._data) {
                    this.addElements();
                }
            };
            Object.defineProperty(TestEffectSystem.prototype, "totalFrameCount", {
                /**
                * @private
                */
                get: function () {
                    return this.data.life * framework.effectSystem.fps;
                },
                enumerable: false,
                configurable: true
            });
            TestEffectSystem.prototype.start = function () {
                this.init();
            };
            TestEffectSystem.prototype.onPlay = function () {
            };
            TestEffectSystem.prototype.update = function (delta) {
                if (this.gameObject.getScene() == null || this.gameObject.getScene() == undefined)
                    return;
                if (this.state == framework.EffectPlayStateEnum.Play || this.state == framework.EffectPlayStateEnum.Pause) {
                    if (this.state == framework.EffectPlayStateEnum.Play)
                        this.playTimer += delta * this.speed;
                    if (!this.beLoop) {
                        if (this.playTimer >= this.data.life) {
                            this.stop();
                        }
                    }
                    this._update(delta);
                }
                else if (this.state == framework.EffectPlayStateEnum.BeReady) {
                    if (this.autoplay) {
                        this.play();
                        this._update(delta);
                    }
                    else {
                        this.gameObject.visible = false;
                        this.gameObject.transform.markDirty();
                    }
                }
            };
            /**
             * 更新特效数据
             *
             * @private
             * @param {number} delta
             *
             * @memberof effectSystem
             */
            TestEffectSystem.prototype._update = function (delta) {
                if (this.delayElements.length > 0) {
                    if (this.refElements.length > 0)
                        this.refElements = [];
                    for (var i_9 = this.delayElements.length - 1; i_9 >= 0; i_9--) {
                        var data = this.delayElements[i_9];
                        if (data.delayTime <= this.playTimer) {
                            this.addElement(this.delayElements[i_9]);
                            this.delayElements.splice(i_9, 1);
                        }
                    }
                }
                if (this.checkFrameId()) {
                    if (this.emissionElement != null) {
                        for (var i = 0; i < this.emissionElement.length; i++) {
                            this.emissionElement[i].update(1 / framework.effectSystem.fps);
                        }
                    }
                }
            };
            /**
             * 提交各个EffectBatcher中的数据进行渲染
             *
             * @param {renderContext} context
             * @param {assetMgr} assetmgr
             * @param {m4m.framework.camera} camera
             *
             * @memberof effectSystem
             */
            TestEffectSystem.prototype.render = function (context, assetmgr, camera) {
                if (!(camera.CullingMask & (1 << this.renderLayer)))
                    return;
                if (this.state == framework.EffectPlayStateEnum.Play) {
                    context.updateModel(this.gameObject.transform);
                    // for (let i in this.effectBatchers)
                    // {
                    //     let subEffectBatcher = this.effectBatchers[i];
                    //     let mesh = subEffectBatcher.mesh;
                    //     if (subEffectBatcher.state === EffectBatcherState.NotInitedStateType)
                    //     {
                    //         mesh.glMesh.initBuffer(context.webgl, this.vf, subEffectBatcher.curTotalVertexCount);
                    //         if (mesh.glMesh.ebos.length == 0)
                    //         {
                    //             mesh.glMesh.addIndex(context.webgl, subEffectBatcher.dataForEbo.length);
                    //         }
                    //         else
                    //         {
                    //             mesh.glMesh.resetEboSize(context.webgl, 0, subEffectBatcher.dataForEbo.length);
                    //         }
                    //         mesh.glMesh.uploadIndexSubData(context.webgl, 0, subEffectBatcher.dataForEbo);
                    //         mesh.submesh[0].size = subEffectBatcher.dataForEbo.length;
                    //         subEffectBatcher.state = EffectBatcherState.InitedStateType;
                    //     }
                    //     else if (subEffectBatcher.state === EffectBatcherState.ResizeCapacityStateType)
                    //     {
                    //         mesh.glMesh.resetEboSize(context.webgl, 0, subEffectBatcher.dataForEbo.length);//动态修正掉mesh中的ebo大小
                    //         mesh.submesh[0].size = subEffectBatcher.dataForEbo.length;
                    //         mesh.glMesh.uploadIndexSubData(context.webgl, 0, subEffectBatcher.dataForEbo);
                    //         mesh.glMesh.resetVboSize(context.webgl, subEffectBatcher.curTotalVertexCount * subEffectBatcher.vertexSize);//动态修正mesh中的vbo大小
                    //         subEffectBatcher.state = EffectBatcherState.InitedStateType;
                    //     }
                    //     mesh.glMesh.uploadVertexSubData(context.webgl, subEffectBatcher.dataForVbo);
                    //     if (this.gameObject.getScene().fog)
                    //     {
                    //         context.fog = this.gameObject.getScene().fog;
                    //         subEffectBatcher.mat.draw(context, mesh, mesh.submesh[0], "base_fog");//只有一个submesh
                    //     } else
                    //     {
                    //         subEffectBatcher.mat.draw(context, mesh, mesh.submesh[0], "base");//只有一个submesh
                    //     }
                    // }
                    // if (this.particles != undefined)
                    // {
                    //     this.particles.render(context, assetmgr, camera);
                    // }
                    if (this.emissionElement != null) {
                        for (var i = 0; i < this.emissionElement.length; i++) {
                            this.emissionElement[i].render(context, assetmgr, camera);
                        }
                    }
                }
            };
            /**
             * @private
             */
            TestEffectSystem.prototype.clone = function () {
                var effect = new framework.effectSystem();
                effect.data = this.data.clone();
                return effect;
            };
            /**
             * @public
             * @language zh_CN
             * @param speed 播放速度
             * @classdesc
             * 播放特效
             * @version m4m 1.0
             */
            TestEffectSystem.prototype.play = function (speed) {
                if (speed === void 0) { speed = 1; }
                this.speed = speed;
                this.state = framework.EffectPlayStateEnum.Play;
                this.gameObject.visible = true;
                this.gameObject.transform.markDirty();
            };
            /**
             * @public
             * @language zh_CN
             * @param speed 播放速度
             * @classdesc
             * 暂停播放
             * @version m4m 1.0
             */
            TestEffectSystem.prototype.pause = function () {
                this.state = framework.EffectPlayStateEnum.Pause;
            };
            /**
             * @public
             * @language zh_CN
             * @param speed 播放速度
             * @classdesc
             * 停止播放
             * @version m4m 1.0
             */
            TestEffectSystem.prototype.stop = function () {
                this.reset();
                this.state = framework.EffectPlayStateEnum.Stop;
            };
            /**
             * @public
             * @language zh_CN
             * @param speed 播放速度
             * @classdesc
             * 重置到初始状态
             * @version m4m 1.0
             */
            TestEffectSystem.prototype.reset = function (restSinglemesh, resetParticle) {
                if (restSinglemesh === void 0) { restSinglemesh = true; }
                if (resetParticle === void 0) { resetParticle = true; }
                this.state = framework.EffectPlayStateEnum.BeReady;
                this.gameObject.visible = false;
                this.playTimer = 0;
                this.resetSingleMesh();
                //this.resetparticle();
            };
            TestEffectSystem.prototype.resetSingleMesh = function () {
                for (var i in this.effectBatchers) {
                    var subEffectBatcher = this.effectBatchers[i];
                    for (var key in subEffectBatcher.effectElements) {
                        var element = subEffectBatcher.effectElements[key];
                        element.setActive(true);
                        if (element.data.initFrameData != undefined) //引用问题还没处理
                            element.curAttrData = element.data.initFrameData.attrsData.copyandinit();
                    }
                }
            };
            /**
             * 向特效中增加元素
             */
            TestEffectSystem.prototype.addElements = function () {
                for (var name_5 in this.data.elementDic) {
                    var data = this.data.elementDic[name_5];
                    if (data.delayTime > 0) {
                        this.delayElements.push(data);
                        continue;
                    }
                    this.addElement(data);
                }
                this.state = framework.EffectPlayStateEnum.BeReady;
                this.beLoop = this.data.beLoop;
            };
            TestEffectSystem.prototype.addElement = function (data) {
                // if (data.type == EffectElementTypeEnum.EmissionType)
                // {
                //     if (this.particles == undefined)
                //     {
                //         this.particles = new Particles(this);
                //     }
                //     this.particles.addEmission(data);
                //     this.particleElementDic[data.name] = data;
                // }
                // else if (data.type == EffectElementTypeEnum.SingleMeshType)
                // {
                //     this.addInitFrame(data);
                // }
            };
            TestEffectSystem.prototype.addEmissionElement = function (data) {
                if (data === void 0) { data = null; }
                if (this.emissionElement == null) {
                    this.emissionElement = [];
                }
                var emission = new framework.EffectElementEmission(this, data);
                this.emissionElement.push(emission);
            };
            /**
            * @private
            */
            TestEffectSystem.prototype.setFrameId = function (id) {
                if (this.state == framework.EffectPlayStateEnum.Pause && id >= 0 && id < this.totalFrameCount)
                    this.curFrameId = id;
            };
            /**
            * @private
            */
            TestEffectSystem.prototype.getDelayFrameCount = function (delayTime) {
                return delayTime * framework.effectSystem.fps;
            };
            /**
             * 计算当前的frameid
             *
             * @private
             *
             * @memberof effectSystem
             */
            TestEffectSystem.prototype.checkFrameId = function () {
                // if(this.state == EffectPlayStateEnum.Pause)
                //     return true;
                var curid = (framework.effectSystem.fps * this.playTimer) | 0;
                if (curid != this.curFrameId) {
                    if (this.state == framework.EffectPlayStateEnum.Play)
                        this.curFrameId = curid;
                    this.beExecuteNextFrame = true;
                    return true;
                }
                return false;
            };
            /**
            * @private
            */
            TestEffectSystem.prototype.remove = function () {
                this.state = framework.EffectPlayStateEnum.Dispose;
                if (this.data)
                    this.data.dispose();
                for (var key in this.effectBatchers) {
                    this.effectBatchers[key].dispose();
                }
                if (this.particles)
                    this.particles.dispose();
            };
            Object.defineProperty(TestEffectSystem.prototype, "leftLifeTime", {
                /**
                * @private
                * 临时测试时显示使用
                * @readonly
                * @type {number}
                * @memberof effectSystem
                */
                get: function () {
                    if (this.data != null) {
                        return this.data.life - this.playTimer;
                    }
                    else
                        return 9999999999;
                },
                enumerable: false,
                configurable: true
            });
            TestEffectSystem.ClassName = "TestEffectSystem";
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 特效播放速度
             * @version m4m 1.0
             */
            TestEffectSystem.fps = 30;
            __decorate([
                m4m.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], TestEffectSystem.prototype, "autoplay", void 0);
            __decorate([
                m4m.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], TestEffectSystem.prototype, "beLoop", void 0);
            __decorate([
                m4m.reflect.Field("textasset"),
                __metadata("design:type", framework.textasset)
            ], TestEffectSystem.prototype, "jsonData", void 0);
            TestEffectSystem = __decorate([
                m4m.reflect.nodeRender,
                m4m.reflect.nodeComponent,
                m4m.reflect.selfClone
            ], TestEffectSystem);
            return TestEffectSystem;
        }());
        framework.TestEffectSystem = TestEffectSystem;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../io/reflect.ts" />
var m4m;
/// <reference path="../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        var f4skinnedMeshRenderer = /** @class */ (function () {
            function f4skinnedMeshRenderer() {
                /**
                 * 场景渲染层级（common、transparent、overlay）
                 */
                this.layer = framework.RenderLayerEnum.Common;
                this.issetq = false;
                this._queue = 0;
                ////////////////////////////////////////////////////////////////////
                this.useBoneTexture = true;
                this.boneSamplerTexindex = -1;
                this.texID = 0;
                this.tempMatrix = new m4m.math.matrix();
                this.inverseRootBone = new m4m.math.matrix();
            }
            f4skinnedMeshRenderer_1 = f4skinnedMeshRenderer;
            Object.defineProperty(f4skinnedMeshRenderer.prototype, "renderLayer", {
                /**
                 * 渲染mask层级（和相机相对应）
                 */
                //renderLayer: CullingMask = CullingMask.default;
                get: function () { return this.gameObject.layer; },
                set: function (layer) {
                    this.gameObject.layer = layer;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(f4skinnedMeshRenderer.prototype, "queue", {
                /**
                 * 返回此组件的场景渲染层级排序依据queue大小
                 */
                get: function () {
                    return this._queue;
                },
                /**
                 * 设置此组件的场景渲染层级排序number大小
                 */
                set: function (value) {
                    this._queue = value;
                    this.issetq = true;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(f4skinnedMeshRenderer.prototype, "mesh", {
                /**
                 * 返回mesh数据
                 */
                get: function () {
                    return this._mesh;
                },
                /**
                 * 设置mesh数据
                 */
                set: function (mesh) {
                    if (this._mesh != null) {
                        this._mesh.unuse();
                    }
                    this._mesh = mesh;
                    if (this._mesh != null) {
                        this._mesh.use();
                    }
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(f4skinnedMeshRenderer.prototype, "aabb", {
                get: function () {
                    if (!this._aabb) {
                        // calculate aabb from bounds
                        var _a = this, size = _a.size, center = _a.center;
                        var max = m4m.math.pool.new_vector3();
                        var min = m4m.math.pool.new_vector3();
                        var temp = m4m.math.pool.new_vector3();
                        m4m.math.vec3ScaleByNum(size, 0.5, min); // temp
                        // Ensure extent
                        min.x = Math.abs(min.x);
                        min.y = Math.abs(min.y);
                        min.z = Math.abs(min.z);
                        m4m.math.vec3Add(center, min, max);
                        m4m.math.vec3Subtract(center, min, min);
                        // Apply root bone matrix
                        // 骨骼可能有旋转之类的操作, aabb默认只会计算位移
                        var rootboneMat = this.rootBone.getWorldMatrix();
                        m4m.math.matrixTransformVector3(max, rootboneMat, max);
                        m4m.math.matrixTransformVector3(min, rootboneMat, min);
                        m4m.math.vec3Max(max, min, temp);
                        m4m.math.vec3Min(max, min, min);
                        m4m.math.vec3Clone(temp, max);
                        this._aabb = new framework.aabb(max, min);
                        m4m.math.pool.delete_vector3(max);
                        m4m.math.pool.delete_vector3(min);
                        m4m.math.pool.delete_vector3(temp);
                    }
                    return this._aabb;
                },
                enumerable: false,
                configurable: true
            });
            f4skinnedMeshRenderer.prototype.start = function () {
                if (!this.ibmContainer)
                    return;
                // Handle ibm
                this.ibm = [];
                for (var i = 0; i < this.ibmContainer.length / 4; i++) {
                    // Column major
                    var data = [
                        this.ibmContainer[i * 4 + 0].x,
                        this.ibmContainer[i * 4 + 0].y,
                        this.ibmContainer[i * 4 + 0].z,
                        this.ibmContainer[i * 4 + 0].w,
                        this.ibmContainer[i * 4 + 1].x,
                        this.ibmContainer[i * 4 + 1].y,
                        this.ibmContainer[i * 4 + 1].z,
                        this.ibmContainer[i * 4 + 1].w,
                        this.ibmContainer[i * 4 + 2].x,
                        this.ibmContainer[i * 4 + 2].y,
                        this.ibmContainer[i * 4 + 2].z,
                        this.ibmContainer[i * 4 + 2].w,
                        this.ibmContainer[i * 4 + 3].x,
                        this.ibmContainer[i * 4 + 3].y,
                        this.ibmContainer[i * 4 + 3].z,
                        this.ibmContainer[i * 4 + 3].w,
                    ];
                    this.ibm[i] = new m4m.math.matrix(data);
                }
                this.initBoneMatrices();
            };
            f4skinnedMeshRenderer.prototype.onPlay = function () {
            };
            f4skinnedMeshRenderer.prototype.update = function (delta) {
                // this.updateBoneMatrix();
                if (this.materials != null && this.materials.length > 0) {
                    var _mat = this.materials[0];
                    if (_mat) {
                        this.layer = _mat.getLayer();
                        if (!this.issetq)
                            this._queue = _mat.getQueue();
                    }
                }
                // if (this.player != null && this.player.gameObject)
                // {
                //     this.player.fillPoseData(this._skeletonMatrixData, this.bones);
                // }
            };
            f4skinnedMeshRenderer.prototype.render = function (context, assetmgr, camera) {
                if (!this.ibm)
                    return;
                framework.DrawCallInfo.inc.currentState = framework.DrawCallEnum.SKinrender;
                context.updateModel(this.gameObject.transform); // Update MVP
                this.updateBoneMatrix();
                if (this.useBoneTexture) {
                    this.updateBoneTexture(context);
                }
                else {
                    context.matrix_bones = this.boneMatrices;
                }
                if (this._mesh && this.mesh.glMesh) {
                    // this._mesh.glMesh.bindVboBuffer(context.webgl);
                    if (this._mesh.submesh != null) {
                        for (var i = 0; i < this._mesh.submesh.length; i++) {
                            var sm = this._mesh.submesh[i];
                            var mid = this._mesh.submesh[i].matIndex; //根据这个找到使用的具体哪个材质
                            var usemat = this.materials[mid];
                            if (usemat != null) {
                                if (this.gameObject.transform.scene.fog) {
                                    // context.fog = this.gameObject.transform.scene.fog;
                                    usemat.draw(context, this._mesh, sm, "skin_fog");
                                }
                                else {
                                    usemat.draw(context, this._mesh, sm, "skin");
                                }
                            }
                        }
                    }
                }
            };
            /**
             * @private
             */
            f4skinnedMeshRenderer.prototype.remove = function () {
                this.materials.forEach(function (element) {
                    if (element)
                        element.unuse();
                });
                if (this.mesh)
                    this.mesh.unuse();
                this.bones.length = 0;
                // TODO:
                this.boneMatrices = null;
                this.boneMatrixChunks = null;
                this.boneMatricesTexture.unuse();
            };
            /**
             * @private
             */
            f4skinnedMeshRenderer.prototype.clone = function () {
            };
            f4skinnedMeshRenderer.prototype.initBoneMatrices = function () {
                if (!this.boneMatrices) {
                    this.boneMatrices = new Float32Array(16 * (this.bones.length + 0));
                }
                // Assign individual matrix
                this.boneMatrixChunks = [];
                for (var i = 0; i < this.bones.length; i++) {
                    this.boneMatrixChunks[i] = this.boneMatrices.subarray(i * 16, (i + 1) * 16);
                }
            };
            f4skinnedMeshRenderer.prototype.initStaticPoseMatrices = function () {
                this.ibm = [];
                if (this.bones && this.bones.length) {
                    if (!this.rootBone) {
                        this.rootBone = this.bones[0];
                    }
                    // FIXME: correct matrix
                    m4m.math.matrixInverse(this.rootBone.getWorldMatrix(), this.tempMatrix);
                    for (var i = 0; i < this.bones.length; i++) {
                        var bone = this.bones[i];
                        var mat = new m4m.math.matrix();
                        m4m.math.matrixMultiply(this.tempMatrix, bone.getWorldMatrix(), mat);
                        m4m.math.matrixInverse(mat, mat);
                        this.ibm[i] = mat;
                    }
                }
            };
            f4skinnedMeshRenderer.prototype.updateBoneTexture = function (context) {
                var ctx = context.webgl;
                if (!this.boneMatricesTexture) {
                    this.boneMatricesTexture = new m4m.framework.texture("bone_matrices_".concat(this.texID++));
                    this.boneMatricesTexture.glTexture = new m4m.render.glTexture2D(ctx, m4m.render.TextureFormatEnum.FLOAT32, false, false);
                    // Manually assign tex size
                    this.boneMatricesTexture.glTexture.width = this.boneMatrices.length / 4;
                    this.boneMatricesTexture.glTexture.height = 1;
                    this.boneMatricesTexture.use();
                }
                // Ensure boneMatrices is correct, if multiple skinnedMeshRenderer sharing the same material
                // this.materials[0].setTexture("boneSampler", this.boneMatricesTexture);
                var mat = this.materials[0];
                mat.setTexture(f4skinnedMeshRenderer_1.boneSampler, this.boneMatricesTexture);
                mat.setFloat(f4skinnedMeshRenderer_1.boneSamplerTexelSize, 4 / this.boneMatrices.length);
                //处理uniform 同材质去重优化,贴图通道被污染
                var basetype = this.gameObject.transform.scene.fog ? "skin_fog" : "skin";
                var drawType = context.drawtype;
                var shader = mat.getShader();
                var drawPasses = shader.passes[basetype + drawType][0];
                if (this.boneSamplerTexindex == -1) {
                    this.boneSamplerTexindex = ctx.getUniform(drawPasses.program.program, drawPasses.mapuniforms[f4skinnedMeshRenderer_1.boneSampler].location);
                }
                ctx.activeTexture(m4m.render.webglkit.GetTextureNumber(this.boneSamplerTexindex));
                // update data texture
                this.boneMatricesTexture.glTexture.uploadByteArray(false, false, this.boneMatrices.length / 4, 1, this.boneMatrices, false, false, false, false, false, ctx.FLOAT);
            };
            f4skinnedMeshRenderer.prototype.updateBoneMatrix = function () {
                for (var i = 0; i < this.bones.length; i++) {
                    var bone = this.bones[i];
                    // tempMatrix = render object world inverse matrix ('M'VP)
                    // gameobject空间 抵消掉shader里的M
                    m4m.math.matrixInverse(this.gameObject.transform.getWorldMatrix(), this.tempMatrix);
                    m4m.math.matrixMultiply(this.tempMatrix, bone.getWorldMatrix(), this.tempMatrix);
                    // inverse bind pose
                    this.matrixMultiplyToArray(this.tempMatrix, this.ibm[i], this.boneMatrixChunks[i]);
                }
            };
            f4skinnedMeshRenderer.prototype.matrixMultiplyToArray = function (lhs, rhs, out) {
                var a00 = lhs.rawData[0], a01 = lhs.rawData[1], a02 = lhs.rawData[2], a03 = lhs.rawData[3];
                var a10 = lhs.rawData[4], a11 = lhs.rawData[5], a12 = lhs.rawData[6], a13 = lhs.rawData[7];
                var a20 = lhs.rawData[8], a21 = lhs.rawData[9], a22 = lhs.rawData[10], a23 = lhs.rawData[11];
                var a30 = lhs.rawData[12], a31 = lhs.rawData[13], a32 = lhs.rawData[14], a33 = lhs.rawData[15];
                var b0 = rhs.rawData[0], b1 = rhs.rawData[1], b2 = rhs.rawData[2], b3 = rhs.rawData[3];
                out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                b0 = rhs.rawData[4];
                b1 = rhs.rawData[5];
                b2 = rhs.rawData[6];
                b3 = rhs.rawData[7];
                out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                b0 = rhs.rawData[8];
                b1 = rhs.rawData[9];
                b2 = rhs.rawData[10];
                b3 = rhs.rawData[11];
                out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
                b0 = rhs.rawData[12];
                b1 = rhs.rawData[13];
                b2 = rhs.rawData[14];
                b3 = rhs.rawData[15];
                out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
                out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
                out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
                out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            };
            var f4skinnedMeshRenderer_1;
            f4skinnedMeshRenderer.ClassName = "f4skinnedMeshRenderer";
            f4skinnedMeshRenderer.boneSampler = "boneSampler";
            f4skinnedMeshRenderer.boneSamplerTexelSize = "boneSamplerTexelSize";
            __decorate([
                m4m.reflect.Field("material[]"),
                __metadata("design:type", Array)
            ], f4skinnedMeshRenderer.prototype, "materials", void 0);
            __decorate([
                m4m.reflect.Field("mesh"),
                __metadata("design:type", framework.mesh),
                __metadata("design:paramtypes", [framework.mesh])
            ], f4skinnedMeshRenderer.prototype, "mesh", null);
            __decorate([
                m4m.reflect.Field("transform[]"),
                __metadata("design:type", Array)
            ], f4skinnedMeshRenderer.prototype, "bones", void 0);
            __decorate([
                m4m.reflect.Field("transform"),
                __metadata("design:type", framework.transform)
            ], f4skinnedMeshRenderer.prototype, "rootBone", void 0);
            __decorate([
                m4m.reflect.Field("vector3"),
                __metadata("design:type", m4m.math.vector3)
            ], f4skinnedMeshRenderer.prototype, "center", void 0);
            __decorate([
                m4m.reflect.Field("vector3"),
                __metadata("design:type", m4m.math.vector3)
            ], f4skinnedMeshRenderer.prototype, "size", void 0);
            __decorate([
                m4m.reflect.Field("vector4[]"),
                __metadata("design:type", Array)
            ], f4skinnedMeshRenderer.prototype, "ibmContainer", void 0);
            f4skinnedMeshRenderer = f4skinnedMeshRenderer_1 = __decorate([
                m4m.reflect.nodeRender,
                m4m.reflect.nodeComponent
            ], f4skinnedMeshRenderer);
            return f4skinnedMeshRenderer;
        }());
        framework.f4skinnedMeshRenderer = f4skinnedMeshRenderer;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 视锥剔除组件，作为标记存在
         * @version m4m 1.0
         */
        var frustumculling = /** @class */ (function () {
            function frustumculling() {
            }
            frustumculling.prototype.start = function () {
            };
            frustumculling.prototype.onPlay = function () {
            };
            frustumculling.prototype.update = function (delta) {
            };
            frustumculling.prototype.remove = function () {
            };
            frustumculling.prototype.clone = function () {
            };
            frustumculling.ClassName = "frustumculling";
            frustumculling = __decorate([
                m4m.reflect.nodeComponent,
                __metadata("design:paramtypes", [])
            ], frustumculling);
            return frustumculling;
        }());
        framework.frustumculling = frustumculling;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 路径组件
         * @version m4m 1.0
         */
        var guidpath = /** @class */ (function () {
            function guidpath() {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 移动速度
                 * @version m4m 1.0
                 */
                this.speed = 1;
                this.isactived = false;
                this.datasafe = false;
                this.folowindex = 0;
                this.isloop = false;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 挂载此组件的gameobject是否朝向前方
                 * @version m4m 1.0
                 */
                this.lookforward = false;
                this.loopCount = 1;
                this.adjustDir = false;
            }
            Object.defineProperty(guidpath.prototype, "pathasset", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 路径组件的pathasset
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._pathasset;
                },
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 设置路径组件需要的路径资源
                 * @version m4m 1.0
                 */
                set: function (pathasset) {
                    if (this._pathasset) {
                        this._pathasset.unuse();
                    }
                    this._pathasset = pathasset;
                    if (this._pathasset) {
                        this._pathasset.use();
                    }
                },
                enumerable: false,
                configurable: true
            });
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 按照路径开始移动
             * @version m4m 1.0
             */
            guidpath.prototype.play = function (loopCount) {
                if (loopCount === void 0) { loopCount = 1; }
                this.isactived = true;
                this.loopCount = loopCount;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 暂停移动
             * @version m4m 1.0
             */
            guidpath.prototype.pause = function () {
                this.isactived = false;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 停止移动
             * @version m4m 1.0
             */
            guidpath.prototype.stop = function () {
                this.isactived = false;
                this.folowindex = 0;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 重新按照路径移动
             * @version m4m 1.0
             */
            guidpath.prototype.replay = function (loopCount) {
                if (loopCount === void 0) { loopCount = 1; }
                this.isactived = true;
                this.folowindex = 0;
                this.loopCount = loopCount;
            };
            /**
             * @public
             * @language zh_CN
             * @param pathasset 路径资源
             * @param speed 移动速度
             * @param oncomplete 按照路径移动结束需要执行的事件
             * @classdesc
             * 设置路径组件的需要的参数
             * @version m4m 1.0
             */
            guidpath.prototype.setpathasset = function (pathasset, speed, oncomplete) {
                if (speed === void 0) { speed = 1; }
                if (oncomplete === void 0) { oncomplete = null; }
                this.pathasset = pathasset;
                if (pathasset == null) {
                    console.log(this.gameObject.getName().toString + ":are you sure set the right pathasset（error：null）");
                    return;
                }
                this.paths = pathasset.paths;
                if (this.paths[0] != null) {
                    m4m.math.vec3Clone(this.paths[0], this.gameObject.transform.localTranslate);
                    this.datasafe = true;
                }
                this.mystrans = this.gameObject.transform;
                this.speed = speed;
                this.oncomplete = oncomplete;
            };
            guidpath.prototype.start = function () {
            };
            guidpath.prototype.onPlay = function () {
            };
            guidpath.prototype.update = function (delta) {
                if (!this.isactived || !this.datasafe)
                    return;
                this.followmove(delta);
            };
            guidpath.prototype.followmove = function (delta) {
                var dist = m4m.math.vec3Distance(this.mystrans.localTranslate, this.paths[this.folowindex]);
                if (dist < 0.01) {
                    if (this.folowindex < this.paths.length - 1) {
                        var dir = new m4m.math.vector3();
                        m4m.math.vec3Clone(this.paths[this.folowindex], this.mystrans.localTranslate);
                        this.folowindex++;
                        this.adjustDir = true;
                    }
                    else {
                        this.folowindex = 0;
                        if (!this.isloop) {
                            this.loopCount--;
                            if (this.loopCount == 0) {
                                this.isactived = false;
                                this.loopCount = 1;
                                if (this.oncomplete) {
                                    this.oncomplete();
                                }
                            }
                        }
                    }
                }
                else {
                    var dir = new m4m.math.vector3();
                    m4m.math.vec3Subtract(this.paths[this.folowindex], this.mystrans.localTranslate, dir);
                    if (this.adjustDir) {
                        var targetpos = this.paths[this.folowindex];
                        var localppos = this.mystrans.localTranslate;
                        var quat = m4m.math.pool.new_quaternion();
                        m4m.math.quatLookat(localppos, targetpos, quat);
                        m4m.math.quatClone(quat, this.mystrans.localRotate);
                        m4m.math.pool.delete_quaternion(quat);
                        this.adjustDir = false;
                    }
                    var distadd = this.speed * delta;
                    if (distadd > dist)
                        distadd = dist;
                    var lerp = distadd / dist;
                    m4m.math.vec3SLerp(this.mystrans.localTranslate, this.paths[this.folowindex], lerp, this.mystrans.localTranslate);
                    this.mystrans.markDirty();
                }
            };
            /**
            * @private
            */
            guidpath.prototype.remove = function () {
                if (this._pathasset) {
                    this._pathasset.unuse();
                }
            };
            /**
            * @private
            */
            guidpath.prototype.clone = function () {
            };
            guidpath.ClassName = "guidpath";
            guidpath = __decorate([
                m4m.reflect.nodeComponent
            ], guidpath);
            return guidpath;
        }());
        framework.guidpath = guidpath;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../io/reflect.ts" />
var m4m;
/// <reference path="../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        var AnimationCullingType;
        (function (AnimationCullingType) {
            /** Animation culling is disabled - object is animated even when offscreen. */
            AnimationCullingType[AnimationCullingType["AlwaysAnimate"] = 0] = "AlwaysAnimate";
            /** Animation is disabled when renderers are not visible. */
            AnimationCullingType[AnimationCullingType["BasedOnRenderers"] = 1] = "BasedOnRenderers";
            AnimationCullingType[AnimationCullingType["BasedOnClipBounds"] = 2] = "BasedOnClipBounds";
            AnimationCullingType[AnimationCullingType["BasedOnUserBounds"] = 3] = "BasedOnUserBounds";
        })(AnimationCullingType = framework.AnimationCullingType || (framework.AnimationCullingType = {}));
        var keyFrameAniPlayer = /** @class */ (function () {
            function keyFrameAniPlayer() {
                this.clipMap = {};
                //当前播放到的时间
                this._nowTime = 0;
                //对象路径map
                this.pathPropertyMap = {};
                this.playEndDic = {};
                this._currClipName = "";
                this._speed = 1;
                this._animateOnlyIfVisible = true;
                this._cullingType = AnimationCullingType.AlwaysAnimate;
                /** 播放结束的归一化时间点 范围 0 ~ 1 */
                this.endNormalizedTime = 1;
                this.eulerStatusMap = {};
                this.eulerMap = {};
            }
            keyFrameAniPlayer_1 = keyFrameAniPlayer;
            Object.defineProperty(keyFrameAniPlayer.prototype, "nowFrame", {
                //当前播放到的帧
                get: function () {
                    if (!this._nowClip)
                        return 0;
                    return Math.floor(this._nowClip.fps * this._nowTime);
                },
                enumerable: false,
                configurable: true
            });
            ;
            Object.defineProperty(keyFrameAniPlayer.prototype, "nowTime", {
                /** 当前播放到的时间 */
                get: function () { return this._nowTime; },
                enumerable: false,
                configurable: true
            });
            ;
            Object.defineProperty(keyFrameAniPlayer.prototype, "currClipName", {
                /** 获得当前片段的名字 */
                get: function () { return this._currClipName; },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(keyFrameAniPlayer.prototype, "speed", {
                /** 播放速度 */
                get: function () { return this._speed; },
                set: function (v) { this._speed = v; },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(keyFrameAniPlayer.prototype, "animateOnlyIfVisible", {
                /** 动画是否仅仅可显示时 有效播放 */
                get: function () { return this._animateOnlyIfVisible; },
                set: function (v) { this._animateOnlyIfVisible = v; },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(keyFrameAniPlayer.prototype, "cullingType", {
                /** 动画的剔除类型 */
                get: function () { return this._cullingType; },
                set: function (v) { this._cullingType = v; },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(keyFrameAniPlayer.prototype, "localBounds", {
                /** 动画的剔除类型 */
                get: function () { return this._localBounds; },
                set: function (v) { this._localBounds = v; },
                enumerable: false,
                configurable: true
            });
            keyFrameAniPlayer.prototype.start = function () {
                this.init();
            };
            keyFrameAniPlayer.prototype.onPlay = function () {
            };
            keyFrameAniPlayer.prototype.update = function (delta) {
                if (this._animateOnlyIfVisible && !this.gameObject.visible)
                    return;
                var clip = this._nowClip;
                if (!clip)
                    return;
                this._nowTime += delta * this._speed;
                var raelTime = this._nowTime;
                var clipTime = clip.time;
                //    
                //是否播完
                if (this.checkPlayEnd(clip)) {
                    this.OnClipPlayEnd();
                }
                this._nowTime = raelTime % clipTime;
                var playTime = this._nowClip == null ? clipTime : this._nowTime; //当前播放时间
                this.displayByTime(clip, playTime);
            };
            /**
             * 获取指定名称的clip 资源
             * @param clipName
             */
            keyFrameAniPlayer.prototype.getClip = function (clipName) {
                if (!this.clips || this.clips.length < 1)
                    return;
                if (this.clipMap[clipName])
                    return this.clipMap[clipName];
                var len = this.clips.length;
                for (var i = 0; i < len; i++) {
                    var clip = this.clips[i];
                    if (clip && clip.getName() == clipName)
                        return clip;
                }
            };
            //播放到指定时间状态
            keyFrameAniPlayer.prototype.displayByTime = function (clip, playTime) {
                var curves = this.timeFilterCurves(clip, playTime);
                if (!curves || curves.length < 1)
                    return;
                //修改属性值
                for (var i = 0; i < curves.length; i++) {
                    var tempc = curves[i];
                    this.refrasCurveProperty(tempc, playTime);
                }
            };
            keyFrameAniPlayer.vec3lerp = function (a, b, t, out) {
                out.x = a.x + t * (b.x - a.x);
                out.y = a.y + t * (b.y - a.y);
                out.z = a.z + t * (b.z - a.z);
                return out;
            };
            keyFrameAniPlayer.quatSlerp = function (a, b, t, out) {
                var omega, cosom, sinom, scale0, scale1;
                cosom = a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w;
                if (cosom < 0.0) {
                    cosom = -cosom;
                    b.x = -b.x;
                    b.y = -b.y;
                    b.z = -b.z;
                    b.w = -b.w;
                }
                if ((1.0 - cosom) > 0.000001) {
                    omega = Math.acos(cosom);
                    sinom = Math.sin(omega);
                    scale0 = Math.sin((1.0 - t) * omega) / sinom;
                    scale1 = Math.sin(t * omega) / sinom;
                }
                else {
                    scale0 = 1.0 - t;
                    scale1 = t;
                }
                out.x = scale0 * a.x + scale1 * b.x;
                out.y = scale0 * a.y + scale1 * b.y;
                out.z = scale0 * a.z + scale1 * b.z;
                out.w = scale0 * a.w + scale1 * b.w;
                return out;
            };
            keyFrameAniPlayer.prototype.calcValueByTime = function (curve, playTime) {
                var kfs = curve.keyFrames;
                if (!kfs || kfs.length < 1)
                    return 0;
                if (kfs.length == 1 && kfs[0])
                    return kfs[0].value;
                //找到目标关键帧
                var leftKf;
                var rightKf;
                for (var i = 0; i < kfs.length; i++) {
                    rightKf = kfs[i];
                    if (kfs[i].time > playTime) {
                        if (i > 0)
                            leftKf = kfs[i - 1];
                        break;
                    }
                }
                // NOTE: Using LINEAR instead of bezier
                var progress = leftKf
                    ? (playTime - leftKf.time) / (rightKf.time - leftKf.time)
                    : 1;
                switch (curve.propertyName) {
                    case 'localScale':
                    case 'localTranslate':
                        keyFrameAniPlayer_1.rhvec.x = rightKf.value[0];
                        keyFrameAniPlayer_1.rhvec.y = rightKf.value[1];
                        keyFrameAniPlayer_1.rhvec.z = rightKf.value[2];
                        if (!leftKf) {
                            return keyFrameAniPlayer_1.rhvec;
                        }
                        keyFrameAniPlayer_1.lhvec.x = leftKf.value[0];
                        keyFrameAniPlayer_1.lhvec.y = leftKf.value[1];
                        keyFrameAniPlayer_1.lhvec.z = leftKf.value[2];
                        return keyFrameAniPlayer_1.vec3lerp(keyFrameAniPlayer_1.lhvec, keyFrameAniPlayer_1.rhvec, progress, keyFrameAniPlayer_1.resvec);
                        break;
                    case 'localRotate':
                        keyFrameAniPlayer_1.rhquat.x = rightKf.value[0];
                        keyFrameAniPlayer_1.rhquat.y = rightKf.value[1];
                        keyFrameAniPlayer_1.rhquat.z = rightKf.value[2];
                        keyFrameAniPlayer_1.rhquat.w = rightKf.value[3];
                        if (!leftKf) {
                            return keyFrameAniPlayer_1.rhquat;
                        }
                        keyFrameAniPlayer_1.lhquat.x = leftKf.value[0];
                        keyFrameAniPlayer_1.lhquat.y = leftKf.value[1];
                        keyFrameAniPlayer_1.lhquat.z = leftKf.value[2];
                        keyFrameAniPlayer_1.lhquat.w = leftKf.value[3];
                        return keyFrameAniPlayer_1.quatSlerp(keyFrameAniPlayer_1.lhquat, keyFrameAniPlayer_1.rhquat, progress, keyFrameAniPlayer_1.resquat);
                }
                return null;
                //贝塞尔算值
                return bezierCurveTool.calcValue(leftKf, rightKf, playTime);
            };
            //刷新curve 属性
            keyFrameAniPlayer.prototype.refrasCurveProperty = function (curve, playTime) {
                if (playTime < 0 || !curve || curve.keyFrames.length < 2 || framework.StringUtil.isNullOrEmptyObject(curve.propertyName))
                    return;
                var path = curve.path;
                var key = "".concat(path, "_").concat(curve.type);
                var obj = this.pathPropertyMap[key];
                if (!obj)
                    return;
                var sub = obj;
                var strs = curve.propertyName.split(".");
                var prop_type = "";
                while (strs.length > 0) {
                    if (strs.length == 1) {
                        var str_p = strs[0];
                        var target = this.calcValueByTime(curve, playTime);
                        // const target = 0;
                        if (curve.type == framework.transform["name"]) {
                            if (obj instanceof framework.transform) {
                                if (target) {
                                    switch (curve.propertyName) {
                                        case 'localScale':
                                            obj.localScale.x = target['x'];
                                            obj.localScale.y = target['y'];
                                            obj.localScale.z = target['z'];
                                            break;
                                        case 'localTranslate':
                                            obj.localTranslate.x = target['x'];
                                            obj.localTranslate.y = target['y'];
                                            obj.localTranslate.z = target['z'];
                                            break;
                                        case 'localRotate':
                                            obj.localRotate.x = target['x'];
                                            obj.localRotate.y = target['y'];
                                            obj.localRotate.z = target['z'];
                                            obj.localRotate.w = target['w'];
                                            break;
                                    }
                                }
                                // if(prop_type == "localEulerAngles"){
                                //     if(!this.eulerStatusMap[path]) this.eulerStatusMap[path] = 0;
                                //     let p_val = 0;
                                //     switch(str_p){
                                //         case "x" : p_val = 0;  break;
                                //         case "y" : p_val = 1;  break;
                                //         case "z" : p_val = 2;  break;
                                //     }
                                //     this.eulerStatusMap[path] |= 1 << p_val;
                                //     this.eulerMap[path+str_p] = target;
                                //     if(this.eulerStatusMap[path] == 7){
                                //         this.eulerStatusMap[path] = 0;
                                //         sub.x = this.eulerMap[path+'x'];
                                //         sub.y = this.eulerMap[path+'y'];
                                //         sub.z = this.eulerMap[path+'z'];
                                //         obj.localEulerAngles = sub;
                                //         // m4m.math.quatNormalize(obj.localRotate,obj.localRotate);
                                //         // obj.localRotate = obj.localRotate;
                                //     }
                                // } else {
                                //     sub[str_p] = target;
                                // }
                                // obj.markDirty();
                                // obj["dirtyLocal"] = true;
                                obj["dirtify"](true);
                                // dirtify
                            }
                        }
                        return;
                    }
                    var str = strs.shift();
                    prop_type = str;
                    sub = sub[str];
                    if (!sub)
                        return;
                }
            };
            //按时间筛选需要播放的 curve
            keyFrameAniPlayer.prototype.timeFilterCurves = function (clip, nowTime) {
                if (!clip || clip.curves.length < 1)
                    return;
                var result = [];
                for (var i = 0; i < clip.curves.length; i++) {
                    var curve = clip.curves[i];
                    var kfs = curve.keyFrames;
                    if (kfs.length < 1 || !kfs[kfs.length - 1] || kfs[kfs.length - 1].time < nowTime)
                        continue;
                    result.push(curve);
                }
                return result;
            };
            //检查播放是否完毕
            keyFrameAniPlayer.prototype.checkPlayEnd = function (clip) {
                if (!clip)
                    return true;
                if (clip._wrapMode == framework.WrapMode.Loop || clip._wrapMode == framework.WrapMode.PingPong)
                    return false;
                if (this._nowTime >= clip.time * this.endNormalizedTime)
                    return true;
            };
            keyFrameAniPlayer.prototype.init = function () {
                if (this.clips) {
                    var len = this.clips.length;
                    for (var i = 0; i < len; i++) {
                        var clip = this.clips[i];
                        if (i == 0)
                            this._currClipName = clip.getName();
                        this.clipMap[clip.getName()] = clip;
                    }
                }
            };
            /**
             * 动画是否在播放
             * @param ClipName 指定片段名 ，不指定仅判断当前是否在执行
             */
            keyFrameAniPlayer.prototype.isPlaying = function (ClipName) {
                if (ClipName === void 0) { ClipName = ""; }
                if (!this._nowClip)
                    return false;
                if (ClipName)
                    return this._nowClip.getName() == ClipName;
                return true;
            };
            // /**
            //  * @public
            //  * @language zh_CN
            //  * @classdesc
            //  * 播放指定动画
            //  * @version m4m 1.0
            //  */
            // playByName(ClipName: string, onPlayEnd: () => void = null)
            // {
            //     let clip = this.getClip(ClipName);
            //     this.playByClip(clip, onPlayEnd);
            // }
            /**
             * 播放动画
             * @param ClipName 指定播放的动画 片段名（为空状态播放队列第一个）
             * @param onPlayEnd 播放结束后回调函数
             * @param normalizedTime 播放结束时间点归一化时间（范围：0~1）
             */
            keyFrameAniPlayer.prototype.play = function (ClipName, onPlayEnd, normalizedTime) {
                if (ClipName === void 0) { ClipName = ""; }
                if (onPlayEnd === void 0) { onPlayEnd = null; }
                if (normalizedTime === void 0) { normalizedTime = 1; }
                if (!this.clips)
                    return;
                if (!isNaN(normalizedTime) && normalizedTime != null) {
                    this.endNormalizedTime = m4m.math.floatClamp(normalizedTime, 0, 1);
                }
                var clip = this.getClip(ClipName);
                this.playByClip(clip, onPlayEnd);
            };
            /**
             * 播放动画 通过 clip
             * @param clip
             */
            keyFrameAniPlayer.prototype.playByClip = function (clip, onPlayEnd) {
                if (onPlayEnd === void 0) { onPlayEnd = null; }
                if (this._nowClip) {
                    this.OnClipPlayEnd();
                }
                if (!clip)
                    return;
                var clipName = clip.getName();
                this.playEndDic[clipName] = onPlayEnd;
                this._nowTime = 0;
                this._nowClip = clip;
                this._currClipName = clipName;
                this.collectPathPropertyObj(this._nowClip, this.pathPropertyMap);
            };
            /** clip 播放完毕 */
            keyFrameAniPlayer.prototype.OnClipPlayEnd = function () {
                if (!this._nowClip)
                    return;
                var clipName = this._nowClip.getName();
                this._nowClip = null;
                this._nowTime = 0;
                this.endNormalizedTime = 1;
                var endFunc = this.playEndDic[clipName];
                if (endFunc)
                    endFunc();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 停止默认动画
             * @version m4m 1.0
             */
            keyFrameAniPlayer.prototype.stop = function () {
                this._nowClip = null;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 倒带默认动画
             * @version m4m 1.0
             */
            keyFrameAniPlayer.prototype.rewind = function () {
                if (!this._nowClip)
                    return;
                this.displayByTime(this._nowClip, 0); //到第一帧
                this._nowTime = 0;
            };
            keyFrameAniPlayer.prototype.addClip = function (clip) {
                if (!this.clips)
                    this.clips = [];
                this.clips.push(clip);
                this.clipMap[clip.getName()] = clip;
            };
            keyFrameAniPlayer.prototype.collectPropertyObj = function (clip) {
                if (!clip)
                    return;
                for (var i = 0; i < clip.curves.length; i++) { //"gameobj_0/gameobj_1"
                    var curve = clip.curves[i];
                    var tran = this.gameObject.transform;
                    if (!framework.StringUtil.isNullOrEmptyObject(curve.path)) {
                        tran = this.pathPropertyMap[curve.path];
                    }
                    var comp = tran;
                    if (curve.type != framework.transform.prototype.name) {
                        comp = tran.gameObject.getComponent(curve.type);
                    }
                    if (!comp)
                        continue;
                }
            };
            //children对象收集路径
            keyFrameAniPlayer.prototype.collectPathPropertyObj = function (clip, pathMap) {
                if (!clip || !pathMap)
                    return;
                for (var i = 0; i < clip.curves.length; i++) { //"gameobj_0/gameobj_1"
                    var curve = clip.curves[i];
                    var key = "";
                    var tran = this.gameObject.transform;
                    if (!framework.StringUtil.isNullOrEmptyObject(curve.path)) {
                        var strs = curve.path.split("/");
                        for (var j = 0; j < strs.length; j++) {
                            tran = this.serchChild(strs[j], tran);
                            if (!tran)
                                break;
                        }
                        if (!tran)
                            continue;
                    }
                    key = "".concat(curve.path, "_").concat(curve.type);
                    var comp = tran;
                    if (curve.type != framework.transform["name"]) {
                        comp = tran.gameObject.getComponent(curve.type);
                    }
                    pathMap[key] = comp;
                }
            };
            //寻找child by name
            keyFrameAniPlayer.prototype.serchChild = function (name, trans) {
                if (!trans || !trans.children || trans.children.length < 1)
                    return;
                for (var i = 0; i < trans.children.length; i++) {
                    var child = trans.children[i];
                    if (child && child.name == name)
                        return child;
                }
            };
            keyFrameAniPlayer.prototype.clone = function () {
            };
            keyFrameAniPlayer.prototype.remove = function () {
                this.gameObject = null;
                this.pathPropertyMap = null;
                this._nowClip = null;
                if (this.clips) {
                    this.clips.length = 0;
                }
                this.clips = null;
                this.clipMap = null;
                this.playEndDic = null;
            };
            var keyFrameAniPlayer_1;
            keyFrameAniPlayer.ClassName = "keyFrameAniPlayer";
            //通过时间计算curve 值
            // 插值函数
            keyFrameAniPlayer.lhvec = new m4m.math.vector3();
            keyFrameAniPlayer.rhvec = new m4m.math.vector3();
            keyFrameAniPlayer.lhquat = new m4m.math.quaternion();
            keyFrameAniPlayer.rhquat = new m4m.math.quaternion();
            keyFrameAniPlayer.resvec = new m4m.math.vector3();
            keyFrameAniPlayer.resquat = new m4m.math.quaternion();
            __decorate([
                m4m.reflect.Field("keyFrameAniClip[]"),
                __metadata("design:type", Array)
            ], keyFrameAniPlayer.prototype, "clips", void 0);
            keyFrameAniPlayer = keyFrameAniPlayer_1 = __decorate([
                m4m.reflect.nodeComponent
            ], keyFrameAniPlayer);
            return keyFrameAniPlayer;
        }());
        framework.keyFrameAniPlayer = keyFrameAniPlayer;
        //贝塞尔计算工具
        var bezierCurveTool = /** @class */ (function () {
            function bezierCurveTool() {
            }
            bezierCurveTool.calcValue = function (kf_l, kf_r, playTime) {
                //是否 是常量
                if (kf_l.outTangent == Infinity || kf_r.inTangent == Infinity)
                    return kf_l.value;
                var rate = (playTime - kf_l.time) / (kf_r.time - kf_l.time);
                var v2 = bezierCurveTool.converCalc(kf_l.value, kf_r.value, kf_l.time, kf_r.time, kf_l.inTangent, kf_r.outTangent, rate);
                return v2.y;
            };
            bezierCurveTool.converCalc = function (inV, outV, inTime, outTime, inTangent, outTangent, t) {
                var p0 = m4m.math.pool.new_vector2(inTime, inV);
                var p1 = m4m.math.pool.new_vector2();
                var p2 = m4m.math.pool.new_vector2();
                var p3 = m4m.math.pool.new_vector2(outTime, outV);
                var dir1 = m4m.math.pool.new_vector2(inTangent < 0 ? -1 : 1, Math.sqrt(1 + inTangent * inTangent));
                var dir2 = m4m.math.pool.new_vector2(outTangent < 0 ? -1 : 1, Math.sqrt(1 + outTangent * outTangent));
                m4m.math.vec2Add(p0, dir1, p1);
                m4m.math.vec2Add(p3, dir2, p2);
                bezierCurveTool.calcCurve(t, p0, p1, p2, p3, bezierCurveTool.cupV2);
                m4m.math.pool.delete_vector2Array([p0, p1, p2, p3, dir1, dir2]);
                return bezierCurveTool.cupV2;
            };
            //三阶 贝塞尔曲线
            bezierCurveTool.calcCurve = function (t, P0, P1, P2, P3, out) {
                var equation = function (t, val0, val1, val2, val3) {
                    var res = (1.0 - t) * (1.0 - t) * (1.0 - t) * val0 + 3.0 * t * (1.0 - t) * (1.0 - t) * val1 + 3.0 * t * t * (1.0 - t) * val2 + t * t * t * val3;
                    return res;
                };
                out.x = equation(t, P0.x, P1.x, P2.x, P3.x);
                out.y = equation(t, P0.y, P1.y, P2.y, P3.y);
                return out;
            };
            bezierCurveTool.cupV2 = new m4m.math.vector2();
            return bezierCurveTool;
        }());
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../io/reflect.ts" />
var m4m;
/// <reference path="../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        var LightTypeEnum;
        (function (LightTypeEnum) {
            LightTypeEnum[LightTypeEnum["Direction"] = 0] = "Direction";
            LightTypeEnum[LightTypeEnum["Point"] = 1] = "Point";
            LightTypeEnum[LightTypeEnum["Spot"] = 2] = "Spot";
        })(LightTypeEnum = framework.LightTypeEnum || (framework.LightTypeEnum = {}));
        /**
        * @public
        * @language zh_CN
        * @classdesc
        * 灯光组件
        * @version m4m 1.0
        */
        var light = /** @class */ (function () {
            function light() {
                /**
                * @private
                */
                this.spotAngelCos = 0.9;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 光源范围
                 * @version m4m 1.0
                 */
                this.range = 10;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 光源强度
                 * @version m4m 1.0
                 */
                this.intensity = 1;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 光源颜色
                 * @version m4m 1.0
                 */
                this.color = new m4m.math.color(1.0, 1.0, 1.0, 1.0);
                /**
                * @public
                * @language zh_CN
                * @classdesc
                * 光照剔除mask
                * @version m4m 1.0
                */
                this.cullingMask = framework.CullingMask.everything; //最大 32个layer（32位） 默认everything = 0xffffffff
            }
            light.prototype.start = function () {
            };
            light.prototype.onPlay = function () {
            };
            light.prototype.update = function (delta) {
                var _scene = framework.sceneMgr.scene;
                if (_scene.autoCollectlightCamera) {
                    //收集灯光
                    var l = this;
                    if (l != null && l.gameObject.visible) {
                        _scene.addLight(l);
                    }
                }
            };
            /**
            * @private
            */
            light.prototype.remove = function () {
            };
            /**
            * @private
            */
            light.prototype.clone = function () {
            };
            light.ClassName = "light";
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], light.prototype, "type", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], light.prototype, "range", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], light.prototype, "intensity", void 0);
            __decorate([
                m4m.reflect.Field("color"),
                __metadata("design:type", m4m.math.color)
            ], light.prototype, "color", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], light.prototype, "cullingMask", void 0);
            light = __decorate([
                m4m.reflect.nodeComponent,
                m4m.reflect.nodeLight
            ], light);
            return light;
        }());
        framework.light = light;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
// /// <reference path="../../io/reflect.ts" />
// namespace m4m.framework
// {
//     /**
//     * @public
//     * @language zh_CN
//     * @classdesc
//     * 蒙皮网格渲染组件
//     * @version m4m 1.0
//     */
//     @reflect.nodeRender
//     @reflect.nodeComponent
//     export class skinnedMeshRenderer implements IRenderer
//     {
//         constructor()
//         {
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 挂载的gameobject
//          * @version m4m 1.0
//          */
//         gameObject: gameObject;
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 场景渲染层级（common、transparent、overlay）
//          * @version m4m 1.0
//          */
//         layer: RenderLayerEnum = RenderLayerEnum.Common;
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 渲染mask层级（和相机相对应）
//          * @version m4m 1.0
//          */
//         //renderLayer: CullingMask = CullingMask.default;
//         get renderLayer() { return this.gameObject.layer; }
//         set renderLayer(layer: number)
//         {
//             this.gameObject.layer = layer;
//         }
//         private issetq = false;
//         /**
//          * @private
//          */
//         _queue: number = 0;
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 返回此组件的场景渲染层级排序依据queue大小
//          * @version m4m 1.0
//          */
//         get queue(): number
//         {
//             return this._queue;
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 设置此组件的场景渲染层级排序number大小
//          * @version m4m 1.0
//          */
//         set queue(value: number)
//         {
//             this._queue = value;
//             this.issetq = true;
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 材质数组
//          * @version m4m 1.0
//          */
//         @m4m.reflect.Field("material[]")
//         materials: material[];
//         /**
//          * @private
//          */
//         _player: aniplayer;
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 返回动画播放组件
//          * @version m4m 1.0
//          */
//         get player(): aniplayer
//         {
//             if (this._player == null)
//             {
//                 this._player = this.gameObject.getComponentInParent("aniplayer") as aniplayer;
//             }
//             return this._player;
//         }
//         private _mesh: mesh;
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 返回mesh数据
//          * @version m4m 1.0
//          */
//         @m4m.reflect.Field("mesh")
//         get mesh()
//         {
//             return this._mesh;
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 设置mesh数据
//          * @version m4m 1.0
//          */
//         set mesh(mesh: mesh)
//         {
//             if (this._mesh != null)
//             {
//                 this._mesh.unuse();
//             }
//             this._mesh = mesh;
//             if (this._mesh != null)
//             {
//                 this._mesh.use();
//             }
//         }
//         /**
//          * @private
//          */
//         @m4m.reflect.Field("transform[]")
//         bones: transform[];
//         /**
//          * @private
//          */
//         @m4m.reflect.Field("transform")
//         rootBone: transform;
//         /**
//          * @private
//          */
//         // @m4m.reflect.Field("vector3")
//         center: math.vector3;
//         /**
//          * @private
//          */
//         // @m4m.reflect.Field("vector3")
//         size: math.vector3;
//         /**
//          * @public
//          * @language zh_CN
//          * @classdesc
//          * 最大骨骼数量
//          * @version m4m 1.0
//          */
//         maxBoneCount: number = 0;
//         //骨骼数据提交形态
//         private _skintype: number = 0;
//         //这个数据是扣掉tpose之后的
//         private _skeletonMatrixData: Float32Array;
//         /**
//          * @private
//          */
//         public static dataCaches: { key: string, data: Float32Array }[] = [];
//         private cacheData: Float32Array;
//         //是否高效
//         private _efficient: boolean = true;
//         start()
//         {
//         }
//         onPlay()
//         {
//         }
//         /**
//          * @private
//          * @param index 
//          */
//         getMatByIndex(index: number)
//         {
//             let data = this.mesh.data;
//             if (data.blendIndex[index].v0 >= this.maxBoneCount || data.blendIndex[index].v1 >= this.maxBoneCount || data.blendIndex[index].v2 >= this.maxBoneCount || data.blendIndex[index].v3 >= this.maxBoneCount)
//             {
//                 return null;
//             }
//             let mat = new m4m.math.matrix();
//             if (this._efficient)
//             {
//                 let vec40r = m4m.math.pool.new_vector4();
//                 let vec30p = m4m.math.pool.new_vector3();
//                 vec40r.x = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 0];
//                 vec40r.y = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 1];
//                 vec40r.z = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 2];
//                 vec40r.w = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 3];
//                 vec30p.x = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 4];
//                 vec30p.y = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 5];
//                 vec30p.z = this._skeletonMatrixData[8 * data.blendIndex[index].v0 + 6];
//                 let vec41r = m4m.math.pool.new_vector4();
//                 let vec31p = m4m.math.pool.new_vector3();
//                 vec41r.x = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 0];
//                 vec41r.y = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 1];
//                 vec41r.z = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 2];
//                 vec41r.w = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 3];
//                 vec31p.x = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 4];
//                 vec31p.y = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 5];
//                 vec31p.z = this._skeletonMatrixData[8 * data.blendIndex[index].v1 + 6];
//                 let vec42r = m4m.math.pool.new_vector4();
//                 let vec32p = m4m.math.pool.new_vector3();
//                 vec42r.x = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 0];
//                 vec42r.y = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 1];
//                 vec42r.z = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 2];
//                 vec42r.w = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 3];
//                 vec32p.x = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 4];
//                 vec32p.y = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 5];
//                 vec32p.z = this._skeletonMatrixData[8 * data.blendIndex[index].v2 + 6];
//                 let vec43r = m4m.math.pool.new_vector4();
//                 let vec33p = m4m.math.pool.new_vector3();
//                 vec43r.x = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 0];
//                 vec43r.y = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 1];
//                 vec43r.z = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 2];
//                 vec43r.w = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 3];
//                 vec33p.x = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 4];
//                 vec33p.y = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 5];
//                 vec33p.z = this._skeletonMatrixData[8 * data.blendIndex[index].v3 + 6];
//                 let mat0 = m4m.math.pool.new_matrix();
//                 let mat1 = m4m.math.pool.new_matrix();
//                 let mat2 = m4m.math.pool.new_matrix();
//                 let mat3 = m4m.math.pool.new_matrix();
//                 m4m.math.matrixMakeTransformRTS(vec30p, math.pool.vector3_one, vec40r, mat0);
//                 m4m.math.matrixMakeTransformRTS(vec31p, math.pool.vector3_one, vec41r, mat1);
//                 m4m.math.matrixMakeTransformRTS(vec32p, math.pool.vector3_one, vec42r, mat2);
//                 m4m.math.matrixMakeTransformRTS(vec33p, math.pool.vector3_one, vec43r, mat3);
//                 m4m.math.matrixScaleByNum(data.blendWeight[index].v0, mat0);
//                 m4m.math.matrixScaleByNum(data.blendWeight[index].v1, mat1);
//                 m4m.math.matrixScaleByNum(data.blendWeight[index].v2, mat2);
//                 m4m.math.matrixScaleByNum(data.blendWeight[index].v3, mat3);
//                 m4m.math.matrixAdd(mat0, mat1, mat);
//                 m4m.math.matrixAdd(mat, mat2, mat);
//                 m4m.math.matrixAdd(mat, mat3, mat);
//                 m4m.math.pool.delete_vector4(vec40r);
//                 m4m.math.pool.delete_vector4(vec41r);
//                 m4m.math.pool.delete_vector4(vec42r);
//                 m4m.math.pool.delete_vector4(vec43r);
//                 m4m.math.pool.delete_vector3(vec30p);
//                 m4m.math.pool.delete_vector3(vec31p);
//                 m4m.math.pool.delete_vector3(vec32p);
//                 m4m.math.pool.delete_vector3(vec33p);
//                 m4m.math.pool.delete_matrix(mat0);
//                 m4m.math.pool.delete_matrix(mat1);
//                 m4m.math.pool.delete_matrix(mat2);
//                 m4m.math.pool.delete_matrix(mat3);
//             }
//             else
//             {
//                 let mat0 = m4m.math.pool.new_matrix();
//                 mat0.rawData = this._skeletonMatrixData.slice(16 * data.blendIndex[index].v0, 16 * data.blendIndex[index].v0 + 16);
//                 let mat1 = m4m.math.pool.new_matrix();
//                 mat1.rawData = this._skeletonMatrixData.slice(16 * data.blendIndex[index].v1, 16 * data.blendIndex[index].v1 + 16);
//                 let mat2 = m4m.math.pool.new_matrix();
//                 mat2.rawData = this._skeletonMatrixData.slice(16 * data.blendIndex[index].v2, 16 * data.blendIndex[index].v2 + 16);
//                 let mat3 = m4m.math.pool.new_matrix();
//                 mat3.rawData = this._skeletonMatrixData.slice(16 * data.blendIndex[index].v3, 16 * data.blendIndex[index].v3 + 16);
//                 m4m.math.matrixScaleByNum(data.blendWeight[index].v0, mat0);
//                 m4m.math.matrixScaleByNum(data.blendWeight[index].v1, mat1);
//                 m4m.math.matrixScaleByNum(data.blendWeight[index].v2, mat2);
//                 m4m.math.matrixScaleByNum(data.blendWeight[index].v3, mat3);
//                 m4m.math.matrixAdd(mat0, mat1, mat);
//                 m4m.math.matrixAdd(mat, mat2, mat);
//                 m4m.math.matrixAdd(mat, mat3, mat);
//                 m4m.math.pool.delete_matrix(mat0);
//                 m4m.math.pool.delete_matrix(mat1);
//                 m4m.math.pool.delete_matrix(mat2);
//                 m4m.math.pool.delete_matrix(mat3);
//             }
//             return mat;
//         }
//         /**
//          * @public
//          * @language zh_CN
//          * @param ray 射线
//          * @classdesc
//          * 射线检测
//          * @version m4m 1.0
//          */
//         intersects(ray: ray, outInfo: pickinfo): boolean
//         {
//             let ishided = false;
//             let lastDistance = Number.MAX_VALUE;
//             let mvpmat = this.player.gameObject.transform.getWorldMatrix();
//             let data = this.mesh.data;
//             for (var i = 0; i < this.mesh.submesh.length; i++)
//             {
//                 var submesh = this.mesh.submesh[i];
//                 var t0 = m4m.math.pool.new_vector3();
//                 var t1 = m4m.math.pool.new_vector3();
//                 var t2 = m4m.math.pool.new_vector3();
//                 for (var index = submesh.start; index < submesh.size; index += 3)
//                 {
//                     let verindex0 = data.trisindex[index];
//                     let verindex1 = data.trisindex[index + 1];
//                     let verindex2 = data.trisindex[index + 2];
//                     var p0 = data.pos[verindex0];
//                     var p1 = data.pos[verindex1];
//                     var p2 = data.pos[verindex2];
//                     let mat0 = this.getMatByIndex(verindex0);
//                     let mat1 = this.getMatByIndex(verindex1);
//                     let mat2 = this.getMatByIndex(verindex2);
//                     if (mat0 == null || mat1 == null || mat2 == null) continue;
//                     let mat00 = m4m.math.pool.new_matrix();
//                     m4m.math.matrixMultiply(mvpmat, mat0, mat00);
//                     let mat11 = m4m.math.pool.new_matrix();
//                     m4m.math.matrixMultiply(mvpmat, mat1, mat11);
//                     let mat22 = m4m.math.pool.new_matrix();
//                     m4m.math.matrixMultiply(mvpmat, mat2, mat22);
//                     m4m.math.matrixTransformVector3(p0, mat00, t0);
//                     m4m.math.matrixTransformVector3(p1, mat11, t1);
//                     m4m.math.matrixTransformVector3(p2, mat22, t2);
//                     let tempinfo = math.pool.new_pickInfo();
//                     var bool = ray.intersectsTriangle(t0, t1, t2, tempinfo);
//                     if (bool)
//                     {
//                         if (tempinfo.distance < 0) continue;
//                         if (lastDistance > tempinfo.distance)
//                         {
//                             ishided = true;
//                             outInfo.cloneFrom(tempinfo);
//                             lastDistance = outInfo.distance;
//                             outInfo.faceId = index / 3;
//                             outInfo.subMeshId = i;
//                             var tdir = m4m.math.pool.new_vector3();
//                             m4m.math.vec3ScaleByNum(ray.direction, outInfo.distance, tdir);
//                             m4m.math.vec3Add(ray.origin, tdir, outInfo.hitposition);
//                             m4m.math.pool.delete_vector3(tdir);
//                         }
//                     }
//                     math.pool.delete_pickInfo(tempinfo);
//                 }
//                 m4m.math.pool.delete_vector3(t0);
//                 m4m.math.pool.delete_vector3(t1);
//                 m4m.math.pool.delete_vector3(t2);
//             }
//             return ishided;
//         }
//         update(delta: number)
//         {
//             if (this._skeletonMatrixData == null)
//             {
//                 //根据shader决定传什么数据
//                 this._skintype = this.useBoneShader(this.materials[0]);
//                 if (this._skintype == 1)
//                 {
//                     this.maxBoneCount = 24;
//                     this._skeletonMatrixData = new Float32Array(16 * this.maxBoneCount);
//                     this._efficient = false;
//                 }
//                 else if (this._skintype == 2)
//                 {
//                     this.maxBoneCount = 55;
//                     this._skeletonMatrixData = new Float32Array(8 * this.maxBoneCount);
//                     this._efficient = true;
//                 }
//             }
//             if (this.materials != null && this.materials.length > 0)
//             {
//                 let _mat = this.materials[0];
//                 if (_mat)
//                 {
//                     this.layer = _mat.getLayer();
//                     if (!this.issetq)
//                         this._queue = _mat.getQueue();
//                 }
//             }
//             if (this.player != null)
//             {
//                 if (this.player.isCache && !this.player.mix)
//                 {
//                     let cacheKey = this.player.cacheKey + "_" + this.mesh.getGUID();
//                     let data: Float32Array = skinnedMeshRenderer.dataCaches[cacheKey];
//                     if (!data)
//                     {
//                         let _cachePlayer = aniplayer.playerCaches[this.player.cacheKey];
//                         if (_cachePlayer)
//                         {
//                             let baseSize = this._efficient ? 8 : 16;
//                             data = new Float32Array(this.maxBoneCount * baseSize);
//                             _cachePlayer.fillPoseData(data, this.bones, this._efficient);
//                             skinnedMeshRenderer.dataCaches[cacheKey] = data;
//                             this.cacheData = data;
//                             return;
//                         }
//                     }
//                     else
//                     {
//                         this.cacheData = data;
//                         return;
//                     }
//                 }
//                 this.cacheData = null;
//                 if (this._skeletonMatrixData != null)
//                 {
//                     this.player.fillPoseData(this._skeletonMatrixData, this.bones, this._efficient);
//                 }
//             }
//         }
//         render(context: renderContext, assetmgr: assetMgr, camera: m4m.framework.camera)
//         {
//             DrawCallInfo.inc.currentState=DrawCallEnum.SKinrender;
//             if (this.player != null)
//             {
//                 context.updateLightMask(this.gameObject.layer);
//                 context.updateModel(this.player.gameObject.transform);
//             }
//             for (let i = 0; i < this.materials.length; i++)
//             {
//                 if (this.materials[i] == null) continue;
//                 if (this.cacheData != null && this._skintype > 0)
//                 {
//                     if (this._efficient)
//                     {
//                         //this.materials[i].setVector4v("glstate_vec4_bones", this.cacheData);
//                         context.vec4_bones = this.cacheData;
//                     }
//                     else
//                     {
//                         //this.materials[i].setMatrixv("glstate_matrix_bones", this.cacheData);
//                         context.matrix_bones = this.cacheData;
//                     }
//                     continue;
//                 }
//                 if (this._skeletonMatrixData != null && this._skintype > 0)
//                 {
//                     if (this._efficient)
//                     {
//                         //this.materials[i].setVector4v("glstate_vec4_bones", this._skeletonMatrixData);
//                         context.vec4_bones = this._skeletonMatrixData;
//                     }
//                     else
//                     {
//                         //this.materials[i].setMatrixv("glstate_matrix_bones", this._skeletonMatrixData);
//                         context.matrix_bones = this._skeletonMatrixData;
//                     }
//                 }
//             }
//             if (this._mesh && this.mesh.glMesh)
//             {
//                 this._mesh.glMesh.bindVboBuffer(context.webgl);
//                 if (this._mesh.submesh != null)
//                 {
//                     for (var i = 0; i < this._mesh.submesh.length; i++)
//                     {
//                         var sm = this._mesh.submesh[i];
//                         var mid = this._mesh.submesh[i].matIndex;//根据这个找到使用的具体哪个材质
//                         var usemat = this.materials[mid];
//                         if (usemat != null)
//                         {
//                             if (this.gameObject.transform.scene.fog)
//                             {
//                                 context.fog = this.gameObject.transform.scene.fog;
//                                 usemat.draw(context, this._mesh, sm, "skin_fog");
//                             } else
//                             {
//                                 usemat.draw(context, this._mesh, sm, "skin");
//                             }
//                         }
//                     }
//                 }
//             }
//         }
//         /**
//          * @private
//          */
//         remove()
//         {
//             this.materials.forEach(element =>
//             {
//                 if (element) element.unuse();
//             });
//             if (this.mesh)
//                 this.mesh.unuse(true);
//             this.bones.length = 0;
//         }
//         /**
//          * @private
//          */
//         clone()
//         {
//         }
//         /**
//          * @private
//          */
//         useBoneShader(mat: material): number
//         {
//             var matpasses: m4m.render.glDrawPass[] = mat.getShader().passes["skin"];
//             if (matpasses == null || matpasses.length == 0) return 0;
//             if (matpasses[0].mapuniforms["glstate_vec4_bones"] != null)
//                 return 2;
//             else if (matpasses[0].mapuniforms["glstate_matrix_bones"] != null)
//                 return 1;
//             return 0;
//         }
//     }
// }
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 球形碰撞盒结构体
         * @version m4m 1.0
         */
        var spherestruct = /** @class */ (function () {
            function spherestruct(_center, _r) {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 球形碰撞盒中心点
                 * @version m4m 1.0
                 */
                this.center = new m4m.math.vector3();
                this.tempScale = new m4m.math.vector3();
                this.srcCenter = new m4m.math.vector3();
                m4m.math.vec3Clone(_center, this.srcCenter);
                m4m.math.vec3Clone(_center, this.center);
                this.srcradius = _r;
            }
            spherestruct.prototype.update = function (worldmatrix) {
                m4m.math.matrixTransformVector3(this.srcCenter, worldmatrix, this.center);
                // m4m.math.matrixGetTranslation(worldmatrix, this.center);
                m4m.math.matrixGetScale(worldmatrix, this.tempScale);
                if (this.tempScale.x < this.tempScale.y)
                    this.tempScale.x = this.tempScale.y;
                if (this.tempScale.x < this.tempScale.z)
                    this.tempScale.x = this.tempScale.z;
                this.radius = this.srcradius * this.tempScale.x;
            };
            /**
             * @public
             * @language zh_CN
             * @param bound 碰撞体
             * @classdesc
             * 碰撞体检测碰撞
             * @version m4m 1.0
             */
            spherestruct.prototype.intersects = function (bound) {
                if (!bound)
                    return false;
                if (bound instanceof spherestruct) {
                    return framework.collision.sphereVsSphere(this, bound);
                    // let dis = math.vec3Distance(this.center, bound.center);
                    // if(dis > this.radius + bound.radius)    return false;
                    // return true;
                }
                else if (bound instanceof framework.obb) {
                    return framework.collision.obbVsSphere(bound, this);
                }
            };
            /**
             * @public
             * @language zh_CN
             * @param axis 指定轴
             * @param out 长度范围
             * @classdesc
             * 计算到指定轴上投影的长度
             * @version m4m 1.0
             */
            spherestruct.prototype.computeExtentsByAxis = function (axis, out) {
                var p = m4m.math.vec3Dot(this.center, axis);
                out.x = p - this.radius;
                out.y = p + this.radius;
            };
            return spherestruct;
        }());
        framework.spherestruct = spherestruct;
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 球形碰撞盒组件
         * @version m4m 1.0
         */
        var spherecollider = /** @class */ (function () {
            function spherecollider() {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 碰撞球中心点
                 * @version m4m 1.0
                 */
                this.center = new m4m.math.vector3();
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 碰撞球大小
                 * @version m4m 1.0
                 */
                this.radius = 0.5;
                /**
                 * @private
                 */
                this._worldCenter = new m4m.math.vector3();
                /**
                * @private
                */
                this._colliderVisible = false;
            }
            spherecollider_1 = spherecollider;
            Object.defineProperty(spherecollider.prototype, "worldCenter", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 碰撞球中心点
                 * @version m4m 1.0
                 */
                get: function () {
                    m4m.math.vec3Clone(this.center, this._worldCenter);
                    m4m.math.matrixTransformVector3(this._worldCenter, this.gameObject.transform.getWorldMatrix(), this._worldCenter);
                    return this._worldCenter;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 碰撞球数据
             * @version m4m 1.0
             */
            spherecollider.prototype.getBound = function () {
                return this.spherestruct;
            };
            Object.defineProperty(spherecollider.prototype, "matrix", {
                /**
                * @public
                * @language zh_CN
                * @classdesc
                * 获取该碰撞盒物体的世界矩阵
                * @version m4m 1.0
                */
                get: function () {
                    if (this.gameObject)
                        return this.gameObject.transform.getWorldMatrix();
                    return new m4m.math.matrix();
                },
                enumerable: false,
                configurable: true
            });
            spherecollider.prototype.start = function () {
                this.filter = this.gameObject.getComponent("meshFilter");
                this.build();
            };
            spherecollider.prototype.onPlay = function () {
            };
            spherecollider.prototype.update = function (delta) {
                if (this.spherestruct) {
                    this.spherestruct.update(this.matrix);
                    if (this.subTran && this.subTran.gameObject.components.length > 0) {
                        var r = this.spherestruct.radius;
                        var sc = m4m.math.pool.new_vector3(r, r, r);
                        this.subTran.setWorldScale(sc);
                        m4m.math.pool.delete_vector3(sc);
                        this.subTran.setWorldPosition(this.spherestruct.center);
                    }
                }
            };
            Object.defineProperty(spherecollider.prototype, "colliderVisible", {
                /**
                * @public
                * @language zh_CN
                * @classdesc
                * 返回碰撞盒可见性
                * @version m4m 1.0
                */
                get: function () {
                    return this._colliderVisible;
                },
                /**
                * @public
                * @language zh_CN
                * @classdesc
                * 设置碰撞盒是否可见
                * @version m4m 1.0
                */
                set: function (value) {
                    this._colliderVisible = value;
                    if (this._colliderVisible) {
                        if (!this.subTran) {
                            this.buildMesh();
                        }
                        // if(this.subTran && this.subTran.gameObject.components.length<1){
                        //     this.setMeshRenderer();
                        // }
                    }
                    if (this.subTran) {
                        this.subTran.gameObject.visible = this._colliderVisible;
                    }
                },
                enumerable: false,
                configurable: true
            });
            /**
            * @private
            */
            spherecollider.prototype.caclPlaneInDir = function (v0, v1, v2) {
                var subv0 = m4m.math.pool.new_vector3();
                var subv1 = m4m.math.pool.new_vector3();
                var cro0 = m4m.math.pool.new_vector3();
                var point = m4m.math.pool.new_vector3();
                m4m.math.vec3Subtract(v1, v0, subv0);
                m4m.math.vec3Subtract(v2, v1, subv1);
                m4m.math.vec3Cross(subv0, subv1, cro0);
                m4m.math.calPlaneLineIntersectPoint(cro0, v0, cro0, this.worldCenter, point);
                var sublp = m4m.math.pool.new_vector3();
                m4m.math.vec3Subtract(point, this.worldCenter, sublp);
                var val = m4m.math.vec3Dot(cro0, sublp);
                m4m.math.pool.delete_vector3(subv0);
                m4m.math.pool.delete_vector3(subv1);
                m4m.math.pool.delete_vector3(cro0);
                if (val <= 0)
                    return true;
                var dis = m4m.math.vec3Distance(this.worldCenter, point);
                m4m.math.pool.delete_vector3(point);
                if (dis < this.radius)
                    return true;
                return false;
            };
            /**
            * @public
            * @language zh_CN
            * @param tran 目标transform
            * @classdesc
            * 检测碰撞
            * @version m4m 1.0
            */
            spherecollider.prototype.intersectsTransform = function (tran) {
                if (tran.gameObject.collider == null)
                    return false;
                if (this.spherestruct == null || tran.gameObject.collider.getBound() == null)
                    return false;
                var _obb = tran.gameObject.collider.getBound();
                return this.spherestruct.intersects(_obb);
            };
            /**
            * @private
            * @language zh_CN
            * @classdesc
            * 构建碰撞盒
            * @version m4m 1.0
            */
            spherecollider.prototype.build = function () {
                if (this.center && this.radius) {
                    this.spherestruct = new spherestruct(this.center, this.radius);
                }
                //this.buildMesh();
            };
            /**
            * @private
            * @language zh_CN
            * @classdesc
            * 构建碰撞盒mesh 并显示
            * @version m4m 1.0
            */
            spherecollider.prototype.buildMesh = function () {
                this.subTran = new m4m.framework.transform();
                this.subTran.gameObject.hideFlags = framework.HideFlags.DontSave | framework.HideFlags.HideInHierarchy | framework.HideFlags.NotEditable;
                this.subTran.name = "sphereCollider";
                if (this._colliderVisible) {
                    this.setMeshRenderer();
                }
            };
            spherecollider.prototype.setMeshRenderer = function () {
                var mesh = this.subTran.gameObject.addComponent("meshFilter");
                mesh.mesh = this.gameObject.getScene().app.getAssetMgr().getDefaultMesh("sphere");
                var renderer = this.subTran.gameObject.addComponent("meshRenderer");
                //
                renderer.materials = [];
                if (!spherecollider_1.helpMat) {
                    var ass = this.gameObject.getScene().app.getAssetMgr();
                    spherecollider_1.helpMat = new framework.material("sphereCMat");
                    spherecollider_1.helpMat.defaultAsset = true;
                    spherecollider_1.helpMat.setShader(ass.getShader("shader/materialcolor"));
                    var color = new m4m.math.vector4(0, 1, 0, 1);
                    spherecollider_1.helpMat.setVector4("_Color", color);
                    spherecollider_1.helpMat.setFloat("_Alpha", 0.3);
                }
                renderer.materials[0] = spherecollider_1.helpMat;
                this.subTran.gameObject.visible = this._colliderVisible;
                this.gameObject.transform.addChild(this.subTran);
                this.gameObject.transform.markDirty();
                this.subTran.markDirty(); //要标记自己脏了，才会更新
                this.gameObject.transform.updateWorldTran();
            };
            /**
            * @private
            * @language zh_CN
            * @classdesc
            * 获取碰撞盒mesh
            * @version m4m 1.0
            */
            spherecollider.prototype.getColliderMesh = function () {
                var _mesh = new framework.mesh();
                // _mesh.data = m4m.render.meshData.genBoxByArray_Quad(this.obb.vectors);
                // var vf = m4m.render.VertexFormatMask.Position | m4m.render.VertexFormatMask.Normal;
                // var v32 = _mesh.data.genVertexDataArray(vf);
                // var i16 = _mesh.data.genIndexDataArrayQuad2Line();
                // var webgl = this.gameObject.getScene().webgl;
                // _mesh.glMesh = new m4m.render.glMesh();
                // _mesh.glMesh.initBuffer(webgl, vf, _mesh.data.pos.length);
                // _mesh.glMesh.uploadVertexSubData(webgl, v32);
                // _mesh.glMesh.addIndex(webgl, i16.length);
                // _mesh.glMesh.uploadIndexSubData(webgl, 0, i16);
                // _mesh.submesh = [];
                // {
                //     var sm = new subMeshInfo();
                //     sm.matIndex = 0;
                //     sm.start = 0;
                //     sm.size = i16.length;
                //     sm.line = true;
                //     _mesh.submesh.push(sm);
                // }
                return _mesh;
            };
            /**
            * @private
            */
            spherecollider.prototype.remove = function () {
                if (this.subTran) {
                    this.subTran.dispose();
                }
            };
            /**
            * @private
            */
            spherecollider.prototype.clone = function () {
            };
            var spherecollider_1;
            spherecollider.ClassName = "spherecollider";
            spherecollider.helpMat = null;
            __decorate([
                m4m.reflect.Field("vector3"),
                __metadata("design:type", m4m.math.vector3)
            ], spherecollider.prototype, "center", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], spherecollider.prototype, "radius", void 0);
            spherecollider = spherecollider_1 = __decorate([
                m4m.reflect.nodeComponent,
                m4m.reflect.nodeSphereCollider
            ], spherecollider);
            return spherecollider;
        }());
        framework.spherecollider = spherecollider;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
        * @public
        * @language zh_CN
        * @classdesc
        * 拖尾组件
        * @version m4m 1.0
        */
        var trailRender = /** @class */ (function () {
            function trailRender() {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 场景渲染层级（common、transparent、overlay）
                 * @version m4m 1.0
                 */
                this.layer = framework.RenderLayerEnum.Common;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 同场景渲染层级时候先后排序依据
                 * @version m4m 1.0
                 */
                this.queue = 0;
                this.width = 1.0;
                this.vertexcount = 24;
                // private targetpos:Float32Array;
                this.active = false;
                this.reInit = false;
                /**
               * @public
               * @language zh_CN
               * @classdesc
               * 拖尾mesh是否向经过路径的单边延展
               * @version m4m 1.0
               */
                this.extenedOneSide = true; //延展方向
                /**
                * @public
                * @language zh_CN
                * @classdesc
                * 拖尾是否朝向相机
                * @version m4m 1.0
                */
                this.lookAtCamera = false;
                //透明渐变
                this.isAlphaGradual = false;
                this.inited = false;
                this.speed = 0.5;
            }
            Object.defineProperty(trailRender.prototype, "renderLayer", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 渲染mask层级（和相机相对应）
                 * @version m4m 1.0
                 */
                //renderLayer: m4m.framework.CullingMask = CullingMask.default;
                get: function () { return this.gameObject.layer; },
                set: function (layer) {
                    this.gameObject.layer = layer;
                },
                enumerable: false,
                configurable: true
            });
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * start
            * @version m4m 1.0
            */
            trailRender.prototype.start = function () {
                this.app = this.gameObject.getScene().app;
                this.webgl = this.app.webgl;
                this.initmesh();
            };
            trailRender.prototype.onPlay = function () {
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * update
            * @version m4m 1.0
            */
            trailRender.prototype.update = function (delta) {
                if (!this.active)
                    return;
                if (!this.inited) {
                    this.intidata();
                }
                if (this.reInit) {
                    this.reInitdata();
                    this.reInit = false;
                }
                var targetpos = this.gameObject.transform.getWorldTranslate();
                if (this.lookAtCamera) {
                    this.camerapositon = framework.sceneMgr.app.getScene().mainCamera.gameObject.transform.getWorldTranslate();
                    var camdir = m4m.math.pool.new_vector3();
                    m4m.math.vec3Subtract(this.camerapositon, this.sticks[0].location, camdir);
                    m4m.math.vec3Normalize(camdir, camdir);
                    var direction = m4m.math.pool.new_vector3();
                    m4m.math.vec3Subtract(targetpos, this.sticks[0].location, direction);
                    m4m.math.vec3Normalize(direction, direction);
                    m4m.math.vec3Cross(camdir, direction, this.sticks[0].updir);
                    m4m.math.vec3ScaleByNum(this.sticks[0].updir, this.width, this.sticks[0].updir);
                    m4m.math.pool.delete_vector3(direction);
                }
                m4m.math.vec3Clone(targetpos, this.sticks[0].location);
                var length = this.sticks.length;
                for (var i = 1; i < length; i++) {
                    m4m.math.vec3SLerp(this.sticks[i].location, this.sticks[i - 1].location, this.speed, this.sticks[i].location);
                }
                //--------------------------------延展面片方向-------------------------------------------------
                if (this.lookAtCamera) {
                    for (var i = 1; i < length; i++) {
                        var tocamdir = m4m.math.pool.new_vector3();
                        m4m.math.vec3Subtract(this.camerapositon, this.sticks[i].location, tocamdir);
                        m4m.math.vec3Normalize(tocamdir, tocamdir);
                        var movedir = m4m.math.pool.new_vector3();
                        m4m.math.vec3Subtract(this.sticks[i - 1].location, this.sticks[i].location, movedir);
                        m4m.math.vec3Normalize(movedir, movedir);
                        m4m.math.vec3Cross(tocamdir, movedir, this.sticks[i].updir);
                        m4m.math.vec3ScaleByNum(this.sticks[i].updir, this.width, this.sticks[i].updir);
                        m4m.math.pool.delete_vector3(tocamdir);
                    }
                }
                else {
                    this.gameObject.transform.getUpInWorld(this.sticks[0].updir);
                    m4m.math.vec3ScaleByNum(this.sticks[0].updir, this.width, this.sticks[0].updir);
                    for (var i = 1; i < length; i++) {
                        m4m.math.vec3SLerp(this.sticks[i].updir, this.sticks[i - 1].updir, this.speed, this.sticks[i].updir);
                    }
                }
                this.updateTrailData();
            };
            Object.defineProperty(trailRender.prototype, "material", {
                /**
                * @public
                * @language zh_CN
                * @classdesc
                * 得到拖尾上的材质
                * @version m4m 1.0
                */
                get: function () {
                    if (this._material != undefined) {
                        return this._material;
                    }
                    else {
                        var mat = new m4m.framework.material();
                        mat.setShader(this.app.getAssetMgr().getShader("shader/def"));
                        this.material = mat;
                        return this._material;
                    }
                },
                //-----------------------------------------------------------------------------------------------
                /**
                 * @public
                 * @language zh_CN
                * @param material 材质
                 * @classdesc
                 * 设置拖尾的材质
                 * @version m4m 1.0
                 */
                set: function (material) {
                    this._material = material;
                    this.layer = this.material.getLayer();
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(trailRender.prototype, "color", {
                /**
                * @public
                * @language zh_CN
                * @classdesc
                *  返回 matrial调色
                * @version m4m 1.0
                */
                get: function () {
                    if (this._color == undefined) {
                        this._color = new m4m.math.color(1, 1, 1, 1);
                    }
                    return this._color;
                },
                /**
                * @public
                * @language zh_CN
                * @classdesc
                *设置 matrial颜色
                * @version m4m 1.0
                */
                set: function (color) {
                    this._color = color;
                },
                enumerable: false,
                configurable: true
            });
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 拖尾速度，调节拖尾长短（0-1）
            * @version m4m 1.0
            */
            trailRender.prototype.setspeed = function (upspeed) {
                this.speed = upspeed;
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 调节拖尾宽度
            * @version m4m 1.0
            */
            trailRender.prototype.setWidth = function (Width) {
                this.width = Width;
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 开始拖尾
            * @version m4m 1.0
            */
            trailRender.prototype.play = function () {
                //this.intidata();//项目喜欢添加组件后立刻播放，会报错，此时组件的start还没走
                this.reInit = true;
                this.active = true;
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 关闭拖尾
            * @version m4m 1.0
            */
            trailRender.prototype.stop = function () {
                this.active = false;
            };
            //------------------------------------------------------------------------------------------------------
            trailRender.prototype.initmesh = function () {
                this.mesh = new m4m.framework.mesh();
                this.mesh.data = new m4m.render.meshData();
                this.mesh.glMesh = new m4m.render.glMesh();
                this.dataForVbo = new Float32Array(this.vertexcount * 9);
                this.dataForEbo = new Uint16Array((this.vertexcount / 2 - 1) * 6);
                var vf = m4m.render.VertexFormatMask.Position | m4m.render.VertexFormatMask.Color | m4m.render.VertexFormatMask.UV0;
                this.mesh.glMesh.initBuffer(this.webgl, vf, this.vertexcount, m4m.render.MeshTypeEnum.Dynamic);
                this.mesh.glMesh.addIndex(this.webgl, this.dataForEbo.length);
                this.mesh.glMesh.initVAO();
                this.mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.start = 0;
                    sm.size = this.dataForEbo.length;
                    sm.line = false;
                    this.mesh.submesh.push(sm);
                }
                //this.intidata();
            };
            trailRender.prototype.reInitdata = function () {
                if (!this.inited)
                    return;
                var length = this.vertexcount / 2;
                for (var i = 0; i < length; i++) {
                    var sti = this.sticks[i];
                    m4m.math.vec3Clone(this.gameObject.transform.getWorldTranslate(), sti.location);
                    this.gameObject.transform.getUpInWorld(sti.updir);
                    m4m.math.vec3ScaleByNum(sti.updir, this.width, sti.updir);
                }
            };
            trailRender.prototype.intidata = function () {
                //用棍子去刷顶点
                //用逻辑去刷棍子
                this.sticks = [];
                for (var i = 0; i < this.vertexcount / 2; i++) {
                    var ts = new trailStick();
                    this.sticks.push(ts);
                    ts.location = new m4m.math.vector3();
                    m4m.math.vec3Clone(this.gameObject.transform.getWorldTranslate(), ts.location);
                    ts.updir = new m4m.math.vector3();
                    this.gameObject.transform.getUpInWorld(ts.updir);
                    m4m.math.vec3ScaleByNum(ts.updir, this.width, ts.updir);
                }
                var length = this.vertexcount / 2;
                //-----------------------------------------------
                var updir = m4m.math.pool.new_vector3();
                this.gameObject.transform.getUpInWorld(updir);
                m4m.math.vec3ScaleByNum(updir, this.width, updir);
                var pos = m4m.math.pool.new_vector3();
                m4m.math.vec3Clone(this.gameObject.transform.getWorldTranslate(), pos);
                var uppos = m4m.math.pool.new_vector3();
                m4m.math.vec3Add(pos, updir, uppos);
                var downpos = m4m.math.pool.new_vector3();
                m4m.math.vec3Subtract(pos, updir, downpos);
                for (var i = 0; i < length; i++) {
                    var tempA = this.isAlphaGradual ? (length - i - 1) / length : 1;
                    this.dataForVbo[i * 2 * 9] = uppos.x;
                    this.dataForVbo[i * 2 * 9 + 1] = uppos.y;
                    this.dataForVbo[i * 2 * 9 + 2] = uppos.z;
                    this.dataForVbo[i * 2 * 9 + 3] = this.color.r;
                    this.dataForVbo[i * 2 * 9 + 4] = this.color.g;
                    this.dataForVbo[i * 2 * 9 + 5] = this.color.b;
                    this.dataForVbo[i * 2 * 9 + 6] = this.color.a * tempA;
                    this.dataForVbo[i * 2 * 9 + 7] = i / (length - 1);
                    this.dataForVbo[i * 2 * 9 + 8] = 0;
                    this.dataForVbo[(i * 2 + 1) * 9] = downpos.x;
                    this.dataForVbo[(i * 2 + 1) * 9 + 1] = downpos.y;
                    this.dataForVbo[(i * 2 + 1) * 9 + 2] = downpos.z;
                    this.dataForVbo[(i * 2 + 1) * 9 + 3] = this.color.r;
                    this.dataForVbo[(i * 2 + 1) * 9 + 4] = this.color.g;
                    this.dataForVbo[(i * 2 + 1) * 9 + 5] = this.color.b;
                    this.dataForVbo[(i * 2 + 1) * 9 + 6] = this.color.a * tempA;
                    this.dataForVbo[(i * 2 + 1) * 9 + 7] = i / (length - 1);
                    this.dataForVbo[(i * 2 + 1) * 9 + 8] = 1;
                }
                //--------------------------------------     
                for (var k = 0; k < length - 1; k++) {
                    this.dataForEbo[k * 6 + 0] = k * 2;
                    this.dataForEbo[k * 6 + 1] = (k + 1) * 2;
                    this.dataForEbo[k * 6 + 2] = k * 2 + 1;
                    this.dataForEbo[k * 6 + 3] = k * 2 + 1;
                    this.dataForEbo[k * 6 + 4] = (k + 1) * 2;
                    this.dataForEbo[k * 6 + 5] = (k + 1) * 2 + 1;
                }
                this.mesh.glMesh.uploadVertexData(this.webgl, this.dataForVbo);
                this.mesh.glMesh.uploadIndexData(this.webgl, 0, this.dataForEbo);
                m4m.math.pool.delete_vector3(updir);
                m4m.math.pool.delete_vector3(pos);
                m4m.math.pool.delete_vector3(uppos);
                m4m.math.pool.delete_vector3(downpos);
                this.inited = true;
            };
            trailRender.prototype.updateTrailData = function () {
                var length = this.vertexcount / 2;
                if (this.extenedOneSide) {
                    for (var i = 0; i < length; i++) {
                        var pos = this.sticks[i].location;
                        var up = this.sticks[i].updir;
                        this.dataForVbo[i * 2 * 9] = pos.x;
                        this.dataForVbo[i * 2 * 9 + 1] = pos.y;
                        this.dataForVbo[i * 2 * 9 + 2] = pos.z;
                        this.dataForVbo[(i * 2 + 1) * 9] = pos.x + up.x;
                        this.dataForVbo[(i * 2 + 1) * 9 + 1] = pos.y + up.y;
                        this.dataForVbo[(i * 2 + 1) * 9 + 2] = pos.z + up.z;
                    }
                }
                else {
                    for (var i = 0; i < length; i++) {
                        var pos = this.sticks[i].location;
                        var up = this.sticks[i].updir;
                        this.dataForVbo[i * 2 * 9] = pos.x - up.x;
                        this.dataForVbo[i * 2 * 9 + 1] = pos.y - up.y;
                        this.dataForVbo[i * 2 * 9 + 2] = pos.z - up.z;
                        this.dataForVbo[(i * 2 + 1) * 9] = pos.x + up.x;
                        this.dataForVbo[(i * 2 + 1) * 9 + 1] = pos.y + up.y;
                        this.dataForVbo[(i * 2 + 1) * 9 + 2] = pos.z + up.z;
                    }
                }
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * render
            * @version m4m 1.0
            */
            trailRender.prototype.render = function (context, assetmgr, camera) {
                if (!this.active)
                    return;
                context.updateModeTrail();
                this.mesh.glMesh.uploadVertexData(context.webgl, this.dataForVbo);
                //--------------------------render-------------------------------------------
                if (this.gameObject.getScene().fog) {
                    // context.fog = this.gameObject.getScene().fog;
                    this.material.draw(context, this.mesh, this.mesh.submesh[0], "base_fog");
                }
                else {
                    this.material.draw(context, this.mesh, this.mesh.submesh[0], "base");
                }
            };
            /**
            * @private
            */
            trailRender.prototype.clone = function () {
            };
            /**
            * @private
            */
            trailRender.prototype.remove = function () {
            };
            trailRender.ClassName = "trailRender";
            trailRender = __decorate([
                m4m.reflect.nodeRender,
                m4m.reflect.nodeComponent
            ], trailRender);
            return trailRender;
        }());
        framework.trailRender = trailRender;
        /**
         * @private
         */
        var trailStick = /** @class */ (function () {
            function trailStick() {
            }
            return trailStick;
        }());
        framework.trailStick = trailStick;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
        * @private
        * @language zh_CN
        * @classdesc
        * 拖尾组件，废弃
        * @version m4m 1.0
        */
        var trailRender_recorde = /** @class */ (function () {
            function trailRender_recorde() {
                //記錄軌跡
                this.layer = framework.RenderLayerEnum.Common;
                this.queue = 0;
                //width:number=1;
                this._startWidth = 1;
                this._endWidth = 0;
                this.lifetime = 0.35;
                this.minStickDistance = 0.1;
                this.maxStickCout = 12;
                this.nodes = [];
                this.interpolate = false; //是否中间插点完成平滑
                this.interpNumber = 3;
                this.interpPath = [];
                this.activeMaxpointlimit = false;
                this.notRender = false;
            }
            Object.defineProperty(trailRender_recorde.prototype, "renderLayer", {
                //renderLayer: m4m.framework.CullingMask = CullingMask.default;
                get: function () { return this.gameObject.layer; },
                set: function (layer) {
                    this.gameObject.layer = layer;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(trailRender_recorde.prototype, "material", {
                get: function () {
                    if (this._material != undefined) {
                        return this._material;
                    }
                    else {
                        var mat = new m4m.framework.material();
                        mat.setShader(this.app.getAssetMgr().getShader("shader/def"));
                        this._material = mat;
                        return this._material;
                    }
                },
                //-----------------------------------------------------------------------------------------------
                set: function (material) {
                    this._material = material;
                    this.layer = this._material.getLayer();
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(trailRender_recorde.prototype, "startColor", {
                get: function () {
                    if (this._startColor == undefined) {
                        this._startColor = new m4m.math.color(1, 1, 1, 1);
                    }
                    return this._startColor;
                },
                set: function (color) {
                    this._startColor = color;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(trailRender_recorde.prototype, "endColor", {
                get: function () {
                    if (this._endColor == undefined) {
                        this._endColor = new m4m.math.color(this.startColor.r, this.startColor.g, this.startColor.b, 0);
                    }
                    return this._endColor;
                },
                set: function (color) {
                    this._endColor = color;
                },
                enumerable: false,
                configurable: true
            });
            trailRender_recorde.prototype.setWidth = function (startWidth, endWidth) {
                if (endWidth === void 0) { endWidth = 0; }
                this._startWidth = startWidth;
                this._endWidth = endWidth;
            };
            trailRender_recorde.prototype.setMaxpointcontroll = function (value) {
                if (value === void 0) { value = false; }
                this.activeMaxpointlimit = value;
            };
            //------------------------------------------------------------------------------------------------------
            trailRender_recorde.prototype.start = function () {
                this.app = this.gameObject.getScene().app;
                this.webgl = this.app.webgl;
                this.mesh = new m4m.framework.mesh();
                this.mesh.data = new m4m.render.meshData();
                this.mesh.glMesh = new m4m.render.glMesh();
                this.dataForVbo = new Float32Array(128);
                this.dataForEbo = new Uint16Array(128);
                var vf = m4m.render.VertexFormatMask.Position | m4m.render.VertexFormatMask.Color | m4m.render.VertexFormatMask.UV0;
                this.mesh.glMesh.initBuffer(this.webgl, vf, 128, m4m.render.MeshTypeEnum.Dynamic);
                this.mesh.glMesh.addIndex(this.webgl, this.dataForEbo.length);
                this.mesh.glMesh.initVAO();
                this.mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.start = 0;
                    sm.size = this.dataForEbo.length;
                    sm.line = false;
                    this.mesh.submesh.push(sm);
                }
                if (this.interpolate) {
                    this.maxStickCout *= this.interpNumber;
                    this.targetPath = this.interpPath;
                }
                else {
                    this.targetPath = this.nodes;
                }
            };
            trailRender_recorde.prototype.onPlay = function () {
            };
            trailRender_recorde.prototype.update = function (delta) {
                var _time = this.app.getTotalTime();
                this.refreshTrailNode(_time);
                this.updateTrailData(_time);
            };
            /**
            * @private
            */
            trailRender_recorde.prototype.remove = function () {
            };
            trailRender_recorde.prototype.refreshTrailNode = function (curTime) {
                //移除死掉的粒子
                while (this.targetPath.length > 0 && curTime > this.targetPath[this.targetPath.length - 1].time + this.lifetime) {
                    this.targetPath.pop();
                }
                //插入新粒子
                var pos = new m4m.math.vector3();
                m4m.math.vec3Clone(this.gameObject.transform.getWorldTranslate(), pos);
                var length = this.targetPath.length;
                if (length != 0) {
                    if (m4m.math.vec3Distance(pos, this.targetPath[0].location) < this.minStickDistance)
                        return;
                }
                var updir = new m4m.math.vector3();
                this.gameObject.transform.getUpInWorld(updir);
                var newNode = new trailNode(pos, updir, curTime);
                this.nodes.unshift(newNode);
                if (this.interpolate) {
                    if (this.nodes.length > 2) {
                        var handle1 = new m4m.math.vector3();
                        m4m.math.vec3Subtract(this.nodes[2].location, this.nodes[0].location, handle1);
                        m4m.math.vec3Normalize(handle1, handle1);
                        this.nodes[1].handle = handle1;
                        if (this.nodes[2].handle == undefined) {
                            var handdle = new m4m.math.vector3();
                            m4m.math.vec3Subtract(this.nodes[2].location, this.nodes[1].location, handdle);
                            m4m.math.vec3Normalize(handdle, handdle);
                            this.nodes[2].handle = handdle;
                        }
                        var vec3Distance = m4m.math.vec3Distance(this.nodes[2].location, this.nodes[1].location);
                        //this.nodes[1].trailNodes = [];
                        for (var i = 0; i < this.interpNumber; i++) {
                            var lerp = (i + 1) / (this.interpNumber + 1);
                            var inter_pos = new m4m.math.vector3();
                            var tempRhandle = m4m.math.pool.new_vector3();
                            var tempLhandle = m4m.math.pool.new_vector3();
                            // m4m.math.vec3Subtract(m4m.math.pool.vector3_one, this.nodes[2].handle, tempLhandle);
                            tempLhandle.x = -this.nodes[2].handle.x;
                            tempLhandle.y = -this.nodes[2].handle.y;
                            tempLhandle.z = -this.nodes[2].handle.z;
                            m4m.math.vec3ScaleByNum(tempLhandle, vec3Distance / 2, tempLhandle);
                            m4m.math.vec3Add(tempLhandle, this.nodes[2].location, tempLhandle);
                            m4m.math.vec3ScaleByNum(this.nodes[1].handle, vec3Distance / 2, tempRhandle);
                            m4m.math.vec3Add(tempRhandle, this.nodes[1].location, tempRhandle);
                            m4m.math.GetPointAlongCurve(this.nodes[2].location, tempLhandle, this.nodes[1].location, tempRhandle, (i + 1) / (this.interpNumber + 1), inter_pos);
                            var inter_updir = new m4m.math.vector3();
                            m4m.math.vec3SLerp(this.nodes[1].updir, this.nodes[2].updir, lerp, inter_updir);
                            var inter_node = new trailNode(inter_pos, inter_updir, curTime);
                            // this.interpPath.unshift(inter_node);
                            this.interpPath.splice(1, 0, inter_node);
                            m4m.math.pool.delete_vector3(tempRhandle);
                            m4m.math.pool.delete_vector3(tempLhandle);
                        }
                        this.interpPath.unshift(newNode);
                    }
                }
                // while (this.nodes.length > 0 && curTime > this.nodes[this.nodes.length - 1].time + this.lifetime) {
                //     this.nodes.pop();
                // }
                //控制粒子数量
                if (this.activeMaxpointlimit) {
                    while (this.targetPath.length > this.maxStickCout) {
                        this.targetPath.pop();
                    }
                }
            };
            trailRender_recorde.prototype.updateTrailData = function (curTime) {
                if (this.nodes.length < 2) {
                    this.notRender = true;
                    return;
                }
                else {
                    this.notRender = false;
                }
                this.checkBufferSize();
                for (var i = 0; i < this.targetPath.length; i++) {
                    var curNode = this.targetPath[i];
                    var u = i / this.targetPath.length;
                    var timeAlong = (curTime - curNode.time) / this.lifetime;
                    var _updir = new m4m.math.vector3();
                    m4m.math.vec3Clone(curNode.updir, _updir);
                    var _width = this._startWidth + (this._endWidth - this._startWidth) * timeAlong;
                    m4m.math.vec3ScaleByNum(_updir, _width, _updir);
                    var tempPos = m4m.math.pool.new_vector3();
                    m4m.math.vec3Add(curNode.location, _updir, tempPos);
                    this.dataForVbo[2 * i * 9 + 0] = tempPos.x;
                    this.dataForVbo[2 * i * 9 + 1] = tempPos.y;
                    this.dataForVbo[2 * i * 9 + 2] = tempPos.z;
                    var tempColor = m4m.math.pool.new_color();
                    m4m.math.colorLerp(this.startColor, this.endColor, timeAlong, tempColor);
                    this.dataForVbo[2 * i * 9 + 3] = tempColor.r;
                    this.dataForVbo[2 * i * 9 + 4] = tempColor.g;
                    this.dataForVbo[2 * i * 9 + 5] = tempColor.b;
                    this.dataForVbo[2 * i * 9 + 6] = tempColor.a;
                    this.dataForVbo[2 * i * 9 + 7] = u;
                    //this.dataForVbo[2 * i * 9 + 7] = timeAlong;
                    this.dataForVbo[2 * i * 9 + 8] = 1.0;
                    //m4m.math.vec3Subtract(curNode.location, _updir, tempPos);
                    this.dataForVbo[(2 * i + 1) * 9 + 0] = curNode.location.x;
                    this.dataForVbo[(2 * i + 1) * 9 + 1] = curNode.location.y;
                    this.dataForVbo[(2 * i + 1) * 9 + 2] = curNode.location.z;
                    this.dataForVbo[(2 * i + 1) * 9 + 3] = tempColor.r;
                    this.dataForVbo[(2 * i + 1) * 9 + 4] = tempColor.g;
                    this.dataForVbo[(2 * i + 1) * 9 + 5] = tempColor.b;
                    this.dataForVbo[(2 * i + 1) * 9 + 6] = tempColor.a;
                    var u = i / this.nodes.length;
                    this.dataForVbo[(2 * i + 1) * 9 + 7] = u;
                    //this.dataForVbo[(2 * i + 1) * 9 + 7] = timeAlong;
                    this.dataForVbo[(2 * i + 1) * 9 + 8] = 0;
                    m4m.math.pool.delete_vector3(tempPos);
                    m4m.math.pool.delete_color(tempColor);
                }
                for (var k = 0; k < this.nodes.length - 1; k++) {
                    this.dataForEbo[k * 6 + 0] = k * 2;
                    this.dataForEbo[k * 6 + 1] = (k + 1) * 2;
                    this.dataForEbo[k * 6 + 2] = k * 2 + 1;
                    this.dataForEbo[k * 6 + 3] = k * 2 + 1;
                    this.dataForEbo[k * 6 + 4] = (k + 1) * 2;
                    this.dataForEbo[k * 6 + 5] = (k + 1) * 2 + 1;
                }
            };
            trailRender_recorde.prototype.checkBufferSize = function () {
                var stickNumber = this.targetPath.length;
                if (stickNumber * 2 * 9 > this.dataForVbo.length) {
                    var length = this.dataForVbo.length;
                    this.mesh.glMesh.resetVboSize(this.webgl, length * 2);
                    this.dataForVbo = new Float32Array(length * 2);
                }
                if ((stickNumber - 1) * 6 > this.dataForEbo.length) {
                    var length = this.dataForEbo.length;
                    this.mesh.glMesh.resetEboSize(this.webgl, 0, length * 2);
                    this.dataForEbo = new Uint16Array(length * 2);
                }
            };
            trailRender_recorde.prototype.render = function (context, assetmgr, camera) {
                if (this.notRender)
                    return;
                context.updateModeTrail();
                this.mesh.glMesh.uploadVertexData(context.webgl, this.dataForVbo);
                this.mesh.glMesh.uploadIndexData(context.webgl, 0, this.dataForEbo);
                this.mesh.submesh[0].size = (this.targetPath.length - 1) * 6;
                //--------------------------render-------------------------------------------
                if (this.gameObject.getScene().fog) {
                    // context.fog = this.gameObject.getScene().fog;
                    this.material.draw(context, this.mesh, this.mesh.submesh[0], "base_fog");
                }
                else {
                    this.material.draw(context, this.mesh, this.mesh.submesh[0], "base");
                }
            };
            /**
            * @private
            */
            trailRender_recorde.prototype.clone = function () {
            };
            trailRender_recorde.ClassName = "trailRender_recorde";
            trailRender_recorde = __decorate([
                m4m.reflect.nodeRender,
                m4m.reflect.nodeComponent
            ], trailRender_recorde);
            return trailRender_recorde;
        }());
        framework.trailRender_recorde = trailRender_recorde;
        var trailNode = /** @class */ (function () {
            function trailNode(p, updir, t) {
                this.location = p;
                this.updir = updir;
                this.time = t;
            }
            return trailNode;
        }());
        framework.trailNode = trailNode;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../io/reflect.ts" />
var m4m;
/// <reference path="../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * Vignetting后期效果 控制器
         * @version m4m 1.0
         */
        var vignettingCtr = /** @class */ (function () {
            function vignettingCtr() {
                this.tag = "__vignettingtag__";
                this._init = false;
            }
            vignettingCtr.prototype.init = function () {
                var sh = this.scene.app.getAssetMgr().getShader("vignetting.shader.json");
                if (!sh) {
                    console.warn("vignetting.shader.json not find");
                    return;
                }
                var psize = 1024;
                var color = new framework.cameraPostQueue_Color();
                color[this.tag] = true;
                color.renderTarget = new m4m.render.glRenderTarget(this.scene.webgl, psize, psize, true, false);
                if (!this.camera.postQueues)
                    this.camera.postQueues = [];
                this.camera.postQueues.push(color);
                var textcolor = new framework.texture("_color");
                textcolor.glTexture = color.renderTarget;
                // Blur
                var texsize = 512;
                var blur_post = new m4m.framework.cameraPostQueue_Quad();
                blur_post.renderTarget = new m4m.render.glRenderTarget(this.scene.webgl, texsize, texsize, true, false);
                blur_post.material.setShader(this.scene.app.getAssetMgr().getShader("separate_blur.shader.json"));
                blur_post.material.setTexture("_MainTex", textcolor);
                blur_post.material.setVector4("sample_offsets", new m4m.math.vector4(0, 1.0, 0, -1.0));
                blur_post.material.setVector4("_MainTex_TexelSize", new m4m.math.vector4(1.0 / texsize, 1.0 / texsize, texsize, texsize));
                this.camera.postQueues.push(blur_post);
                var blur0 = new m4m.framework.texture("_blur0");
                blur0.glTexture = blur_post.renderTarget;
                var blur_post1 = new m4m.framework.cameraPostQueue_Quad();
                blur_post1.renderTarget = new m4m.render.glRenderTarget(this.scene.webgl, texsize, texsize, true, false);
                blur_post1.material.setShader(this.scene.app.getAssetMgr().getShader("separate_blur.shader.json"));
                blur_post1.material.setTexture("_MainTex", blur0);
                blur_post1.material.setVector4("sample_offsets", new m4m.math.vector4(1.0, 0, -1.0, 0));
                blur_post1.material.setVector4("_MainTex_TexelSize", new m4m.math.vector4(1.0 / texsize, 1.0 / texsize, texsize, texsize));
                this.camera.postQueues.push(blur_post1);
                var blur = new m4m.framework.texture("_blur0");
                blur.glTexture = blur_post1.renderTarget;
                // Vignetting
                var post0 = new framework.cameraPostQueue_Quad();
                // post0[this.tag] = true;
                this.material_1 = post0.material;
                post0.material.use();
                post0.material.setShader(sh);
                post0.material.setTexture("_MainTex", textcolor);
                post0.material.setTexture("_BlurTex", blur);
                post0.material.setFloat("_Vignetting", 0.3);
                post0.material.setFloat("_Blurred_Corners", 3.0);
                post0.material.setFloat("_Chromatic_Aberration", 3.0);
                // post0.material.setVector4("_MainTex_TexelSize",new m4m.math.vector4( 1/psize,1/psize,psize,psize));
                this.camera.postQueues.push(post0);
                this._init = true;
            };
            vignettingCtr.prototype.start = function () {
                this.app = this.gameObject.transform.scene.app;
                this.scene = this.app.getScene();
            };
            vignettingCtr.prototype.onPlay = function () {
            };
            vignettingCtr.prototype.update = function (delta) {
                if (this._init)
                    return;
                if (!this.camera)
                    this.camera = this.gameObject.getComponent("camera");
                if (this.camera)
                    this.init();
            };
            /**
             * @private
             */
            vignettingCtr.prototype.remove = function () {
                this._init = false;
                if (this.camera) {
                    var arr_2 = this.camera.postQueues;
                    var dArr = [];
                    for (var i = 0; i < arr_2.length; i++) {
                        var temp = arr_2[i];
                        if (temp[this.tag]) {
                            dArr.push(temp);
                        }
                    }
                    dArr.forEach(function (element) {
                        if (element) {
                            var idx = arr_2.indexOf(element);
                            if (idx != -1) {
                                arr_2.splice(idx, 1);
                            }
                        }
                    });
                }
                if (this.material) {
                    this.material.unuse();
                    this.material = null;
                }
                if (this.material_1) {
                    this.material_1.unuse();
                    this.material_1 = null;
                }
                if (this.material_2) {
                    this.material_2.unuse();
                    this.material_2 = null;
                }
                if (this.material_3) {
                    this.material_3.unuse();
                    this.material_3 = null;
                }
            };
            /**
             * @private
             */
            vignettingCtr.prototype.clone = function () {
            };
            vignettingCtr.ClassName = "vignettingCtr";
            vignettingCtr = __decorate([
                m4m.reflect.nodeComponent
            ], vignettingCtr);
            return vignettingCtr;
        }());
        framework.vignettingCtr = vignettingCtr;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var f14EffectSystem = /** @class */ (function () {
            function f14EffectSystem(bundleName) {
                this.bundleName = bundleName;
                this.layer = framework.RenderLayerEnum.Transparent;
                this.queue = 10;
                this.fps = 30;
                this.layers = [];
                //--------------------------------------------------------------------
                this.VF = m4m.render.VertexFormatMask.Position | m4m.render.VertexFormatMask.Color | m4m.render.VertexFormatMask.UV0;
                this._delayTime = 0;
                this.elements = [];
                this.renderBatch = [];
                this.loopCount = 0;
                this.allTime = 0;
                this.renderActive = false;
                this.beref = false;
                this.mvpMat = new m4m.math.matrix();
                this.totalTime = 0;
                this.totalFrame = 0;
                this.playRate = 1.0;
                //private playState:PlayStateEnum=PlayStateEnum.beReady;
                //private active:boolean=false;
                this.enabletimeFlow = false;
                this.enableDraw = false;
            }
            Object.defineProperty(f14EffectSystem.prototype, "renderLayer", {
                //renderLayer: CullingMask=CullingMask.default;
                get: function () { return this.gameObject.layer; },
                set: function (layer) {
                    this.gameObject.layer = layer;
                },
                enumerable: false,
                configurable: true
            });
            f14EffectSystem.prototype.start = function () {
                if (this.data && this.data.beloop == true) {
                    this.play();
                }
            };
            f14EffectSystem.prototype.onPlay = function () {
            };
            Object.defineProperty(f14EffectSystem.prototype, "f14eff", {
                /**
                 * f14eff 资源
                 * @private
                 */
                get: function () {
                    return this._f14eff;
                },
                set: function (asset) {
                    if (this._f14eff != null) {
                        this._f14eff.unuse();
                    }
                    this._f14eff = asset;
                    this.bundleName = asset.assetbundle;
                    this.setData(asset.data, this.bundleName);
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(f14EffectSystem.prototype, "delay", {
                /**
                 * delaytime
                 * @private
                 */
                get: function () {
                    return this._delayTime;
                },
                set: function (deley) {
                    this._delayTime = deley;
                },
                enumerable: false,
                configurable: true
            });
            f14EffectSystem.prototype.setData = function (data, bundleName) {
                //-------------------准备各种需要访问
                this.webgl = m4m.framework.sceneMgr.app.webgl;
                this.data = data;
                for (var i = 0, count = this.data.layers.length; i < count; i++) {
                    var layerdata = this.data.layers[i];
                    this.addF14layer(layerdata.type, layerdata, bundleName);
                }
                for (var i = 0; i < this.renderBatch.length; i++) {
                    if (this.renderBatch[i].type == framework.F14TypeEnum.SingleMeshType) {
                        this.renderBatch[i].OnEndCollectElement();
                    }
                }
            };
            Object.defineProperty(f14EffectSystem.prototype, "root", {
                /**
                 * ref effect 增加transform层控制
                 */
                // refRoot:math.matrix=new math.matrix();
                // public setBatchRootMat(pos:math.vector3,euler:math.vector3,scale:math.vector3)
                // {
                //     let temtrot=m4m.math.pool.new_quaternion();
                //     math.quatFromEulerAngles(euler.x,euler.y,euler.z,temtrot);
                //     math.matrixMakeTransformRTS(pos,scale,temtrot,this.refRoot);
                //     m4m.math.pool.delete_quaternion(temtrot);
                // }
                get: function () {
                    // if(this._root!=null&&this._root.parent==null)
                    // {
                    //     this._root.parent=this.gameObject.transform;
                    // }
                    return this._root || this.gameObject.transform;
                },
                enumerable: false,
                configurable: true
            });
            f14EffectSystem.prototype.update = function (deltaTime) {
                if (this.data == null) {
                    this.renderActive = false;
                    return;
                }
                this.renderActive = true;
                if (this.enabletimeFlow) {
                    this.allTime += deltaTime * this.playRate;
                    this.totalTime = this.allTime - this._delayTime;
                    if (this.totalTime <= 0) {
                        this.renderActive = false;
                        return;
                    }
                    this.totalFrame = this.totalTime * this.fps;
                    if (!this.data.beloop && this.totalFrame > this.data.lifeTime) {
                        this.renderActive = false;
                        this.enabletimeFlow = false;
                        //this.stop();
                        if (this.onFinish) {
                            this.onFinish();
                        }
                        return;
                    }
                    this.restartFrame = this.totalFrame % this.data.lifeTime;
                    this.restartFrame = Math.floor(this.restartFrame);
                    var newLoopCount = Math.floor(this.totalFrame / this.data.lifeTime);
                    if (newLoopCount != this.loopCount) {
                        this.OnEndOnceLoop();
                    }
                    this.loopCount = newLoopCount;
                    if (this.renderCamera == null)
                        return;
                    for (var i = 0; i < this.elements.length; i++) {
                        this.elements[i].update(deltaTime, this.totalFrame, this.fps);
                    }
                }
                else {
                    if (this.totalTime <= 0) {
                        this.renderActive = false;
                        return;
                    }
                    if (!this.data.beloop && this.totalFrame > this.data.lifeTime) {
                        this.renderActive = false;
                        return;
                    }
                }
                // if (this.data == null||this.playState==PlayStateEnum.beReady)
                // {
                //     this.renderActive=false;
                //     return;
                // }
                // if(this.playState==PlayStateEnum.play)
                // {
                //     this.allTime+=deltaTime*this.playRate;
                //     this.totalTime=this.allTime-this._delayTime;
                //     if(this.totalTime<=0)
                //     {
                //         this.renderActive=false;
                //         return;
                //     }
                // }
                // this.renderActive=true;//上面return了应该不再render 
                // this.totalFrame=this.totalTime*this.fps;
                // if(!this.data.beloop&&this.totalFrame>this.data.lifeTime)
                // {
                //     this.renderActive=false;
                //     this.stop();
                // }
                // this.restartFrame = this.totalFrame % this.data.lifeTime;
                // this.restartFrame=Math.floor(this.restartFrame);
                // let newLoopCount=Math.floor(this.totalFrame/this.data.lifeTime);
                // if(newLoopCount!=this.loopCount)
                // {
                //     this.OnEndOnceLoop();
                // }
                // this.loopCount=newLoopCount;
                // for (let i = 0; i < this.elements.length; i++)
                // {
                //     this.elements[i].update(deltaTime, this.totalFrame, this.fps);
                // }
            };
            f14EffectSystem.prototype.OnEndOnceLoop = function () {
                for (var i = 0; i < this.elements.length; i++) {
                    this.elements[i].OnEndOnceLoop();
                }
            };
            Object.defineProperty(f14EffectSystem.prototype, "renderCamera", {
                get: function () {
                    if (this._renderCamera != null) {
                        return this._renderCamera;
                    }
                    else {
                        return m4m.framework.sceneMgr.app.getScene().mainCamera;
                    }
                },
                enumerable: false,
                configurable: true
            });
            f14EffectSystem.prototype.render = function (context, assetmgr, camera, Effqueue) {
                if (Effqueue === void 0) { Effqueue = 0; }
                if (!this.renderActive || !this.enableDraw)
                    return;
                framework.DrawCallInfo.inc.currentState = framework.DrawCallEnum.EffectSystem;
                this._renderCamera = camera;
                var curCount = 0;
                context.updateModel(this.root);
                m4m.math.matrixClone(context.matrixModelViewProject, this.mvpMat);
                for (var i = 0; i < this.renderBatch.length; i++) {
                    this.renderBatch[i].render(context, assetmgr, camera, Effqueue + curCount);
                    curCount += this.renderBatch[i].getElementCount();
                }
            };
            f14EffectSystem.prototype.addF14layer = function (type, layerdata, bundleName) {
                if (type == framework.F14TypeEnum.SingleMeshType) {
                    var layer = new framework.F14Layer(this, layerdata);
                    var element = new framework.F14SingleMesh(this, layer);
                    layer.element = element;
                    this.layers.push(layer);
                    this.elements.push(element);
                    //--------------------------------------放到batcher中----------
                    var data = layerdata.elementdata;
                    if (this.layers.length > 1 && this.layers[this.layers.length - 2].type == type) {
                        var batch = this.layers[this.layers.length - 2].batch;
                        if (batch.type == framework.F14TypeEnum.SingleMeshType && batch.canBatch(element)) {
                            batch.addElement(element);
                            layer.batch = batch;
                        }
                        else {
                            var _batch = new framework.F14SingleMeshBath(data.material, this);
                            _batch.addElement(element);
                            layer.batch = _batch;
                            this.renderBatch.push(_batch);
                        }
                    }
                    else if (this.layers.length = 1) {
                        var batch = new framework.F14SingleMeshBath(data.material, this);
                        batch.addElement(element);
                        layer.batch = batch;
                        this.renderBatch.push(batch);
                    }
                    return layer;
                }
                else if (type == framework.F14TypeEnum.particlesType) {
                    var layer = new framework.F14Layer(this, layerdata);
                    var element = new framework.F14Emission(this, layer);
                    layer.element = element;
                    this.layers.push(layer);
                    this.elements.push(element);
                    //--------------------------------------放到batcher中----------
                    var batch = new framework.F14EmissionBatch(this, element);
                    layer.batch = batch;
                    this.renderBatch.push(batch);
                    return layer;
                }
                else {
                    var layer = new framework.F14Layer(this, layerdata);
                    var element = new framework.F14RefElement(this, layer, bundleName);
                    var data = layerdata.elementdata;
                    layer.element = element;
                    //element.RefEffect.setBatchRootMat(data.localPos,data.localEuler,data.localScale);
                    this.layers.push(layer);
                    this.elements.push(element);
                    var refbath = new framework.F14RefElementBatch(this, element);
                    this.renderBatch.push(refbath);
                    layer.batch = refbath;
                    return layer;
                }
            };
            //返回element个数（包含reflayer内部的）
            f14EffectSystem.prototype.getElementCount = function () {
                var totalcount = 0;
                for (var i = 0; i < this.layers.length; i++) {
                    if (this.layers[i].type == framework.F14TypeEnum.RefType) {
                        totalcount += this.layers[i].batch.getElementCount();
                    }
                    else {
                        totalcount++;
                    }
                }
                return totalcount;
            };
            f14EffectSystem.prototype.play = function (onFinish, PlayRate) {
                if (onFinish === void 0) { onFinish = null; }
                if (PlayRate === void 0) { PlayRate = 1.0; }
                if (this.allTime > 0) {
                    this.reset();
                }
                this.enabletimeFlow = true;
                this.enableDraw = true;
                this.playRate = PlayRate;
                if (onFinish) {
                    this.onFinish = onFinish;
                }
                // if(this.playState!=PlayStateEnum.beReady)
                // {
                //     this.reset();
                // }
                // this.playState=PlayStateEnum.play;
                // this.playRate=PlayRate;
            };
            f14EffectSystem.prototype.stop = function () {
                this.enabletimeFlow = false;
                this.enableDraw = false;
                this.reset();
                // this.playState=PlayStateEnum.beReady;
                // this.reset();
            };
            //private bePause:boolean=false;
            f14EffectSystem.prototype.pause = function () {
                // if(this.playState==PlayStateEnum.pause)
                // {
                //     this.playState=PlayStateEnum.play;
                // }else
                // {
                //     this.playState=PlayStateEnum.pause;
                // }
                this.enableDraw = true;
                this.enabletimeFlow = false;
            };
            f14EffectSystem.prototype.changeColor = function (newcolor) {
                for (var i = 0; i < this.elements.length; i++) {
                    this.elements[i].changeColor(newcolor);
                }
            };
            f14EffectSystem.prototype.changeAlpha = function (newAlpha) {
                for (var i = 0; i < this.elements.length; i++) {
                    this.elements[i].changeAlpha(newAlpha);
                }
            };
            f14EffectSystem.prototype.reset = function () {
                this.allTime = 0;
                //this.totalTime=0;
                for (var key in this.elements) {
                    this.elements[key].reset();
                }
            };
            f14EffectSystem.prototype.clone = function () {
            };
            f14EffectSystem.prototype.remove = function () {
                this.data = null;
                this._f14eff = null;
                this.webgl = null;
                this._root = null;
                this._renderCamera = null;
                this.gameObject = null;
                for (var key in this.layers) {
                    this.layers[key].dispose();
                }
                for (var key in this.elements) {
                    this.elements[key].dispose();
                }
                for (var key in this.renderBatch) {
                    this.renderBatch[key].dispose();
                }
                delete this.layers;
                delete this.elements;
                delete this.renderBatch;
            };
            f14EffectSystem.ClassName = "f14EffectSystem";
            __decorate([
                m4m.reflect.Field("f14eff"),
                m4m.reflect.UIStyle("WidgetDragSelect"),
                __metadata("design:type", framework.f14eff),
                __metadata("design:paramtypes", [framework.f14eff])
            ], f14EffectSystem.prototype, "f14eff", null);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number),
                __metadata("design:paramtypes", [Number])
            ], f14EffectSystem.prototype, "delay", null);
            f14EffectSystem = __decorate([
                m4m.reflect.nodeRender,
                m4m.reflect.nodeComponent,
                __metadata("design:paramtypes", [String])
            ], f14EffectSystem);
            return f14EffectSystem;
        }());
        framework.f14EffectSystem = f14EffectSystem;
        var PlayStateEnum;
        (function (PlayStateEnum) {
            PlayStateEnum[PlayStateEnum["play"] = 0] = "play";
            PlayStateEnum[PlayStateEnum["beReady"] = 1] = "beReady";
            PlayStateEnum[PlayStateEnum["pause"] = 2] = "pause";
        })(PlayStateEnum = framework.PlayStateEnum || (framework.PlayStateEnum = {}));
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var F14TypeEnum;
        (function (F14TypeEnum) {
            F14TypeEnum[F14TypeEnum["SingleMeshType"] = 0] = "SingleMeshType";
            F14TypeEnum[F14TypeEnum["particlesType"] = 1] = "particlesType";
            F14TypeEnum[F14TypeEnum["RefType"] = 2] = "RefType"; //索引
        })(F14TypeEnum = framework.F14TypeEnum || (framework.F14TypeEnum = {}));
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var F14Layer = /** @class */ (function () {
            function F14Layer(effect, data) {
                this.active = true; //timeline window 的toggle
                this.frameList = []; //记录存在的frame，再排个序  boolcontainframe (关键帧的索引值，从小到大)
                this.frames = {}; //取得对应Frame的信息
                this.Attlines = {}; //记录了五种数据的（关键帧位置和值）
                this.effect = effect;
                this.data = data;
                this.type = data.type;
                for (var ff in this.data.frames) {
                    var framedata = this.data.frames[ff];
                    this.addFrame(framedata.frameindex, framedata);
                }
            }
            // //改变data的life
            // public OnChangeEffectLife()
            // {
            //     for(let i= this.frameList.length-1; i>=0;i--)
            //     {
            //        if(this.frameList[i]>=this.effect.data.lifeTime)
            //         {
            //             this.removeFrame(this.frameList[i]);
            //         } 
            //     }
            // }
            F14Layer.prototype.addFrame = function (index, framedata) {
                if (this.frames[index])
                    return this.frames[index];
                // if(framedata == null)
                // {
                //     framedata = new F14FrameData(index,this.type);
                //     if(this.type==F14TypeEnum.particlesType)
                //     {
                //         F14EmissionBaseData.copyto(this.data.elementdata, framedata.EmissionData);
                //     }
                //     // //scriptableObject
                //     this.data.frames[index]=framedata;
                // }
                var frame = new F14Frame(this, framedata);
                this.frameList.push(index);
                this.frameList.sort(function (a, b) { return a - b; });
                this.frames[index] = frame;
                return frame;
            };
            F14Layer.prototype.removeFrame = function (frame) {
                if (this.frames[frame]) {
                    delete this.frames[frame];
                    var index = this.frameList.indexOf(frame);
                    this.frameList.splice(index, 1);
                    //scriptableObject
                    delete this.data.frames[frame];
                }
                for (var item in this.Attlines) {
                    this.Attlines[item].remove(frame);
                }
            };
            F14Layer.prototype.dispose = function () {
                this.data = null;
                this.effect = null;
                this.frameList.length = 0;
                this.frames = null;
                this.Attlines = null;
                this.element = null;
                this.batch = null;
            };
            return F14Layer;
        }());
        framework.F14Layer = F14Layer;
        var F14Frame = /** @class */ (function () {
            function F14Frame(layer, data) {
                this.layer = layer;
                this.data = data;
                this.attDic = this.data.singlemeshAttDic;
                for (var key in this.data.singlemeshAttDic) {
                    this.setdata(key, this.data.singlemeshAttDic[key]);
                }
            }
            F14Frame.prototype.setdata = function (name, obj) {
                if (this.layer.Attlines[name] == null) {
                    if (obj instanceof m4m.math.vector3) {
                        this.layer.Attlines[name] = new F14AttTimeLine(name, m4m.math.vec3SLerp, m4m.math.vec3Clone);
                    }
                    else if (obj instanceof m4m.math.vector4) {
                        this.layer.Attlines[name] = new F14AttTimeLine(name, m4m.math.vec4SLerp, m4m.math.vec4Clone);
                    }
                    else if (obj instanceof m4m.math.color) {
                        this.layer.Attlines[name] = new F14AttTimeLine(name, m4m.math.colorLerp, m4m.math.colorClone);
                    }
                }
                this.layer.Attlines[name].addNode(this.data.frameindex, obj);
                this.attDic[name] = obj;
            };
            F14Frame.prototype.removedata = function (name) {
                delete this.attDic[name];
                if (this.layer.Attlines[name]) {
                    this.layer.Attlines[name].remove(this.data.frameindex);
                }
            };
            F14Frame.prototype.getdata = function (name) {
                return this.attDic[name];
            };
            return F14Frame;
        }());
        framework.F14Frame = F14Frame;
        var F14AttTimeLine = /** @class */ (function () {
            function F14AttTimeLine(name, lerpfunc, clonefunc) {
                this.frameList = []; //记录了关键帧的索引值
                this.line = {}; //记录了关键帧的帧索引和某一项值
                this.name = name;
                this.lerpFunc = lerpfunc;
                this.cloneFunc = clonefunc;
            }
            //public Dictionary<int, object> cacheData = new Dictionary<int, object>();
            F14AttTimeLine.prototype.addNode = function (frame, value) {
                var index = this.frameList.indexOf(frame);
                if (index < 0) {
                    this.frameList.push(frame);
                    this.frameList.sort(function (a, b) { return a - b; });
                }
                this.line[frame] = value;
            };
            F14AttTimeLine.prototype.remove = function (frame) {
                if (this.line[frame]) {
                    delete this.line[frame];
                    var index = this.frameList.indexOf(frame);
                    this.frameList.splice(index, 1);
                }
            };
            F14AttTimeLine.prototype.getValue = function (frame, basedate, out) {
                //if (this.frameList.Contains(frame)) return this.line[frame];
                if (this.frameList.length == 0) {
                    return;
                }
                if (this.line[frame]) {
                    this.cloneFunc(this.line[frame], out);
                    return;
                }
                if (frame < this.frameList[0]) {
                    var toindex = this.frameList[0];
                    var from = basedate[this.name];
                    var to = this.line[toindex];
                    var lerp = (frame - basedate.firtstFrame) / toindex;
                    this.lerpFunc(from, to, lerp, out);
                }
                else if (frame >= this.frameList[this.frameList.length - 1]) {
                    //out=this.line[this.frameList[this.frameList.length - 1]];
                    this.cloneFunc(this.line[this.frameList[this.frameList.length - 1]], out);
                }
                else {
                    for (var i = 0; i < this.frameList.length; i++) {
                        if (this.frameList[i] > frame) {
                            var to = this.frameList[i];
                            var from = this.frameList[i - 1];
                            this.lerpFunc(this.line[from], this.line[to], (frame - from) / (to - from), out);
                            return;
                        }
                    }
                }
            };
            return F14AttTimeLine;
        }());
        framework.F14AttTimeLine = F14AttTimeLine;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var F14EffectData = /** @class */ (function () {
            function F14EffectData() {
                this.beloop = false;
                this.lifeTime = 100;
                this.layers = [];
            }
            F14EffectData.prototype.parsejson = function (json, assetmgr, assetbundle) {
                // return new threading.gdPromise((resolve) =>
                // {
                this.beloop = json.beloop;
                this.lifeTime = json.lifeTime;
                var jsonlayer = json.layers;
                // let total = 0;
                for (var i = 0, len = jsonlayer.length; i < len; ++i) {
                    var layer = new F14LayerData();
                    layer.parse(jsonlayer[i], assetmgr, assetbundle);
                    // .then(() =>
                    // {
                    //     if (++total >= len)
                    //         resolve();
                    // });
                    this.layers.push(layer);
                }
                // });
                return this;
            };
            return F14EffectData;
        }());
        framework.F14EffectData = F14EffectData;
        var F14LayerData = /** @class */ (function () {
            function F14LayerData() {
                this.Name = "newLayer";
                this.type = framework.F14TypeEnum.SingleMeshType;
                // F14SingleMeshBaseData singlemeshdata;
                // F14EmissionBaseData emissiondata;
                // F14RefBaseData RefData;
                //frames:F14FrameData[]=[];
                this.frames = {};
            }
            F14LayerData.prototype.parse = function (json, assetmgr, assetbundle) {
                // return new threading.gdPromise((resolve) =>
                // {
                this.Name = json.Name;
                switch (json.type) {
                    case "particlesType":
                        this.type = framework.F14TypeEnum.particlesType;
                        this.elementdata = new framework.F14EmissionBaseData();
                        this.elementdata.parse(json.emissiondata, assetmgr, assetbundle);
                        break;
                    case "SingleMeshType":
                        this.type = framework.F14TypeEnum.SingleMeshType;
                        this.elementdata = new framework.F14SingleMeshBaseData(json.frames[0].frameindex);
                        this.elementdata.parse(json.singlemeshdata, assetmgr, assetbundle);
                        break;
                    case "RefType":
                        this.type = framework.F14TypeEnum.RefType;
                        this.elementdata = new framework.F14RefBaseData();
                        this.elementdata.parse(json.RefData, assetmgr, assetbundle);
                        break;
                    default:
                        console.log("f14Eff parse layerjson error!");
                        return;
                }
                for (var i = 0; i < json.frames.length; i++) {
                    var framejson = json.frames[i];
                    var frameindex = framejson.frameindex;
                    var frameitem = new F14FrameData(frameindex, this.type);
                    this.frames[frameindex] = frameitem;
                    switch (this.type) {
                        case framework.F14TypeEnum.SingleMeshType:
                            for (var k = 0; k < framejson.vec3Atts.length; k++) {
                                var name_6 = framejson.vec3Atts[k].name;
                                var strValue = framejson.vec3Atts[k].value;
                                var v3 = new m4m.math.vector3();
                                m4m.math.vec3FormJson(strValue, v3);
                                frameitem.singlemeshAttDic[name_6] = v3;
                            }
                            for (var k = 0; k < framejson.vec4Atts.length; k++) {
                                var name_7 = framejson.vec4Atts[k].name;
                                var strValue = framejson.vec4Atts[k].value;
                                var v4 = new m4m.math.vector4();
                                m4m.math.vec4FormJson(strValue, v4);
                                frameitem.singlemeshAttDic[name_7] = v4;
                            }
                            for (var k = 0; k < framejson.colorAtts.length; k++) {
                                var name_8 = framejson.colorAtts[k].name;
                                var strValue = framejson.colorAtts[k].value;
                                var color = new m4m.math.color();
                                m4m.math.colorFormJson(strValue, color);
                                frameitem.singlemeshAttDic[name_8] = color;
                            }
                            break;
                        case framework.F14TypeEnum.particlesType:
                            var data = new framework.F14EmissionBaseData();
                            data.parse(framejson.emissionData, assetmgr, assetbundle);
                            frameitem.EmissionData = data;
                    }
                }
                //     resolve();
                // });
            };
            return F14LayerData;
        }());
        framework.F14LayerData = F14LayerData;
        var F14FrameData = /** @class */ (function () {
            function F14FrameData(index, type) {
                this.frameindex = index;
                if (type == framework.F14TypeEnum.SingleMeshType) {
                    this.singlemeshAttDic = {};
                }
                else {
                    this.EmissionData = new framework.F14EmissionBaseData();
                }
            }
            return F14FrameData;
        }());
        framework.F14FrameData = F14FrameData;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var NumberData = /** @class */ (function () {
            function NumberData(value) {
                if (value === void 0) { value = 0; }
                this.isRandom = false;
                this._value = 0;
                this._valueLimitMin = 0;
                this._valueLimitMax = 0;
                this.beInited = false;
                this._value = value;
            }
            NumberData.prototype.setValue = function (value) {
                this._value = value;
            };
            NumberData.prototype.setRandomValue = function (max, min) {
                this._valueLimitMax = max;
                this._valueLimitMin = min;
                this.isRandom = true;
            };
            /**
             * 针对随机类型，只要随机过一次就返回值不变（rerandom=false），返回新的随机值（rerandom=true）
             */
            NumberData.prototype.getValue = function (reRandom) {
                if (reRandom === void 0) { reRandom = false; }
                if (this.isRandom) {
                    if (reRandom || !this.beInited) {
                        this.key = Math.random();
                        this._value = this.key * (this._valueLimitMax - this._valueLimitMin) + this._valueLimitMin;
                        this.beInited = true;
                    }
                }
                return this._value;
            };
            NumberData.copyto = function (from, to) {
                to.isRandom = from.isRandom;
                to._value = from._value;
                to._valueLimitMin = from._valueLimitMin;
                to._valueLimitMax = from._valueLimitMax;
            };
            NumberData.FormJson = function (json, data) {
                if (json.indexOf("~") < 0) {
                    data.setValue(Number(json));
                }
                else {
                    var arr = json.split("~");
                    data.setRandomValue(Number(arr[1]), Number(arr[0]));
                }
            };
            return NumberData;
        }());
        framework.NumberData = NumberData;
        var Vector3Data = /** @class */ (function () {
            function Vector3Data(x, y, z) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (z === void 0) { z = 0; }
                this.x = new NumberData();
                this.y = new NumberData();
                this.z = new NumberData();
                this.x.setValue(x);
                this.y.setValue(y);
                this.z.setValue(z);
            }
            Vector3Data.prototype.getValue = function (reRandom) {
                if (reRandom === void 0) { reRandom = false; }
                var _out = new m4m.math.vector3();
                _out.x = this.x.getValue(reRandom);
                _out.y = this.y.getValue(reRandom);
                _out.z = this.z.getValue(reRandom);
                return _out;
            };
            Vector3Data.copyto = function (from, to) {
                NumberData.copyto(from.x, to.x);
                NumberData.copyto(from.y, to.y);
                NumberData.copyto(from.z, to.z);
            };
            Vector3Data.FormJson = function (json, data) {
                var arr = json.split(",");
                NumberData.FormJson(arr[0], data.x);
                NumberData.FormJson(arr[1], data.y);
                NumberData.FormJson(arr[2], data.z);
            };
            return Vector3Data;
        }());
        framework.Vector3Data = Vector3Data;
        var NumberKey = /** @class */ (function () {
            function NumberKey(_key, _value) {
                this.key = _key;
                this.value = _value;
            }
            return NumberKey;
        }());
        framework.NumberKey = NumberKey;
        var Vector3Key = /** @class */ (function () {
            function Vector3Key(_key, _value) {
                this.key = _key;
                this.value = _value;
            }
            return Vector3Key;
        }());
        framework.Vector3Key = Vector3Key;
        var Vector2Key = /** @class */ (function () {
            function Vector2Key(_key, _value) {
                this.key = _key;
                this.value = _value;
            }
            return Vector2Key;
        }());
        framework.Vector2Key = Vector2Key;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var F14Emission = /** @class */ (function () {
            function F14Emission(effect, layer) {
                //-------------------------数据------------------------------------
                this.particlelist = [];
                this.deadParticles = [];
                //--------------------------------------------------------
                this.frameLife = 0;
                this.TotalTime = 0;
                this.newStartDataTime = 0; //改变currentdata的时间
                this.curTime = 0; //减去dely剩下的
                this.beover = false;
                //private bool beBurst = false;
                this.numcount = 0;
                //--------------------
                this.localMatrix = new m4m.math.matrix();
                this._worldMatrix = new m4m.math.matrix();
                this.localrot = new m4m.math.quaternion();
                this.worldRot = new m4m.math.quaternion();
                this.lastFrame = 0;
                this.bursts = [];
                this.type = framework.F14TypeEnum.particlesType;
                this.effect = effect;
                this.layer = layer;
                this.baseddata = layer.data.elementdata;
                this.currentData = this.baseddata;
                this.newStartDataTime = this.baseddata.delayTime;
                this.initBycurrentdata();
                if (this.currentData.mesh.data) {
                    this.vertexCount = this.currentData.mesh.data.getVertexCount();
                    this.posArr = this.currentData.mesh.data.pos;
                    this.colorArr = this.currentData.mesh.data.color;
                    this.uvArr = this.currentData.mesh.data.uv;
                    this.dataforebo = this.currentData.mesh.data.genIndexDataArray();
                    this.vertexLength = m4m.render.meshData.calcByteSize(this.effect.VF) / 4;
                    this.dataforvboLen = this.vertexCount * this.vertexLength;
                }
                else {
                    this.vertexCount = 0;
                    this.posArr = [];
                    this.colorArr = [];
                    this.uvArr = [];
                    this.dataforebo = new Uint16Array(0);
                }
            }
            F14Emission.prototype.update = function (deltaTime, frame, fps) {
                // if(!this.effect.gameObject.transform.inCameraVisible)
                //     return;
                //this.drawActive = true;
                this.TotalTime += deltaTime;
                if (this.frameGap == undefined) {
                    this.frameGap = 1 / fps;
                }
                this.refreshByFrameData(fps);
                this.updateLife();
                for (var i = 0; i < this.particlelist.length; i++) {
                    this.particlelist[i].update(deltaTime);
                }
            };
            F14Emission.prototype.refreshByFrameData = function (fps) {
                this.frameLife = Math.floor(this.baseddata.duration * fps);
                if (this.frameLife == 0)
                    this.frameLife = 1;
                var frame = Math.floor(this.TotalTime * fps) % this.frameLife;
                //-------------------------------change current basedata------------------------------------------------------------
                if (frame != this.lastFrame && this.layer.frames[frame]) {
                    if (frame == this.layer.frameList[0]) {
                        this.currentData = this.baseddata;
                    }
                    if (this.layer.frames[frame].data.EmissionData != this.currentData) {
                        this.changeCurrentBaseData(this.layer.frames[frame].data.EmissionData);
                    }
                }
                this.lastFrame = frame;
            };
            F14Emission.prototype.changeCurrentBaseData = function (data) {
                this.currentData = data;
                this.newStartDataTime = this.TotalTime;
                this.numcount = 0;
                this.initBycurrentdata();
            };
            F14Emission.prototype.initBycurrentdata = function () {
                m4m.math.quatFromEulerAngles(this.currentData.rotEuler.x, this.currentData.rotEuler.y, this.currentData.rotEuler.z, this.localrot);
                m4m.math.matrixMakeTransformRTS(this.currentData.rotPosition, this.currentData.rotScale, this.localrot, this.localMatrix);
            };
            F14Emission.prototype.getWorldMatrix = function () {
                var mat = this.effect.root.getWorldMatrix();
                m4m.math.matrixMultiply(mat, this.localMatrix, this._worldMatrix);
                return this._worldMatrix;
            };
            F14Emission.prototype.getWorldRotation = function () {
                var rot = this.effect.root.getWorldRotate();
                m4m.math.quatMultiply(rot, this.localrot, this.worldRot);
                return this.worldRot;
            };
            F14Emission.prototype.updateLife = function () {
                if (this.beover)
                    return;
                this.curTime = this.TotalTime - this.baseddata.delayTime;
                if (this.curTime <= 0)
                    return;
                //--------------update in Livelife-------------------
                this.updateEmission();
                if (this.curTime > this.baseddata.duration) {
                    if (this.baseddata.beloop) {
                        switch (this.baseddata.loopenum) {
                            case framework.LoopEnum.Restart:
                                this.reInit();
                                break;
                            case framework.LoopEnum.TimeContinue:
                                this.beover = true;
                                break;
                        }
                    }
                    else {
                        this.beover = true;
                    }
                }
            };
            F14Emission.prototype.reInit = function () {
                this.currentData = this.baseddata;
                this.newStartDataTime = this.baseddata.delayTime;
                this.beover = false;
                this.TotalTime = 0;
                this.numcount = 0;
                this.currentData.rateOverTime.getValue(true); //重新随机
                if (this.settedAlpha != null) {
                    this.currentData.startAlpha = new framework.NumberData(this.baseddata.startAlpha._value * this.settedAlpha);
                }
                // for (let i = 0; i < this.baseddata.bursts.length; i++)
                // {
                //     this.baseddata.bursts[i].burst(false);
                // }
                this.bursts = [];
            };
            F14Emission.prototype.updateEmission = function () {
                var maxLifeTime = this.baseddata.lifeTime.isRandom
                    ? this.baseddata.lifeTime._valueLimitMax
                    : this.baseddata.lifeTime._value;
                var needCount = Math.floor(this.currentData.rateOverTime.getValue() * ((this.TotalTime - this.newStartDataTime) % (maxLifeTime + this.frameGap)));
                // var needCount = Math.floor(this.currentData.rateOverTime.getValue() * (this.TotalTime - this.newStartDataTime));
                var realcount = needCount - this.numcount;
                if (realcount > 0) {
                    this.addParticle(realcount);
                }
                this.numcount += realcount;
                if (this.baseddata.bursts.length > 0) {
                    for (var i = 0; i < this.baseddata.bursts.length; i++) {
                        var index = this.bursts.indexOf(this.baseddata.bursts[i].time);
                        if (index < 0 && this.baseddata.bursts[i].time <= this.TotalTime) {
                            var count = this.baseddata.bursts[i].count.getValue(true);
                            this.baseddata.bursts[i].burst();
                            this.bursts.push(this.baseddata.bursts[i].time);
                            this.addParticle(count);
                        }
                        // if(!this.baseddata.bursts[i].beburst()&&this.baseddata.bursts[i].time<=this.TotalTime)
                        // {
                        //     let count = this.baseddata.bursts[i].count.getValue(true);
                        //     this.baseddata.bursts[i].burst();
                        //     this.addParticle(count);
                        // }
                    }
                }
            };
            F14Emission.prototype.addParticle = function (count) {
                if (count === void 0) { count = 1; }
                if (count > 150)
                    count = 150;
                for (var i = 0; i < count; i++) {
                    if (this.deadParticles.length > 0) {
                        var pp = this.deadParticles.pop();
                        pp.initByEmissionData(this.currentData);
                    }
                    else {
                        var pp = new framework.F14Particle(this, this.currentData);
                        this.particlelist.push(pp);
                    }
                }
            };
            //重置，例子啥的消失
            F14Emission.prototype.reset = function () {
                this.reInit();
                //----------------
                for (var i = 0; i < this.particlelist.length; i++) {
                    if (this.particlelist[i].actived) {
                        this.particlelist[i].actived = false;
                        this.deadParticles.push(this.particlelist[i]);
                    }
                }
            };
            F14Emission.prototype.changeColor = function (value) {
                this.currentData.startColor = new framework.Vector3Data(value.r, value.g, value.b);
                this.currentData.startAlpha = new framework.NumberData(value.a);
            };
            F14Emission.prototype.changeAlpha = function (value) {
                this.currentData.startAlpha = new framework.NumberData(this.baseddata.startAlpha._value * value);
                this.settedAlpha = value;
            };
            F14Emission.prototype.OnEndOnceLoop = function () {
            };
            F14Emission.prototype.dispose = function () {
                this.effect = null;
                this.baseddata = null;
                this.currentData = null;
                delete this.dataforebo;
                delete this.posArr;
                delete this.colorArr;
                delete this.uvArr;
                delete this.bursts;
                // for (let key in this.particlelist)
                for (var i = 0, len = this.particlelist.length; i < len; ++i)
                    this.particlelist[i].dispose();
                // for (let key in this.deadParticles)
                for (var i = 0, len = this.deadParticles.length; i < len; ++i)
                    this.deadParticles[i].dispose();
            };
            return F14Emission;
        }());
        framework.F14Emission = F14Emission;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var RenderModelEnum;
        (function (RenderModelEnum) {
            RenderModelEnum[RenderModelEnum["None"] = 0] = "None";
            RenderModelEnum[RenderModelEnum["BillBoard"] = 1] = "BillBoard";
            RenderModelEnum[RenderModelEnum["StretchedBillBoard"] = 2] = "StretchedBillBoard";
            RenderModelEnum[RenderModelEnum["HorizontalBillBoard"] = 3] = "HorizontalBillBoard";
            RenderModelEnum[RenderModelEnum["VerticalBillBoard"] = 4] = "VerticalBillBoard";
            RenderModelEnum[RenderModelEnum["Mesh"] = 5] = "Mesh";
        })(RenderModelEnum = framework.RenderModelEnum || (framework.RenderModelEnum = {}));
        var F14EmissionBaseData = /** @class */ (function () {
            function F14EmissionBaseData() {
                this.loopenum = framework.LoopEnum.Restart;
                this.rotPosition = new m4m.math.vector3();
                this.rotScale = new m4m.math.vector3(1, 1, 1);
                this.rotEuler = new m4m.math.vector3();
                //----------------render
                this.rendermodel = RenderModelEnum.Mesh;
                //public Material material;  
                //public Mesh mesh;//仅在rendermodel为mesh的时候显示     
                this.beloop = true;
                this.lifeTime = new framework.NumberData(20);
                this.simulateInLocalSpace = true; //粒子运动运动空间（世界还是本地)
                this.startScaleRate = new framework.NumberData(1);
                this.startScale = new framework.Vector3Data(1, 1, 1);
                this.startEuler = new framework.Vector3Data();
                //public Vector4 startColor = new Vector4(1, 1, 1, 1);//直接分为color和alpha，不纠结了
                this.startColor = new framework.Vector3Data(1, 1, 1);
                this.startAlpha = new framework.NumberData(1);
                this.colorRate = 1;
                this.simulationSpeed = new framework.NumberData(1);
                //20171018增加的
                this.start_tex_st = new m4m.math.vector4(1, 1, 0, 0);
                //----------------emision
                this.delayTime = 0;
                this.duration = 10;
                //public NumberData emissionCount = new NumberData(4);
                //20171017增加的
                this.rateOverTime = new framework.NumberData(1);
                //burst 只在basedata中展示，不在关键帧编辑窗口展示
                this.bursts = [];
                //----------------emission shape
                this.shapeType = framework.ParticleSystemShape.NORMAL;
                this.emitFrom = framework.emitfromenum.base;
                //----------------------------------------可选类型-----------------------------------------------------------
                //-----------------position over lifetime
                this.enableVelocityOverLifetime = false;
                this.moveSpeed = new framework.Vector3Data(0);
                //-----------------scale over lifetime
                this.enableSizeOverLifetime = false;
                this.sizeNodes = [];
                //-----------------rot over lifetime
                this.enableRotOverLifeTime = false;
                this.angleSpeed = new framework.NumberData(0);
                //-----------------color & alpha over lifetime
                this.enableColorOverLifetime = false;
                this.colorNodes = [];
                this.alphaNodes = [];
                //-----------------texture animation
                this.enableTexAnimation = false;
                this.uvType = framework.UVTypeEnum.NONE;
            }
            F14EmissionBaseData.prototype.parse = function (json, assetmgr, assetbundle) {
                switch (json.loopenum) {
                    case "Restart":
                        this.loopenum = framework.LoopEnum.Restart;
                        break;
                    case "TimeContinue":
                        this.loopenum = framework.LoopEnum.TimeContinue;
                        break;
                }
                this.mesh = (assetmgr.getAssetByName(json.mesh, assetbundle) || assetmgr.getAssetByName(json.mesh.replace("mesh.bin", "cmesh.bin"), assetbundle));
                this.material = assetmgr.getAssetByName(json.material, assetbundle);
                m4m.math.vec3FormJson(json.rotPosition, this.rotPosition);
                m4m.math.vec3FormJson(json.rotScale, this.rotScale);
                m4m.math.vec3FormJson(json.rotEuler, this.rotEuler);
                switch (json.rendermodel) {
                    default:
                    case "BillBoard":
                        this.rendermodel = RenderModelEnum.BillBoard;
                        break;
                    case "HorizontalBillBoard":
                        this.rendermodel = RenderModelEnum.HorizontalBillBoard;
                        break;
                    case "Mesh":
                        this.rendermodel = RenderModelEnum.Mesh;
                        break;
                    case "StretchedBillBoard":
                        this.rendermodel = RenderModelEnum.StretchedBillBoard;
                        break;
                    case "VerticalBillBoard":
                        this.rendermodel = RenderModelEnum.VerticalBillBoard;
                        break;
                    case "None":
                        this.rendermodel = RenderModelEnum.None;
                        break;
                }
                this.beloop = json.beloop;
                framework.NumberData.FormJson(json.lifeTime, this.lifeTime);
                this.simulateInLocalSpace = json.simulateInLocalSpace;
                framework.NumberData.FormJson(json.startScaleRate, this.startScaleRate);
                framework.Vector3Data.FormJson(json.startScale, this.startScale);
                framework.Vector3Data.FormJson(json.startEuler, this.startEuler);
                framework.Vector3Data.FormJson(json.startColor, this.startColor);
                framework.NumberData.FormJson(json.startAlpha, this.startAlpha);
                this.colorRate = json.colorRate;
                framework.NumberData.FormJson(json.simulationSpeed, this.simulationSpeed);
                m4m.math.vec4FormJson(json.start_tex_st, this.start_tex_st);
                this.delayTime = json.delayTime;
                this.duration = json.duration;
                framework.NumberData.FormJson(json.rateOverTime, this.rateOverTime);
                for (var i = 0; i < json.bursts.length; i++) {
                    var item = json.bursts[i];
                    var info = busrtInfo.CreatformJson(item);
                    this.bursts.push(info);
                }
                switch (json.shapeType) {
                    case "NORMAL":
                        this.shapeType = framework.ParticleSystemShape.NORMAL;
                        break;
                    case "BOX":
                        this.shapeType = framework.ParticleSystemShape.BOX;
                        this.width = json.width;
                        this.height = json.height;
                        this.depth = json.depth;
                        break;
                    case "SPHERE":
                        this.shapeType = framework.ParticleSystemShape.SPHERE;
                        this.radius = json.radius;
                        break;
                    case "HEMISPHERE":
                        this.shapeType = framework.ParticleSystemShape.HEMISPHERE;
                        this.radius = json.radius;
                        break;
                    case "CONE":
                        this.shapeType = framework.ParticleSystemShape.CONE;
                        this.height = json.height;
                        this.angle = json.angle;
                        this.radius = json.radius;
                        switch (json.emitFrom) {
                            case "base_":
                                this.emitFrom = framework.emitfromenum.base;
                                break;
                            case "volume":
                                this.emitFrom = framework.emitfromenum.volume;
                                break;
                        }
                        break;
                    case "CIRCLE":
                        this.shapeType = framework.ParticleSystemShape.CIRCLE;
                        break;
                    case "EDGE":
                        this.shapeType = framework.ParticleSystemShape.EDGE;
                        break;
                }
                this.enableVelocityOverLifetime = json.enableVelocityOverLifetime;
                if (this.enableVelocityOverLifetime) {
                    framework.Vector3Data.FormJson(json.moveSpeed, this.moveSpeed);
                }
                this.enableSizeOverLifetime = json.enableSizeOverLifetime;
                if (this.enableSizeOverLifetime) {
                    for (var i = 0; i < json.sizeNodes.length; i++) {
                        var jsonitem = json.sizeNodes[i];
                        var item = new framework.NumberKey(jsonitem.key, jsonitem.value);
                        this.sizeNodes.push(item);
                    }
                }
                this.enableRotOverLifeTime = json.enableRotOverLifeTime;
                if (this.enableRotOverLifeTime) {
                    framework.NumberData.FormJson(json.angleSpeed, this.angleSpeed);
                }
                this.enableColorOverLifetime = json.enableColorOverLifetime;
                if (this.enableColorOverLifetime) {
                    for (var i = 0; i < json.colorNodes.length; i++) {
                        var jsonitem = json.colorNodes[i];
                        var v3 = new m4m.math.vector3();
                        m4m.math.vec3FormJson(jsonitem.value, v3);
                        var item = new framework.Vector3Key(jsonitem.key, v3);
                        this.colorNodes.push(item);
                    }
                    for (var i = 0; i < json.alphaNodes.length; i++) {
                        var jsonitem = json.alphaNodes[i];
                        var item = new framework.NumberKey(jsonitem.key, jsonitem.value);
                        this.alphaNodes.push(item);
                    }
                }
                this.enableTexAnimation = json.enableTexAnimation;
                if (this.enableTexAnimation) {
                    switch (json.uvType) {
                        case "UVRoll":
                            this.uvType = framework.UVTypeEnum.UVRoll;
                            this.uSpeed = json.uSpeed;
                            this.vSpeed = json.vSpeed;
                            break;
                        case "UVSprite":
                            this.uvType = framework.UVTypeEnum.UVSprite;
                            this.row = json.row;
                            this.column = json.column;
                            this.count = json.count;
                            break;
                        case "NONE":
                            this.uvType = framework.UVTypeEnum.NONE;
                            break;
                    }
                }
            };
            F14EmissionBaseData.getRandomDirAndPosByZEmission = function (emission, outDir, outPos) {
                var o, o1;
                switch (emission.shapeType) {
                    case framework.ParticleSystemShape.NORMAL:
                        m4m.math.vec3Clone(m4m.math.pool.vector3_zero, outPos);
                        m4m.math.vec3Clone(m4m.math.pool.vector3_up, outDir);
                        break;
                    case framework.ParticleSystemShape.SPHERE:
                        o = Math.random() * Math.PI * 2;
                        o1 = Math.random() * Math.PI;
                        outDir.x = Math.sin(o1) * Math.cos(o);
                        outDir.y = Math.cos(o1);
                        outDir.z = Math.sin(o1) * Math.sin(o);
                        var radius = Math.random() * emission.radius;
                        m4m.math.vec3ScaleByNum(outDir, radius, outPos);
                        break;
                    case framework.ParticleSystemShape.HEMISPHERE:
                        o = Math.random() * Math.PI * 2;
                        o1 = Math.random() * Math.PI * 0.5;
                        var radius = Math.random() * emission.radius;
                        outDir.x = Math.sin(o1) * Math.cos(o);
                        outDir.y = Math.cos(o1);
                        outDir.z = Math.sin(o1) * Math.sin(o);
                        m4m.math.vec3ScaleByNum(outDir, radius, outPos);
                        break;
                    case framework.ParticleSystemShape.BOX:
                        outPos.x = framework.ValueData.RandomRange(-emission.width / 2, emission.width / 2);
                        outPos.y = framework.ValueData.RandomRange(-emission.height / 2, emission.height / 2);
                        outPos.z = framework.ValueData.RandomRange(-emission.depth / 2, emission.depth / 2);
                        m4m.math.vec3Normalize(outPos, outDir);
                        break;
                    case framework.ParticleSystemShape.CONE:
                        var randomAngle = Math.random() * Math.PI * 2; //弧度
                        var randomHeight = Math.random() * emission.height;
                        var upradius = randomHeight * Math.tan(emission.angle * Math.PI / 180) + emission.radius;
                        var radomRadius = Math.random() * upradius;
                        var bottompos = m4m.math.pool.new_vector3();
                        bottompos.x = emission.radius * Math.cos(randomAngle);
                        bottompos.y = 0;
                        bottompos.z = emission.radius * Math.sin(randomAngle);
                        if (emission.emitFrom == framework.emitfromenum.base) {
                            m4m.math.vec3Clone(bottompos, outPos);
                        }
                        else if (emission.emitFrom == framework.emitfromenum.volume) {
                            outPos.x = radomRadius * Math.cos(randomAngle);
                            outPos.z = radomRadius * Math.sin(randomAngle);
                            outPos.y = randomHeight;
                        }
                        outDir.x = Math.cos(randomAngle) * Math.sin(emission.angle * Math.PI / 180);
                        outDir.z = Math.sin(randomAngle) * Math.sin(emission.angle * Math.PI / 180);
                        outDir.y = Math.cos(emission.angle * Math.PI / 180);
                        break;
                }
            };
            return F14EmissionBaseData;
        }());
        framework.F14EmissionBaseData = F14EmissionBaseData;
        var busrtInfo = /** @class */ (function () {
            function busrtInfo() {
                this.time = 0;
                this.count = new framework.NumberData(10);
                this._beburst = false;
            }
            busrtInfo.prototype.beburst = function () {
                return this._beburst;
            };
            busrtInfo.prototype.burst = function (bebusrt) {
                if (bebusrt === void 0) { bebusrt = true; }
                this._beburst = bebusrt;
            };
            busrtInfo.CreatformJson = function (json) {
                var info = new busrtInfo();
                info.time = json.time;
                framework.NumberData.FormJson(json.count, info.count);
                return info;
            };
            return busrtInfo;
        }());
        framework.busrtInfo = busrtInfo;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var F14EmissionBatch = /** @class */ (function () {
            //private maxcoun:number;
            function F14EmissionBatch(effect, element) {
                // private totalVertexCount:number=0;
                // private toltalIndexCount:number=0;
                this.curRealVboCount = 0;
                this.curVertexcount = 0;
                this.curIndexCount = 0;
                this.vertexLength = 0;
                this.type = framework.F14TypeEnum.particlesType;
                this.effect = effect;
                this.emission = element;
                var datamesh = this.emission.baseddata.mesh;
                this.mesh = new framework.mesh();
                this.mat = this.emission.baseddata.material;
                //---------------------
                this.vertexLength = m4m.render.meshData.calcByteSize(this.effect.VF) / 4;
                var maxParticlesCount = this.getMaxParticleCount();
                //this.maxcoun=maxParticlesCount;
                var particleVertexCount = datamesh.data.getVertexCount();
                var particleIndexCount = datamesh.data.getTriIndexCount();
                var totalVertex = maxParticlesCount * particleVertexCount;
                var totalIndex = maxParticlesCount * particleIndexCount;
                this.dataForVbo = new Float32Array(totalVertex * this.vertexLength);
                this.dataForEbo = new Uint16Array(totalIndex);
                this.mesh.glMesh = new m4m.render.glMesh();
                this.mesh.glMesh.initBuffer(this.effect.webgl, this.effect.VF, totalVertex, m4m.render.MeshTypeEnum.Dynamic);
                //this.mesh.glMesh.uploadVertexData(webgl, v32);
                this.mesh.glMesh.addIndex(this.effect.webgl, this.dataForEbo.length);
                this.mesh.glMesh.initVAO();
                //this.mesh.glMesh.uploadIndexData(webgl, 0, i16);
                this.mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.start = 0;
                    sm.size = this.dataForEbo.length;
                    sm.line = false;
                    this.mesh.submesh.push(sm);
                }
            }
            F14EmissionBatch.prototype.getMaxParticleCount = function () {
                var maxrate;
                var basrat = this.emission.baseddata.rateOverTime;
                maxrate = basrat.isRandom ? basrat._valueLimitMax : basrat._value;
                var liftime = this.emission.baseddata.lifeTime;
                var maxlife = liftime.isRandom ? Math.max(liftime._valueLimitMax, liftime._valueLimitMin) : liftime._value;
                if (!this.emission.baseddata.beloop) {
                    var duration = this.emission.baseddata.duration;
                    if (duration < maxlife) {
                        maxlife = duration;
                    }
                }
                for (var item in this.emission.layer.frameList) {
                    var frame = this.emission.layer.frameList[item];
                    var framerate = this.emission.layer.frames[frame].data.EmissionData.rateOverTime;
                    var rate = framerate.isRandom ? framerate._valueLimitMax : framerate._value;
                    if (rate > maxrate) {
                        maxrate = rate;
                    }
                }
                var burstCount = 0;
                for (var i = 0; i < this.emission.baseddata.bursts.length; i++) {
                    var info = this.emission.baseddata.bursts[i];
                    var Count = info.count.isRandom ? info.count._valueLimitMax : info.count._value;
                    burstCount += Count;
                }
                return Math.floor(maxrate * maxlife + burstCount + 2);
            };
            F14EmissionBatch.prototype.render = function (context, assetmgr, camera, Effqueue) {
                if (!this.mat || !this.mat.setQueue)
                    return;
                //m4m.math.matrixMultiply(this.effect.mvpMat,m4m.math.pool.identityMat, context.matrixModelViewProject);
                if (this.emission.baseddata.simulateInLocalSpace) {
                    m4m.math.matrixClone(this.effect.mvpMat, context.matrixModelViewProject);
                }
                else {
                    //m4m.math.matrixClone(context.matrixViewProject, context.matrixModelViewProject);
                    context.updateModeTrail();
                }
                this.mat.setQueue(Effqueue);
                //---------------------集合数据
                this.curIndexCount = 0;
                this.curVertexcount = 0;
                this.curRealVboCount = 0;
                // console.log("emissionCount:   "+this.emission.particlelist.length);
                for (var i = 0, len = this.emission.particlelist.length; i < len; i++) {
                    this.emission.particlelist[i].uploadMeshdata();
                }
                //---------------------render
                //this.mesh.glMesh.bindVboBuffer(context.webgl);      
                this.mesh.glMesh.uploadVertexData(context.webgl, this.dataForVbo);
                this.mesh.glMesh.uploadIndexData(context.webgl, 0, this.dataForEbo);
                this.mesh.submesh[0].size = this.curIndexCount;
                //console.log("ebo leng="+this.dataForEbo.length+" vbo leng="+this.dataForVbo.length+" draw size="+this.curIndexCount+"particle count="+this.curVertexcount/this.emission.vertexCount+"max count:"+this.maxcoun);
                this.mat.draw(context, this.mesh, this.mesh.submesh[0]);
            };
            F14EmissionBatch.prototype.unRender = function () {
            };
            F14EmissionBatch.prototype.getElementCount = function () {
                return 1;
            };
            F14EmissionBatch.prototype.dispose = function () {
                this.effect = null;
                this.emission = null;
                this.mesh = null;
                this.mat = null;
                delete this.dataForEbo;
                delete this.dataForVbo;
            };
            return F14EmissionBatch;
        }());
        framework.F14EmissionBatch = F14EmissionBatch;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var F14Particle = /** @class */ (function () {
            //private float startTime = 0;
            function F14Particle(element, data) {
                this.StartPos = new m4m.math.vector3();
                this.speedDir = new m4m.math.vector3();
                this.tex_ST = new m4m.math.vector4();
                this.rotationByEuler = new m4m.math.quaternion();
                this.rotationByShape = new m4m.math.quaternion();
                this.startRotation = new m4m.math.quaternion();
                this.rotAngle = 0;
                this.localMatrix = new m4m.math.matrix();
                this.localTranslate = new m4m.math.vector3();
                this.localRotation = new m4m.math.quaternion();
                this.localScale = new m4m.math.vector3(1, 1, 1);
                this.color = new m4m.math.vector3(1, 1, 1);
                this.alpha = 1;
                this.Color = new m4m.math.color();
                this.life01 = 0; //(0---1)
                this.actived = false;
                this.tempos = m4m.math.pool.new_vector3();
                this.temcolor = m4m.math.pool.new_color();
                this.temUv = m4m.math.pool.new_vector2();
                /**
                 * 在emission是在simulate in local space 时候，为matTobathcer
                 * 在emission是在simulate in world space 时候，为matToWorld
                 */
                this.transformVertex = new m4m.math.matrix();
                //------temp value
                this.angleRot = new m4m.math.quaternion();
                this.worldpos = new m4m.math.vector3();
                this.tarWorldpos = new m4m.math.vector3();
                this.worldspeeddir = new m4m.math.vector3();
                this.lookDir = new m4m.math.vector3();
                this.temptx = new m4m.math.vector3();
                this.worldRotation = new m4m.math.quaternion();
                this.invParWorldRot = new m4m.math.quaternion();
                this.worldStartPos = new m4m.math.vector3();
                this.data = data;
                this.element = element;
                this.initByEmissionData(data);
            }
            F14Particle.prototype.getEmissionMatToWorld = function () {
                if (this.data.simulateInLocalSpace) {
                    return this.element.getWorldMatrix();
                }
                else {
                    return this.emissionMatToWorld;
                }
            };
            F14Particle.prototype.getemissionWorldRotation = function () {
                if (this.data.simulateInLocalSpace) {
                    return this.element.getWorldRotation();
                }
                else {
                    return this.emissionWorldRotation;
                }
            };
            F14Particle.prototype.initByEmissionData = function (data) {
                this.actived = true;
                this.curLife = 0;
                this.totalLife = data.lifeTime.getValue(true);
                this.simulateInLocalSpace = data.simulateInLocalSpace;
                this.simulationSpeed = data.simulationSpeed.getValue(true);
                this.startScaleRate = data.startScaleRate.getValue(true);
                this.startScale = data.startScale.getValue(true);
                m4m.math.vec3ScaleByNum(this.startScale, this.startScaleRate, this.startScale);
                this.Starteuler = data.startEuler.getValue(true);
                this.startColor = data.startColor.getValue(true);
                this.startAlpha = data.startAlpha.getValue(true);
                this.colorRate = data.colorRate;
                this.starTex_ST = data.start_tex_st;
                //math.vec4Clone(data.start_tex_st,this.starTex_ST);
                this.movespeed = data.moveSpeed.getValue(true);
                this.sizeNodes = data.sizeNodes;
                this.eulerSpeed = data.angleSpeed.getValue(true);
                this.colorNodes = data.colorNodes;
                this.alphaNodes = data.alphaNodes;
                this.uvType = data.uvType;
                //tex_ST 与粒子curtime也有相关性
                this.getCurTex_ST(data);
                framework.F14EmissionBaseData.getRandomDirAndPosByZEmission(data, this.speedDir, this.StartPos);
                //this.rotationByEuler = Quaternion.Euler(this.Starteuler);
                m4m.math.quatFromEulerAngles(this.Starteuler.x, this.Starteuler.y, this.Starteuler.z, this.rotationByEuler);
                this.rotAngle = 0;
                //todo simulateinworld/billboard
                m4m.math.vec3Clone(this.startScale, this.localScale);
                m4m.math.vec3Clone(this.startColor, this.color);
                this.alpha = this.startAlpha;
                //this.tex_ST = this.starTex_ST;
                m4m.math.vec4Clone(this.starTex_ST, this.tex_ST);
                if (!data.simulateInLocalSpace) {
                    this.emissionMatToWorld = new m4m.math.matrix();
                    this.emissionWorldRotation = new m4m.math.quaternion();
                    m4m.math.matrixClone(this.element.getWorldMatrix(), this.emissionMatToWorld);
                    m4m.math.quatClone(this.element.getWorldRotation(), this.emissionWorldRotation);
                }
                //--strechbillboard
                if (data.rendermodel == framework.RenderModelEnum.StretchedBillBoard) {
                    this.emissionMatToWorld = this.getEmissionMatToWorld();
                    m4m.math.matrixTransformNormal(this.speedDir, this.emissionMatToWorld, this.worldspeeddir);
                    m4m.math.vec3Normalize(this.worldspeeddir, this.worldspeeddir);
                    m4m.math.matrixTransformVector3(this.StartPos, this.emissionMatToWorld, this.worldStartPos);
                }
                // Vector3 worldStartPos = this.getElementMatToWorld() * this.StartPos;
            };
            F14Particle.prototype.update = function (deltaTime) {
                if (!this.actived)
                    return;
                this.curLife += deltaTime;
                //this.curLife = Time.time - this.startTime;
                this.life01 = this.curLife / this.totalLife;
                if (this.life01 > 1) {
                    this.actived = false;
                    // this.transformVertex = Matrix4x4.zero;
                    // this.transformVertex.m33 = 1;
                    //this.updateMeshData();
                    //this.element.particlelist.Remove(this);
                    if (this.element.deadParticles.length < 150)
                        this.element.deadParticles.push(this);
                    return;
                }
                this.updatePos();
                this.updateSize();
                this.updateEuler();
                this.updateRot();
                this.updateLocalMatrix();
                this.updateColor();
                this.updateUV();
                //this.updateMeshData(this.curVertexCount);
            };
            F14Particle.prototype.uploadMeshdata = function () {
                if (this.actived) {
                    var batch = this.element.layer.batch;
                    for (var i = 0; i < this.element.vertexCount; i++) {
                        m4m.math.matrixTransformVector3(this.element.posArr[i], this.transformVertex, this.tempos);
                        batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 0] = this.tempos.x;
                        batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 1] = this.tempos.y;
                        batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 2] = this.tempos.z;
                        //math.colorMultiply(this.element.colorArr[i],this.Color,this.temcolor);
                        if (this.element.colorArr) {
                            m4m.math.colorMultiply(this.element.colorArr[i], this.Color, this.temcolor);
                        }
                        else {
                            m4m.math.colorClone(this.Color, this.temcolor);
                        }
                        batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 3] = this.temcolor.r;
                        batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 4] = this.temcolor.g;
                        batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 5] = this.temcolor.b;
                        batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 6] = this.temcolor.a;
                        this.temUv.x = this.element.uvArr[i].x * this.tex_ST.x + this.tex_ST.z;
                        this.temUv.y = this.element.uvArr[i].y * this.tex_ST.y + this.tex_ST.w;
                        batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 7] = this.temUv.x;
                        batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 8] = this.temUv.y;
                    }
                    for (var i = 0; i < this.element.dataforebo.length; i++) {
                        batch.dataForEbo[i + batch.curIndexCount] = this.element.dataforebo[i] + batch.curVertexcount;
                    }
                    batch.curRealVboCount += this.element.dataforvboLen;
                    batch.curIndexCount += this.element.dataforebo.length;
                    batch.curVertexcount += this.element.vertexCount;
                }
            };
            F14Particle.prototype.updateLocalMatrix = function () {
                m4m.math.matrixMakeTransformRTS(this.localTranslate, this.localScale, this.localRotation, this.localMatrix);
                if (this.data.simulateInLocalSpace) {
                    m4m.math.matrixMultiply(this.element.localMatrix, this.localMatrix, this.transformVertex);
                }
                else {
                    m4m.math.matrixMultiply(this.emissionMatToWorld, this.localMatrix, this.transformVertex);
                }
            };
            F14Particle.prototype.updatePos = function () {
                m4m.math.vec3ScaleByNum(this.speedDir, this.simulationSpeed * this.curLife, this.localTranslate);
                m4m.math.vec3Add(this.localTranslate, this.StartPos, this.localTranslate);
                if (this.data.enableVelocityOverLifetime) {
                    var moved = m4m.math.pool.new_vector3();
                    m4m.math.vec3ScaleByNum(this.movespeed, this.curLife, moved);
                    m4m.math.vec3Add(this.localTranslate, moved, this.localTranslate);
                    m4m.math.pool.delete_vector3(moved);
                }
            };
            F14Particle.prototype.updateSize = function () {
                if (this.data.enableSizeOverLifetime && this.sizeNodes.length > 0) {
                    if (this.sizeNodes[0].key > this.life01) {
                        var tar = m4m.math.numberLerp(1, this.sizeNodes[0].value, this.life01 / this.sizeNodes[0].key);
                        m4m.math.vec3ScaleByNum(this.startScale, tar, this.localScale);
                        return;
                    }
                    for (var i = 0; i < this.sizeNodes.length - 1; i++) {
                        if (this.sizeNodes[i].key <= this.life01 && this.sizeNodes[i + 1].key >= this.life01) {
                            var tar = m4m.math.numberLerp(this.sizeNodes[i].value, this.sizeNodes[i + 1].value, (this.life01 - this.sizeNodes[i].key) / (this.sizeNodes[i + 1].key - this.sizeNodes[i].key));
                            m4m.math.vec3ScaleByNum(this.startScale, tar, this.localScale);
                            break;
                        }
                    }
                }
            };
            F14Particle.prototype.updateEuler = function () {
                if (this.data.enableRotOverLifeTime) {
                    this.rotAngle = this.eulerSpeed * this.curLife;
                }
            };
            F14Particle.prototype.updateRot = function () {
                if (this.data.rendermodel == framework.RenderModelEnum.Mesh) {
                    m4m.math.quatFromAxisAngle(m4m.math.pool.vector3_up, this.rotAngle, this.angleRot);
                    m4m.math.quatMultiply(this.rotationByEuler, this.angleRot, this.localRotation);
                }
                else if (this.data.rendermodel == framework.RenderModelEnum.BillBoard) {
                    this.emissionMatToWorld = this.getEmissionMatToWorld();
                    m4m.math.matrixTransformVector3(this.localTranslate, this.emissionMatToWorld, this.worldpos);
                    var targetTrans = this.element.effect.renderCamera.gameObject.transform;
                    this.tarWorldpos = targetTrans.getWorldTranslate();
                    //m4m.math.quatLookat(this.worldpos, this.tarWorldpos, this.worldRotation);
                    targetTrans.getRightInWorld(this.temptx);
                    m4m.math.vec3ScaleByNum(this.temptx, -1, this.temptx);
                    m4m.math.vec3Subtract(this.tarWorldpos, this.worldpos, this.lookDir);
                    m4m.math.vec3Normalize(this.lookDir, this.lookDir);
                    m4m.math.vec3Cross(this.lookDir, this.temptx, this.worldspeeddir);
                    m4m.math.unitxyzToRotation(this.temptx, this.worldspeeddir, this.lookDir, this.worldRotation);
                    this.emissionWorldRotation = this.getemissionWorldRotation();
                    m4m.math.quatInverse(this.emissionWorldRotation, this.invParWorldRot);
                    m4m.math.quatMultiply(this.invParWorldRot, this.worldRotation, this.localRotation);
                    m4m.math.quatFromAxisAngle(m4m.math.pool.vector3_forward, this.rotAngle + this.Starteuler.z, this.rotationByEuler);
                    m4m.math.quatMultiply(this.localRotation, this.rotationByEuler, this.localRotation);
                }
                else if (this.data.rendermodel == framework.RenderModelEnum.HorizontalBillBoard) {
                    this.worldRotation.x = -0.5;
                    this.worldRotation.y = 0.5;
                    this.worldRotation.z = 0.5;
                    this.worldRotation.w = 0.5;
                    this.emissionWorldRotation = this.getemissionWorldRotation();
                    m4m.math.quatInverse(this.emissionWorldRotation, this.invParWorldRot);
                    m4m.math.quatMultiply(this.invParWorldRot, this.worldRotation, this.localRotation);
                    m4m.math.quatFromAxisAngle(m4m.math.pool.vector3_forward, this.rotAngle + this.Starteuler.z, this.rotationByEuler);
                    m4m.math.quatMultiply(this.localRotation, this.rotationByEuler, this.localRotation);
                }
                else if (this.data.rendermodel == framework.RenderModelEnum.VerticalBillBoard) {
                    this.emissionMatToWorld = this.getEmissionMatToWorld();
                    m4m.math.matrixTransformVector3(this.localTranslate, this.emissionMatToWorld, this.worldpos);
                    var campos = this.element.effect.renderCamera.gameObject.transform.getWorldTranslate();
                    m4m.math.vec3Clone(campos, this.tarWorldpos);
                    this.tarWorldpos.y = this.worldpos.y;
                    m4m.math.quatLookat(this.worldpos, this.tarWorldpos, this.worldRotation);
                    this.emissionWorldRotation = this.getemissionWorldRotation();
                    m4m.math.quatInverse(this.emissionWorldRotation, this.invParWorldRot);
                    m4m.math.quatMultiply(this.invParWorldRot, this.worldRotation, this.localRotation);
                    m4m.math.quatFromAxisAngle(m4m.math.pool.vector3_forward, this.rotAngle + this.Starteuler.z, this.rotationByEuler);
                    m4m.math.quatMultiply(this.localRotation, this.rotationByEuler, this.localRotation);
                }
                else if (this.data.rendermodel == framework.RenderModelEnum.StretchedBillBoard) {
                    //todo先留着
                    //Debug.Log("还未处理！");
                    // Vector3 worldStartPos = this.getElementMatToWorld() * this.StartPos;
                    // Vector3 targetpos = F14EffectPlayer.currentCamera.transform.position;
                    // Vector3 dir = targetpos - worldStartPos;
                    // Vector3 lookdir=(Vector3.Dot(this.speedDir, dir) * this.speedDir + worldStartPos)-targetpos;
                    //Quaternion worldRot = Quaternion.LookRotation(lookdir,this.speedDir);
                    // Quaternion parentRot = this.getElementQuat();
                    // this.localRotation = Quaternion.Inverse(parentRot) * worldRot;
                    this.emissionMatToWorld = this.getEmissionMatToWorld();
                    m4m.math.matrixTransformVector3(this.localTranslate, this.emissionMatToWorld, this.worldpos);
                    var campos = this.element.effect.renderCamera.gameObject.transform.getWorldTranslate();
                    m4m.math.vec3Subtract(campos, this.worldpos, this.lookDir);
                    m4m.math.vec3Normalize(this.lookDir, this.lookDir);
                    m4m.math.vec3Cross(this.worldspeeddir, this.lookDir, this.temptx);
                    m4m.math.vec3Cross(this.temptx, this.worldspeeddir, this.lookDir);
                    m4m.math.unitxyzToRotation(this.temptx, this.worldspeeddir, this.lookDir, this.worldRotation);
                    this.emissionWorldRotation = this.getemissionWorldRotation();
                    m4m.math.quatInverse(this.emissionWorldRotation, this.invParWorldRot);
                    m4m.math.quatMultiply(this.invParWorldRot, this.worldRotation, this.localRotation);
                }
            };
            F14Particle.prototype.updateColor = function () {
                if (this.data.enableColorOverLifetime) {
                    if (this.colorNodes.length > 0) {
                        if (this.colorNodes[0].key > this.life01) {
                            m4m.math.vec3SLerp(this.startColor, this.colorNodes[0].value, this.life01 / this.colorNodes[0].key, this.color);
                        }
                        else {
                            for (var i = 0; i < this.colorNodes.length - 1; i++) {
                                if (this.colorNodes[i].key <= this.life01 && this.colorNodes[i + 1].key >= this.life01) {
                                    m4m.math.vec3SLerp(this.colorNodes[i].value, this.colorNodes[i + 1].value, (this.life01 - this.colorNodes[i].key) / (this.colorNodes[i + 1].key - this.colorNodes[i].key), this.color);
                                    break;
                                }
                            }
                        }
                    }
                    if (this.alphaNodes.length > 0) {
                        if (this.alphaNodes[0].key > this.life01) {
                            this.alpha = m4m.math.numberLerp(this.startAlpha, this.alphaNodes[0].value, this.life01 / this.alphaNodes[0].key);
                        }
                        else {
                            for (var i = 0; i < this.alphaNodes.length - 1; i++) {
                                if (this.alphaNodes[i].key <= this.life01 && this.alphaNodes[i + 1].key >= this.life01) {
                                    this.alpha = m4m.math.numberLerp(this.alphaNodes[i].value, this.alphaNodes[i + 1].value, (this.life01 - this.alphaNodes[i].key) / (this.alphaNodes[i + 1].key - this.alphaNodes[i].key));
                                    break;
                                }
                            }
                        }
                    }
                }
                this.Color.r = this.color.x;
                this.Color.g = this.color.y;
                this.Color.b = this.color.z;
                this.Color.a = this.alpha;
            };
            F14Particle.prototype.updateUV = function () {
                this.getCurTex_ST(this.data);
            };
            F14Particle.prototype.getCurTex_ST = function (data) {
                if (!data.enableTexAnimation)
                    return;
                if (data.uvType == framework.UVTypeEnum.UVRoll) {
                    this.tex_ST.x = 1;
                    this.tex_ST.y = 1;
                    this.tex_ST.z = data.uSpeed * this.curLife;
                    this.tex_ST.w = data.vSpeed * this.curLife;
                }
                else {
                    var index = Math.floor(this.life01 * data.count);
                    if (index >= data.count)
                        index = data.count - 1;
                    m4m.math.spriteAnimation(data.row, data.column, index, this.tex_ST);
                }
            };
            F14Particle.prototype.dispose = function () {
                this.data = null;
                this.element = null;
                delete this.sizeNodes;
                delete this.colorNodes;
                delete this.alphaNodes;
            };
            return F14Particle;
        }());
        framework.F14Particle = F14Particle;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var F14RefElementBatch = /** @class */ (function () {
            function F14RefElementBatch(effect, element) {
                this.type = framework.F14TypeEnum.RefType;
                this.effect = effect;
                this.element = element;
            }
            F14RefElementBatch.prototype.unRender = function () {
                //this.element.RefEffect.unRender();
            };
            F14RefElementBatch.prototype.getElementCount = function () {
                return this.element.RefEffect.getElementCount();
            };
            F14RefElementBatch.prototype.render = function (context, assetmgr, camera, Effqueue) {
                //this.element.RefEffect.render();
                if (this.element.drawActive) {
                    this.element.RefEffect.render(context, assetmgr, camera, Effqueue);
                }
                else {
                    //this.element.RefEffect.unRender();
                }
            };
            F14RefElementBatch.prototype.dispose = function () {
                this.effect = null;
                this.element = null;
            };
            return F14RefElementBatch;
        }());
        framework.F14RefElementBatch = F14RefElementBatch;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var F14RefBaseData = /** @class */ (function () {
            function F14RefBaseData() {
                this.beLoop = false;
                this.localPos = new m4m.math.vector3();
                this.localEuler = new m4m.math.vector3();
                this.localScale = new m4m.math.vector3(1, 1, 1);
            }
            F14RefBaseData.prototype.parse = function (json, assetmgr, assetbundle) {
                this.beLoop = json.beLoop;
                this.refdataName = json.F14EffectData;
                m4m.math.vec3FormJson(json.localPos, this.localPos);
                m4m.math.vec3FormJson(json.localEuler, this.localEuler);
                m4m.math.vec3FormJson(json.localScale, this.localScale);
            };
            return F14RefBaseData;
        }());
        framework.F14RefBaseData = F14RefBaseData;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var F14RefElement = /** @class */ (function () {
            function F14RefElement(effect, layer, bundleName) {
                this.type = framework.F14TypeEnum.RefType;
                this.effect = effect;
                this.baseddata = layer.data.elementdata;
                this.layer = layer;
                var f14Dat = framework.sceneMgr.app.getAssetMgr().getAssetByName(this.baseddata.refdataName, bundleName);
                if (!f14Dat)
                    return;
                this.refreshStartEndFrame();
                this.RefEffect = new framework.f14EffectSystem(bundleName);
                this.RefEffect._root = new framework.transform();
                this.RefEffect.enableDraw = true;
                this.RefEffect.gameObject = this.RefEffect._root.gameObject;
                //this.RefEffect.root.parent=this.effect.gameObject.transform;
                var data = layer.data.elementdata;
                m4m.math.vec3Clone(data.localPos, this.RefEffect._root.localTranslate);
                m4m.math.vec3Clone(data.localScale, this.RefEffect._root.localScale);
                m4m.math.quatFromEulerAngles(data.localEuler.x, data.localEuler.y, data.localEuler.z, this.RefEffect._root.localRotate);
                this.RefEffect._root.markDirty();
                this.RefEffect.beref = true;
                this.baseddata.refData = f14Dat.data;
                this.RefEffect.setData(this.baseddata.refData, bundleName);
                //this.RefEffect.batchRoot = effect.player.transform;
            }
            //---------------------------------------reset-----------------------------------------------
            F14RefElement.prototype.reset = function () {
                this.RefEffect.reset();
            };
            //------------------------------------update----------------------------------------------
            F14RefElement.prototype.refreshStartEndFrame = function () {
                if (this.layer.frameList.length == 0) {
                    this.startFrame = 0;
                }
                else {
                    this.startFrame = this.layer.frameList[0];
                }
                if (this.layer.frameList.length > 1) {
                    this.endFrame = this.layer.frameList[this.layer.frameList.length - 1];
                }
                else {
                    this.endFrame = this.effect.data.lifeTime;
                }
            };
            F14RefElement.prototype.update = function (deltaTime, frame, fps) {
                if (this.RefEffect && this.RefEffect._root.parent == null) {
                    this.effect.gameObject.transform.addChild(this.RefEffect._root);
                    //this.RefEffect._root.parent=this.effect.gameObject.transform;
                    this.RefEffect._root.markDirty();
                    this.RefEffect._root.updateWorldTran();
                }
                if (this.layer.frameList.length == 0) {
                    this.drawActive = false;
                    return;
                }
                if (this.effect.data.beloop) {
                    frame = this.effect.restartFrame;
                }
                if (frame < this.startFrame || frame > this.endFrame) {
                    this.drawActive = false;
                    this.RefEffect["playState"] = framework.PlayStateEnum.beReady;
                    return;
                }
                else {
                    this.drawActive = true;
                    //this.RefEffect["playState"]=PlayStateEnum.play;
                    this.RefEffect.enabletimeFlow = true;
                }
                this.RefEffect.update(deltaTime);
            };
            F14RefElement.prototype.OnEndOnceLoop = function () {
            };
            F14RefElement.prototype.changeColor = function (value) {
                this.RefEffect.changeColor(value);
            };
            F14RefElement.prototype.changeAlpha = function (value) {
                this.RefEffect.changeAlpha(value);
            };
            F14RefElement.prototype.dispose = function () {
                this.baseddata = null;
                this.RefEffect.remove();
                this.RefEffect = null;
            };
            return F14RefElement;
        }());
        framework.F14RefElement = F14RefElement;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var F14SingleMesh = /** @class */ (function () {
            function F14SingleMesh(effect, layer) {
                this.position = new m4m.math.vector3();
                this.scale = new m4m.math.vector3();
                this.euler = new m4m.math.vector3();
                this.color = new m4m.math.color();
                this.tex_ST = new m4m.math.vector4();
                this.localRotate = new m4m.math.quaternion();
                this.targetMat = new m4m.math.matrix();
                //------temp value
                this.tempos = m4m.math.pool.new_vector3();
                this.temColor = m4m.math.pool.new_color();
                this.temUv = m4m.math.pool.new_vector2();
                //----------tempt
                this.eulerRot = new m4m.math.quaternion();
                this.worldpos = new m4m.math.vector3();
                this.worldRot = new m4m.math.quaternion();
                this.inverseRot = new m4m.math.quaternion();
                this.lookDir = new m4m.math.vector3();
                this.worldDirx = new m4m.math.vector3();
                this.worldDiry = new m4m.math.vector3();
                this.type = framework.F14TypeEnum.SingleMeshType;
                this.effect = effect;
                this.layer = layer;
                this.baseddata = layer.data.elementdata;
                m4m.math.vec3Clone(this.baseddata.position, this.position);
                m4m.math.vec3Clone(this.baseddata.scale, this.scale);
                m4m.math.vec3Clone(this.baseddata.euler, this.euler);
                m4m.math.quatFromEulerAngles(this.euler.x, this.euler.y, this.euler.z, this.localRotate);
                m4m.math.colorClone(this.baseddata.color, this.color);
                m4m.math.vec4Clone(this.baseddata.tex_ST, this.tex_ST);
                this.refreshStartEndFrame();
                this.posArr = this.baseddata.mesh.data.pos;
                this.colorArr = this.baseddata.mesh.data.color;
                this.uvArr = this.baseddata.mesh.data.uv;
                this.vertexCount = this.posArr.length;
                this.dataforvbo = this.baseddata.mesh.data.genVertexDataArray(this.effect.VF);
                this.dataforebo = this.baseddata.mesh.data.genIndexDataArray();
            }
            F14SingleMesh.prototype.refreshStartEndFrame = function () {
                if (this.layer.frameList.length == 0) {
                    this.startFrame = 0;
                }
                else {
                    this.startFrame = this.layer.frameList[0];
                }
                if (this.layer.frameList.length > 1) {
                    this.endFrame = this.layer.frameList[this.layer.frameList.length - 1];
                }
                else {
                    this.endFrame = this.effect.data.lifeTime;
                }
            };
            F14SingleMesh.prototype.update = function (deltaTime, frame, fps) {
                if (this.layer.frameList.length == 0) {
                    this.drawActive = false;
                    return;
                }
                if (this.effect.data.beloop) {
                    switch (this.baseddata.loopenum) {
                        case framework.LoopEnum.Restart:
                            frame = this.effect.restartFrame;
                            break;
                        case framework.LoopEnum.TimeContinue:
                            break;
                    }
                }
                if (frame < this.startFrame || frame > this.endFrame) {
                    this.drawActive = false;
                    return;
                }
                else {
                    this.drawActive = true;
                }
                ////------------------time line 方式--------------------
                //先传入本身初始的属性值，属性不一定在lin中存在值，需要初始值
                for (var item in this.layer.Attlines) {
                    var att = this.layer.Attlines[item];
                    att.getValue(frame, this.baseddata, this[item]);
                }
                if (this.baseddata.enableTexAnimation) {
                    this.refreshCurTex_ST(frame, deltaTime, fps);
                }
                this.updateRotByBillboard();
                this.refreshTargetMatrix();
            };
            F14SingleMesh.prototype.OnEndOnceLoop = function () {
                this.reset();
            };
            F14SingleMesh.prototype.refreshTargetMatrix = function () {
                // math.quatFromEulerAngles(this.euler.x, this.euler.y, this.euler.z,this.localRotate);
                m4m.math.matrixMakeTransformRTS(this.position, this.scale, this.localRotate, this.targetMat);
                //return Matrix4x4.TRS(this.position, Quaternion.Euler(this.euler.x, this.euler.y, this.euler.z),this.scale);
            };
            F14SingleMesh.prototype.uploadMeshdata = function () {
                var batch = this.layer.batch;
                for (var i = 0; i < this.vertexCount; i++) {
                    m4m.math.matrixTransformVector3(this.posArr[i], this.targetMat, this.tempos);
                    batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 0] = this.tempos.x;
                    batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 1] = this.tempos.y;
                    batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 2] = this.tempos.z;
                    if (this.colorArr) {
                        m4m.math.colorMultiply(this.colorArr[i], this.color, this.temColor);
                    }
                    else {
                        m4m.math.colorClone(this.color, this.temColor);
                    }
                    batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 3] = this.temColor.r;
                    batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 4] = this.temColor.g;
                    batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 5] = this.temColor.b;
                    batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 6] = this.temColor.a;
                    this.temUv.x = this.uvArr[i].x * this.tex_ST.x + this.tex_ST.z;
                    this.temUv.y = this.uvArr[i].y * this.tex_ST.y + this.tex_ST.w;
                    batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 7] = this.temUv.x;
                    batch.dataForVbo[i * batch.vertexLength + batch.curRealVboCount + 8] = this.temUv.y;
                }
                for (var i = 0; i < this.dataforebo.length; i++) {
                    batch.dataForEbo[i + batch.curIndexCount] = this.dataforebo[i] + batch.curVertexcount;
                }
                batch.curRealVboCount += this.dataforvbo.length;
                batch.curIndexCount += this.dataforebo.length;
                batch.curVertexcount += this.vertexCount;
            };
            F14SingleMesh.prototype.refreshCurTex_ST = function (curframe, detalTime, fps) {
                if (this.baseddata.uvType == framework.UVTypeEnum.UVRoll) {
                    this.tex_ST.z += this.baseddata.uSpeed * detalTime;
                    this.tex_ST.w += this.baseddata.vSpeed * detalTime;
                }
                else if (this.baseddata.uvType == framework.UVTypeEnum.UVSprite) {
                    var lerp = (curframe - this.startFrame) / (this.endFrame + 1 - this.startFrame);
                    var spritindex = Math.floor(lerp * this.baseddata.count);
                    m4m.math.spriteAnimation(this.baseddata.row, this.baseddata.column, spritindex, this.tex_ST);
                }
            };
            F14SingleMesh.prototype.updateRotByBillboard = function () {
                if (this.baseddata.beBillboard) {
                    if (this.baseddata.bindAxis == framework.BindAxis.NONE) {
                        var mat = this.effect.root.getWorldMatrix();
                        m4m.math.matrixTransformVector3(this.position, mat, this.worldpos);
                        var targetpos = this.effect.renderCamera.gameObject.transform.getWorldTranslate();
                        m4m.math.quatLookat(this.worldpos, targetpos, this.worldRot);
                        var parentRot = this.effect.root.getWorldRotate();
                        m4m.math.quatInverse(parentRot, this.inverseRot);
                        m4m.math.quatMultiply(this.inverseRot, this.worldRot, this.localRotate);
                        m4m.math.quatFromAxisAngle(m4m.math.pool.vector3_forward, this.euler.z, this.eulerRot);
                        m4m.math.quatMultiply(this.localRotate, this.eulerRot, this.localRotate);
                    }
                    else if (this.baseddata.bindAxis == framework.BindAxis.X) {
                        var mat = this.effect.root.getWorldMatrix();
                        m4m.math.matrixTransformVector3(this.position, mat, this.worldpos);
                        var targetpos = this.effect.renderCamera.gameObject.transform.getWorldTranslate();
                        m4m.math.vec3Subtract(targetpos, this.worldpos, this.lookDir);
                        m4m.math.vec3Normalize(this.lookDir, this.lookDir);
                        m4m.math.matrixMakeTransformRTS(this.baseddata.position, this.baseddata.scale, this.localRotate, this.targetMat);
                        m4m.math.matrixMultiply(mat, this.targetMat, this.targetMat);
                        m4m.math.matrixTransformNormal(m4m.math.pool.vector3_right, this.targetMat, this.worldDirx);
                        m4m.math.vec3Normalize(this.worldDirx, this.worldDirx);
                        m4m.math.vec3Cross(this.lookDir, this.worldDirx, this.worldDiry);
                        m4m.math.vec3Cross(this.worldDirx, this.worldDiry, this.lookDir);
                        m4m.math.unitxyzToRotation(this.worldDirx, this.worldDiry, this.lookDir, this.worldRot);
                        var parentRot = this.effect.root.getWorldRotate();
                        m4m.math.quatInverse(parentRot, this.inverseRot);
                        m4m.math.quatMultiply(this.inverseRot, this.worldRot, this.localRotate);
                    }
                    else {
                        var mat = this.effect.root.getWorldMatrix();
                        m4m.math.matrixTransformVector3(this.position, mat, this.worldpos);
                        var targetpos = this.effect.renderCamera.gameObject.transform.getWorldTranslate();
                        //m4m.math.quatLookat(this.worldpos,targetpos,this.worldRot);
                        m4m.math.vec3Subtract(targetpos, this.worldpos, this.lookDir);
                        m4m.math.vec3Normalize(this.lookDir, this.lookDir);
                        m4m.math.matrixMakeTransformRTS(this.position, this.scale, this.localRotate, this.targetMat);
                        m4m.math.matrixMultiply(mat, this.targetMat, this.targetMat);
                        m4m.math.matrixTransformNormal(m4m.math.pool.vector3_up, this.targetMat, this.worldDiry);
                        m4m.math.vec3Normalize(this.worldDiry, this.worldDiry);
                        m4m.math.vec3Cross(this.worldDiry, this.lookDir, this.worldDirx);
                        m4m.math.vec3Cross(this.worldDirx, this.worldDiry, this.lookDir);
                        m4m.math.unitxyzToRotation(this.worldDirx, this.worldDiry, this.lookDir, this.worldRot);
                        var parentRot = this.effect.root.getWorldRotate();
                        m4m.math.quatInverse(parentRot, this.inverseRot);
                        m4m.math.quatMultiply(this.inverseRot, this.worldRot, this.localRotate);
                    }
                }
                else {
                    m4m.math.quatFromEulerAngles(this.euler.x, this.euler.y, this.euler.z, this.localRotate);
                }
            };
            F14SingleMesh.prototype.reset = function () {
                m4m.math.vec3Clone(this.baseddata.position, this.position);
                m4m.math.vec3Clone(this.baseddata.scale, this.scale);
                m4m.math.vec3Clone(this.baseddata.euler, this.euler);
                m4m.math.quatFromEulerAngles(this.euler.x, this.euler.y, this.euler.z, this.localRotate);
                m4m.math.colorClone(this.baseddata.color, this.color);
                m4m.math.vec4Clone(this.baseddata.tex_ST, this.tex_ST);
                // if(this.settedAlpha!=null)
                // {
                //     this.color.a=this.baseddata.color.a*this.settedAlpha;
                // }
            };
            F14SingleMesh.prototype.changeColor = function (value) {
                this.color = value;
            };
            F14SingleMesh.prototype.changeAlpha = function (value) {
                // this.color.a=this.baseddata.color.a*this.settedAlpha;
                this.settedAlpha = value;
            };
            F14SingleMesh.prototype.dispose = function () {
                this.layer = null;
                this.RenderBatch = null;
                this.baseddata = null;
                this.effect = null;
                // this.posArr.length=0;
                // this.colorArr.length=0;
                // this.uvArr.length=0;
                delete this.posArr;
                delete this.colorArr;
                delete this.uvArr;
                delete this.dataforvbo;
                delete this.dataforebo;
            };
            return F14SingleMesh;
        }());
        framework.F14SingleMesh = F14SingleMesh;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var F14SingleMeshBath = /** @class */ (function () {
            function F14SingleMeshBath(mat, effect) {
                this.meshlist = [];
                this.activemeshlist = [];
                this.mesh = new framework.mesh();
                this.indices = [];
                this.vertices = [];
                this.colors = [];
                this.uv = [];
                // private totalVertexCount:number=0;
                // private toltalIndexCount:number=0;
                this.curRealVboCount = 0;
                this.curVertexcount = 0;
                this.curIndexCount = 0;
                this.vertexLength = 0;
                this.noBatch = false;
                this.mat = new m4m.math.matrix();
                this.defST = new m4m.math.vector4(1, 1, 0, 0);
                this.temptColorv4 = new m4m.math.vector4();
                this.uploadData = false;
                this.type = framework.F14TypeEnum.SingleMeshType;
                this.effect = effect;
                this.ElementMat = mat;
            }
            F14SingleMeshBath.prototype.OnEndCollectElement = function () {
                this.vertexLength = m4m.render.meshData.calcByteSize(this.effect.VF) / 4;
                if (this.meshlist.length == 1) {
                    this.noBatch = true;
                    this.mesh.glMesh = new m4m.render.glMesh();
                    //this.dataForVbo=this.meshlist[0].dataforvbo;
                    this.dataForVbo = this.meshlist[0].baseddata.mesh.data.genVertexDataArray(this.effect.VF);
                    //this.dataForEbo=this.meshlist[0].dataforebo;
                    this.dataForEbo = this.meshlist[0].baseddata.mesh.data.genIndexDataArray();
                    this.mesh.glMesh.initBuffer(this.effect.webgl, this.effect.VF, this.meshlist[0].baseddata.mesh.data.getVertexCount(), m4m.render.MeshTypeEnum.Static);
                    this.mesh.glMesh.uploadVertexData(this.effect.webgl, this.dataForVbo);
                    this.mesh.glMesh.addIndex(this.effect.webgl, this.dataForEbo.length);
                    this.mesh.glMesh.uploadIndexData(this.effect.webgl, 0, this.dataForEbo);
                    this.mesh.glMesh.initVAO();
                    this.mesh.submesh = [];
                    {
                        var sm = new framework.subMeshInfo();
                        sm.matIndex = 0;
                        sm.start = 0;
                        sm.size = this.dataForEbo.length;
                        sm.line = false;
                        this.mesh.submesh.push(sm);
                    }
                    return;
                }
                var totalVertexCount = 0;
                var toltalIndexCount = 0;
                for (var i = 0, len = this.meshlist.length; i < len; i++) {
                    totalVertexCount += this.meshlist[i].baseddata.mesh.data.getVertexCount();
                    toltalIndexCount += this.meshlist[i].baseddata.mesh.data.getTriIndexCount();
                }
                this.dataForVbo = new Float32Array(totalVertexCount * this.vertexLength);
                this.dataForEbo = new Uint16Array(toltalIndexCount);
                this.mesh.glMesh = new m4m.render.glMesh();
                this.mesh.glMesh.initBuffer(this.effect.webgl, this.effect.VF, totalVertexCount, m4m.render.MeshTypeEnum.Dynamic);
                //this.mesh.glMesh.uploadVertexData(webgl, v32);
                this.mesh.glMesh.addIndex(this.effect.webgl, this.dataForEbo.length);
                this.mesh.glMesh.initVAO();
                //this.mesh.glMesh.uploadIndexData(webgl, 0, i16);
                this.mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.start = 0;
                    sm.size = this.dataForEbo.length;
                    sm.line = false;
                    this.mesh.submesh.push(sm);
                }
            };
            F14SingleMeshBath.prototype.reInit = function (mat, effect) {
                this.effect = effect;
                this.ElementMat = mat;
                this.meshlist.length = 0;
            };
            F14SingleMeshBath.prototype.addElement = function (mesh, insert) {
                if (insert === void 0) { insert = false; }
                this.meshlist.push(mesh);
                mesh.layer.batch = this;
            };
            F14SingleMeshBath.prototype.canBatch = function (mesh) {
                if (this.ElementMat != mesh.baseddata.material) {
                    return false;
                }
                if (this.ElementMat.getShader().getName().indexOf("mask") > 0) {
                    return false;
                }
                return true;
            };
            F14SingleMeshBath.prototype.getElementCount = function () {
                return this.meshlist.length;
            };
            F14SingleMeshBath.prototype.render = function (context, assetmgr, camera, Effqueue) {
                //----------------------------找出draw active 的element----------------------------------
                if (this.meshlist.length == 0)
                    return;
                this.activemeshlist.length = 0;
                for (var i = 0, len = this.meshlist.length; i < len; i++) //比如，前后两个singlemesh的element，用了同一个material，则共用这一个batch
                 {
                    if (this.meshlist[i].drawActive) {
                        this.activemeshlist.push(this.meshlist[i]);
                    }
                }
                if (this.activemeshlist.length < 1)
                    return;
                this.ElementMat.setQueue(Effqueue);
                if (this.noBatch) {
                    m4m.math.matrixMultiply(this.effect.mvpMat, this.activemeshlist[0].targetMat, context.matrixModelViewProject);
                    // if(!this.uploadData)
                    // {
                    //     this.uploadData=true;
                    //     this.dataForVbo=this.activemeshlist[0].baseddata.mesh.data.genVertexDataArray(this.effect.VF);
                    //     this.dataForEbo=this.activemeshlist[0].baseddata.mesh.data.genIndexDataArray();
                    //     this.mesh.glMesh.uploadVertexData(context.webgl,this.dataForVbo);
                    //     this.mesh.glMesh.uploadIndexData(context.webgl, 0, this.dataForEbo);
                    //     this.mesh.submesh[0].size=this.dataForEbo.length;
                    // }
                    var singlemesh = this.activemeshlist[0].baseddata.mesh;
                    if (singlemesh.updateByEffect == false) {
                        var newglmesh = new m4m.render.glMesh();
                        newglmesh.initBuffer(this.effect.webgl, this.effect.VF, singlemesh.data.getVertexCount(), m4m.render.MeshTypeEnum.Static);
                        newglmesh.uploadVertexData(this.effect.webgl, this.activemeshlist[0].dataforvbo);
                        // newglmesh.addIndex(this.effect.webgl, this.activemeshlist[0].dataforebo.length);
                        // newglmesh.uploadIndexData(this.effect.webgl, 0, this.activemeshlist[0].dataforebo);
                        newglmesh.ebo = singlemesh.glMesh.ebo;
                        newglmesh.indexCount = singlemesh.glMesh.indexCount;
                        newglmesh.initVAO();
                        singlemesh.glMesh = newglmesh;
                        singlemesh.submesh[0].size = this.activemeshlist[0].dataforebo.length;
                        singlemesh.updateByEffect = true;
                    }
                    this.temptColorv4.x = this.activemeshlist[0].color.r;
                    this.temptColorv4.y = this.activemeshlist[0].color.g;
                    this.temptColorv4.z = this.activemeshlist[0].color.b;
                    this.temptColorv4.w = this.activemeshlist[0].color.a * (this.activemeshlist[0].settedAlpha || 1.0);
                    // let basemesh=this.activemeshlist[0].baseddata.mesh;
                    this.ElementMat.setVector4("_Main_Color", this.temptColorv4);
                    this.ElementMat.setVector4("_Main_Tex_ST", this.activemeshlist[0].tex_ST);
                    // singlemesh.glMesh.bindVboBuffer(context.webgl);
                    this.ElementMat.draw(context, singlemesh, singlemesh.submesh[0]);
                }
                // if(this.noBatch)
                // {
                //     this.ElementMat.setColor("_Main_Color",this.activemeshlist[0].color);
                //     this.ElementMat.setVector4("_Main_Tex_ST", this.activemeshlist[0].tex_ST);
                //     this.ElementMat.setMatrix("_mat",this.activemeshlist[0].targetMat);
                //     this.ElementMat.draw(context,this.mesh,this.mesh.submesh[0]);
                // }else
                else {
                    m4m.math.matrixClone(this.effect.mvpMat, context.matrixModelViewProject);
                    //---------------------集合数据
                    this.curIndexCount = 0;
                    this.curVertexcount = 0;
                    this.curRealVboCount = 0;
                    for (var i = 0, len = this.activemeshlist.length; i < len; i++) {
                        this.activemeshlist[i].uploadMeshdata();
                    }
                    //---------------------render
                    //this.mesh.glMesh.bindVboBuffer(context.webgl);
                    this.mesh.glMesh.uploadVertexData(context.webgl, this.dataForVbo);
                    this.mesh.glMesh.uploadIndexData(context.webgl, 0, this.dataForEbo);
                    this.mesh.submesh[0].size = this.curIndexCount;
                    this.ElementMat.setVector4("_Main_Color", new m4m.math.vector4(1, 1, 1, 1));
                    this.ElementMat.setVector4("_Main_Tex_ST", new m4m.math.vector4(1, 1, 0, 0));
                    this.ElementMat.draw(context, this.mesh, this.mesh.submesh[0]);
                }
                // if (this.activemeshlist.length == 1)
                // {
                //     let singlemsh=this.activemeshlist[0];
                //     let mesh=singlemsh.baseddata.mesh;
                //     this.ElementMat.setColor("_Main_Color", singlemsh.color);
                //     this.ElementMat.setVector4("_Main_Tex_ST", this.activemeshlist[0].tex_ST);
                //     this.ElementMat.setMatrix("_mat",singlemsh.targetMat);
                //     this.ElementMat.draw(context,mesh,mesh.submesh[0]);
                // }else
                // {
                //     //---------------------集合数据
                //     this.curIndexCount=0;
                //     this.curVertexcount=0;
                //     this.curRealVboCount=0;
                //     for(let i=0,len=this.activemeshlist.length;i<len;i++)
                //     {
                //         this.activemeshlist[i].uploadMeshdata();
                //     }
                //     //---------------------render
                //     this.mesh.glMesh.uploadVertexData(context.webgl,this.dataForVbo);
                //     this.mesh.glMesh.uploadIndexData(context.webgl, 0, this.dataForEbo);
                //     this.mesh.submesh[0].size=this.curIndexCount;
                //     this.ElementMat.draw(context,this.mesh,this.mesh.submesh[0]);
                // }
                //----------------------------按照count分情况处理--------------------------------------
            };
            F14SingleMeshBath.prototype.unRender = function () {
            };
            F14SingleMeshBath.prototype.dispose = function () {
                this.effect = null;
                this.ElementMat = null;
                delete this.meshlist;
                delete this.activemeshlist;
                this.mesh.dispose();
                delete this.mesh;
                delete this.indices;
                delete this.vertices;
                delete this.colors;
                delete this.uv;
                delete this.dataForEbo;
                delete this.dataForVbo;
            };
            return F14SingleMeshBath;
        }());
        framework.F14SingleMeshBath = F14SingleMeshBath;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var LoopEnum;
        (function (LoopEnum) {
            LoopEnum[LoopEnum["Restart"] = 0] = "Restart";
            LoopEnum[LoopEnum["TimeContinue"] = 1] = "TimeContinue";
        })(LoopEnum = framework.LoopEnum || (framework.LoopEnum = {}));
        // export enum UVTypeEnum
        // {
        //     NONE,
        //     UVRoll,
        //     UVSprite
        // }
        var BindAxis;
        (function (BindAxis) {
            BindAxis[BindAxis["X"] = 0] = "X";
            BindAxis[BindAxis["Y"] = 1] = "Y";
            BindAxis[BindAxis["NONE"] = 2] = "NONE";
        })(BindAxis = framework.BindAxis || (framework.BindAxis = {}));
        var F14SingleMeshBaseData = /** @class */ (function () {
            function F14SingleMeshBaseData(firstFrame) {
                this.loopenum = LoopEnum.Restart;
                //public bool beloop = false;
                this.position = new m4m.math.vector3();
                this.scale = new m4m.math.vector3(1, 1, 1);
                this.euler = new m4m.math.vector3();
                this.color = new m4m.math.color(1, 1, 1, 1);
                this.tex_ST = new m4m.math.vector4();
                //-----------------texture animation
                this.enableTexAnimation = false;
                this.uvType = framework.UVTypeEnum.NONE;
                //-------------billboard
                this.beBillboard = false;
                this.bindAxis = BindAxis.NONE;
                //-----------------attline 计算插值
                this.firtstFrame = 0;
                this.firtstFrame = firstFrame;
                this.mesh = m4m.framework.sceneMgr.app.getAssetMgr().getDefaultMesh("quad");
                this.material = m4m.framework.sceneMgr.app.getAssetMgr().getDefParticleMat();
            }
            F14SingleMeshBaseData.prototype.parse = function (json, assetmgr, assetbundle) {
                switch (json.loopenum) {
                    case "Restart":
                        this.loopenum = LoopEnum.Restart;
                        break;
                    case "TimeContinue":
                        this.loopenum = LoopEnum.TimeContinue;
                        break;
                }
                this.mesh = (assetmgr.getAssetByName(json.mesh, assetbundle) || assetmgr.getAssetByName(json.mesh.replace(".mesh.bin", ".cmesh.bin"), assetbundle));
                this.material = assetmgr.getAssetByName(json.material, assetbundle);
                m4m.math.vec3FormJson(json.position, this.position);
                m4m.math.vec3FormJson(json.scale, this.scale);
                m4m.math.vec3FormJson(json.euler, this.euler);
                m4m.math.colorFormJson(json.color, this.color);
                m4m.math.vec4FormJson(json.tex_ST, this.tex_ST);
                this.enableTexAnimation = json.enableTexAnimation;
                if (this.enableTexAnimation) {
                    switch (json.uvType) {
                        case "UVRoll":
                            this.uvType = framework.UVTypeEnum.UVRoll;
                            this.uSpeed = json.uSpeed;
                            this.vSpeed = json.vSpeed;
                            break;
                        case "UVSprite":
                            this.uvType = framework.UVTypeEnum.UVSprite;
                            this.row = json.row;
                            this.column = json.column;
                            this.count = json.count;
                            break;
                        case "NONE":
                            this.uvType = framework.UVTypeEnum.NONE;
                            break;
                    }
                }
                if (json.beBillboard != null) {
                    this.beBillboard = json.beBillboard;
                    switch (json.bindAxis) {
                        case "NONE":
                            this.bindAxis = BindAxis.NONE;
                            break;
                        case "X":
                            this.bindAxis = BindAxis.X;
                            break;
                        case "Y":
                            this.bindAxis = BindAxis.Y;
                            break;
                    }
                }
            };
            return F14SingleMeshBaseData;
        }());
        framework.F14SingleMeshBaseData = F14SingleMeshBaseData;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var starCamCtr = /** @class */ (function () {
            function starCamCtr() {
                this.moveDuration = 1; //移动速度
                this.minSpeed = 5; //角速度
                this.relativelocation = new m4m.math.vector3(0, 6, 0);
                this.relativeEuler = new m4m.math.vector3(90, 0, 0);
                this.relativeRot = new m4m.math.quaternion();
                this.starteCamRot = new m4m.math.quaternion();
                this.targetCamPos = new m4m.math.vector3();
                this.targetCamRot = new m4m.math.quaternion();
                this.movedir = new m4m.math.vector3();
                this.active = false;
                this.moveDis = new m4m.math.vector3();
            }
            starCamCtr.prototype.start = function () {
            };
            starCamCtr.prototype.onPlay = function () {
            };
            starCamCtr.prototype.update = function (delta) {
                if (!this.active)
                    return;
                var pos = this.gameObject.transform.localTranslate;
                var rot = this.gameObject.transform.localRotate;
                var distanc = m4m.math.vec3Distance(pos, this.targetCamPos);
                var movedis = this.moveSpeed * delta;
                if (distanc > movedis) {
                    m4m.math.vec3ScaleByNum(this.movedir, movedis, this.moveDis);
                    m4m.math.vec3Add(pos, this.moveDis, this.gameObject.transform.localTranslate);
                    m4m.math.quatLerp(this.starteCamRot, this.targetCamRot, this.gameObject.transform.localRotate, (this.distance - distanc) / this.distance);
                    this.gameObject.transform.markDirty();
                    this.gameObject.transform.updateWorldTran();
                }
                else {
                    this.active = false;
                }
            };
            starCamCtr.prototype.remove = function () {
            };
            starCamCtr.prototype.clone = function () {
            };
            starCamCtr.prototype.moveTo = function (to) {
                m4m.math.quatClone(this.gameObject.transform.localRotate, this.starteCamRot);
                m4m.math.quatFromEulerAngles(this.relativeEuler.x, this.relativeEuler.y, this.relativeEuler.z, this.relativeRot);
                m4m.math.quatTransformVector(to.localRotate, this.relativelocation, this.targetCamPos);
                m4m.math.vec3Add(to.localTranslate, this.targetCamPos, this.targetCamPos);
                m4m.math.quatMultiply(to.localRotate, this.relativeRot, this.targetCamRot);
                var distanc = m4m.math.pool.new_vector3();
                m4m.math.vec3Subtract(this.targetCamPos, this.gameObject.transform.localTranslate, distanc);
                m4m.math.vec3Normalize(distanc, this.movedir);
                this.distance = m4m.math.vec3Length(distanc);
                this.moveSpeed = this.distance / this.moveDuration;
                m4m.math.pool.delete_vector3(distanc);
                this.active = true;
            };
            starCamCtr.ClassName = "starCamCtr";
            starCamCtr = __decorate([
                m4m.reflect.nodeComponent
            ], starCamCtr);
            return starCamCtr;
        }());
        framework.starCamCtr = starCamCtr;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * The line renderer is used to draw free-floating lines in 3D space.
         *
         * 线渲染器用于在三维空间中绘制自由浮动的线。
         */
        var LineRenderer = /** @class */ (function () {
            function LineRenderer() {
                this.mesh = new m4m.framework.mesh("LineRenderer" + ".mesh.bin");
                this.layer = framework.RenderLayerEnum.Transparent;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 同场景渲染层级时候先后排序依据
                 * @version m4m 1.0
                 */
                this.queue = 0;
                /**
                 * Connect the start and end positions of the line together to form a continuous loop.
                 *
                 * 将直线的起点和终点连接在一起，形成一个连续的回路。
                 */
                this.loop = false;
                /**
                 * 顶点列表。
                 */
                this.positions = [];
                /**
                 * 曲线宽度。
                 */
                this.lineWidth = framework.serialization.setValue(new framework.MinMaxCurve(), { between0And1: true, curveMultiplier: 0.1, mode: framework.MinMaxCurveMode.Curve });
                /**
                 *
                 * 线条颜色。
                 */
                this.lineColor = framework.serialization.setValue(new framework.MinMaxGradient(), { mode: framework.MinMaxGradientMode.Gradient });
                /**
                 * Set this to a value greater than 0, to get rounded corners between each segment of the line.
                 *
                 * 将此值设置为大于0的值，以在直线的每个线段之间获取圆角。
                 */
                this.numCornerVertices = 0;
                /**
                 * Set this to a value greater than 0, to get rounded corners on each end of the line.
                 *
                 * 将此值设置为大于0的值，以在行的两端获得圆角。
                 */
                this.numCapVertices = 0;
                /**
                 * Select whether the line will face the camera, or the orientation of the Transform Component.
                 *
                 * 选择线是否将面对摄像机，或转换组件的方向。
                 */
                // alignment = LineAlignment.View;
                this.alignment = framework.LineAlignment.TransformZ;
                /**
                 * Choose whether the U coordinate of the line texture is tiled or stretched.
                 *
                 * 选择是平铺还是拉伸线纹理的U坐标。
                 */
                this.textureMode = framework.LineTextureMode.Stretch;
                /**
                 * Apply a shadow bias to prevent self-shadowing artifacts. The specified value is the proportion of the line width at each segment.
                 *
                 * 应用阴影偏差以防止自阴影伪影。指定的值是每段线宽的比例。
                 */
                this.shadowBias = 0.5;
                /**
                 * Configures a line to generate Normals and Tangents. With this data, Scene lighting can affect the line via Normal Maps and the Unity Standard Shader, or your own custom-built Shaders.
                 *
                 * 是否自动生成灯光所需的法线与切线。
                 */
                this.generateLightingData = false;
                /**
                 * If enabled, the lines are defined in world space.
                 *
                 * 如果启用，则在世界空间中定义线。
                 */
                this.useWorldSpace = false;
                this.localToWorldMatrix = new m4m.math.matrix();
                this.worldToLocalMatrix = new m4m.math.matrix();
            }
            LineRenderer_1 = LineRenderer;
            Object.defineProperty(LineRenderer.prototype, "renderLayer", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 渲染层级
                 * @version m4m 1.0
                 */
                //renderLayer: CullingMask = CullingMask.default;
                get: function () { return this.gameObject.layer; },
                set: function (layer) {
                    this.gameObject.layer = layer;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(LineRenderer.prototype, "transform", {
                get: function () {
                    return this.gameObject && this.gameObject.transform;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(LineRenderer.prototype, "widthCurve", {
                /**
                 * Set the curve describing the width of the line at various points along its length.
                 *
                 * 设置曲线，以描述沿线长度在各个点处的线宽。
                 */
                get: function () {
                    return this.lineWidth.curve;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(LineRenderer.prototype, "widthMultiplier", {
                /**
                 * Set an overall multiplier that is applied to the LineRenderer.widthCurve to get the final width of the line.
                 *
                 * 设置一个应用于LineRenderer.widthCurve的总乘数，以获取线的最终宽度。
                 */
                get: function () {
                    return this.lineWidth.curveMultiplier;
                },
                set: function (v) {
                    this.lineWidth.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(LineRenderer.prototype, "colorGradient", {
                /**
                 * Set the color gradient describing the color of the line at various points along its length.
                 *
                 * 设置颜色渐变，以描述线条沿其长度的各个点的颜色。
                 */
                get: function () {
                    return this.lineColor.gradient;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(LineRenderer.prototype, "endColor", {
                /**
                 * Set the color at the end of the line.
                 *
                 * 设置线尾颜色。
                 */
                get: function () {
                    var color4 = new m4m.math.color();
                    var color3 = this.colorGradient.colorKeys[this.colorGradient.colorKeys.length - 1];
                    var alpha = this.colorGradient.alphaKeys[this.colorGradient.alphaKeys.length - 1];
                    color4.r = color3.color.r;
                    color4.g = color3.color.g;
                    color4.b = color3.color.b;
                    color4.a = alpha.alpha;
                    return color4;
                },
                set: function (v) {
                    this.colorGradient.alphaKeys[this.colorGradient.alphaKeys.length - 1].alpha = v.a;
                    var color = this.colorGradient.colorKeys[this.colorGradient.colorKeys.length - 1].color;
                    color.r = v.r;
                    color.g = v.g;
                    color.b = v.b;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(LineRenderer.prototype, "endWidth", {
                /**
                 * Set the width at the end of the line.
                 *
                 * 设置线尾宽度。
                 */
                get: function () {
                    return this.widthCurve.keys[this.widthCurve.keys.length - 1].value;
                },
                set: function (v) {
                    this.widthCurve.keys[this.widthCurve.keys.length - 1].value = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(LineRenderer.prototype, "positionCount", {
                /**
                 * Set/get the number of vertices.
                 *
                 * 设置/获取顶点数。
                 */
                get: function () {
                    return this.positions.length;
                },
                set: function (v) {
                    this.positions.length = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(LineRenderer.prototype, "startColor", {
                /**
                 * Set the color at the start of the line.
                 *
                 * 设置行线头颜色。
                 */
                get: function () {
                    var color4 = new m4m.math.color();
                    var color3 = this.colorGradient.colorKeys[0];
                    var alpha = this.colorGradient.alphaKeys[0];
                    color4.r = color3.color.r;
                    color4.g = color3.color.g;
                    color4.b = color3.color.b;
                    color4.a = alpha.alpha;
                    return color4;
                },
                set: function (v) {
                    this.colorGradient.alphaKeys[0].alpha = v.a;
                    var color = this.colorGradient.colorKeys[0].color;
                    color.r = v.r;
                    color.g = v.g;
                    color.b = v.b;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(LineRenderer.prototype, "startWidth", {
                /**
                 * Set the width at the start of the line.
                 *
                 * 设置线头宽度
                 */
                get: function () {
                    return this.widthCurve.keys[0].value * this.widthMultiplier;
                },
                set: function (v) {
                    this.widthCurve.keys[0].value = v / this.widthMultiplier;
                },
                enumerable: false,
                configurable: true
            });
            LineRenderer.prototype.render = function (context, assetmgr, camera) {
                m4m.math.matrixClone(this.transform.getWorldMatrix(), this.localToWorldMatrix);
                m4m.math.matrixInverse(this.localToWorldMatrix, this.worldToLocalMatrix);
                if (!this.material) {
                    this.material = framework.sceneMgr.app.getAssetMgr().getDefLineRendererMat();
                }
                // 清理网格
                LineRenderer_1.clearMesh(this.mesh);
                // 烘焙网格
                this.BakeMesh(this.mesh, camera, false);
                if (this.positions.length < 2)
                    return;
                // 上传网格数据
                LineRenderer_1.uploadMesh(this.mesh, assetmgr.webgl);
                // 绘制
                LineRenderer_1.draw(context, this.gameObject, this.mesh, this.material);
            };
            LineRenderer.prototype.onPlay = function () {
            };
            LineRenderer.prototype.start = function () {
            };
            /**
             * 每帧执行
             */
            LineRenderer.prototype.update = function (interval) {
            };
            LineRenderer.prototype.remove = function () {
                console.warn("\u672A\u5B9E\u73B0 LineRenderer  remove");
                // throw "未实现";
            };
            LineRenderer.prototype.clone = function () {
                console.warn("\u672A\u5B9E\u73B0 LineRenderer  clone");
                // throw "未实现";
            };
            /**
             * Creates a snapshot of LineRenderer and stores it in mesh.
             *
             * 创建LineRenderer的快照并将其存储在网格中。
             *
             * @param mesh	A static mesh that will receive the snapshot of the line.
             * @param camera	The camera used for determining which way camera-space lines will face.
             * @param useTransform	Include the rotation and scale of the Transform in the baked mesh.
             */
            LineRenderer.prototype.BakeMesh = function (mesh, camera, useTransform) {
                var positions = this.positions.concat();
                if (positions.length < 2)
                    return;
                var textureMode = this.textureMode;
                var loop = this.loop;
                var lineWidth = this.lineWidth;
                var alignment = this.alignment;
                var colorGradient = this.colorGradient;
                // 计算摄像机本地坐标
                var cameraPosition = new m4m.math.vector3();
                m4m.math.vec3Clone(camera.gameObject.transform.getWorldPosition(), cameraPosition);
                m4m.math.matrixTransformVector3(cameraPosition, this.worldToLocalMatrix, cameraPosition);
                // 计算线条总长度
                var totalLength = LineRenderer_1.calcTotalLength(positions, loop);
                // 计算结点所在线段位置
                var rateAtLines = LineRenderer_1.calcRateAtLines(positions, loop, textureMode);
                // 计算结点的顶点
                var positionVectex = LineRenderer_1.calcPositionVectex(positions, loop, rateAtLines, lineWidth, alignment, cameraPosition);
                // 计算网格
                LineRenderer_1.calcMesh(positionVectex, textureMode, colorGradient, totalLength, mesh);
            };
            /**
             * Get the position of a vertex in the line.
             *
             * 获取直线在顶点的位置。
             *
             * @param index	The index of the position to retrieve.
             */
            LineRenderer.prototype.GetPosition = function (index) {
                return this.positions[index];
            };
            /**
             * Get the positions of all vertices in the line.
             *
             * 获取行中所有顶点的位置。
             *
             * @param positions	The array of positions to retrieve. The array passed should be of at least positionCount in size.
             *
             * @returns How many positions were actually stored in the output array.
             */
            LineRenderer.prototype.GetPositions = function (positions) {
                if (positions === void 0) { positions = []; }
                positions.length = this.positions.length;
                for (var i = 0; i < this.positions.length; i++) {
                    positions[i] = positions[i] || new m4m.math.vector3();
                    positions[i].x = this.positions[i].x;
                    positions[i].y = this.positions[i].y;
                    positions[i].z = this.positions[i].z;
                }
                return positions;
            };
            /**
             * Set the position of a vertex in the line.
             *
             * 设置顶点在直线中的位置。
             *
             * @param index	Which position to set.
             * @param position	The new position.
             */
            LineRenderer.prototype.setPosition = function (index, position) {
                this.positions[index].x = position.x;
                this.positions[index].y = position.y;
                this.positions[index].z = position.z;
            };
            /**
             * Set the positions of all vertices in the line.
             *
             * 设置线中所有顶点的位置。
             *
             * @param positions	The array of positions to set.
             */
            LineRenderer.prototype.SetPositions = function (positions) {
                this.positions.length = positions.length;
                for (var i = 0; i < positions.length; i++) {
                    this.positions[i] = this.positions[i] || new m4m.math.vector3();
                    this.positions[i].x = positions[i].x;
                    this.positions[i].y = positions[i].y;
                    this.positions[i].z = positions[i].z;
                }
            };
            /**
             * Generates a simplified version of the original line by removing points that fall within the specified tolerance.
             *
             * 通过删除落在指定公差范围内的点，生成原始线的简化版本。
             *
             * @param tolerance	This value is used to evaluate which points should be removed from the line. A higher value results in a simpler line (less points). A positive value close to zero results in a line with little to no reduction. A value of zero or less has no effect.
             *
             * @todo
             */
            LineRenderer.prototype.Simplify = function (tolerance) {
            };
            /**
             * 绘制
             *
             * @param context
             * @param go 游戏对象
             * @param mesh 网格
             * @param material 材质
             */
            LineRenderer.draw = function (context, go, mesh, material) {
                framework.DrawCallInfo.inc.currentState = framework.DrawCallEnum.EffectSystem;
                var tran = go.transform;
                context.updateLightMask(go.layer);
                context.updateModel(tran);
                if (!material)
                    return;
                if (mesh == null || mesh.glMesh == null || mesh.submesh == null)
                    return;
                var subMeshs = mesh.submesh;
                if (subMeshs == null)
                    return;
                // mesh.glMesh.bindVboBuffer(context.webgl);
                material.draw(context, mesh, subMeshs[0]);
            };
            /**
             * 清理网格
             *
             * @param mesh
             */
            LineRenderer.clearMesh = function (mesh) {
                if (!mesh.data) {
                    mesh.data = new m4m.render.meshData();
                }
                var data = mesh.data;
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                data.color = [];
            };
            LineRenderer.uploadMesh = function (_mesh, webgl) {
                var vf = m4m.render.VertexFormatMask.Position | m4m.render.VertexFormatMask.Normal | m4m.render.VertexFormatMask.Tangent | m4m.render.VertexFormatMask.Color | m4m.render.VertexFormatMask.UV0;
                _mesh.data.originVF = vf;
                var v32 = _mesh.data.genVertexDataArray(vf);
                var i16 = _mesh.data.genIndexDataArray();
                _mesh.glMesh = new m4m.render.glMesh();
                _mesh.glMesh.initBuffer(webgl, vf, _mesh.data.getVertexCount());
                _mesh.glMesh.uploadVertexData(webgl, v32);
                _mesh.glMesh.addIndex(webgl, i16.length);
                _mesh.glMesh.uploadIndexData(webgl, 0, i16);
                _mesh.glMesh.initVAO();
                _mesh.submesh = [];
                {
                    var sm = new m4m.framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.start = 0;
                    sm.size = i16.length;
                    sm.line = false;
                    _mesh.submesh.push(sm);
                }
            };
            /**
             * 计算网格
             *
             * @param positionVectex 顶点列表
             * @param rateAtLines 顶点所在线条位置
             * @param textureMode 纹理模式
             * @param totalLength 线条总长度
             * @param mesh 保存网格数据的对象
             */
            LineRenderer.calcMesh = function (positionVectex, textureMode, colorGradient, totalLength, mesh) {
                var data = mesh.data;
                var a_positions = [];
                var a_uvs = [];
                var a_colors = [];
                //
                // 摄像机在该对象空间内的坐标
                for (var i = 0, n = positionVectex.length; i < n; i++) {
                    //
                    var vertex = positionVectex[i];
                    //
                    var offset0 = vertex.vertexs[0];
                    var offset1 = vertex.vertexs[1];
                    //
                    var rateAtLine = vertex.rateAtLine;
                    // 颜色
                    var currentColor = colorGradient.getValue(rateAtLine);
                    //
                    a_positions.push(offset0.x, offset0.y, offset0.z, offset1.x, offset1.y, offset1.z);
                    a_colors.push(currentColor.r, currentColor.g, currentColor.b, currentColor.a, currentColor.r, currentColor.g, currentColor.b, currentColor.a);
                    // 计算UV
                    if (textureMode == framework.LineTextureMode.Stretch) {
                        a_uvs.push(rateAtLine, 1, rateAtLine, 0);
                    }
                    else if (textureMode == framework.LineTextureMode.Tile) {
                        a_uvs.push(rateAtLine * totalLength, 1, rateAtLine * totalLength, 0);
                    }
                    else if (textureMode == framework.LineTextureMode.DistributePerSegment) {
                        a_uvs.push(rateAtLine, 1, rateAtLine, 0);
                    }
                    else if (textureMode == framework.LineTextureMode.RepeatPerSegment) {
                        a_uvs.push(i, 1, i, 0);
                    }
                    // 计算索引
                    if (i > 0) {
                        m4m.render.meshData.addQuadVec3ByValue(data.normal, vertex.normal);
                        m4m.render.meshData.addQuadPos(data, [
                            new m4m.math.vector3(a_positions[(i - 1) * 6], a_positions[(i - 1) * 6 + 1], a_positions[(i - 1) * 6 + 2]),
                            new m4m.math.vector3(a_positions[(i - 1) * 6 + 3], a_positions[(i - 1) * 6 + 4], a_positions[(i - 1) * 6 + 5]),
                            new m4m.math.vector3(a_positions[i * 6], a_positions[i * 6 + 1], a_positions[i * 6 + 2]),
                            new m4m.math.vector3(a_positions[i * 6 + 3], a_positions[i * 6 + 4], a_positions[i * 6 + 5]),
                        ]);
                        m4m.render.meshData.addQuadVec2(data.uv, [
                            new m4m.math.vector2(a_uvs[(i - 1) * 4], a_uvs[(i - 1) * 4 + 1]),
                            new m4m.math.vector2(a_uvs[(i - 1) * 4 + 2], a_uvs[(i - 1) * 4 + 3]),
                            new m4m.math.vector2(a_uvs[i * 4], a_uvs[i * 4 + 1]),
                            new m4m.math.vector2(a_uvs[i * 4 + 2], a_uvs[i * 4 + 3])
                        ]);
                        m4m.render.meshData.addQuadVec3ByValue(data.tangent, vertex.tangent);
                        data.color.push(new m4m.math.color(a_colors[(i - 1) * 8], a_colors[(i - 1) * 8 + 1], a_colors[(i - 1) * 8 + 2], a_colors[(i - 1) * 8 + 3]), new m4m.math.color(a_colors[(i - 1) * 8 + 4], a_colors[(i - 1) * 8 + 5], a_colors[(i - 1) * 8 + 6], a_colors[(i - 1) * 8 + 7]), new m4m.math.color(a_colors[i * 8], a_colors[i * 8 + 1], a_colors[i * 8 + 2], a_colors[i * 8 + 3]), new m4m.math.color(a_colors[i * 8 + 4], a_colors[i * 8 + 5], a_colors[i * 8 + 6], a_colors[i * 8 + 7]));
                    }
                }
            };
            /**
             * 计算结点的三角形顶点列表
             *
             * @param positions 结点列表
             * @param loop 是否成换线
             * @param rateAtLines 结点所在线条位置
             * @param lineWidth 线条宽度曲线
             * @param alignment 朝向方式
             * @param cameraPosition 摄像机局部坐标
             */
            LineRenderer.calcPositionVectex = function (positions, loop, rateAtLines, lineWidth, alignment, cameraPosition) {
                // 
                var positionVectex = [];
                // 处理两端循环情况
                if (loop) {
                    positions.unshift(positions[positions.length - 1]);
                    positions.push(positions[1]);
                    positions.push(positions[2]);
                }
                else {
                    positions.unshift(positions[0]);
                    positions.push(positions[positions.length - 1]);
                }
                //
                var positionCount = positions.length;
                //
                // 摄像机在该对象空间内的坐标
                for (var i = 0; i < positionCount - 2; i++) {
                    // 顶点索引
                    var prePosition = positions[i];
                    var currentPosition = positions[i + 1];
                    var nextPosition = positions[i + 2];
                    //
                    // 当前所在线条，0表示起点，1表示终点
                    var rateAtLine = rateAtLines[i];
                    // 线条宽度
                    var currentLineWidth = lineWidth.getValue(rateAtLine);
                    // 切线，线条方向
                    var tangent0 = new m4m.math.vector3(0, 0, 0);
                    m4m.math.vec3Subtract(currentPosition, prePosition, tangent0);
                    m4m.math.vec3Normalize(tangent0, tangent0);
                    var tangent1 = new m4m.math.vector3(0, 0, 0);
                    m4m.math.vec3Subtract(nextPosition, currentPosition, tangent1);
                    m4m.math.vec3Normalize(tangent1, tangent1);
                    var tangent = new m4m.math.vector3(1, 0, 0);
                    m4m.math.vec2Add(tangent0, tangent1, tangent);
                    m4m.math.vec3Normalize(tangent, tangent);
                    // 处理切线为0的情况
                    if (m4m.math.vec3SqrLength(tangent) == 0) {
                        if (m4m.math.vec3SqrLength(tangent0) != 0)
                            m4m.math.vec3Clone(tangent0, tangent);
                        else {
                            tangent.x = 1;
                            tangent.y = 0;
                            tangent.y = 0;
                        }
                    }
                    // 法线，面朝向
                    var normal = new m4m.math.vector3(0, 0, -1);
                    if (alignment == framework.LineAlignment.View) {
                        m4m.math.vec3Subtract(cameraPosition, currentPosition, normal);
                        m4m.math.vec3Normalize(normal, normal);
                    }
                    else if (alignment == framework.LineAlignment.TransformZ) {
                        normal.x = 0;
                        normal.y = 0;
                        normal.z = -1;
                    }
                    // 使用强制面向Z轴或者摄像机，会出现 与 线条方向一致的情况
                    if (m4m.math.vec3IsParallel(tangent, normal)) {
                        // 强制修改切线方向
                        tangent.x = 1;
                        tangent.y = 0;
                        tangent.z = 0;
                        if (m4m.math.vec3IsParallel(tangent, normal)) {
                            tangent.x = 0;
                            tangent.y = 1;
                            tangent.z = 0;
                        }
                        // 重新计算与法线垂直的切线
                        var tempTN = new m4m.math.vector3();
                        m4m.math.vec3Cross(tangent, normal, tempTN);
                        m4m.math.vec3Cross(normal, tempTN, tangent);
                        m4m.math.vec3Normalize(tangent, tangent);
                    }
                    // 用于计算线条中点生成两个点的偏移量
                    var offset = new m4m.math.vector3();
                    m4m.math.vec3Cross(tangent, normal, offset);
                    m4m.math.vec3Normalize(offset, offset);
                    m4m.math.vec3ScaleByNum(offset, currentLineWidth / 2, offset);
                    // 保持线条宽度
                    var temp = new m4m.math.vector3();
                    m4m.math.vec3Clone(offset, temp);
                    m4m.math.vec3Normalize(temp, temp);
                    var cos = m4m.math.vec3Dot(temp, tangent0);
                    var sin = Math.sqrt(1 - Math.pow(cos, 2));
                    sin = Math.min(Math.max(sin, 0.2), 5);
                    m4m.math.vec3ScaleByNum(offset, 1 / sin, offset);
                    //
                    var offset0 = new m4m.math.vector3();
                    m4m.math.vec3Add(currentPosition, offset, offset0);
                    var offset1 = new m4m.math.vector3();
                    m4m.math.vec3Subtract(currentPosition, offset, offset1);
                    //
                    positionVectex[i] = { vertexs: [offset0, offset1], tangent: tangent0, normal: normal, rateAtLine: rateAtLine };
                }
                return positionVectex;
            };
            /**
             * 计算线条总长度
             *
             * @param positions 顶点列表
             * @param loop 是否循环
             */
            LineRenderer.calcTotalLength = function (positions, loop) {
                var total = 0;
                var length = positions.length;
                for (var i = 0, n = length - 1; i < n; i++) {
                    total += m4m.math.vec3Distance(positions[i + 1], positions[i]);
                }
                if (loop && length > 0) {
                    total += m4m.math.vec3Distance(positions[length - 1], positions[0]);
                }
                return total;
            };
            /**
             * 计算结点所在线段位置
             *
             * @param positions 顶点列表
             * @param loop 是否循环
             */
            LineRenderer.calcRateAtLines = function (positions, loop, textureMode) {
                // 结点所在线段位置
                var rateAtLines = [0];
                // 线条总长度
                var totalLength = 0;
                var positionCount = positions.length;
                for (var i = 0, n = positionCount - 1; i < n; i++) {
                    totalLength += m4m.math.vec3Distance(positions[i + 1], positions[i]);
                    rateAtLines[i + 1] = totalLength;
                }
                if (loop && positionCount > 0) {
                    totalLength += m4m.math.vec3Distance(positions[positionCount - 1], positions[0]);
                    rateAtLines[positionCount] = totalLength;
                }
                // 计算结点所在线段位置
                rateAtLines = rateAtLines.map(function (v, i) {
                    // 计算UV
                    if (textureMode == framework.LineTextureMode.Stretch || textureMode == framework.LineTextureMode.Tile) {
                        return v / totalLength;
                    }
                    return i / (loop ? positionCount : (positionCount - 1));
                });
                return rateAtLines;
            };
            var LineRenderer_1;
            LineRenderer.ClassName = "LineRenderer";
            __decorate([
                m4m.reflect.Field("material"),
                __metadata("design:type", framework.material)
            ], LineRenderer.prototype, "material", void 0);
            LineRenderer = LineRenderer_1 = __decorate([
                m4m.reflect.nodeRender,
                m4m.reflect.nodeComponent
            ], LineRenderer);
            return LineRenderer;
        }());
        framework.LineRenderer = LineRenderer;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * The trail renderer is used to make trails behind objects in the Scene as they move about.
         *
         * 拖尾染器
         */
        var TrailRenderer = /** @class */ (function () {
            function TrailRenderer() {
                this.mesh = new m4m.framework.mesh("TrailRenderer" + ".mesh.bin");
                this.layer = framework.RenderLayerEnum.Transparent;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 同场景渲染层级时候先后排序依据
                 * @version m4m 1.0
                 */
                this.queue = 0;
                /**
                 * 结点列表。
                 */
                this.positions = [];
                /**
                 * 曲线宽度。
                 */
                this.lineWidth = framework.serialization.setValue(new framework.MinMaxCurve(), { between0And1: true, curveMultiplier: 0.1, mode: framework.MinMaxCurveMode.Curve });
                /**
                 *
                 * 线条颜色。
                 */
                this.lineColor = framework.serialization.setValue(new framework.MinMaxGradient(), { mode: framework.MinMaxGradientMode.Gradient });
                /**
                 * Set this to a value greater than 0, to get rounded corners between each segment of the line.
                 *
                 * 将此值设置为大于0的值，以在直线的每个线段之间获取圆角。
                 */
                this.numCornerVertices = 0;
                /**
                 * Set this to a value greater than 0, to get rounded corners on each end of the line.
                 *
                 * 将此值设置为大于0的值，以在行的两端获得圆角。
                 */
                this.numCapVertices = 0;
                /**
                 * Select whether the line will face the camera, or the orientation of the Transform Component.
                 *
                 * 选择线是否将面对摄像机，或转换组件的方向。
                 */
                // alignment = LineAlignment.View;
                this.alignment = framework.LineAlignment.TransformZ;
                /**
                 * Does the GameObject of this Trail Renderer auto destruct?
                 */
                this.autodestruct = false;
                /**
                 * Creates trails when the GameObject moves.
                 */
                this.emitting = true;
                /**
                 * Set the minimum distance the trail can travel before a new vertex is added to it.
                 */
                this.minVertexDistance = 0.1;
                /**
                 * How long does the trail take to fade out.
                 */
                this.time = 5;
                /**
                 * Choose whether the U coordinate of the line texture is tiled or stretched.
                 *
                 * 选择是平铺还是拉伸线纹理的U坐标。
                 */
                this.textureMode = framework.LineTextureMode.Stretch;
                /**
                 * Apply a shadow bias to prevent self-shadowing artifacts. The specified value is the proportion of the line width at each segment.
                 *
                 * 应用阴影偏差以防止自阴影伪影。指定的值是每段线宽的比例。
                 */
                this.shadowBias = 0.5;
                /**
                 * Configures a line to generate Normals and Tangents. With this data, Scene lighting can affect the line via Normal Maps and the Unity Standard Shader, or your own custom-built Shaders.
                 *
                 * 是否自动生成灯光所需的法线与切线。
                 */
                this.generateLightingData = false;
                /**
                 * 上次结点位置
                 */
                this._preworldPos = null;
                this.localToWorldMatrix = new m4m.math.matrix();
                this.worldToLocalMatrix = new m4m.math.matrix();
            }
            Object.defineProperty(TrailRenderer.prototype, "renderLayer", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 渲染层级
                 * @version m4m 1.0
                 */
                //renderLayer: CullingMask = CullingMask.default;
                get: function () { return this.gameObject.layer; },
                set: function (layer) {
                    this.gameObject.layer = layer;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(TrailRenderer.prototype, "transform", {
                get: function () {
                    return this.gameObject && this.gameObject.transform;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(TrailRenderer.prototype, "widthCurve", {
                /**
                 * Set the curve describing the width of the line at various points along its length.
                 *
                 * 设置曲线，以描述沿线长度在各个点处的线宽。
                 */
                get: function () {
                    return this.lineWidth.curve;
                },
                set: function (v) {
                    this.lineWidth.curve = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(TrailRenderer.prototype, "widthMultiplier", {
                /**
                 * Set an overall multiplier that is applied to the LineRenderer.widthCurve to get the final width of the line.
                 *
                 * 设置一个应用于LineRenderer.widthCurve的总乘数，以获取线的最终宽度。
                 */
                get: function () {
                    return this.lineWidth.curveMultiplier;
                },
                set: function (v) {
                    this.lineWidth.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(TrailRenderer.prototype, "colorGradient", {
                /**
                 * Set the color gradient describing the color of the line at various points along its length.
                 *
                 * 设置颜色渐变，以描述线条沿其长度的各个点的颜色。
                 */
                get: function () {
                    return this.lineColor.gradient;
                },
                set: function (v) {
                    this.lineColor.gradient = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(TrailRenderer.prototype, "endColor", {
                /**
                 * Set the color at the end of the line.
                 *
                 * 设置线尾颜色。
                 */
                get: function () {
                    var color4 = new m4m.math.color();
                    var color3 = this.colorGradient.colorKeys[this.colorGradient.colorKeys.length - 1];
                    var alpha = this.colorGradient.alphaKeys[this.colorGradient.alphaKeys.length - 1];
                    color4.r = color3.color.r;
                    color4.g = color3.color.g;
                    color4.b = color3.color.b;
                    color4.a = alpha.alpha;
                    return color4;
                },
                set: function (v) {
                    this.colorGradient.alphaKeys[this.colorGradient.alphaKeys.length - 1].alpha = v.a;
                    var color = this.colorGradient.colorKeys[this.colorGradient.colorKeys.length - 1].color;
                    color.r = v.r;
                    color.g = v.g;
                    color.b = v.b;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(TrailRenderer.prototype, "endWidth", {
                /**
                 * Set the width at the end of the line.
                 *
                 * 设置线尾宽度。
                 */
                get: function () {
                    return this.widthCurve.keys[this.widthCurve.keys.length - 1].value * this.widthMultiplier;
                },
                set: function (v) {
                    this.widthCurve.keys[this.widthCurve.keys.length - 1].value = v / this.widthMultiplier;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(TrailRenderer.prototype, "positionCount", {
                /**
                 * Set/get the number of vertices.
                 *
                 * 设置/获取顶点数。
                 */
                get: function () {
                    return this.positions.length;
                },
                set: function (v) {
                    this.positions.length = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(TrailRenderer.prototype, "startColor", {
                /**
                 * Set the color at the start of the line.
                 *
                 * 设置行线头颜色。
                 */
                get: function () {
                    var color4 = new m4m.math.color();
                    var color3 = this.colorGradient.colorKeys[0];
                    var alpha = this.colorGradient.alphaKeys[0];
                    color4.r = color3.color.r;
                    color4.g = color3.color.g;
                    color4.b = color3.color.b;
                    color4.a = alpha.alpha;
                    return color4;
                },
                set: function (v) {
                    this.colorGradient.alphaKeys[0].alpha = v.a;
                    var color = this.colorGradient.colorKeys[0].color;
                    color.r = v.r;
                    color.g = v.g;
                    color.b = v.b;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(TrailRenderer.prototype, "startWidth", {
                /**
                 * Set the width at the start of the line.
                 *
                 * 设置线头宽度
                 */
                get: function () {
                    return this.widthCurve.keys[0].value * this.widthMultiplier;
                },
                set: function (v) {
                    this.widthCurve.keys[0].value = v / this.widthMultiplier;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(TrailRenderer.prototype, "trailRendererData", {
                get: function () {
                    return this._trailRendererData;
                },
                set: function (v) {
                    var data = framework.TrailRendererData.get(v.value);
                    if (data.objectData) {
                        framework.serialization.setValue(this, data.objectData);
                    }
                    else {
                        data.trailRenderer = this;
                    }
                    this._trailRendererData = data;
                },
                enumerable: false,
                configurable: true
            });
            TrailRenderer.prototype.render = function (context, assetmgr, camera) {
                m4m.math.matrixClone(this.transform.getWorldMatrix(), this.localToWorldMatrix);
                m4m.math.matrixInverse(this.localToWorldMatrix, this.worldToLocalMatrix);
                if (!this.material) {
                    this.material = framework.sceneMgr.app.getAssetMgr().getDefLineRendererMat();
                }
                // 清理网格
                framework.LineRenderer.clearMesh(this.mesh);
                // 烘焙网格
                this.BakeMesh(this.mesh, camera, false);
                if (this.positions.length < 2)
                    return;
                // 上传网格数据
                framework.LineRenderer.uploadMesh(this.mesh, assetmgr.webgl);
                // 绘制
                framework.LineRenderer.draw(context, this.gameObject, this.mesh, this.material);
            };
            TrailRenderer.prototype.onPlay = function () {
            };
            TrailRenderer.prototype.start = function () {
            };
            TrailRenderer.prototype.remove = function () {
                console.warn("\u672A\u5B9E\u73B0 TrailRenderer  remove");
                // throw "未实现";
            };
            TrailRenderer.prototype.clone = function () {
                console.warn("\u672A\u5B9E\u73B0 TrailRenderer  remove");
                // throw "未实现";
            };
            /**
             * 每帧执行
             */
            TrailRenderer.prototype.update = function (interval) {
                var _this = this;
                m4m.math.matrixClone(this.transform.getWorldMatrix(), this.localToWorldMatrix);
                m4m.math.matrixInverse(this.localToWorldMatrix, this.worldToLocalMatrix);
                if (this.emitting) {
                    var currentPosition = new m4m.math.vector3();
                    m4m.math.vec3Clone(this.transform.getWorldPosition(), currentPosition);
                    // 初始化一个必定添加顶点的值
                    var moveDistance = this.minVertexDistance * 2;
                    if (this._preworldPos)
                        moveDistance = m4m.math.vec3Distance(currentPosition, this._preworldPos);
                    // 移动新增结点
                    if (moveDistance >= this.minVertexDistance) {
                        this.AddPosition(currentPosition);
                        this._preworldPos = currentPosition;
                    }
                }
                // 移除死亡结点
                var nowTime = Date.now();
                this.positions = this.positions.filter(function (v) { return ((nowTime - v.birthTime) < _this.time * 1000); });
                //
                if (this.positions.length == 0) {
                    this._preworldPos == null;
                }
            };
            /**
             * Creates a snapshot of LineRenderer and stores it in mesh.
             *
             * 创建LineRenderer的快照并将其存储在网格中。
             *
             * @param mesh	A static mesh that will receive the snapshot of the line.
             * @param camera	The camera used for determining which way camera-space lines will face.
             * @param useTransform	Include the rotation and scale of the Transform in the baked mesh.
             */
            TrailRenderer.prototype.BakeMesh = function (mesh, camera, useTransform) {
                var _this = this;
                var positions = this.positions.map(function (v) { return v.position; });
                if (positions.length < 2)
                    return;
                var textureMode = this.textureMode;
                var loop = false;
                var lineWidth = this.lineWidth;
                var alignment = this.alignment;
                var colorGradient = this.colorGradient;
                // 计算摄像机世界坐标
                var cameraPosition = new m4m.math.vector3();
                m4m.math.vec3Clone(camera.gameObject.transform.getWorldPosition(), cameraPosition);
                // 计算线条总长度
                var totalLength = framework.LineRenderer.calcTotalLength(positions, loop);
                // 计算结点所在线段位置
                var rateAtLines = framework.LineRenderer.calcRateAtLines(positions, loop, textureMode);
                // 计算结点的顶点
                var positionVectex = framework.LineRenderer.calcPositionVectex(positions, loop, rateAtLines, lineWidth, alignment, cameraPosition);
                // 世界坐标转换为局部坐标
                positionVectex.forEach(function (v) {
                    v.vertexs.forEach(function (ver) {
                        m4m.math.matrixTransformVector3(ver, _this.worldToLocalMatrix, ver);
                    });
                });
                // 计算网格
                framework.LineRenderer.calcMesh(positionVectex, textureMode, colorGradient, totalLength, mesh);
            };
            /**
             * Adds a position to the trail.
             *
             * @param position	The position to add to the trail.
             */
            TrailRenderer.prototype.AddPosition = function (position) {
                this.positions.unshift({ position: position, birthTime: Date.now() });
            };
            /**
             * Add an array of positions to the trail.
             *
             * All points inside a TrailRenderer store a timestamp when they are born. This, together with the TrailRenderer.time property, is used to determine when they will be removed. For trails to disappear smoothly, each position must have a unique, increasing timestamp. When positions are supplied from script and the current time is identical for multiple points, position timestamps are adjusted to interpolate smoothly between the timestamp of the newest existing point in the trail and the current time.
             *
             * @param positions	The positions to add to the trail.
             */
            TrailRenderer.prototype.AddPositions = function (positions) {
                var preTime = Date.now();
                if (this.positions.length > 0)
                    preTime = this.positions[this.positions.length - 1].birthTime;
                for (var i = 0, n = positions.length; i < n; i++) {
                    this.positions.unshift({
                        position: positions[i], birthTime: preTime + (Date.now() - preTime) * (i + 1) / n
                    });
                }
            };
            /**
             * Removes all points from the TrailRenderer. Useful for restarting a trail from a new position.
             */
            TrailRenderer.prototype.Clear = function () {
                this.positions.length = 0;
                this._preworldPos = null;
            };
            /**
             * Get the position of a vertex in the line.
             *
             * 获取直线在顶点的位置。
             *
             * @param index	The index of the position to retrieve.
             */
            TrailRenderer.prototype.GetPosition = function (index) {
                return this.positions[index];
            };
            /**
             * Get the positions of all vertices in the line.
             *
             * 获取行中所有顶点的位置。
             *
             * @param positions	The array of positions to retrieve. The array passed should be of at least positionCount in size.
             *
             * @returns How many positions were actually stored in the output array.
             */
            TrailRenderer.prototype.GetPositions = function (positions) {
                if (positions === void 0) { positions = []; }
                positions.length = this.positions.length;
                for (var i = 0; i < this.positions.length; i++) {
                    positions[i] = positions[i] || new m4m.math.vector3();
                    positions[i].x = this.positions[i].position.x;
                    positions[i].y = this.positions[i].position.y;
                    positions[i].z = this.positions[i].position.z;
                }
                return positions;
            };
            /**
             * Set the position of a vertex in the line.
             *
             * 设置顶点在直线中的位置。
             *
             * @param index	Which position to set.
             * @param position	The new position.
             */
            TrailRenderer.prototype.setPosition = function (index, position) {
                this.positions[index].position.x = position.x;
                this.positions[index].position.y = position.y;
                this.positions[index].position.z = position.z;
            };
            /**
             * Set the positions of all vertices in the line.
             *
             * 设置线中所有顶点的位置。
             *
             * @param positions	The array of positions to set.
             */
            TrailRenderer.prototype.SetPositions = function (positions) {
                this.positions.length = positions.length;
                for (var i = 0; i < positions.length; i++) {
                    if (this.positions[i]) {
                        this.positions[i].position.x = positions[i].x;
                        this.positions[i].position.y = positions[i].y;
                        this.positions[i].position.z = positions[i].z;
                    }
                }
            };
            TrailRenderer.ClassName = "trailrenderer";
            __decorate([
                m4m.reflect.Field("material"),
                __metadata("design:type", framework.material)
            ], TrailRenderer.prototype, "material", void 0);
            __decorate([
                m4m.reflect.Field("TrailRendererData"),
                __metadata("design:type", Object),
                __metadata("design:paramtypes", [Object])
            ], TrailRenderer.prototype, "trailRendererData", null);
            TrailRenderer = __decorate([
                m4m.reflect.nodeRender,
                m4m.reflect.nodeComponent
            ], TrailRenderer);
            return TrailRenderer;
        }());
        framework.TrailRenderer = TrailRenderer;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * 拖尾染器数据
         */
        var TrailRendererData = /** @class */ (function () {
            function TrailRendererData(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.name = null;
                this.id = new framework.resID();
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 是否为默认资源
                 * @version m4m 1.0
                 */
                this.defaultAsset = false;
                if (!assetName) {
                    assetName = "TrailRenderer_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            TrailRendererData_1 = TrailRendererData;
            /**
             * 获取已经创建了的粒子系统数据
             *
             * @param valueName
             */
            TrailRendererData.get = function (valueName) {
                return this._datas[valueName];
            };
            Object.defineProperty(TrailRendererData.prototype, "value", {
                /**
                 * 粒子系统资源名称
                 */
                get: function () {
                    return this._value;
                },
                set: function (v) {
                    this._value = v;
                    if (TrailRendererData_1._datas[v]) {
                        return;
                    }
                    TrailRendererData_1._datas[v] = this;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取资源名称
             * @version m4m 1.0
             */
            TrailRendererData.prototype.getName = function () {
                if (this.name == undefined) {
                    return null;
                }
                return this.name.getText();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取资源唯一id
             * @version m4m 1.0
             */
            TrailRendererData.prototype.getGUID = function () {
                return this.id.getID();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 释放资源
             * @version m4m 1.0
             */
            TrailRendererData.prototype.dispose = function () {
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 引用计数加一
             * @version m4m 1.0
             */
            TrailRendererData.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 引用计数减一
             * @version m4m 1.0
             */
            TrailRendererData.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 计算资源字节大小
             * @version m4m 1.0
             */
            TrailRendererData.prototype.caclByteLength = function () {
                var total = 0;
                return total;
            };
            TrailRendererData.prototype.setData = function (v) {
                this.objectData = JSON.parse(v);
                if (this.trailRenderer) {
                    framework.serialization.setValue(this.trailRenderer, this.objectData);
                }
            };
            var TrailRendererData_1;
            TrailRendererData.ClassName = "TrailRendererData";
            TrailRendererData._datas = {};
            __decorate([
                m4m.reflect.Field("constText"),
                __metadata("design:type", framework.constText)
            ], TrailRendererData.prototype, "name", void 0);
            __decorate([
                m4m.reflect.Field("string"),
                __metadata("design:type", Object),
                __metadata("design:paramtypes", [Object])
            ], TrailRendererData.prototype, "value", null);
            TrailRendererData = TrailRendererData_1 = __decorate([
                m4m.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], TrailRendererData);
            return TrailRendererData;
        }());
        framework.TrailRendererData = TrailRendererData;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * Control the direction lines face, when using the LineRenderer or TrailRenderer.
         *
         * 使用LineRenderer或TrailRenderer时，控制方向线的面。
         */
        var LineAlignment;
        (function (LineAlignment) {
            /**
             * Lines face the camera.
             *
             * 线面向相机。
             */
            LineAlignment[LineAlignment["View"] = 0] = "View";
            /**
             * Lines face the Z axis of the Transform Component.
             *
             * 线面向变换组件的Z轴。
             */
            LineAlignment[LineAlignment["TransformZ"] = 1] = "TransformZ";
        })(LineAlignment = framework.LineAlignment || (framework.LineAlignment = {}));
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * Choose how textures are applied to Lines and Trails.
         *
         * 选择如何将纹理应用于线和迹线。
         */
        var LineTextureMode;
        (function (LineTextureMode) {
            /**
             * Map the texture once along the entire length of the line.
             *
             * 沿线的整个长度映射一次纹理。
             */
            LineTextureMode[LineTextureMode["Stretch"] = 0] = "Stretch";
            /**
             * Repeat the texture along the line, based on its length in world units. To set the tiling rate, use Material.SetTextureScale.
             *
             * 根据纹理的长度（以世界单位为单位），沿线重复纹理。要设置平铺率，请使用Material.SetTextureScale。
             */
            LineTextureMode[LineTextureMode["Tile"] = 1] = "Tile";
            /**
             * Map the texture once along the entire length of the line, assuming all vertices are evenly spaced.
             *
             * 假设所有顶点均等分布，则沿着线的整个长度映射一次纹理。
             */
            LineTextureMode[LineTextureMode["DistributePerSegment"] = 2] = "DistributePerSegment";
            /**
             * Repeat the texture along the line, repeating at a rate of once per line segment. To adjust the tiling rate, use Material.SetTextureScale.
             *
             * 沿线重复纹理，每个线段重复一次。要调整平铺率，请使用Material.SetTextureScale。
             */
            LineTextureMode[LineTextureMode["RepeatPerSegment"] = 3] = "RepeatPerSegment";
        })(LineTextureMode = framework.LineTextureMode || (framework.LineTextureMode = {}));
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var AEvent = /** @class */ (function () {
        function AEvent() {
            this.events = {};
        }
        /**
         * 监听事件添加
         * @param event 事件类型
         * @param func 事件触发回调方法 (Warn: 不要使用 func.bind() , 它会导致相等判断失败)
         * @param thisArg 回调方法执行者
         */
        AEvent.prototype.On = function (event, func, thisArg) {
            var arr = this.events[event];
            var FT;
            if (!arr) {
                arr = this.events[event] = [];
            }
            else {
                for (var _i = 0, arr_3 = arr; _i < arr_3.length; _i++) {
                    var ft = arr_3[_i];
                    if (ft.func == func) {
                        FT = ft;
                        break;
                    }
                }
            }
            if (!FT)
                arr.push({ func: func, thisArgs: [thisArg] });
            else {
                var idx = FT.thisArgs.lastIndexOf(thisArg);
                if (idx == -1)
                    FT.thisArgs.push(thisArg);
            }
        };
        /**
         * 发出事件
         * @param event 事件类型
         * @param args 传递参数
         */
        AEvent.prototype.Emit = function (event) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var arr = this.events[event];
            if (!arr)
                return;
            for (var _a = 0, arr_4 = arr; _a < arr_4.length; _a++) {
                var FT = arr_4[_a];
                for (var _b = 0, _c = FT.thisArgs; _b < _c.length; _b++) {
                    var thisArg = _c[_b];
                    FT.func.apply(thisArg, args);
                }
            }
        };
        /**
         * 移除事件监听者
         * @param event 事件类型
         * @param func 事件触发回调方法
         * @param thisArg 回调方法执行者
         */
        AEvent.prototype.RemoveListener = function (event, func, thisArg) {
            var arr = this.events[event];
            if (!arr)
                return;
            for (var i = 0, len = arr.length; i < len; ++i) {
                if (func == arr[i].func) {
                    var idx = arr[i].thisArgs.lastIndexOf(thisArg);
                    if (idx != -1) {
                        arr[i].thisArgs.splice(idx, 1);
                        if (arr[i].thisArgs.length < 1)
                            arr.splice(i, 1);
                        if (arr.length < 1)
                            delete this.events[event];
                        break;
                    }
                }
            }
        };
        /**
         * 移除所有监听者
         */
        AEvent.prototype.RemoveListenerAll = function () {
            this.events = {};
        };
        /**
         * 指定事件监听者的数量
         */
        AEvent.prototype.listenerCount = function (event) {
            return this.events[event] ? this.events[event].length : 0;
        };
        return AEvent;
    }());
    m4m.AEvent = AEvent;
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var event;
    (function (event) {
        /**
         * UI 事件枚举
         */
        var UIEventEnum;
        (function (UIEventEnum) {
            UIEventEnum[UIEventEnum["PointerDown"] = 0] = "PointerDown";
            UIEventEnum[UIEventEnum["PointerUp"] = 1] = "PointerUp";
            UIEventEnum[UIEventEnum["PointerClick"] = 2] = "PointerClick";
            UIEventEnum[UIEventEnum["PointerEnter"] = 3] = "PointerEnter";
            UIEventEnum[UIEventEnum["PointerExit"] = 4] = "PointerExit";
        })(UIEventEnum = event.UIEventEnum || (event.UIEventEnum = {}));
        /**
         * 点事件枚举
         */
        var PointEventEnum;
        (function (PointEventEnum) {
            PointEventEnum[PointEventEnum["PointDown"] = 0] = "PointDown";
            PointEventEnum[PointEventEnum["PointHold"] = 1] = "PointHold";
            PointEventEnum[PointEventEnum["PointUp"] = 2] = "PointUp";
            PointEventEnum[PointEventEnum["PointMove"] = 3] = "PointMove";
            PointEventEnum[PointEventEnum["PointClick"] = 4] = "PointClick";
            PointEventEnum[PointEventEnum["MouseWheel"] = 5] = "MouseWheel";
        })(PointEventEnum = event.PointEventEnum || (event.PointEventEnum = {}));
        /**
         * 按键事件枚举
         */
        var KeyEventEnum;
        (function (KeyEventEnum) {
            KeyEventEnum[KeyEventEnum["KeyDown"] = 0] = "KeyDown";
            KeyEventEnum[KeyEventEnum["KeyUp"] = 1] = "KeyUp";
        })(KeyEventEnum = event.KeyEventEnum || (event.KeyEventEnum = {}));
        /**
         * Key codes returned by Event keyCode These map directly to a physical key on
         * he keyboard
         * */
        var KeyCode;
        (function (KeyCode) {
            KeyCode[KeyCode["Numpad4"] = 100] = "Numpad4";
            KeyCode[KeyCode["Numpad5"] = 101] = "Numpad5";
            KeyCode[KeyCode["Numpad6"] = 102] = "Numpad6";
            KeyCode[KeyCode["Numpad7"] = 103] = "Numpad7";
            KeyCode[KeyCode["Numpad8"] = 104] = "Numpad8";
            KeyCode[KeyCode["Numpad9"] = 105] = "Numpad9";
            KeyCode[KeyCode["NumpadMultiply"] = 106] = "NumpadMultiply";
            KeyCode[KeyCode["NumpadAdd"] = 107] = "NumpadAdd";
            KeyCode[KeyCode["NumpadSubtract"] = 109] = "NumpadSubtract";
            KeyCode[KeyCode["NumpadDecimal"] = 110] = "NumpadDecimal";
            KeyCode[KeyCode["NumpadDivide"] = 111] = "NumpadDivide";
            KeyCode[KeyCode["F1"] = 112] = "F1";
            KeyCode[KeyCode["F2"] = 113] = "F2";
            KeyCode[KeyCode["F3"] = 114] = "F3";
            KeyCode[KeyCode["F4"] = 115] = "F4";
            KeyCode[KeyCode["F5"] = 116] = "F5";
            KeyCode[KeyCode["F6"] = 117] = "F6";
            KeyCode[KeyCode["F7"] = 118] = "F7";
            KeyCode[KeyCode["F8"] = 119] = "F8";
            KeyCode[KeyCode["F9"] = 120] = "F9";
            KeyCode[KeyCode["F10"] = 121] = "F10";
            KeyCode[KeyCode["F11"] = 122] = "F11";
            KeyCode[KeyCode["F12"] = 123] = "F12";
            KeyCode[KeyCode["Enter"] = 13] = "Enter";
            KeyCode[KeyCode["NumLock"] = 144] = "NumLock";
            KeyCode[KeyCode["ScrollLock"] = 145] = "ScrollLock";
            KeyCode[KeyCode["ShiftLeft"] = 16] = "ShiftLeft";
            KeyCode[KeyCode["ControlRight"] = 17] = "ControlRight";
            KeyCode[KeyCode["AltRight"] = 18] = "AltRight";
            KeyCode[KeyCode["Semicolon"] = 186] = "Semicolon";
            KeyCode[KeyCode["Comma"] = 188] = "Comma";
            KeyCode[KeyCode["Pause"] = 19] = "Pause";
            KeyCode[KeyCode["Period"] = 190] = "Period";
            KeyCode[KeyCode["Slash"] = 191] = "Slash";
            KeyCode[KeyCode["CapsLock"] = 20] = "CapsLock";
            KeyCode[KeyCode["BracketLeft"] = 219] = "BracketLeft";
            KeyCode[KeyCode["Backslash"] = 220] = "Backslash";
            KeyCode[KeyCode["BracketRight"] = 221] = "BracketRight";
            KeyCode[KeyCode["Quote"] = 222] = "Quote";
            KeyCode[KeyCode["Escape"] = 27] = "Escape";
            KeyCode[KeyCode["Space"] = 32] = "Space";
            KeyCode[KeyCode["PageUp"] = 33] = "PageUp";
            KeyCode[KeyCode["PageDown"] = 34] = "PageDown";
            KeyCode[KeyCode["End"] = 35] = "End";
            KeyCode[KeyCode["Home"] = 36] = "Home";
            KeyCode[KeyCode["ArrowLeft"] = 37] = "ArrowLeft";
            KeyCode[KeyCode["ArrowUp"] = 38] = "ArrowUp";
            KeyCode[KeyCode["ArrowRight"] = 39] = "ArrowRight";
            KeyCode[KeyCode["ArrowDown"] = 40] = "ArrowDown";
            KeyCode[KeyCode["Insert"] = 45] = "Insert";
            KeyCode[KeyCode["Delete"] = 46] = "Delete";
            KeyCode[KeyCode["Digit1"] = 49] = "Digit1";
            KeyCode[KeyCode["Digit2"] = 50] = "Digit2";
            KeyCode[KeyCode["Digit3"] = 51] = "Digit3";
            KeyCode[KeyCode["Digit4"] = 52] = "Digit4";
            KeyCode[KeyCode["KeyA"] = 65] = "KeyA";
            KeyCode[KeyCode["KeyB"] = 66] = "KeyB";
            KeyCode[KeyCode["KeyC"] = 67] = "KeyC";
            KeyCode[KeyCode["KeyD"] = 68] = "KeyD";
            KeyCode[KeyCode["KeyE"] = 69] = "KeyE";
            KeyCode[KeyCode["KeyF"] = 70] = "KeyF";
            KeyCode[KeyCode["KeyG"] = 71] = "KeyG";
            KeyCode[KeyCode["KeyH"] = 72] = "KeyH";
            KeyCode[KeyCode["KeyI"] = 73] = "KeyI";
            KeyCode[KeyCode["KeyJ"] = 74] = "KeyJ";
            KeyCode[KeyCode["KeyK"] = 75] = "KeyK";
            KeyCode[KeyCode["KeyL"] = 76] = "KeyL";
            KeyCode[KeyCode["KeyM"] = 77] = "KeyM";
            KeyCode[KeyCode["KeyN"] = 78] = "KeyN";
            KeyCode[KeyCode["KeyO"] = 79] = "KeyO";
            KeyCode[KeyCode["KeyP"] = 80] = "KeyP";
            KeyCode[KeyCode["KeyQ"] = 81] = "KeyQ";
            KeyCode[KeyCode["KeyR"] = 82] = "KeyR";
            KeyCode[KeyCode["KeyS"] = 83] = "KeyS";
            KeyCode[KeyCode["KeyT"] = 84] = "KeyT";
            KeyCode[KeyCode["KeyU"] = 85] = "KeyU";
            KeyCode[KeyCode["KeyV"] = 86] = "KeyV";
            KeyCode[KeyCode["KeyW"] = 87] = "KeyW";
            KeyCode[KeyCode["KeyX"] = 88] = "KeyX";
            KeyCode[KeyCode["KeyY"] = 89] = "KeyY";
            KeyCode[KeyCode["Tab"] = 9] = "Tab";
            KeyCode[KeyCode["KeyZ"] = 90] = "KeyZ";
            KeyCode[KeyCode["MetaLeft"] = 91] = "MetaLeft";
            KeyCode[KeyCode["ContextMenu"] = 93] = "ContextMenu";
            KeyCode[KeyCode["Numpad0"] = 96] = "Numpad0";
            KeyCode[KeyCode["Numpad1"] = 97] = "Numpad1";
            KeyCode[KeyCode["Numpad2"] = 98] = "Numpad2";
            KeyCode[KeyCode["Numpad3"] = 99] = "Numpad3";
        })(KeyCode = event.KeyCode || (event.KeyCode = {}));
        /**
         * 2d Physics 事件枚举
         */
        var Physic2dEventEnum;
        (function (Physic2dEventEnum) {
            /** 物理引擎更新前 */
            Physic2dEventEnum[Physic2dEventEnum["BeforeUpdate"] = 0] = "BeforeUpdate";
            /** 物理引擎更新后 */
            Physic2dEventEnum[Physic2dEventEnum["afterUpdate"] = 1] = "afterUpdate";
            /** 开始碰撞 （触发在update 之后）*/
            Physic2dEventEnum[Physic2dEventEnum["collisionStart"] = 2] = "collisionStart";
            /** 碰撞持续中 （触发在update 之后）*/
            Physic2dEventEnum[Physic2dEventEnum["collisionActive"] = 3] = "collisionActive";
            /** 碰撞结束 （触发在update 之后）*/
            Physic2dEventEnum[Physic2dEventEnum["collisionEnd"] = 4] = "collisionEnd";
        })(Physic2dEventEnum = event.Physic2dEventEnum || (event.Physic2dEventEnum = {}));
    })(event = m4m.event || (m4m.event = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var event;
    (function (event_1) {
        /** 输入事件 */
        var InputEvent = /** @class */ (function (_super) {
            __extends(InputEvent, _super);
            function InputEvent() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            InputEvent.prototype.OnEnum_key = function (event, func, thisArg) {
                this.On(event_1.KeyEventEnum[event], func, thisArg);
            };
            InputEvent.prototype.EmitEnum_key = function (event) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                _super.prototype.Emit.call(this, event_1.KeyEventEnum[event], args);
            };
            InputEvent.prototype.OnEnum_point = function (event, func, thisArg) {
                this.On(event_1.PointEventEnum[event], func, thisArg);
            };
            InputEvent.prototype.EmitEnum_point = function (event) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                _super.prototype.Emit.call(this, event_1.PointEventEnum[event], args);
            };
            return InputEvent;
        }(m4m.AEvent));
        event_1.InputEvent = InputEvent;
        /** 输入htmlElement 原生事件 */
        var inputHtmlNativeEvent = /** @class */ (function (_super) {
            __extends(inputHtmlNativeEvent, _super);
            function inputHtmlNativeEvent() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            inputHtmlNativeEvent.prototype.On = function (tagName, func, thisArg) {
                _super.prototype.On.call(this, tagName, func, thisArg);
            };
            inputHtmlNativeEvent.prototype.Emit = function (tagName, ev) {
                _super.prototype.Emit.call(this, tagName, ev);
            };
            return inputHtmlNativeEvent;
        }(m4m.AEvent));
        event_1.inputHtmlNativeEvent = inputHtmlNativeEvent;
    })(event = m4m.event || (m4m.event = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var event;
    (function (event_2) {
        var Physic2dEvent = /** @class */ (function (_super) {
            __extends(Physic2dEvent, _super);
            function Physic2dEvent() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            Physic2dEvent.prototype.OnEnum = function (event, func, thisArg) {
                this.On(event_2.Physic2dEventEnum[event], func, thisArg);
            };
            Physic2dEvent.prototype.EmitEnum = function (event) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                _super.prototype.Emit.call(this, event_2.Physic2dEventEnum[event], args);
            };
            return Physic2dEvent;
        }(m4m.AEvent));
        event_2.Physic2dEvent = Physic2dEvent;
    })(event = m4m.event || (m4m.event = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var event;
    (function (event_3) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * ui事件
         * @version m4m 1.0
         */
        var UIEvent = /** @class */ (function (_super) {
            __extends(UIEvent, _super);
            function UIEvent() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            UIEvent.prototype.OnEnum = function (event, func, thisArg) {
                this.On(event_3.UIEventEnum[event], func, thisArg);
            };
            UIEvent.prototype.EmitEnum = function (event) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                _super.prototype.Emit.call(this, event_3.UIEventEnum[event], args);
            };
            return UIEvent;
        }(m4m.AEvent));
        event_3.UIEvent = UIEvent;
    })(event = m4m.event || (m4m.event = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @private
         * @language zh_CN
         * @classdesc
         * 2d事件对象
         * @version m4m 1.0
         */
        var PointEvent = /** @class */ (function () {
            function PointEvent() {
            }
            return PointEvent;
        }());
        framework.PointEvent = PointEvent;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 鼠标(触屏)点击信息
         * @version m4m 1.0
         */
        var pointinfo = /** @class */ (function () {
            function pointinfo() {
                this.id = -1;
                this.touch = false;
                this.multiTouch = false;
                this.x = 0;
                this.y = 0;
            }
            return pointinfo;
        }());
        framework.pointinfo = pointinfo;
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 键盘、鼠标(触屏)事件管理类 应用状态机区分状态
         * @version m4m 1.0
         */
        var inputMgr = /** @class */ (function () {
            function inputMgr(app) {
                this._element = null;
                this._buttons = [false, false, false];
                this._lastbuttons = [false, false, false];
                this.eventer = new m4m.event.InputEvent();
                this.HtmlNativeEventer = new m4m.event.inputHtmlNativeEvent();
                this.inputlast = null;
                this.keyboardMap = {};
                this.handlers = [];
                this._wheel = 0;
                this._point = new pointinfo();
                this._touches = {};
                this.rMtr_90 = new m4m.math.matrix3x2();
                this.rMtr_n90 = new m4m.math.matrix3x2();
                this.moveTolerance = 2; //move 状态容忍值
                this.lastTouch = false;
                this.hasPointDown = false;
                this.hasPointUP = false;
                this.hasPointMove = false;
                this.downPoint = new m4m.math.vector2();
                this.lastPoint = new m4m.math.vector2();
                this.keyDownCode = -1;
                this.keyUpCode = -1;
                this.hasWheel = false;
                this.lastWheel = 0;
                this._contextMenu = function (ev) { ev.preventDefault(); };
                this.tempV2_0 = new m4m.math.vector2();
                this.tempV2_1 = new m4m.math.vector2();
                this.devicePixelRatio = window.devicePixelRatio || 1;
                this.app = app;
                m4m.math.matrix3x2MakeRotate(Math.PI * 90 / 180, this.rMtr_90);
                m4m.math.matrix3x2MakeRotate(Math.PI * -90 / 180, this.rMtr_n90);
                this.handlers.push(["touchstart", this._touchstart.bind(this)]);
                this.handlers.push(["touchmove", this._touchmove.bind(this)]);
                this.handlers.push(["touchend", this._touchend.bind(this)]);
                this.handlers.push(["touchcancel", this._touchcancel.bind(this)]);
                this.handlers.push(["mousedown", this._mousedown.bind(this)]);
                this.handlers.push(["mouseup", this._mouseup.bind(this)]);
                this.handlers.push(["mousemove", this._mousemove.bind(this)]);
                // this.handlers.push(["mousewheel",this._mousewheel.bind(this)]);
                this.handlers.push(["wheel", this._mousewheel.bind(this)]);
                this.handlers.push(["DOMMouseScroll", this._mousewheel.bind(this)]);
                this.handlers.push(["keydown", this._keydown.bind(this)]);
                this.handlers.push(["keyup", this._keyup.bind(this)]);
                this.handlers.push(["blur", this._blur.bind(this)]);
                this.attach(app.webgl.canvas);
                this.disableContextMenu();
            }
            Object.defineProperty(inputMgr.prototype, "wheel", {
                get: function () { return this._wheel; },
                enumerable: false,
                configurable: true
            });
            ;
            Object.defineProperty(inputMgr.prototype, "point", {
                get: function () { return this._point; },
                enumerable: false,
                configurable: true
            });
            ;
            Object.defineProperty(inputMgr.prototype, "touches", {
                get: function () { return this._touches; },
                enumerable: false,
                configurable: true
            });
            ;
            inputMgr.prototype.attach = function (element) {
                var _this = this;
                if (this._element) {
                    this.detach();
                }
                this._element = element;
                this.handlers.forEach(function (handler) {
                    if (handler)
                        _this._element.addEventListener(handler[0], handler[1], false); //reg
                });
            };
            inputMgr.prototype.detach = function () {
                var _this = this;
                if (!this._element)
                    return;
                this.handlers.forEach(function (handler) {
                    if (handler)
                        _this._element.removeEventListener(handler[0], handler[1], false); //unreg
                });
                this._element = null;
            };
            //mouse
            inputMgr.prototype._mousedown = function (ev) {
                this.CalcuPoint(ev.offsetX, ev.offsetY, this._point);
                this._buttons[ev.button] = true;
                this._point.touch = true;
                this.HtmlNativeEventer.Emit("mousedown", ev);
            };
            inputMgr.prototype._mouseup = function (ev) {
                this._buttons[ev.button] = false;
                this._point.touch = false;
                this.HtmlNativeEventer.Emit("mouseup", ev);
            };
            inputMgr.prototype._mousemove = function (ev) {
                this.CalcuPoint(ev.offsetX, ev.offsetY, this._point);
                this.HtmlNativeEventer.Emit("mousemove", ev);
            };
            inputMgr.prototype._mousewheel = function (ev) {
                this.hasWheel = true;
                if (ev.detail) {
                    this.lastWheel = -1 * ev.detail;
                }
                else if (ev.wheelDelta) {
                    this.lastWheel = ev.wheelDelta / 120;
                }
                else if (ev.DOM_DELTA_PIXEL) {
                    this.lastWheel = ev.DOM_DELTA_PIXEL / 120;
                }
                else {
                    this.lastWheel = 0;
                }
                this.HtmlNativeEventer.Emit("wheel", ev);
            };
            //touch
            inputMgr.prototype.tryAddTouchP = function (id) {
                if (!this._touches[id]) {
                    this._touches[id] = new pointinfo();
                    this._touches[id].id = id;
                }
            };
            inputMgr.prototype.syncPointByTouches = function () {
                var count = 0;
                var xs = 0;
                var ys = 0;
                for (var key in this._touches) {
                    if (this._touches[key].touch == true) {
                        xs += this._touches[key].x;
                        ys += this._touches[key].y;
                        count++;
                    }
                }
                // this.point.x = x / (count * app.scale);
                // this.point.y = y / (count * app.scale);
                //this.CalcuPoint(x / count,y / count,this._point);
                this._point.x = xs / count;
                this._point.y = ys / count;
            };
            inputMgr.prototype._touchstart = function (ev) {
                ev.preventDefault();
                // this.CalcuPoint(ev.touches[0].clientX,ev.touches[0].clientY,this._point);
                this._point.touch = true;
                this._point.multiTouch = true;
                var lastTouche;
                var rect = this.app.webgl.canvas.getBoundingClientRect();
                for (var i = 0; i < ev.changedTouches.length; i++) {
                    var touch = ev.changedTouches[i];
                    var id = touch.identifier;
                    this.tryAddTouchP(id);
                    this._touches[id].touch = true;
                    this.CalcuPoint(touch.clientX - rect.left, touch.clientY - rect.top, this._touches[id]);
                    // this._touches[id].x = touch.clientX;
                    // this._touches[id].y = touch.clientY;
                    lastTouche = this._touches[id];
                }
                // this.syncPointByTouches();
                if (lastTouche) {
                    this._point.x = lastTouche.x;
                    this._point.y = lastTouche.y;
                }
                this.HtmlNativeEventer.Emit("touchstart", ev);
            };
            inputMgr.prototype._touchmove = function (ev) {
                ev.preventDefault(); //避免 在触摸设备中，下拉 触发浏览器刷新监听。
                this._point.touch = true;
                this._point.multiTouch = true;
                var lastTouche;
                var rect = this.app.webgl.canvas.getBoundingClientRect();
                for (var i = 0; i < ev.changedTouches.length; i++) {
                    var touch = ev.changedTouches[i];
                    var id = touch.identifier;
                    this.tryAddTouchP(id);
                    this._touches[id].touch = true;
                    this.CalcuPoint(touch.clientX - rect.left, touch.clientY - rect.top, this._touches[id]);
                    // this._touches[id].x = touch.clientX;
                    // this._touches[id].y = touch.clientY;
                    lastTouche = this._touches[id];
                }
                // this.syncPointByTouches();
                if (lastTouche) {
                    this._point.x = lastTouche.x;
                    this._point.y = lastTouche.y;
                }
                this.HtmlNativeEventer.Emit("touchmove", ev);
            };
            inputMgr.prototype._touchend = function (ev) {
                ev.preventDefault();
                for (var i = 0; i < ev.changedTouches.length; i++) {
                    var touch = ev.changedTouches[i];
                    var id = touch.identifier;
                    this.tryAddTouchP(id);
                    this._touches[id].touch = false;
                }
                this._point.touch = false;
                //所有触点全放开，point.touch才false
                for (var key in this._touches) {
                    if (this._touches[key].touch == true)
                        return;
                }
                this._point.multiTouch = false;
                this.HtmlNativeEventer.Emit("touchend", ev);
            };
            inputMgr.prototype._touchcancel = function (ev) {
                ev.preventDefault();
                this._touchend(ev);
                this.HtmlNativeEventer.Emit("touchcancel", ev);
            };
            //key
            inputMgr.prototype._keydown = function (ev) {
                this.keyboardMap[ev.keyCode] = true;
                this.keyDownCode = ev.keyCode;
                this.HtmlNativeEventer.Emit("keydown", ev);
            };
            inputMgr.prototype._keyup = function (ev) {
                delete this.keyboardMap[ev.keyCode];
                this.keyUpCode = ev.keyCode;
                this.HtmlNativeEventer.Emit("keyup", ev);
            };
            //
            inputMgr.prototype._blur = function (ev) {
                this._point.touch = false;
                //清理 keys 状态
                var _map = this.keyboardMap;
                for (var key in _map) {
                    _map[key] = false;
                }
                this.HtmlNativeEventer.Emit("blur", ev);
            };
            inputMgr.prototype.update = function (delta) {
                this._lastbuttons[0] = this._buttons[0];
                this._lastbuttons[1] = this._buttons[1];
                this._lastbuttons[2] = this._buttons[2];
                this._wheel = 0;
                this.mouseWheelCk();
                this.pointCk();
                this.keyCodeCk();
            };
            /**
             * point 刷新检查
             */
            inputMgr.prototype.pointCk = function () {
                var pt = this._point;
                if (this.lastPoint.x != pt.x || this.lastPoint.y != pt.y) {
                    //on move
                    this.eventer.EmitEnum_point(m4m.event.PointEventEnum.PointMove, pt.x, pt.y);
                }
                if (!this.lastTouch && pt.touch) {
                    //on down
                    this.hasPointDown = true;
                    this.downPoint.x = pt.x;
                    this.downPoint.y = pt.y;
                    this.eventer.EmitEnum_point(m4m.event.PointEventEnum.PointDown, pt.x, pt.y);
                }
                else if (this.lastTouch && !pt.touch) {
                    //on up
                    this.hasPointUP = true;
                    this.eventer.EmitEnum_point(m4m.event.PointEventEnum.PointUp, pt.x, pt.y);
                }
                else if (this.lastTouch && pt.touch) {
                    //on hold
                    this.eventer.EmitEnum_point(m4m.event.PointEventEnum.PointHold, pt.x, pt.y);
                }
                if (this.hasPointUP && this.hasPointDown) {
                    var isMoveTolerance = (Math.abs(this.downPoint.x - pt.x) > this.moveTolerance || Math.abs(this.downPoint.y - pt.y) > this.moveTolerance);
                    if (!isMoveTolerance) {
                        //on click
                        this.hasPointDown = this.hasPointUP = false;
                        this.eventer.EmitEnum_point(m4m.event.PointEventEnum.PointClick, pt.x, pt.y);
                    }
                }
                if (!pt.touch) {
                    this.hasPointDown = false;
                }
                this.lastTouch = pt.touch;
                this.lastPoint.x = pt.x;
                this.lastPoint.y = pt.y;
            };
            inputMgr.prototype.keyCodeCk = function () {
                if (this.keyDownCode != -1)
                    this.eventer.EmitEnum_key(m4m.event.KeyEventEnum.KeyDown, this.keyDownCode);
                if (this.keyUpCode != -1)
                    this.eventer.EmitEnum_key(m4m.event.KeyEventEnum.KeyUp, this.keyUpCode);
                this.keyDownCode = this.keyUpCode = -1;
            };
            inputMgr.prototype.mouseWheelCk = function () {
                if (this.hasWheel) {
                    this._wheel = this.lastWheel;
                    this.eventer.EmitEnum_point(m4m.event.PointEventEnum.MouseWheel, null);
                }
                this.hasWheel = false;
                this.lastWheel = 0;
            };
            /**
             * 按键是否在按下状态
             * @param button 按键, 0: 左键；1: 中键；2: 右键
             */
            inputMgr.prototype.isPressed = function (button) {
                return this._buttons[button];
            };
            /**
             * 按键被按下一次
             * @param button 按键, 0: 左键；1: 中键；2: 右键
             */
            inputMgr.prototype.wasPressed = function (button) {
                return (this._buttons[button] && !this._lastbuttons[button]);
            };
            /**
             * 禁用右键菜单
             */
            inputMgr.prototype.disableContextMenu = function () {
                if (!this._element)
                    return;
                this._element.addEventListener("contextmenu", this._contextMenu);
            };
            /**
             * 启用右键菜单
             */
            inputMgr.prototype.enableContextMenu = function () {
                if (!this._element)
                    return;
                this._element.removeEventListener("contextmenu", this._contextMenu);
            };
            /**
            * 添加point事件监听者
            * @param eventEnum 事件类型
            * @param func 事件触发回调方法 (Warn: 不要使用 func.bind() , 它会导致相等判断失败)
            * @param thisArg 回调方法执行者
            */
            inputMgr.prototype.addPointListener = function (eventEnum, func, thisArg) {
                this.eventer.OnEnum_point(eventEnum, func, thisArg);
            };
            /**
             * 移除point事件监听者
             * @param eventEnum 事件类型
             * @param func 事件触发回调方法
             * @param thisArg 回调方法执行者
             */
            inputMgr.prototype.removePointListener = function (eventEnum, func, thisArg) {
                this.eventer.RemoveListener(m4m.event.PointEventEnum[eventEnum], func, thisArg);
            };
            /**
            * 添加按键事件监听者
            * @param eventEnum 事件类型
            * @param func 事件触发回调方法 (Warn: 不要使用 func.bind() , 它会导致相等判断失败)
            * @param thisArg 回调方法执行者
            */
            inputMgr.prototype.addKeyListener = function (eventEnum, func, thisArg) {
                this.eventer.OnEnum_key(eventEnum, func, thisArg);
            };
            /**
             * 移除按键事件监听者
             * @param eventEnum 事件类型
             * @param func 事件触发回调方法
             * @param thisArg 回调方法执行者
             */
            inputMgr.prototype.removeKeyListener = function (eventEnum, func, thisArg) {
                this.eventer.RemoveListener(m4m.event.KeyEventEnum[eventEnum], func, thisArg);
            };
            /**
            * 添加HTMLElement原生事件监听者
            * @param tagName 事件类型名字
            * @param func 事件触发回调方法 (Warn: 不要使用 func.bind() , 它会导致相等判断失败)
            * @param thisArg 回调方法执行者
            */
            inputMgr.prototype.addHTMLElementListener = function (tagName, func, thisArg) {
                this.HtmlNativeEventer.On(tagName, func, thisArg);
            };
            /**
             * 移除HTMLElement原生事件监听者
             * @param tagName 事件类型名字
             * @param func 事件触发回调方法
             * @param thisArg 回调方法执行者
             */
            inputMgr.prototype.removeHTMLElementListener = function (tagName, func, thisArg) {
                this.HtmlNativeEventer.RemoveListener(tagName, func, thisArg);
            };
            /**
             * 任意一按键被按下
             */
            inputMgr.prototype.anyKey = function () {
                if (this._point.touch)
                    return true;
                for (var key in this.keyboardMap) {
                    if (this.keyboardMap.hasOwnProperty(key)) {
                        var element = this.keyboardMap[key];
                        if (element == true)
                            return true;
                    }
                }
                return false;
            };
            inputMgr.prototype.GetKeyDown = function (value) {
                if (typeof (value) === "number") {
                    if (this.keyboardMap[value] != null)
                        return this.keyboardMap[value];
                }
                else if (typeof (value) === "string") {
                    var id = m4m.event.KeyCode[value];
                    if (id != null && this.keyboardMap[id] != null)
                        return this.keyboardMap[id];
                }
                return false;
            };
            inputMgr.prototype.GetKeyUP = function (value) {
                if (typeof (value) === "number") {
                    return !this.keyboardMap[value];
                }
                else if (typeof (value) === "string") {
                    var id = m4m.event.KeyCode[value];
                    if (id != null)
                        return !this.keyboardMap[id];
                }
                return false;
            };
            /**
             * 按键按下的数量
             */
            inputMgr.prototype.KeyDownCount = function () {
                var count = 0;
                for (var key in this.keyboardMap) {
                    if (this.keyboardMap.hasOwnProperty(key)) {
                        if (this.keyboardMap[key] === true)
                            count++;
                    }
                }
                return count;
            };
            /**
             * 计算校准html 输入坐标点
             * @param offsetX 输入x
             * @param offsetY 输入y
             * @param out 返回pointinfo
             */
            inputMgr.prototype.CalcuPoint = function (offsetX, offsetY, out) {
                if (!out || !this.app || isNaN(offsetX) || isNaN(offsetY))
                    return;
                this.tempV2_0.x = offsetX * this.devicePixelRatio / this.app.scaleFromPandding;
                this.tempV2_0.y = offsetY * this.devicePixelRatio / this.app.scaleFromPandding;
                m4m.math.vec2Clone(this.tempV2_0, this.tempV2_1);
                if (this.app.shouldRotate) {
                    switch (this.app.orientation) {
                        case m4m.framework.OrientationMode.PORTRAIT:
                            m4m.math.matrix3x2TransformVector2(this.rMtr_90, this.tempV2_0, this.tempV2_1);
                            out.x = this.tempV2_1.x + this.app.webgl.canvas.width;
                            out.y = this.tempV2_1.y;
                            break;
                        case m4m.framework.OrientationMode.LANDSCAPE:
                            m4m.math.matrix3x2TransformVector2(this.rMtr_n90, this.tempV2_0, this.tempV2_1);
                            out.x = this.tempV2_1.x;
                            out.y = this.tempV2_1.y + this.app.webgl.canvas.height;
                            break;
                        case m4m.framework.OrientationMode.LANDSCAPE_FLIPPED:
                            m4m.math.matrix3x2TransformVector2(this.rMtr_90, this.tempV2_0, this.tempV2_1);
                            out.x = this.tempV2_1.x + this.app.webgl.canvas.width;
                            out.y = this.tempV2_1.y;
                            break;
                    }
                }
                else {
                    out.x = this.tempV2_0.x;
                    out.y = this.tempV2_0.y;
                }
                //console.error(`x :${this.point.x}  y :${this.point.y}  w :${this.app.webgl.canvas.width}  h :${this.app.webgl.canvas.height}`);
            };
            return inputMgr;
        }());
        framework.inputMgr = inputMgr;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var io;
    (function (io) {
        var converter = /** @class */ (function () {
            function converter() {
            }
            converter.getApplyFun = function (value) {
                return Array.prototype.concat.apply([], value);
            };
            converter.ULongToArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                //这里注意不能直接用dataView.setFloat64，因为float64是float类型
                var uint1 = value % 0x100000000;
                var uint2 = (value / 0x100000000) | 0;
                converter.dataView.setUint32(0, uint1, true);
                converter.dataView.setUint32(4, uint2, true);
                return new Uint8Array(converter.dataBuffer.subarray(0, 8));
            };
            converter.LongToArray = function (value, t, offset) {
                if (t === void 0) { t = null; }
                if (offset === void 0) { offset = 0; }
                var target = t;
                //这里注意不能直接用dataView.setFloat64，因为float64是float类型
                var uint1 = value % 0x100000000;
                var uint2 = (value / 0x100000000) | 0;
                converter.dataView.setInt32(0, uint1, true);
                converter.dataView.setInt32(4, uint2, true);
                return new Uint8Array(converter.dataBuffer.subarray(0, 8));
            };
            converter.Float64ToArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                converter.dataView.setFloat64(0, value, false);
                return new Uint8Array(converter.dataBuffer.subarray(0, 8));
            };
            converter.Float32ToArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                converter.dataView.setFloat32(0, value, true);
                return new Uint8Array(converter.dataBuffer.subarray(0, 4));
            };
            converter.Int32ToArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                converter.dataView.setInt32(0, value, true);
                return new Uint8Array(converter.dataBuffer.subarray(0, 4));
            };
            converter.Int16ToArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                converter.dataView.setInt16(0, value, true);
                return new Uint8Array(converter.dataBuffer.subarray(0, 2));
            };
            converter.Uint32toArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                converter.dataView.setInt32(0, value, true);
                return new Uint8Array(converter.dataBuffer.subarray(0, 4));
            };
            converter.Uint16ToArray = function (value, target, offset) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                converter.dataView.setUint16(0, value, true);
                return new Uint8Array(converter.dataBuffer.subarray(0, 2));
            };
            converter.StringToUtf8Array = function (str) {
                var bstr = [];
                for (var i = 0, len = str.length; i < len; ++i) {
                    var c = str.charAt(i);
                    var cc = c.charCodeAt(0);
                    if (cc > 0xFFFF) {
                        throw new Error("InvalidCharacterError");
                    }
                    if (cc > 0x80) {
                        if (cc < 0x07FF) {
                            var c1 = (cc >>> 6) | 0xC0;
                            var c2 = (cc & 0x3F) | 0x80;
                            bstr.push(c1, c2);
                        }
                        else {
                            var c1 = (cc >>> 12) | 0xE0;
                            var c2 = ((cc >>> 6) & 0x3F) | 0x80;
                            var c3 = (cc & 0x3F) | 0x80;
                            bstr.push(c1, c2, c3);
                        }
                    }
                    else {
                        bstr.push(cc);
                    }
                }
                return new Uint8Array(bstr);
            };
            converter.ArrayToLong = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                converter.dataBuffer.set(buf.subarray(offset, offset + 4));
                var n1 = converter.dataView.getInt32(0, true);
                converter.dataBuffer.set(buf.subarray(offset + 4, offset + 8));
                var n2 = converter.dataView.getInt32(4, true);
                n1 += n2 * 0x100000000;
                return n1;
            };
            converter.ArrayToULong = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                converter.dataBuffer.set(buf.subarray(offset, offset + 4));
                var n1 = converter.dataView.getUint32(0, true);
                converter.dataBuffer.set(buf.subarray(offset + 4, offset + 8));
                var n2 = converter.dataView.getUint32(4, true);
                n1 += n2 * 0x100000000;
                return n1;
            };
            converter.ArrayToFloat64 = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                converter.dataBuffer.set(buf.subarray(offset, offset + 8));
                return converter.dataView.getFloat64(0, true);
            };
            converter.ArrayToFloat32 = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                converter.dataBuffer.set(buf.subarray(offset, offset + 4));
                return converter.dataView.getFloat32(0, true);
            };
            converter.ArrayToInt32 = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                converter.dataBuffer.set(buf.subarray(offset, offset + 4));
                return converter.dataView.getInt32(0, true);
            };
            converter.ArrayToUint32 = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                converter.dataBuffer.set(buf.subarray(offset, offset + 4));
                return converter.dataView.getUint32(0, true);
            };
            converter.ArrayToInt16 = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                converter.dataBuffer.set(buf.subarray(offset, offset + 2));
                return converter.dataView.getInt16(0, true);
            };
            converter.ArrayToUint16 = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                converter.dataBuffer.set(buf.subarray(offset, offset + 2));
                return converter.dataView.getUint16(0, true);
            };
            converter.ArrayToInt8 = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                return buf[offset];
            };
            converter.ArrayToString = function (buf, offset) {
                if (offset === void 0) { offset = 0; }
                var ret = [];
                for (var i = 0; i < buf.length; i++) {
                    var cc = buf[i];
                    if (cc == 0)
                        break;
                    var ct = 0;
                    if (cc > 0xE0) {
                        ct = (cc & 0x0F) << 12;
                        cc = buf[++i];
                        ct |= (cc & 0x3F) << 6;
                        cc = buf[++i];
                        ct |= cc & 0x3F;
                        ret.push(String.fromCharCode(ct));
                    }
                    else if (cc > 0xC0) {
                        ct = (cc & 0x1F) << 6;
                        cc = buf[++i];
                        ct |= (cc & 0x3F) << 6;
                        ret.push(String.fromCharCode(ct));
                    }
                    else if (cc > 0x80) {
                        console.warn("InvalidCharacterError");
                        return "";
                    }
                    else {
                        ret.push(String.fromCharCode(buf[i]));
                    }
                }
                return ret.join('');
            };
            converter.dataBuffer = new Uint8Array(8);
            converter.dataView = new DataView(converter.dataBuffer.buffer); //八字节临时空间
            return converter;
        }());
        io.converter = converter;
        var binTool = /** @class */ (function () {
            function binTool(size) {
                //this.buffer = new Array(size);
                // if (size)
                //     this.buffer = new Array(size);
                // else
                if (size === void 0) { size = undefined; }
                this.r_offset = 0;
                this.w_offset = 0;
                this.buffer = memoryPool.Insance.newUint8Array(); //new Uint8Array(1024);
            }
            binTool.prototype.ckl = function () {
                if (this.r_offset > this.w_offset)
                    throw Error("[binTool] 内存读取失败 请检查当前输入的内存");
            };
            binTool.prototype.readSingle = function () {
                this.ckl();
                var ret = converter.ArrayToFloat32(this.buffer, this.r_offset);
                this.r_offset += 4;
                return ret;
            };
            binTool.prototype.readLong = function () {
                this.ckl();
                var ret = converter.ArrayToLong(this.buffer, this.r_offset);
                this.r_offset += 8;
                return ret;
            };
            binTool.prototype.readULong = function () {
                this.ckl();
                var ret = converter.ArrayToULong(this.buffer, this.r_offset);
                this.r_offset += 8;
                return ret;
            };
            binTool.prototype.readDouble = function () {
                this.ckl();
                var ret = converter.ArrayToFloat64(this.buffer, this.r_offset);
                this.r_offset += 8;
                return ret;
            };
            binTool.prototype.readInt8 = function () {
                this.ckl();
                var ret = this.buffer[this.r_offset];
                this.r_offset += 1;
                return ret;
            };
            binTool.prototype.readUInt8 = function () {
                this.ckl();
                var ret = this.buffer[this.r_offset];
                this.r_offset += 1;
                return ret;
            };
            binTool.prototype.readInt16 = function () {
                this.ckl();
                var ret = converter.ArrayToInt16(this.buffer, this.r_offset);
                this.r_offset += 2;
                return ret;
            };
            binTool.prototype.readUInt16 = function () {
                this.ckl();
                var ret = converter.ArrayToUint16(this.buffer, this.r_offset);
                this.r_offset += 2;
                return ret;
            };
            binTool.prototype.readInt32 = function () {
                this.ckl();
                var ret = converter.ArrayToInt32(this.buffer, this.r_offset);
                this.r_offset += 4;
                return ret;
            };
            binTool.prototype.readUInt32 = function () {
                this.ckl();
                var ret = converter.ArrayToUint32(this.buffer, this.r_offset);
                this.r_offset += 4;
                return ret;
            };
            binTool.prototype.readBoolean = function () {
                this.ckl();
                var ret = this.buffer[this.r_offset] != 0;
                this.r_offset += 1;
                return ret;
            };
            binTool.prototype.readByte = function () {
                return this.readUInt8();
            };
            binTool.prototype.readUnsignedShort = function () {
                return this.readUInt16();
            };
            binTool.prototype.readUnsignedInt = function () {
                this.ckl();
                var ret = converter.ArrayToUint32(this.buffer, this.r_offset);
                this.r_offset += 4;
                return ret;
            };
            binTool.prototype.readFloat = function () {
                return this.readSingle();
            };
            /// <summary>
            /// 有符号 Byte
            /// </summary>
            binTool.prototype.readSymbolByte = function () {
                return this.readInt8();
            };
            binTool.prototype.readShort = function () {
                return this.readInt16();
            };
            binTool.prototype.readInt = function () {
                return this.readInt32();
            };
            binTool.prototype.readBytes = function (length) {
                this.ckl();
                var array = this.buffer.subarray(this.r_offset, this.r_offset + length);
                this.r_offset += length;
                return array;
            };
            binTool.prototype.readStringUtf8 = function () {
                this.ckl();
                var length = this.readInt8();
                var array = this.buffer.subarray(this.r_offset, this.r_offset + length);
                this.r_offset += length;
                return converter.ArrayToString(array);
            };
            binTool.prototype.readUTFBytes = function ( /*length: number*/) {
                this.ckl();
                var length = this.readUInt16();
                return this.readUTFByLen(length);
                // this.r_offset += length;
                // return converter.ArrayToString(array);
            };
            binTool.prototype.readUTFByLen = function (length) {
                this.ckl();
                var array = this.buffer.subarray(this.r_offset, this.r_offset + length);
                this.r_offset += length;
                return converter.ArrayToString(array);
            };
            binTool.prototype.readStringUtf8FixLength = function (length) {
                this.ckl();
                var array = this.buffer.subarray(this.r_offset, this.r_offset + length);
                this.r_offset += length;
                return converter.ArrayToString(array);
            };
            binTool.prototype.readStringAnsi = function () {
                this.ckl();
                var slen = this.readUInt8();
                var bs = "";
                for (var i = 0; i < slen; i++) {
                    bs += String.fromCharCode(this.readByte());
                }
                return bs;
            };
            binTool.prototype.getLength = function () {
                return this.w_offset;
            };
            binTool.prototype.getBytesAvailable = function () {
                return this.w_offset - this.r_offset;
            };
            Object.defineProperty(binTool.prototype, "length", {
                get: function () {
                    return this.w_offset;
                },
                enumerable: false,
                configurable: true
            });
            binTool.prototype.writeInt8 = function (num) {
                //this.write(converter.Int8ToArray(num));
                this.write(num);
            };
            binTool.prototype.writeUInt8 = function (num) {
                // this.write(converter.Uint8ToArray(num));
                this.write(num);
            };
            binTool.prototype.writeInt16 = function (num) {
                this.write(converter.Int16ToArray(num));
            };
            binTool.prototype.writeUInt16 = function (num) {
                this.write(converter.Uint16ToArray(num));
            };
            binTool.prototype.writeInt32 = function (num) {
                this.write(converter.Int32ToArray(num));
            };
            binTool.prototype.writeUInt32 = function (num) {
                this.write(converter.Uint32toArray(num));
            };
            binTool.prototype.writeSingle = function (num) {
                this.write(converter.Float32ToArray(num));
            };
            binTool.prototype.writeLong = function (num) {
                this.write(converter.LongToArray(num));
            };
            binTool.prototype.writeULong = function (num) {
                this.write(converter.ULongToArray(num));
            };
            binTool.prototype.writeDouble = function (num) {
                this.write(converter.Float64ToArray(num));
            };
            binTool.prototype.writeStringAnsi = function (str) {
                var slen = str.length;
                this.writeUInt8(slen);
                for (var i = 0; i < slen; i++)
                    this.writeUInt8(str.charCodeAt(i));
            };
            binTool.prototype.writeStringUtf8 = function (str) {
                var bstr = converter.StringToUtf8Array(str);
                this.writeUInt8(bstr.length);
                this.write(bstr);
            };
            binTool.prototype.writeStringUtf8DataOnly = function (str) {
                var bstr = converter.StringToUtf8Array(str);
                this.write(bstr);
            };
            binTool.prototype.writeByte = function (num) {
                this.write(num);
            };
            binTool.prototype.writeBytes = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                this.write(array, offset, length);
            };
            binTool.prototype.writeUint8Array = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                this.write(array, offset, length);
            };
            binTool.prototype.writeUnsignedShort = function (num) {
                this.write(converter.Uint16ToArray(num));
            };
            binTool.prototype.writeUnsignedInt = function (num) {
                this.write(converter.Uint32toArray(num));
            };
            binTool.prototype.writeFloat = function (num) {
                this.write(converter.Float32ToArray(num));
            };
            binTool.prototype.writeUTFBytes = function (str) {
                this.write(converter.StringToUtf8Array(str));
            };
            binTool.prototype.writeSymbolByte = function (num) {
                this.write(num);
            };
            binTool.prototype.writeShort = function (num) {
                this.write(converter.Int16ToArray(num));
            };
            binTool.prototype.writeInt = function (num) {
                this.write(converter.Int32ToArray(num));
            };
            binTool.prototype.write = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                var arrLenName = "";
                if (array["byteLength"] != undefined) {
                    arrLenName = "byteLength";
                }
                else if (array["length"] != undefined) {
                    arrLenName = "length";
                }
                //数组
                if (arrLenName != "") {
                    var needSize = array[arrLenName] + this.w_offset;
                    if (this.buffer.byteLength > needSize)
                        this.buffer.set(array, this.w_offset);
                    else {
                        var tnum = this.buffer.byteLength;
                        while (tnum < needSize) {
                            tnum *= 2;
                        }
                        var buf = new Uint8Array(tnum);
                        buf.set(this.buffer);
                        buf.set(array, this.w_offset);
                        this.buffer = buf;
                    }
                    this.w_offset += array.byteLength;
                }
                else {
                    this.buffer[this.w_offset] = array;
                    this.w_offset += 1;
                }
            };
            binTool.prototype.dispose = function () {
                if (this.buffer.byteLength == 1024)
                    memoryPool.Insance.deleteUint8Array(this.buffer);
                this.buffer = null;
            };
            binTool.prototype.getBuffer = function () {
                // let retBuff = new Uint8Array(this.w_offset);
                // memoryCopy(this.buffer, retBuff, 0);
                // return retBuff;
                return new Uint8Array(this.buffer.subarray(0, this.w_offset));
            };
            binTool.prototype.getUint8Array = function () {
                return new Uint8Array(this.buffer.subarray(0, this.w_offset));
            };
            return binTool;
        }());
        io.binTool = binTool;
        var memoryPool = /** @class */ (function () {
            function memoryPool() {
                this.pool = new Array();
                // for (let i = 0; i < 30; ++i)
                //     this.pool.push(new Uint8Array(1024));
            }
            Object.defineProperty(memoryPool, "Insance", {
                get: function () {
                    if (!this.instnace)
                        this.instnace = new memoryPool();
                    return memoryPool.instnace;
                },
                enumerable: false,
                configurable: true
            });
            ;
            memoryPool.prototype.newUint8Array = function () {
                if (this.pool.length > 0)
                    return this.pool.shift();
                return new Uint8Array(1024);
            };
            memoryPool.prototype.deleteUint8Array = function (array) {
                this.pool.push(array);
            };
            return memoryPool;
        }());
    })(io = m4m.io || (m4m.io = {}));
})(m4m || (m4m = {}));
/// <reference path="../../io/reflect.ts" />
var m4m;
/// <reference path="../../io/reflect.ts" />
(function (m4m) {
    var io;
    (function (io) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 对可序列化实例的克隆
         * @param instanceObj 被克隆实例
         * @param clonedObj 克隆实例引用
         * @version m4m 1.0
         */
        function cloneObj(instanceObj, clonedObj) {
            if (clonedObj === void 0) { clonedObj = undefined; }
            io.referenceInfo.oldmap = {};
            clonedObj = _cloneObj(instanceObj, clonedObj);
            io.referenceInfo.oldmap[instanceObj["insId"].getInsID()] = clonedObj;
            fillCloneReference(instanceObj, clonedObj);
            return clonedObj;
        }
        io.cloneObj = cloneObj;
        /**
         * @private
         */
        function fillCloneReference(instanceObj, clonedObj) {
            //过滤掉不需要序列化的对象
            var _flag = m4m.framework.HideFlags.None;
            var _type;
            if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"]) {
                _type = m4m.reflect.getClassName(instanceObj);
            }
            if (_type == "transform") {
                _flag = instanceObj["gameObject"].hideFlags;
            }
            else if (_type == "transform2D") {
                _flag = instanceObj.hideFlags;
            }
            if ((_flag & m4m.framework.HideFlags.DontSaveInBuild) || (_flag & m4m.framework.HideFlags.DontSaveInEditor) || (_flag & m4m.framework.HideFlags.HideInHierarchy)) {
                return null;
            }
            for (var key in instanceObj["__gdmeta__"]) {
                var t = instanceObj["__gdmeta__"][key];
                if (t["custom"] == null)
                    continue;
                if (t["custom"]["SerializeField"] == null && t["custom"]["nodecomp"] == null && t["custom"]["2dcomp"] == null)
                    continue;
                var valueType = t["custom"]["valueType"];
                if (valueType == null) {
                    continue;
                }
                //基本类型和定义为SerializeType的类型才会关心
                switch (valueType.toLowerCase()) {
                    case "number":
                    case "string":
                    case "boolean":
                        break;
                    default:
                        fillCloneReferenceTypeOrArray(instanceObj, clonedObj, key);
                        break;
                }
            }
            return clonedObj;
        }
        io.fillCloneReference = fillCloneReference;
        /**
         * @private
         */
        function fillCloneReferenceTypeOrArray(instanceObj, clonedObj, key) {
            if (instanceObj[key]) {
                if (instanceObj[key]["__gdmeta__"]) {
                    fillCloneReferenceType(instanceObj, clonedObj, key);
                }
                else if (instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"] && instanceObj["__gdmeta__"][key]["custom"]["valueType"]) {
                    for (var newkey in instanceObj[key]) {
                        var field = instanceObj[key][newkey];
                        if (field && field["__gdmeta__"]) {
                            var _meta = field["__gdmeta__"];
                            if (_meta["class"] && _meta["class"]["typename"] == "UniformData" && field.type == 3) {
                                //排除掉Matrix类型的序列化
                            }
                            else {
                                fillCloneReferenceType(instanceObj[key], clonedObj[key], newkey, instanceObj, clonedObj, key);
                            }
                        }
                    }
                    if (clonedObj["waitDelArray"]) {
                        var children = clonedObj[key];
                        //清除 被过滤的 null 元素
                        for (var _i = 0, _a = clonedObj["waitDelArray"]; _i < _a.length; _i++) {
                            var index = _a[_i];
                            children.splice(index, 1);
                        }
                        delete clonedObj["waitDelArray"];
                    }
                }
            }
        }
        io.fillCloneReferenceTypeOrArray = fillCloneReferenceTypeOrArray;
        /**
         * @private
         */
        function fillCloneReferenceType(instanceObj, clonedObj, key, instanceParent, clonedParent, instanceKey) {
            if (instanceParent === void 0) { instanceParent = null; }
            if (clonedParent === void 0) { clonedParent = null; }
            if (instanceKey === void 0) { instanceKey = ""; }
            var _meta = instanceObj[key]["__gdmeta__"];
            if (_meta["class"] && _meta["class"]["custom"] && (_meta["class"]["custom"]["SerializeType"] || _meta["class"]["custom"]["nodecomp"] || _meta["class"]["custom"]["2dcomp"])) {
                var isArray_1 = instanceObj instanceof Array;
                var type = _meta["class"]["typename"];
                if (io.isAsset(type)) {
                }
                else {
                    var isreference = false;
                    var insid = -1;
                    var instance = void 0;
                    if ((isArray_1 && instanceParent["__gdmeta__"] && instanceParent["__gdmeta__"]["class"] && instanceParent["__gdmeta__"]["class"]["custom"] && (instanceParent["__gdmeta__"]["class"]["custom"]["nodecomp"] || instanceParent["__gdmeta__"]["class"]["custom"]["2dcomp"])) ||
                        (!isArray_1 && instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"] && instanceObj["__gdmeta__"]["class"]["custom"] && (instanceObj["__gdmeta__"]["class"]["custom"]["nodecomp"] || instanceObj["__gdmeta__"]["class"]["custom"]["2dcomp"]))) {
                        //当前instance是组件
                        if (_meta["class"]["custom"]["nodecomp"]) {
                            //属性是组件
                            insid = instanceObj[key]["gameObject"]["transform"]["insId"].getInsID();
                            isreference = true;
                            instance = io.referenceInfo.oldmap[insid].gameObject.getComponent(type);
                        }
                        else if (_meta["class"]["custom"]["2dcomp"]) {
                            insid = instanceObj[key]["transform"]["insId"].getInsID();
                            isreference = true;
                            instance = io.referenceInfo.oldmap[insid].getComponent(type);
                        }
                        else if (type == "transform" || type == "transform2D") {
                            //属性是tranform
                            insid = instanceObj[key]["insId"].getInsID();
                            isreference = true;
                            instance = io.referenceInfo.oldmap[insid];
                        }
                    }
                    if (isreference) {
                        if (isArray_1) {
                            clonedObj.push(instance);
                        }
                        else {
                            clonedObj[key] = instance;
                        }
                    }
                    else {
                        if (clonedObj[key])
                            fillCloneReference(instanceObj[key], clonedObj[key]);
                        else {
                            if (!clonedParent["waitDelArray"])
                                clonedParent["waitDelArray"] = [];
                            clonedParent["waitDelArray"].push(parseInt(key));
                        }
                    }
                }
            }
        }
        io.fillCloneReferenceType = fillCloneReferenceType;
        /**
         * @private
         */
        function _cloneObj(instanceObj, clonedObj) {
            //过滤掉不需要序列化的对象
            // let _flag: m4m.framework.HideFlags = m4m.framework.HideFlags.None;
            // let _type: string;
            // if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"])
            // {
            //     _type = reflect.getClassName(instanceObj);
            // }
            // if (_type == "transform")
            // {
            //     _flag = instanceObj["gameObject"].hideFlags;
            // }
            // else if (_type == "transform2D")
            // {
            //     _flag = instanceObj.hideFlags;
            // }
            // if ((_flag & m4m.framework.HideFlags.DontSaveInBuild) || (_flag & m4m.framework.HideFlags.DontSaveInEditor) || (_flag & m4m.framework.HideFlags.HideInHierarchy))
            // {
            //     return null;
            // }
            if (clonedObj === void 0) { clonedObj = undefined; }
            if (clonedObj == undefined) {
                var insid = -1;
                clonedObj = m4m.reflect.createInstance(instanceObj, null);
                if (instanceObj["__gdmeta__"]["class"]["custom"]["nodecomp"]) {
                    insid = instanceObj["gameObject"]["transform"]["insId"].getInsID();
                }
                else if (instanceObj["__gdmeta__"]["class"]["custom"]["2dcomp"]) {
                    insid = instanceObj["transform"]["insId"].getInsID();
                }
                else if (instanceObj["__gdmeta__"]["class"]["typename"] == "transform" || instanceObj["__gdmeta__"]["class"]["typename"] == "transform2D") {
                    insid = instanceObj["insId"].getInsID();
                    io.referenceInfo.oldmap[insid] = clonedObj;
                }
            }
            for (var key in instanceObj["__gdmeta__"]) {
                var t = instanceObj["__gdmeta__"][key];
                if (t["custom"] == null)
                    continue;
                if (t["custom"]["SerializeField"] == null && t["custom"]["nodecomp"] == null && t["custom"]["2dcomp"] == null)
                    continue;
                var valueType = t["custom"]["valueType"];
                if (valueType == null) {
                    continue;
                }
                //基本类型和定义为SerializeType的类型才会关心
                switch (valueType.toLowerCase()) {
                    case "number":
                    case "string":
                    case "boolean":
                        clonedObj[key] = instanceObj[key];
                        break;
                    default:
                        cloneOtherTypeOrArray(instanceObj, clonedObj, key);
                        break;
                }
            }
            return clonedObj;
        }
        io._cloneObj = _cloneObj;
        /**
         * @private
         */
        function cloneOtherTypeOrArray(instanceObj, clonedObj, key) {
            if (instanceObj[key]) {
                if (instanceObj[key]["__gdmeta__"]) {
                    cloneOtherType(instanceObj, clonedObj, key);
                }
                else if (instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"] && instanceObj["__gdmeta__"][key]["custom"]["valueType"]) {
                    var isArray_2 = instanceObj[key] instanceof Array;
                    if (isArray_2)
                        clonedObj[key] = [];
                    else
                        clonedObj[key] = {};
                    for (var newkey in instanceObj[key]) {
                        var field = instanceObj[key][newkey];
                        if (field && field["__gdmeta__"]) {
                            var _meta = field["__gdmeta__"];
                            if (_meta["class"] && _meta["class"]["typename"] == "UniformData" && field.type == 3) {
                                //排除掉Matrix类型的序列化
                            }
                            else {
                                cloneOtherType(instanceObj[key], clonedObj[key], newkey, instanceObj, clonedObj, key);
                            }
                        }
                        else {
                            //如果数组是int、string、boolean。
                            if (!instanceObj[key]["__gdmeta__"]) {
                                var baseType = typeof (field);
                                switch (baseType.toLowerCase()) {
                                    case "number":
                                    case "string":
                                    case "boolean":
                                        if (isArray_2) {
                                            clonedObj[key].push(field);
                                        }
                                        else {
                                            clonedObj[key][newkey] = field;
                                        }
                                        break;
                                    default:
                                        break;
                                }
                            }
                        }
                    }
                }
            }
        }
        io.cloneOtherTypeOrArray = cloneOtherTypeOrArray;
        /**
         * @private
         */
        function cloneOtherType(instanceObj, clonedObj, key, instanceParent, clonedParent, instanceKey) {
            if (instanceParent === void 0) { instanceParent = null; }
            if (clonedParent === void 0) { clonedParent = null; }
            if (instanceKey === void 0) { instanceKey = ""; }
            var _meta = instanceObj[key]["__gdmeta__"];
            if (_meta["class"] && _meta["class"]["custom"] && (_meta["class"]["custom"]["SerializeType"] || _meta["class"]["custom"]["nodecomp"] || _meta["class"]["custom"]["2dcomp"])) {
                var isArray_3 = instanceObj instanceof Array;
                var type = _meta["class"]["typename"];
                if (io.isAsset(type)) {
                    var _defaultAsset = instanceObj[key].defaultAsset;
                    if (instanceObj[key].use) {
                        instanceObj[key].use();
                    }
                    if (isArray_3) {
                        clonedObj.push(instanceObj[key]);
                    }
                    else {
                        clonedObj[key] = instanceObj[key];
                    }
                }
                else {
                    var isreference = false;
                    if ((isArray_3 && instanceParent["__gdmeta__"] && instanceParent["__gdmeta__"]["class"] && instanceParent["__gdmeta__"]["class"]["custom"] && (instanceParent["__gdmeta__"]["class"]["custom"]["nodecomp"] || instanceParent["__gdmeta__"]["class"]["custom"]["2dcomp"])) ||
                        (!isArray_3 && instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"] && instanceObj["__gdmeta__"]["class"]["custom"] && (instanceObj["__gdmeta__"]["class"]["custom"]["nodecomp"] || instanceObj["__gdmeta__"]["class"]["custom"]["2dcomp"]))) {
                        if (_meta["class"]["custom"]["nodecomp"] || _meta["class"]["custom"]["2dcomp"] || type == "transform" || type == "transform2D") {
                            isreference = true;
                        }
                    }
                    if (isreference) {
                        if (isArray_3) {
                            // clonedObj.push(instanceObj[key]);
                        }
                        else {
                            // clonedObj[key] = instanceObj[key];
                        }
                    }
                    else {
                        var _clonedObj = void 0;
                        if (_meta["class"]["custom"]["selfclone"]) {
                            _clonedObj = instanceObj[key].clone();
                        }
                        else {
                            _clonedObj = _cloneObj(instanceObj[key], clonedObj[key]);
                        }
                        if (_clonedObj != null) {
                            if (isArray_3) {
                                if (type == "nodeComponent" && instanceKey == "components" && m4m.reflect.getClassName(instanceParent) == "gameObject") {
                                    clonedParent.addComponentDirect(_clonedObj.comp);
                                }
                                else if (type == "transform" && instanceKey == "children" && m4m.reflect.getClassName(instanceParent) == "transform") {
                                    clonedParent.addChild(_clonedObj);
                                }
                                else if (type == "C2DComponent" && instanceKey == "components" && m4m.reflect.getClassName(instanceParent) == "transform2D") {
                                    clonedParent.addComponentDirect(_clonedObj.comp);
                                }
                                else if (type == "transform2D" && instanceKey == "children" && m4m.reflect.getClassName(instanceParent) == "transform2D") {
                                    clonedParent.addChild(_clonedObj);
                                }
                                else {
                                    clonedObj.push(_clonedObj);
                                }
                            }
                            else {
                                clonedObj[key] = _clonedObj;
                            }
                        }
                        else if (isArray_3) {
                            clonedObj.push(null);
                        }
                    }
                }
            }
        }
        io.cloneOtherType = cloneOtherType;
    })(io = m4m.io || (m4m.io = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var io;
    (function (io) {
        // export interface SaveInterface
        // {
        //     saveBlob(path:string,fun:(blob:Blob)=>void);
        //     saveText(path:string,fun:()=>string);
        //     saveMap(pathMap: { [id: string]: string }, fun:Function)
        // }
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * string转换为blob
         * @version m4m 1.0
         */
        function stringToBlob(content) {
            var u8 = new Uint8Array(stringToUtf8Array(content));
            var blob = new Blob([u8]);
            return blob;
        }
        io.stringToBlob = stringToBlob;
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * string转换为utf8数组
         * @version m4m 1.0
         */
        function stringToUtf8Array(str) {
            var bstr = [];
            for (var i = 0; i < str.length; i++) {
                var c = str.charAt(i);
                var cc = c.charCodeAt(0);
                if (cc > 0xFFFF) {
                    throw new Error("InvalidCharacterError");
                }
                if (cc > 0x80) {
                    if (cc < 0x07FF) {
                        var c1 = (cc >>> 6) | 0xC0;
                        var c2 = (cc & 0x3F) | 0x80;
                        bstr.push(c1, c2);
                    }
                    else {
                        var c1 = (cc >>> 12) | 0xE0;
                        var c2 = ((cc >>> 6) & 0x3F) | 0x80;
                        var c3 = (cc & 0x3F) | 0x80;
                        bstr.push(c1, c2, c3);
                    }
                }
                else {
                    bstr.push(cc);
                }
            }
            return bstr;
        }
        io.stringToUtf8Array = stringToUtf8Array;
    })(io = m4m.io || (m4m.io = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var io;
    (function (io) {
        var assetMgr;
        var filter = { cls: true, insid: true, gameObject: true, components: true, children: true };
        var baseType = { string: true, number: true, boolean: true };
        function ndeSerialize(json, assetbundle, useAsset) {
            if (!assetMgr)
                assetMgr = m4m.framework.sceneMgr.app.getAssetMgr();
            var bundlename = assetbundle;
            var instMap = {};
            var gos = [];
            var root = createTrasn(json, gos, instMap);
            var is2d = json.cls == "transform2D";
            var coms;
            if (is2d)
                coms = [];
            fullTrasn(json, root, gos, instMap, bundlename);
            //先收集transform 再赋值gameobject
            var god;
            for (var i = 0, len = gos.length; i < len; ++i) {
                god = gos[i];
                fullGO(god.data, god.go, bundlename, instMap, useAsset, is2d, coms);
            }
            if (is2d) {
                for (var i = 0, len = coms.length; i < len; ++i) {
                    var com = coms[i];
                    com.src[com.key] = com.cls == "transform2D" ? instMap[com.refid] : instMap[com.refid].getComponent(com.cls);
                }
            }
            return root;
        }
        io.ndeSerialize = ndeSerialize;
        function fullTrasn(json, node, gos, instMap, bundlename) {
            if (json.children) {
                for (var i = 0, len = json.children.length; i < len; ++i) {
                    var ctrans = createTrasn(json.children[i], gos, instMap);
                    node.addChild(ctrans);
                    fullTrasn(json.children[i], ctrans, gos, instMap, bundlename);
                }
            }
        }
        function createTrasn(json, gos, instMap) {
            var trans = new m4m.framework[json.cls];
            trans.name = json.name;
            for (var k in json) {
                if (!filter[k])
                    fullValue(trans, k, json[k]);
                // trans[k] = json[k];
            }
            if (json.components || (json.gameObject && json.gameObject.components)) {
                gos.push({
                    go: json.components ? trans : trans.gameObject,
                    data: json.components ? json : json.gameObject
                });
            }
            instMap[json.insid] = trans;
            return trans;
        }
        function fullGO(json, go, bundlename, instMap, useAsset, is2d, comps) {
            go.layer = json.layer;
            go.tag = json.tag;
            for (var i = 0, len = json.components.length; i < len; ++i) {
                var jcomp = json.components[i];
                var comp = go.addComponent(jcomp.cls);
                for (var k in jcomp)
                    fullProp(comp, jcomp, k, bundlename, instMap, useAsset, is2d, comps);
            }
        }
        function fullProp(comp, jcomp, k, bundlename, instMap, useAsset, is2d, comps) {
            var prop = jcomp[k];
            if (prop instanceof Array) {
                var arrProp = comp[k] || (comp[k] = []);
                for (var i = 0, len = prop.length; i < len; ++i) {
                    var ele = prop[i];
                    var value = void 0;
                    if (ele.cls && io.isAsset(ele.cls))
                        value = getAssetValue(ele.value, ele.cls, bundlename, useAsset);
                    else if (ele.refid) {
                        value = instMap[ele.refid];
                    }
                    else {
                        // value = ele;
                        arrProp.push(null); //先填充空值再赋值
                        fullValue(arrProp, i, prop[i]);
                    }
                    if (value)
                        arrProp.push(value);
                }
            }
            else if (prop.cls && io.isAsset(prop.cls))
                comp[k] = getAssetValue(prop.value, prop.cls, bundlename, useAsset);
            else if (prop.refid) {
                if (is2d) {
                    //comp[k] = instMap[prop.refid].getComponent(prop.cls);
                    comps.push({
                        refid: prop.refid,
                        cls: prop.cls,
                        src: comp,
                        key: k
                    });
                }
                else {
                    if (prop.cls && m4m.reflect.isComp(prop.cls)) {
                        //引用组件
                        var trans = instMap[prop.refid];
                        comp[k] = trans.gameObject.getComponent(prop.cls);
                    }
                    else
                        comp[k] = instMap[prop.refid];
                }
            }
            else
                fullValue(comp, k, prop);
            // comp[k] = prop;
        }
        function fullValue(obj, key, json) {
            if (!json.cls || baseType[json.cls])
                obj[key] = json;
            else {
                var ctor = m4m.math[json.cls] || m4m.framework[json.cls];
                var inst = new ctor();
                for (var k in json) {
                    if (k == "cls")
                        continue;
                    fullValue(inst, k, json[k]);
                }
                obj[key] = inst;
            }
        }
        function getAssetValue(assetName, type, bundlename, useAsset) {
            var asset;
            if (assetName.indexOf("SystemDefaultAsset-") >= 0) {
                assetName = assetName.replace("SystemDefaultAsset-", "");
                if (type == "mesh")
                    asset = assetMgr.getDefaultMesh(assetName.replace(".mesh.bin", "").replace(".cmesh.bin", ""));
                else if (type == "texture")
                    asset = assetMgr.getDefaultTexture(assetName);
            }
            else
                asset = assetMgr.getAssetByName(assetName, bundlename) ||
                    assetMgr.getAssetByName(assetName.replace(".mesh.bin", ".cmesh.bin"), bundlename);
            if (!asset && type == "animationClip") {
                var clip = new m4m.framework.animationClip(assetName);
                clip.bones = [];
                clip.subclips = [];
                asset = clip;
            }
            if (useAsset && asset)
                asset.use();
            return asset;
        }
    })(io = m4m.io || (m4m.io = {}));
})(m4m || (m4m = {}));
/// <reference path="../../io/reflect.ts" />
var m4m;
/// <reference path="../../io/reflect.ts" />
(function (m4m) {
    var io;
    (function (io) {
        var SaveAssetType;
        (function (SaveAssetType) {
            SaveAssetType[SaveAssetType["FullUrl"] = 0] = "FullUrl";
            SaveAssetType[SaveAssetType["NameAndContent"] = 1] = "NameAndContent";
            SaveAssetType[SaveAssetType["DefaultAssets"] = 2] = "DefaultAssets";
        })(SaveAssetType = io.SaveAssetType || (io.SaveAssetType = {}));
        //依赖的资源路径
        /**
         * @private
         */
        var SerializeDependent = /** @class */ (function () {
            function SerializeDependent() {
            }
            // static resourcesContent: any[] = [];
            SerializeDependent.GetAssetContent = function (asset) {
                var data = {};
                if (asset instanceof m4m.framework.material) {
                    var t = asset.getName();
                    var names = t.split(".");
                    if (t.lastIndexOf('.mat.json') == -1) {
                        return { "name": names[0] + ".mat.json", "value": asset.save(), "type": SaveAssetType.NameAndContent };
                    }
                    return { "name": t, "value": asset.save(), "type": SaveAssetType.NameAndContent };
                }
                // if (asset instanceof m4m.framework.mesh)
                //     return { "name": asset.getName() + "_enginedefault.mesh.bin", "type": SaveAssetType.DefaultAssets };
                // if (asset instanceof m4m.framework.texture)
                //     return { "name": asset.getName() + "_enginedefault.png", "type": SaveAssetType.DefaultAssets };
            };
            SerializeDependent.GetAssetUrl = function (asset, assetMgr) {
                if (!assetMgr || !asset)
                    return;
                var url = assetMgr.getAssetUrl(asset);
                // if (!url)
                //     return;
                //为了序列化存储而修改的逻辑hjx
                if (url && !(asset instanceof m4m.framework.material)) { //material 资源 存在 编辑器中修改的情况 不能 走URL 保存原文件
                    SerializeDependent.resourseDatas.push({ "url": url, "type": SaveAssetType.FullUrl });
                    if ((asset instanceof m4m.framework.f14eff)) { //f14eff 处理
                        var assets = asset.getDependents();
                        var note_1 = {}; //过滤重复
                        assets.forEach(function (asset) {
                            if (asset) {
                                var url_1 = assetMgr.getAssetUrl(asset);
                                if (url_1) {
                                    if (!note_1[url_1]) {
                                        SerializeDependent.resourseDatas.push({ "url": url_1, "type": SaveAssetType.FullUrl });
                                        if (asset instanceof m4m.framework.texture && asset.realName && asset.realName != "") {
                                            asset;
                                            var idx = url_1.lastIndexOf("/");
                                            if (idx != -1) {
                                                var haed = url_1.substring(0, idx + 1);
                                                SerializeDependent.resourseDatas.push({ "url": haed + asset.realName, "type": SaveAssetType.FullUrl });
                                            }
                                        }
                                    }
                                    note_1[url_1] = true;
                                }
                            }
                        });
                    }
                }
                else
                    SerializeDependent.resourseDatas.push(SerializeDependent.GetAssetContent(asset));
                if (asset instanceof m4m.framework.material) {
                    // let _mapUniform = (asset as m4m.framework.material).statedMapUniforms;
                    var ass = asset;
                    for (var newKey in ass.statedMapUniforms) {
                        if (!ass.statedMapUniforms[newKey])
                            continue;
                        if (ass.defaultMapUniform[newKey].type != m4m.render.UniformTypeEnum.Texture)
                            continue;
                        var _texture = ass.statedMapUniforms[newKey];
                        if (!_texture)
                            continue;
                        url = assetMgr.getAssetUrl(_texture);
                        // if (!url)
                        //     continue;
                        //为了序列化存储而修改的逻辑hjx
                        if (url)
                            SerializeDependent.resourseDatas.push({ "url": url, "type": SaveAssetType.FullUrl });
                        else {
                            if (_texture.defaultAsset == true)
                                continue;
                            var content = SerializeDependent.GetAssetContent(_texture);
                            if (content)
                                SerializeDependent.resourseDatas.push(content);
                            continue;
                        }
                        if (url.indexOf(".imgdesc.json") < 0)
                            continue;
                        if (!_texture.realName)
                            continue;
                        url = url.replace(_texture.getName(), _texture.realName);
                        SerializeDependent.resourseDatas.push({ "url": url, "type": SaveAssetType.FullUrl });
                    }
                }
            };
            SerializeDependent.resourseDatas = [];
            return SerializeDependent;
        }());
        io.SerializeDependent = SerializeDependent;
        /**
         * @private
         */
        function SerializeForInspector(obj) {
            var str = JSON.stringify(serializeObjForInspector(obj, false));
            return str;
        }
        io.SerializeForInspector = SerializeForInspector;
        /**
         * @private
         */
        function serializeObjForInspector(instanceObj, beComponent, serializedObj) {
            if (serializedObj === void 0) { serializedObj = undefined; }
            var _flag = m4m.framework.HideFlags.None;
            var _type;
            if (boolInNull(instanceObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"]) {
                _type = m4m.reflect.getClassName(instanceObj);
            }
            if (_type == "transform" && instanceObj["gameObject"]) {
                _flag = instanceObj["gameObject"].hideFlags;
            }
            else if (_type == "transform2D") {
                _flag = instanceObj.hideFlags;
            }
            if ((_flag & m4m.framework.HideFlags.HideInInspector)) {
                return null;
            }
            if (serializedObj == undefined) {
                serializedObj = {};
            }
            for (var key in instanceObj["__gdmeta__"]) {
                if (key == "children")
                    continue;
                var t = instanceObj["__gdmeta__"][key];
                if (boolInNull(t)) {
                    continue;
                }
                if (t["custom"] == null)
                    continue;
                if (t["custom"]["SerializeField"] == null && t["custom"]["nodecomp"] == null && t["custom"]["2dcomp"] == null)
                    continue;
                var valueType = t["custom"]["valueType"];
                if (valueType == null) {
                    continue;
                }
                //基本类型和定义为SerializeType的类型才会关心
                switch (valueType.toLowerCase()) {
                    case "number":
                    case "string":
                    case "boolean":
                        var info = new inspectorValueInfo(instanceObj[key], valueType);
                        if (t["custom"]["FieldUIStyle"])
                            info.UIStyle = t["custom"]["FieldUIStyle"];
                        if (t["custom"]["defvalue"])
                            info.defvalue = t["custom"]["defvalue"];
                        if (t["custom"]["min"])
                            info.min = t["custom"]["min"];
                        if (t["custom"]["max"])
                            info.max = t["custom"]["max"];
                        serializedObj[key] = info;
                        break;
                    default:
                        serializeOtherTypeOrArrayForInspector(instanceObj, serializedObj, key, beComponent);
                        break;
                }
            }
            return serializedObj;
        }
        io.serializeObjForInspector = serializeObjForInspector;
        /**
         * @private
         */
        function serializeOtherTypeOrArrayForInspector(instanceObj, serializedObj, key, beComponent) {
            if (boolInNull(instanceObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (boolInNull(serializedObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (instanceObj[key]) {
                if (instanceObj[key]["__gdmeta__"]) {
                    serializeOtherTypeForInspector(instanceObj, serializedObj, key, beComponent);
                }
                else if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"] && instanceObj["__gdmeta__"][key]["custom"]["valueType"]) {
                    var isArray_4 = instanceObj[key] instanceof Array;
                    if (isArray_4)
                        serializedObj[key] = new inspectorValueInfo([], instanceObj["__gdmeta__"][key]["custom"]["valueType"]);
                    else
                        serializedObj[key] = new inspectorValueInfo({}, instanceObj["__gdmeta__"][key]["custom"]["valueType"]);
                    for (var newkey in instanceObj[key]) {
                        if (instanceObj[key][newkey] == null || instanceObj[key][newkey] == undefined) {
                            continue;
                        }
                        if (instanceObj[key][newkey]["__gdmeta__"]) {
                            var _meta = instanceObj[key][newkey]["__gdmeta__"];
                            if (_meta["class"] && _meta["class"]["typename"] == "UniformData" && instanceObj[key][newkey].type == 3) {
                                //排除掉Matrix类型的序列化
                            }
                            else {
                                serializeOtherTypeForInspector(instanceObj[key], serializedObj[key]["value"], newkey, beComponent, instanceObj);
                            }
                        }
                        else {
                            //如果数组是int、string、boolean。
                            if (!instanceObj[key]["__gdmeta__"]) {
                                var baseType = typeof (instanceObj[key][newkey]);
                                switch (baseType.toLowerCase()) {
                                    case "number":
                                    case "string":
                                    case "boolean":
                                        if (boolInNull(serializedObj[key]["value"])) {
                                            continue;
                                        }
                                        var info_1 = new inspectorValueInfo(instanceObj[key][newkey], baseType);
                                        if (isArray_4) {
                                            serializedObj[key]["value"].push(info_1);
                                        }
                                        else {
                                            serializedObj[key]["value"][newkey] = info_1;
                                        }
                                        break;
                                    default:
                                        break;
                                }
                            }
                        }
                    }
                }
            }
            else {
                var isArray_5 = instanceObj instanceof Array;
                if (instanceObj["__gdmeta__"]) {
                    if (instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"]) //&& instanceObj["__gdmeta__"][key]["custom"]["FieldUIStyle"]
                     {
                        var custom = instanceObj["__gdmeta__"][key]["custom"];
                        if (custom["valueType"]) {
                            var info = new inspectorValueInfo(null, custom["valueType"]);
                            if (custom["FieldUIStyle"])
                                info.UIStyle = custom["FieldUIStyle"];
                            if (custom["defvalue"])
                                info.defvalue = custom["defvalue"];
                            if (custom["min"])
                                info.min = custom["min"];
                            if (custom["max"])
                                info.max = custom["max"];
                            if (isArray_5) {
                                serializedObj.push(info); //new valueInfo(_serializeObj, type, id));
                            }
                            else {
                                serializedObj[key] = info; //new valueInfo(_serializeObj, type, id);
                            }
                        }
                    }
                }
            }
        }
        io.serializeOtherTypeOrArrayForInspector = serializeOtherTypeOrArrayForInspector;
        /**
         * @private
         */
        function serializeOtherTypeForInspector(instanceObj, serializedObj, key, beComponent, arrayInst) {
            if (arrayInst === void 0) { arrayInst = null; }
            if (boolInNull(instanceObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (boolInNull(serializedObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (boolInNull(instanceObj[key]) || boolInNull(instanceObj[key]["__gdmeta__"])) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            var _meta = instanceObj[key]["__gdmeta__"];
            if (_meta["class"] && _meta["class"]["custom"] && (_meta["class"]["custom"]["SerializeType"] || _meta["class"]["custom"]["nodecomp"] || _meta["class"]["custom"]["2dcomp"])) {
                var isArray_6 = instanceObj instanceof Array;
                var type = _meta["class"]["typename"];
                if (isAssetInspector(type)) {
                    var _defaultAsset = instanceObj[key].defaultAsset;
                    var _assetName = instanceObj[key].getName();
                    if (_assetName != null) {
                        if (_defaultAsset) {
                            _assetName = "SystemDefaultAsset-" + _assetName;
                        }
                        var info = new inspectorValueInfo(_assetName, type);
                        if (isArray_6) {
                            serializedObj.push(info);
                        }
                        else {
                            serializedObj[key] = info;
                        }
                    }
                }
                else {
                    var isreference = false;
                    var insid = -1;
                    if ((isArray_6 && arrayInst["__gdmeta__"] && arrayInst["__gdmeta__"]["class"] && arrayInst["__gdmeta__"]["class"]["custom"] && (arrayInst["__gdmeta__"]["class"]["custom"]["nodecomp"] || arrayInst["__gdmeta__"]["class"]["custom"]["2dcomp"])) ||
                        (!isArray_6 && instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"] && instanceObj["__gdmeta__"]["class"]["custom"] && (instanceObj["__gdmeta__"]["class"]["custom"]["nodecomp"] || instanceObj["__gdmeta__"]["class"]["custom"]["2dcomp"]))) {
                        beComponent = true;
                        //当前instance是组件
                        if (_meta["class"]["custom"]["nodecomp"]) {
                            //属性是组件
                            insid = instanceObj[key]["gameObject"]["transform"]["insId"].getInsID();
                            isreference = true;
                        }
                        else if (_meta["class"]["custom"]["2dcomp"]) {
                            insid = instanceObj[key]["transform"]["insId"].getInsID();
                            isreference = true;
                        }
                        else if (type == "transform" || type == "transform2D") {
                            //属性是tranform
                            insid = instanceObj[key]["insId"].getInsID();
                            isreference = true;
                        }
                        else if (!referenceInfo.isRegType(type)) {
                            //不是组件和transform 也不是基础类型  忽视
                            return;
                        }
                    }
                    if (isreference) {
                        var info = new inspectorValueInfo(insid, type, "reference");
                        if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"] && instanceObj["__gdmeta__"][key]["custom"]["FieldUIStyle"]) {
                            var custom = instanceObj["__gdmeta__"][key]["custom"];
                            info.UIStyle = instanceObj["__gdmeta__"][key]["custom"]["FieldUIStyle"];
                            if (custom["defvalue"])
                                info.defvalue = custom;
                            if (custom["min"])
                                info.min = custom["min"];
                            if (custom["max"])
                                info.max = custom["max"];
                        }
                        if (isArray_6) {
                            serializedObj.push(info);
                        }
                        else {
                            serializedObj[key] = info;
                        }
                    }
                    else {
                        if (!referenceInfo.isRegType(type) && beComponent)
                            return;
                        var _serializeObj = serializeObjForInspector(instanceObj[key], beComponent, serializedObj[key]);
                        if (_serializeObj != null) {
                            var info = new inspectorValueInfo(_serializeObj, type);
                            if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"] && instanceObj["__gdmeta__"][key]["custom"]["FieldUIStyle"]) {
                                var custom = instanceObj["__gdmeta__"][key]["custom"];
                                info.UIStyle = custom["FieldUIStyle"];
                                if (custom["defvalue"])
                                    info.defvalue = custom;
                                if (custom["min"])
                                    info.min = custom["min"];
                                if (custom["max"])
                                    info.max = custom["max"];
                            }
                            if (isArray_6) {
                                serializedObj.push(info); //new valueInfo(_serializeObj, type, id));
                            }
                            else {
                                serializedObj[key] = info; //new valueInfo(_serializeObj, type, id);
                            }
                        }
                    }
                }
            }
        }
        io.serializeOtherTypeForInspector = serializeOtherTypeForInspector;
        /**
         * 序列化
         */
        /**
         * @private
         */
        function Serialize(obj, assetMgr) {
            if (assetMgr === void 0) { assetMgr = null; }
            return JSON.stringify(serializeObj(obj, null, assetMgr));
        }
        io.Serialize = Serialize;
        //根据反射类型将对象进行序列化
        /**
         * @private
         */
        function serializeObj(instanceObj, serializedObj, assetMgr) {
            if (serializedObj === void 0) { serializedObj = undefined; }
            if (assetMgr === void 0) { assetMgr = null; }
            if (boolInNull(instanceObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            //过滤掉不需要序列化的对象
            var _flag = m4m.framework.HideFlags.None;
            var _type;
            if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"]) {
                _type = m4m.reflect.getClassName(instanceObj); //["__gdmeta__"]["class"]["typename"];
            }
            if (_type == "transform") {
                _flag = instanceObj["gameObject"].hideFlags;
            }
            else if (_type == "transform2D") {
                _flag = instanceObj.hideFlags;
            }
            if ((_flag & m4m.framework.HideFlags.DontSaveInBuild) || (_flag & m4m.framework.HideFlags.DontSaveInEditor) || (_flag & m4m.framework.HideFlags.HideInHierarchy)) {
                return null;
            }
            if (serializedObj == undefined) {
                serializedObj = new valueInfo({}, _type);
                if (instanceObj["insId"] != undefined) {
                    serializedObj["insid"] = instanceObj["insId"].getInsID();
                }
            }
            for (var key in instanceObj["__gdmeta__"]) {
                var t = instanceObj["__gdmeta__"][key];
                if (t == null) {
                    continue;
                }
                if (t["custom"] == null)
                    continue;
                if (t["custom"]["SerializeField"] == null && t["custom"]["nodecomp"] == null && t["custom"]["2dcomp"] == null)
                    continue;
                var valueType = t["custom"]["valueType"];
                if (valueType == null) {
                    continue;
                }
                //基本类型和定义为SerializeType的类型才会关心
                switch (valueType.toLowerCase()) {
                    case "number":
                    case "string":
                    case "boolean":
                        var info = new valueInfo(instanceObj[key], valueType);
                        serializedObj["value"][key] = info;
                        break;
                    default:
                        serializeOtherTypeOrArray(instanceObj, serializedObj["value"], key, assetMgr);
                        break;
                }
            }
            return serializedObj;
        }
        io.serializeObj = serializeObj;
        /**
         * @private
         */
        function serializeOtherTypeOrArray(instanceObj, serializedObj, key, assetMgr) {
            if (assetMgr === void 0) { assetMgr = null; }
            if (boolInNull(instanceObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (boolInNull(serializedObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (instanceObj[key]) {
                if (instanceObj[key]["__gdmeta__"]) {
                    serializeOtherType(instanceObj, serializedObj, key, null, assetMgr);
                }
                else if (instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"][key] && instanceObj["__gdmeta__"][key]["custom"] && instanceObj["__gdmeta__"][key]["custom"]["valueType"]) {
                    var isArray_7 = instanceObj[key] instanceof Array;
                    if (isArray_7)
                        serializedObj[key] = new valueInfo([], instanceObj["__gdmeta__"][key]["custom"]["valueType"]);
                    else
                        serializedObj[key] = new valueInfo({}, instanceObj["__gdmeta__"][key]["custom"]["valueType"]);
                    for (var newkey in instanceObj[key]) {
                        if (instanceObj[key][newkey] && instanceObj[key][newkey]["__gdmeta__"]) {
                            var _meta = instanceObj[key][newkey]["__gdmeta__"];
                            if (_meta["class"] && _meta["class"]["typename"] == "UniformData" && instanceObj[key][newkey].type == 3) {
                                //排除掉Matrix类型的序列化
                            }
                            else {
                                serializeOtherType(instanceObj[key], serializedObj[key]["value"], newkey, instanceObj, assetMgr);
                            }
                        }
                        else {
                            //如果数组是int、string、boolean。
                            if (!instanceObj[key]["__gdmeta__"]) {
                                if (instanceObj[key][newkey] == null || instanceObj[key][newkey] == undefined) {
                                    continue;
                                }
                                var baseType = typeof (instanceObj[key][newkey]);
                                switch (baseType.toLowerCase()) {
                                    case "number":
                                    case "string":
                                    case "boolean":
                                        var info = new valueInfo(instanceObj[key][newkey], baseType);
                                        if (serializedObj[key]["value"]) {
                                            if (isArray_7) {
                                                serializedObj[key]["value"].push(info);
                                            }
                                            else {
                                                serializedObj[key]["value"][newkey] = info;
                                            }
                                        }
                                        break;
                                    default:
                                        break;
                                }
                            }
                        }
                    }
                }
            }
        }
        io.serializeOtherTypeOrArray = serializeOtherTypeOrArray;
        /**
         * @private
         */
        function serializeOtherType(instanceObj, serializedObj, key, arrayInst, assetMgr) {
            if (arrayInst === void 0) { arrayInst = null; }
            if (assetMgr === void 0) { assetMgr = null; }
            if (boolInNull(instanceObj || boolInNull(serializedObj))) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (boolInNull(instanceObj[key]) || boolInNull(instanceObj[key]["__gdmeta__"])) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            var _meta = instanceObj[key]["__gdmeta__"];
            if (_meta["class"] && _meta["class"]["custom"] && (_meta["class"]["custom"]["SerializeType"] || _meta["class"]["custom"]["nodecomp"] || _meta["class"]["custom"]["2dcomp"])) {
                var isArray_8 = instanceObj instanceof Array;
                var type = _meta["class"]["typename"];
                if (isAsset(type)) {
                    var _defaultAsset = instanceObj[key].defaultAsset;
                    var _assetName = instanceObj[key].getName();
                    if (_assetName != null) {
                        if (_defaultAsset) {
                            _assetName = "SystemDefaultAsset-" + _assetName;
                        }
                        else {
                            if (assetMgr) {
                                SerializeDependent.GetAssetUrl(instanceObj[key], assetMgr);
                            }
                        }
                        if (isArray_8) {
                            serializedObj.push(new valueInfo(_assetName, type));
                        }
                        else {
                            serializedObj[key] = new valueInfo(_assetName, type);
                        }
                    }
                }
                else {
                    var isreference = false;
                    var insid = -1;
                    if ((isArray_8 && arrayInst["__gdmeta__"] && arrayInst["__gdmeta__"]["class"] && arrayInst["__gdmeta__"]["class"]["custom"] && (arrayInst["__gdmeta__"]["class"]["custom"]["nodecomp"] || arrayInst["__gdmeta__"]["class"]["custom"]["2dcomp"])) ||
                        (!isArray_8 && instanceObj["__gdmeta__"] && instanceObj["__gdmeta__"]["class"] && instanceObj["__gdmeta__"]["class"]["custom"] && (instanceObj["__gdmeta__"]["class"]["custom"]["nodecomp"] || instanceObj["__gdmeta__"]["class"]["custom"]["2dcomp"]))) {
                        //当前instance是组件
                        if (_meta["class"]["custom"]["nodecomp"]) {
                            //属性是组件
                            if (instanceObj[key] && instanceObj[key]["gameObject"])
                                insid = instanceObj[key]["gameObject"]["transform"]["insId"].getInsID();
                            isreference = true;
                        }
                        else if (_meta["class"]["custom"]["2dcomp"]) {
                            if (instanceObj[key] && instanceObj[key]["transform"])
                                insid = instanceObj[key]["transform"]["insId"].getInsID();
                            isreference = true;
                        }
                        else if (type == "transform" || type == "transform2D") {
                            //属性是tranform
                            if (instanceObj[key])
                                insid = instanceObj[key]["insId"].getInsID();
                            isreference = true;
                        }
                    }
                    if (isreference) {
                        if (isArray_8) {
                            serializedObj.push(new valueInfo(insid, type, "reference"));
                        }
                        else {
                            serializedObj[key] = new valueInfo(insid, type, "reference");
                        }
                    }
                    else {
                        var _serializeObj = serializeObj(instanceObj[key], serializedObj[key], assetMgr);
                        if (_serializeObj != null) {
                            if (isArray_8) {
                                serializedObj.push(_serializeObj);
                            }
                            else {
                                serializedObj[key] = _serializeObj;
                            }
                        }
                    }
                }
            }
        }
        io.serializeOtherType = serializeOtherType;
        /**
         * 反序列化  传入的源数据为json
         */
        /**
         * @private
         */
        function deSerialize(serializedObj, instanceObj, assetMgr, bundlename) {
            if (bundlename === void 0) { bundlename = null; }
            if (boolInNull(serializedObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            referenceInfo.oldmap = {};
            //var serializedObj = JSON.parse(json);
            deSerializeObj(serializedObj["value"], instanceObj, assetMgr, bundlename);
            var insid = serializedObj["insid"];
            if (!insid) {
                //console.error(serializedObj);
            }
            else
                referenceInfo.oldmap[insid] = instanceObj;
            fillReference(serializedObj["value"], instanceObj);
        }
        io.deSerialize = deSerialize;
        /**
         * @private
         */
        function fillReference(serializedObj, instanceObj) {
            if (boolInNull(instanceObj) || boolInNull(instanceObj["__gdmeta__"])) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            for (var key in instanceObj["__gdmeta__"]) {
                var t = instanceObj["__gdmeta__"][key];
                if (boolInNull(t)) {
                    continue;
                }
                if (t["custom"] == null)
                    continue;
                if (t["custom"]["SerializeField"] == null && t["custom"]["nodecomp"] == null && t["custom"]["2dcomp"] == null)
                    continue;
                var valueType = t["custom"]["valueType"];
                if (valueType == null) {
                    continue;
                }
                //基本类型和定义为SerializeType的类型才会关心
                switch (valueType.toLowerCase()) {
                    case "number":
                    case "string":
                    case "boolean":
                        break;
                    default:
                        dofillReferenceOrArray(serializedObj, instanceObj, key);
                        break;
                }
            }
        }
        io.fillReference = fillReference;
        /**
         * @private
         */
        function dofillReferenceOrArray(serializedObj, instanceObj, key) {
            if (boolInNull(serializedObj) || boolInNull(instanceObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (serializedObj[key]) {
                var type = serializedObj[key].type;
                if (isArrayOrDic(type.toLowerCase())) {
                    var _isArray = serializedObj[key].value instanceof Array;
                    // let _isArray: boolean = isArray(type);
                    if (!instanceObj[key]) {
                        if (_isArray)
                            instanceObj[key] = [];
                        else
                            instanceObj[key] = {};
                    }
                    var arrayObj = null;
                    if (boolInNull(instanceObj["__gdmeta__"]) && boolInNull(instanceObj["__gdmeta__"][key]) && boolInNull(instanceObj["__gdmeta__"][key]["custom"])
                        && instanceObj["__gdmeta__"][key]["custom"]["valueType"] != serializedObj[key].type) {
                        throw new Error("反序列化失败，类型不匹配：" + instanceObj["__gdmeta__"][key]["custom"]["valueType"] + " as " + serializedObj[key].type);
                    }
                    arrayObj = serializedObj[key].value;
                    for (var newkey in arrayObj) {
                        if (boolInNull(arrayObj[newkey])) {
                            continue;
                        }
                        var baseType = arrayObj[newkey].type;
                        if (!baseType)
                            continue;
                        switch (baseType.toLowerCase()) {
                            case "number":
                            case "string":
                            case "boolean":
                                break;
                            default:
                                dofillReference(serializedObj[key]["value"], instanceObj[key], newkey);
                                break;
                        }
                    }
                }
                else {
                    dofillReference(serializedObj, instanceObj, key);
                }
            }
        }
        io.dofillReferenceOrArray = dofillReferenceOrArray;
        /**
         * @private
         */
        function dofillReference(serializedObj, instanceObj, key) {
            if (boolInNull(instanceObj) || boolInNull(serializedObj) || boolInNull(serializedObj[key])) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            var _isArray = instanceObj instanceof Array;
            var type = serializedObj[key].type;
            var _parentType = typeof (instanceObj);
            if (isAsset(type)) {
            }
            else {
                if (serializedObj[key].parse == "reference") {
                    var instance = referenceInfo.oldmap[serializedObj[key].value];
                    if (type == "transform" || type == "transform2D") {
                    }
                    else {
                        //是组件直接找value对应transform的type
                        if (instance instanceof m4m.framework.transform2D) {
                            instance = instance.getComponent(type);
                        }
                        else if (instance instanceof m4m.framework.transform) {
                            instance = instance.gameObject.getComponent(type);
                        }
                    }
                    if (_isArray) {
                        instanceObj.push(instance);
                    }
                    else {
                        instanceObj[key] = instance;
                    }
                }
                else {
                    if (!instanceObj[key])
                        return console.warn("".concat(serializedObj[key].value.comp.type, " \u586B\u5145\u503C\u5931\u8D25"));
                    fillReference(serializedObj[key].value, instanceObj[key]);
                }
            }
        }
        io.dofillReference = dofillReference;
        //反序列化赋值
        /**
         * @private
         */
        function deSerializeObj(serializedObj, instanceObj, assetMgr, bundlename) {
            if (bundlename === void 0) { bundlename = null; }
            if (instanceObj == undefined) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (boolInNull(instanceObj["__gdmeta__"])) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            for (var key in instanceObj["__gdmeta__"]) {
                var t = instanceObj["__gdmeta__"][key];
                if (boolInNull(t)) {
                    continue;
                }
                if (t["custom"] == null)
                    continue;
                if (t["custom"]["SerializeField"] == null && t["custom"]["nodecomp"] == null && t["custom"]["2dcomp"] == null)
                    continue;
                var valueType = t["custom"]["valueType"];
                if (valueType == null) {
                    continue;
                }
                //基本类型和定义为SerializeType的类型才会关心
                switch (valueType.toLowerCase()) {
                    case "number":
                    case "string":
                    case "boolean":
                        if (serializedObj[key] == undefined || valueType != serializedObj[key].type) {
                            continue;
                            // throw new Error("反序列化失败，类型不匹配：" + valueType + " as " + serializedObj[key].type);
                        }
                        else {
                            instanceObj[key] = serializedObj[key].value;
                        }
                        break;
                    default:
                        deSerializeOtherTypeOrArray(serializedObj, instanceObj, key, assetMgr, bundlename);
                        break;
                }
            }
        }
        io.deSerializeObj = deSerializeObj;
        /**
         * @private
         */
        function deSerializeOtherTypeOrArray(serializedObj, instanceObj, key, assetMgr, bundlename) {
            if (bundlename === void 0) { bundlename = null; }
            if (boolInNull(serializedObj) || boolInNull(instanceObj)) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            if (serializedObj[key]) {
                var type = serializedObj[key].type;
                if (type == null) {
                    throw new Error("必须传入一个实例，用来赋值");
                }
                if (isArrayOrDic(type.toLowerCase())) {
                    var _isArray = serializedObj[key].value instanceof Array;
                    // let _isArray: boolean = isArray(type);
                    if (!instanceObj[key]) {
                        if (_isArray)
                            instanceObj[key] = [];
                        else
                            instanceObj[key] = {};
                    }
                    var arrayObj = null;
                    if (boolInNull(instanceObj["__gdmeta__"]) && boolInNull(instanceObj["__gdmeta__"][key]) && boolInNull(instanceObj["__gdmeta__"][key]["custom"])
                        && instanceObj["__gdmeta__"][key]["custom"]["valueType"] != serializedObj[key].type) {
                        throw new Error("反序列化失败，类型不匹配：" + instanceObj["__gdmeta__"][key]["custom"]["valueType"] + " as " + serializedObj[key].type);
                    }
                    arrayObj = serializedObj[key].value;
                    for (var newkey in arrayObj) {
                        if (!arrayObj[newkey])
                            continue;
                        var baseType = arrayObj[newkey].type;
                        switch (baseType.toLowerCase()) {
                            case "number":
                            case "string":
                            case "boolean":
                                if (baseType != serializedObj[key]["value"][newkey].type) {
                                    throw new Error("反序列化失败，类型不匹配：" + baseType + " as " + serializedObj[key]["value"][newkey].type);
                                }
                                if (_isArray) {
                                    instanceObj[key].push(serializedObj[key]["value"][newkey].value);
                                }
                                else {
                                    instanceObj[key][newkey] = serializedObj[key]["value"][newkey].value;
                                }
                                break;
                            default:
                                if (baseType == "nodeComponent" && key == "components" && m4m.reflect.getClassName(instanceObj) == "gameObject") {
                                    var _nodeComponent = [];
                                    deSerializeOtherType(serializedObj[key]["value"], _nodeComponent, newkey, assetMgr, bundlename);
                                    if (_nodeComponent[0].comp)
                                        instanceObj.addComponentDirect(_nodeComponent[0].comp);
                                }
                                else if (baseType == "transform" && key == "children" && m4m.reflect.getClassName(instanceObj) == "transform") {
                                    var _transforms = [];
                                    deSerializeOtherType(serializedObj[key]["value"], _transforms, newkey, assetMgr, bundlename);
                                    instanceObj.addChild(_transforms[0]);
                                }
                                else if (baseType == "C2DComponent" && key == "components" && m4m.reflect.getClassName(instanceObj) == "transform2D") {
                                    var _nodeComponent = [];
                                    deSerializeOtherType(serializedObj[key]["value"], _nodeComponent, newkey, assetMgr, bundlename);
                                    if (_nodeComponent[0].comp)
                                        instanceObj.addComponentDirect(_nodeComponent[0].comp);
                                }
                                else if (baseType == "transform2D" && key == "children" && m4m.reflect.getClassName(instanceObj) == "transform2D") {
                                    var _transforms2D = [];
                                    deSerializeOtherType(serializedObj[key]["value"], _transforms2D, newkey, assetMgr, bundlename);
                                    instanceObj.addChild(_transforms2D[0]);
                                }
                                else {
                                    deSerializeOtherType(serializedObj[key]["value"], instanceObj[key], newkey, assetMgr, bundlename);
                                }
                                break;
                        }
                    }
                }
                else {
                    deSerializeOtherType(serializedObj, instanceObj, key, assetMgr, bundlename);
                }
            }
        }
        io.deSerializeOtherTypeOrArray = deSerializeOtherTypeOrArray;
        /**
         * @private
         */
        function deSerializeOtherType(serializedObj, instanceObj, key, assetMgr, bundlename) {
            if (bundlename === void 0) { bundlename = null; }
            if (boolInNull(serializedObj) || boolInNull(instanceObj) || boolInNull(serializedObj[key])) {
                throw new Error("必须传入一个实例，用来赋值");
            }
            var _isArray = instanceObj instanceof Array;
            var type = serializedObj[key].type;
            var _parentType = typeof (instanceObj);
            if (isAsset(type)) {
                var assetName = serializedObj[key].value;
                var _asset = void 0;
                if (assetName.indexOf("SystemDefaultAsset-") >= 0) {
                    assetName = assetName.replace("SystemDefaultAsset-", "");
                    if (type == "mesh") {
                        assetName = assetName.replace(".mesh.bin", "").replace(".cmesh.bin", "");
                        _asset = assetMgr.getDefaultMesh(assetName);
                    }
                    else if (type == "texture") {
                        _asset = assetMgr.getDefaultTexture(assetName);
                    }
                }
                else {
                    _asset = assetMgr.getAssetByName(assetName, bundlename) || assetMgr.getAssetByName(assetName.replace(".mesh.bin", ".cmesh.bin"), bundlename);
                }
                // if (type == "mesh" && _parentType == "meshFilter")
                // {
                //     instanceObj.setMesh(_asset);
                // }
                // else
                if (_asset == null && type == "animationClip") {
                    _asset = assetMgr.getAssetByName(assetName); //资源可能不在同一个包
                    if (!_asset) {
                        _asset = new m4m.framework.animationClip(assetName);
                        _asset.use();
                    }
                }
                {
                    if (instanceObj instanceof Array) {
                        instanceObj.push(_asset);
                    }
                    else {
                        instanceObj[key] = _asset;
                    }
                }
            }
            else {
                if (serializedObj[key].parse == "reference") {
                }
                else {
                    var _newInstance = void 0;
                    var componentType = m4m.m4m_reflect_root["__gdmeta__"][type];
                    if (!componentType) {
                        console.warn(instanceObj);
                        console.warn(type);
                        return console.warn("\u65E0\u6CD5\u627E\u5230\u7EC4\u4EF6:".concat(m4m.m4m_reflect_root["__gdmeta__"][type]));
                    }
                    if (type == "gameObject" && key == "gameObject" && m4m.reflect.getClassName(instanceObj) == "transform") {
                        _newInstance = instanceObj.gameObject;
                    }
                    else if (type == "transform2D" && key == "rootNode" && m4m.reflect.getClassName(instanceObj) == "canvas") {
                        _newInstance = m4m.reflect.createInstance(componentType, null);
                        instanceObj.rootNode = _newInstance;
                        _newInstance.canvas = instanceObj;
                    }
                    else {
                        _newInstance = m4m.reflect.createInstance(componentType, null);
                        if (_isArray)
                            instanceObj.push(_newInstance);
                        else {
                            instanceObj[key] = _newInstance;
                            _newInstance = instanceObj[key];
                        }
                    }
                    deSerializeObj(serializedObj[key].value, _newInstance, assetMgr, bundlename);
                    var insid = serializedObj[key].insid;
                    if (!insid) {
                        // console.error(serializedObj[key]);
                    }
                    else
                        referenceInfo.oldmap[insid] = _newInstance;
                }
            }
        }
        io.deSerializeOtherType = deSerializeOtherType;
        /**
         * @private
         */
        function isArray(type) {
            if (type.indexOf("[]") > 0 || type.indexOf("array") >= 0) {
                return true;
            }
            return false;
        }
        io.isArray = isArray;
        /**
         * @private
         */
        function isArrayOrDic(type) {
            if (type.indexOf("[]") > 0 || type.indexOf("array") >= 0 || type.indexOf("dic") >= 0) {
                return true;
            }
            return false;
        }
        io.isArrayOrDic = isArrayOrDic;
        /**
         * @private
         */
        function isAsset(type) {
            //rawscene比较特殊、不可能存在结构中
            if (type == "mesh" || type == "texture" || type == "shader" ||
                type == "material" || type == "animationClip" || type == "atlas" || type == "keyFrameAniClip" ||
                type == "font" || type == "prefab" || type == "sprite" || type == "textasset" || type == "f14eff")
                return true;
            return false;
        }
        io.isAsset = isAsset;
        /**
         * @private
         */
        function isAssetInspector(type) {
            if (type == "prefab")
                return true;
        }
        io.isAssetInspector = isAssetInspector;
        /**
         * @private
         */
        var valueInfo = /** @class */ (function () {
            function valueInfo(value, type, _parse) {
                if (_parse === void 0) { _parse = "direct"; }
                if (isAsset(type)) {
                    _parse = "nameonly";
                    if (type == "material") {
                        if (value.lastIndexOf(".mat.json") < 0)
                            value += ".mat.json";
                    }
                }
                this.value = value;
                this.type = type;
                this.parse = _parse;
            }
            return valueInfo;
        }());
        /**
         * @private
         */
        var inspectorValueInfo = /** @class */ (function () {
            function inspectorValueInfo(_value, _type, _parse) {
                if (_parse === void 0) { _parse = "direct"; }
                this.value = _value;
                this.type = _type;
                if (isAssetInspector(_type)) {
                    _parse = "nameonly";
                }
                this.parse = _parse;
            }
            return inspectorValueInfo;
        }());
        /**
         * @private
         */
        var referenceInfo = /** @class */ (function () {
            function referenceInfo() {
            }
            referenceInfo.regDefaultType = function () {
                //referenceInfo.regType("vector3");
                referenceInfo.regType("vector4");
                referenceInfo.regType("color");
                referenceInfo.regType("border");
                referenceInfo.regType("quaternion");
                referenceInfo.regType("material");
                referenceInfo.regType("gameObject");
                referenceInfo.regType("transform2D");
                referenceInfo.regType("shader");
                referenceInfo.regType("atlas");
                referenceInfo.regType("font");
                referenceInfo.regType("sprite");
                referenceInfo.regType("texture");
                referenceInfo.regType("mesh");
                referenceInfo.regType("animationclip");
                referenceInfo.regType("keyFrameAniClip");
                referenceInfo.regType("constText");
                referenceInfo.regType("UniformData");
                referenceInfo.regType("f14eff");
            };
            referenceInfo.regType = function (type) {
                referenceInfo.regtypelist.push(type);
            };
            referenceInfo.isRegType = function (type) {
                return this.regtypelist.indexOf(type) >= 0;
            };
            referenceInfo.oldmap = {};
            referenceInfo.regtypelist = [];
            return referenceInfo;
        }());
        io.referenceInfo = referenceInfo;
        /**
         * @private
         */
        var enumMgr = /** @class */ (function () {
            function enumMgr() {
            }
            enumMgr.enumMap = {};
            return enumMgr;
        }());
        io.enumMgr = enumMgr;
        function boolInNull(obj) {
            if (obj == null || obj == undefined) {
                return true;
            }
            return false;
        }
    })(io = m4m.io || (m4m.io = {}));
})(m4m || (m4m = {}));
//0.04
//处理utf8 string 还是不能用encode decode，有些特殊情况没覆盖
var m4m;
//0.04
//处理utf8 string 还是不能用encode decode，有些特殊情况没覆盖
(function (m4m) {
    var io;
    (function (io) {
        /**
         * @private
         */
        var binReader = /** @class */ (function () {
            function binReader(buf, seek) {
                if (seek === void 0) { seek = 0; }
                this._seek = seek;
                if (!(buf instanceof ArrayBuffer))
                    throw new Error("[binReader]Error buf is not Arraybuffer instance");
                this._data = new DataView(buf, seek);
            }
            binReader.prototype.seek = function (seek) {
                this._seek = seek;
            };
            binReader.prototype.peek = function () {
                return this._seek;
            };
            binReader.prototype.length = function () {
                return this._data.byteLength;
            };
            binReader.prototype.canread = function () {
                //LogManager.Warn(this._buf.byteLength + "  &&&&&&&&&&&   " + this._seek + "    " + this._buf.buffer.byteLength);
                return this._data.byteLength - this._seek;
            };
            binReader.prototype.readStringAnsi = function () {
                var slen = this._data.getUint8(this._seek);
                this._seek++;
                var bs = "";
                for (var i = 0; i < slen; i++) {
                    bs += String.fromCharCode(this._data.getUint8(this._seek));
                    this._seek++;
                }
                return bs;
            };
            binReader.utf8ArrayToString = function (array) {
                var ret = [];
                for (var i = 0; i < array.length; i++) {
                    var cc = array[i];
                    if (cc == 0)
                        break;
                    var ct = 0;
                    if (cc > 0xE0) {
                        ct = (cc & 0x0F) << 12;
                        cc = array[++i];
                        ct |= (cc & 0x3F) << 6;
                        cc = array[++i];
                        ct |= cc & 0x3F;
                        ret.push(String.fromCharCode(ct));
                    }
                    else if (cc > 0xC0) {
                        ct = (cc & 0x1F) << 6;
                        cc = array[++i];
                        ct |= (cc & 0x3F) << 6;
                        ret.push(String.fromCharCode(ct));
                    }
                    else if (cc > 0x80) {
                        throw new Error("InvalidCharacterError");
                    }
                    else {
                        ret.push(String.fromCharCode(array[i]));
                    }
                }
                return ret.join('');
                //                var b = array[i];
                //    if (b > 0 && b < 16)
                //    {
                //        uri += '%0' + b.toString(16);
                //    }
                //    else if (b > 16)
                //    {
                //        uri += '%' + b.toString(16);
                //    }
                //}
                //return decodeURIComponent(uri);
            };
            binReader.prototype.readStringUtf8 = function () {
                var length = this._data.getInt8(this._seek);
                this._seek++;
                var arr = new Uint8Array(length);
                this.readUint8Array(arr);
                return binReader.utf8ArrayToString(arr);
            };
            binReader.prototype.readStringUtf8FixLength = function (length) {
                var arr = new Uint8Array(length);
                this.readUint8Array(arr);
                return binReader.utf8ArrayToString(arr);
            };
            binReader.prototype.readSingle = function () {
                var num = this._data.getFloat32(this._seek, true);
                this._seek += 4;
                return num;
            };
            binReader.prototype.readDouble = function () {
                var num = this._data.getFloat64(this._seek, true);
                this._seek += 8;
                return num;
            };
            binReader.prototype.readInt8 = function () {
                var num = this._data.getInt8(this._seek);
                this._seek += 1;
                return num;
            };
            binReader.prototype.readUInt8 = function () {
                //LogManager.Warn(this._data.byteLength + "  @@@@@@@@@@@@@@@@@  " + this._seek);
                var num = this._data.getUint8(this._seek);
                this._seek += 1;
                return num;
            };
            binReader.prototype.readInt16 = function () {
                //LogManager.Log(this._seek + "   " + this.length());
                var num = this._data.getInt16(this._seek, true);
                this._seek += 2;
                return num;
            };
            binReader.prototype.readUInt16 = function () {
                var num = this._data.getUint16(this._seek, true);
                this._seek += 2;
                //LogManager.Warn("readUInt16 " + this._seek);
                return num;
            };
            binReader.prototype.readInt32 = function () {
                var num = this._data.getInt32(this._seek, true);
                this._seek += 4;
                return num;
            };
            binReader.prototype.readUInt32 = function () {
                var num = this._data.getUint32(this._seek, true);
                this._seek += 4;
                return num;
            };
            binReader.prototype.readUint8Array = function (target, offset, length) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = target.length;
                for (var i = 0; i < length; i++) {
                    target[i] = this._data.getUint8(this._seek);
                    this._seek++;
                }
                return target;
            };
            binReader.prototype.readUint8ArrayByOffset = function (target, offset, length) {
                if (length === void 0) { length = 0; }
                if (length < 0)
                    length = target.length;
                for (var i = 0; i < length; i++) {
                    target[i] = this._data.getUint8(offset);
                    offset++;
                }
                return target;
            };
            Object.defineProperty(binReader.prototype, "position", {
                get: function () {
                    return this.peek();
                },
                set: function (value) {
                    this.seek(value);
                },
                enumerable: false,
                configurable: true
            });
            binReader.prototype.readBoolean = function () {
                return this.readUInt8() > 0;
            };
            binReader.prototype.readByte = function () {
                return this.readUInt8();
            };
            binReader.prototype.readBytes = function (target, offset, length) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                return this.readUint8Array(target, offset, length);
            };
            binReader.prototype.readBytesRef = function (length) {
                if (length === void 0) { length = 0; }
                var bytes = new Uint8Array(this._data.buffer.slice(this._seek, this._seek + length));
                this._seek += length;
                return bytes;
            };
            binReader.prototype.readUnsignedShort = function () {
                return this.readUInt16();
            };
            binReader.prototype.readUnsignedInt = function () {
                return this.readUInt32();
            };
            binReader.prototype.readFloat = function () {
                return this.readSingle();
            };
            binReader.prototype.readUTFBytes = function (length) {
                var arry = new Uint8Array(length);
                return binReader.utf8ArrayToString(this.readUint8Array(arry));
            };
            /// <summary>
            /// 有符号 Byte
            /// </summary>
            binReader.prototype.readSymbolByte = function () {
                return this.readInt8();
            };
            binReader.prototype.readShort = function () {
                return this.readInt16();
            };
            binReader.prototype.readInt = function () {
                return this.readInt32();
            };
            return binReader;
        }());
        io.binReader = binReader;
        var binWriter = /** @class */ (function () {
            function binWriter() {
                //if (buf == null)
                {
                    var buf = new ArrayBuffer(1024);
                    this._length = 0;
                }
                this._buf = new Uint8Array(buf);
                this._data = new DataView(this._buf.buffer);
                this._seek = 0;
            }
            binWriter.prototype.sureData = function (addlen) {
                var nextlen = this._buf.byteLength;
                while (nextlen < (this._length + addlen)) {
                    nextlen += 1024;
                }
                if (nextlen != this._buf.byteLength) {
                    var newbuf = new Uint8Array(nextlen);
                    for (var i = 0; i < this._length; i++) {
                        newbuf[i] = this._buf[i];
                    }
                    this._buf = newbuf;
                    this._data = new DataView(this._buf.buffer);
                }
                this._length += addlen;
            };
            binWriter.prototype.getLength = function () {
                return length;
            };
            binWriter.prototype.getBuffer = function () {
                return this._buf.buffer.slice(0, this._length);
            };
            binWriter.prototype.seek = function (seek) {
                this._seek = seek;
            };
            binWriter.prototype.peek = function () {
                return this._seek;
            };
            binWriter.prototype.writeInt8 = function (num) {
                this.sureData(1);
                this._data.setInt8(this._seek, num);
                this._seek++;
            };
            binWriter.prototype.writeUInt8 = function (num) {
                this.sureData(1);
                this._data.setUint8(this._seek, num);
                this._seek++;
            };
            binWriter.prototype.writeInt16 = function (num) {
                this.sureData(2);
                this._data.setInt16(this._seek, num, true);
                this._seek += 2;
            };
            binWriter.prototype.writeUInt16 = function (num) {
                this.sureData(2);
                this._data.setUint16(this._seek, num, true);
                this._seek += 2;
            };
            binWriter.prototype.writeInt32 = function (num) {
                this.sureData(4);
                this._data.setInt32(this._seek, num, true);
                this._seek += 4;
            };
            binWriter.prototype.writeUInt32 = function (num) {
                this.sureData(4);
                this._data.setUint32(this._seek, num, true);
                this._seek += 4;
            };
            binWriter.prototype.writeSingle = function (num) {
                this.sureData(4);
                this._data.setFloat32(this._seek, num, true);
                this._seek += 4;
            };
            binWriter.prototype.writeDouble = function (num) {
                this.sureData(8);
                this._data.setFloat64(this._seek, num, true);
                this._seek += 8;
            };
            binWriter.prototype.writeStringAnsi = function (str) {
                var slen = str.length;
                this.sureData(slen + 1);
                this._data.setUint8(this._seek, slen);
                this._seek++;
                for (var i = 0; i < slen; i++) {
                    this._data.setUint8(this._seek, str.charCodeAt(i));
                    this._seek++;
                }
            };
            binWriter.prototype.writeStringUtf8 = function (str) {
                var bstr = binWriter.stringToUtf8Array(str);
                this.writeUInt8(bstr.length);
                this.writeUint8Array(bstr);
            };
            binWriter.stringToUtf8Array = function (str) {
                var bstr = [];
                for (var i = 0; i < str.length; i++) {
                    var c = str.charAt(i);
                    var cc = c.charCodeAt(0);
                    if (cc > 0xFFFF) {
                        throw new Error("InvalidCharacterError");
                    }
                    if (cc > 0x80) {
                        if (cc < 0x07FF) {
                            var c1 = (cc >>> 6) | 0xC0;
                            var c2 = (cc & 0x3F) | 0x80;
                            bstr.push(c1, c2);
                        }
                        else {
                            var c1 = (cc >>> 12) | 0xE0;
                            var c2 = ((cc >>> 6) & 0x3F) | 0x80;
                            var c3 = (cc & 0x3F) | 0x80;
                            bstr.push(c1, c2, c3);
                        }
                    }
                    else {
                        bstr.push(cc);
                    }
                }
                return bstr;
            };
            binWriter.prototype.writeStringUtf8DataOnly = function (str) {
                var bstr = binWriter.stringToUtf8Array(str);
                this.writeUint8Array(bstr);
            };
            binWriter.prototype.writeUint8Array = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = array.length;
                this.sureData(length);
                for (var i = offset; i < offset + length; i++) {
                    this._data.setUint8(this._seek, array[i]);
                    this._seek++;
                }
            };
            Object.defineProperty(binWriter.prototype, "length", {
                get: function () {
                    return this._seek;
                },
                enumerable: false,
                configurable: true
            });
            binWriter.prototype.writeByte = function (num) {
                this.writeUInt8(num);
            };
            binWriter.prototype.writeBytes = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = 0; }
                this.writeUint8Array(array, offset, length);
            };
            binWriter.prototype.writeUnsignedShort = function (num) {
                this.writeUInt16(num);
            };
            binWriter.prototype.writeUnsignedInt = function (num) {
                this.writeUInt32(num);
            };
            binWriter.prototype.writeFloat = function (num) {
                this.writeSingle(num);
            };
            binWriter.prototype.writeUTFBytes = function (str) {
                var strArray = binWriter.stringToUtf8Array(str);
                this.writeUint8Array(strArray);
            };
            /// <summary>
            /// 写入有符号 Byte
            /// </summary>
            binWriter.prototype.writeSymbolByte = function (num) {
                this.writeInt8(num);
            };
            binWriter.prototype.writeShort = function (num) {
                this.writeInt16(num);
            };
            binWriter.prototype.writeInt = function (num) {
                this.writeInt32(num);
            };
            return binWriter;
        }());
        io.binWriter = binWriter;
    })(io = m4m.io || (m4m.io = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * 方程求解
         *
         * 求解方程 f(x) == 0 在[a, b]上的解
         *
         * 参考：高等数学 第七版上册 第三章第八节 方程的近似解
         * 当f(x)在区间 [a, b] 上连续，且f(a) * f(b) <= 0 时，f(x)在区间 [a, b] 上至少存在一个解使得 f(x) == 0
         *
         * 当f(x)在区间 [a, b] 上连续，且 (f(a) - y) * (f(b) - y) < 0 时，f(x)在区间 [a, b] 上至少存在一个解使得 f(x) == y
         *
         * @author feng / http://feng3d.com 05/06/2018
         */
        var EquationSolving = /** @class */ (function () {
            function EquationSolving() {
            }
            /**
             * 获取数字的(正负)符号
             * @param n 数字
             */
            EquationSolving.getSign = function (n) {
                return n > 0 ? "+" : "-";
            };
            /**
             * 比较 a 与 b 是否相等
             * @param a 值a
             * @param b 值b
             * @param precision 比较精度
             */
            EquationSolving.equalNumber = function (a, b, precision) {
                if (precision === void 0) { precision = 0.0000001; }
                return Math.abs(a - b) < precision;
            };
            /**
             * 获取近似导函数 f'(x)
             *
             * 导函数定义
             * f'(x) = (f(x + Δx) - f(x)) / Δx , Δx → 0
             *
             * 注：通过测试Δx不能太小，由于方程内存在x的n次方问题（比如0.000000000000001的10次方为0），过小会导致计算机计算进度不够反而导致求导不准确！
             *
             * 另外一种办法是还原一元多次函数，然后求出导函数。
             *
             * @param f 函数
             * @param delta Δx，进过测试该值太小或者过大都会导致求导准确率降低（个人猜测是计算机计算精度问题导致）
             */
            EquationSolving.getDerivative = function (f, delta) {
                if (delta === void 0) { delta = 0.000000001; }
                return function (x) {
                    var d = (f(x + delta) - f(x)) / delta;
                    return d;
                };
            };
            /**
             * 函数是否连续
             * @param f 函数
             */
            EquationSolving.isContinuous = function (f) {
                return true;
            };
            /**
             * 方程 f(x) == 0 在 [a, b] 区间内是否有解
             *
             * 当f(x)在区间 [a, b] 上连续，且f(a) * f(b) <= 0 时，f(x)在区间 [a, b] 上至少存在一个解使得 f(x) == 0
             *
             * @param f 函数f(x)
             * @param a 区间起点
             * @param b 区间终点
             * @param errorcallback  错误回调函数
             *
             * @returns 是否有解
             */
            EquationSolving.hasSolution = function (f, a, b, errorcallback) {
                if (!this.isContinuous(f)) {
                    errorcallback && errorcallback(new Error("\u51FD\u6570 ".concat(f, " \u5728 [").concat(a, " ,").concat(b, "] \u533A\u95F4\u5185\u4E0D\u8FDE\u7EED\uFF0C\u65E0\u6CD5\u4E3A\u5176\u6C42\u89E3\uFF01")));
                    return false;
                }
                var fa = f(a);
                var fb = f(b);
                if (fa * fb > 0) {
                    errorcallback && errorcallback(new Error("f(a) * f(b) \u503C\u4E3A ".concat(fa * fb, "\uFF0C\u4E0D\u6EE1\u8DB3 f(a) * f(b) <= 0\uFF0C\u65E0\u6CD5\u4E3A\u5176\u6C42\u89E3\uFF01")));
                    return false;
                }
                return true;
            };
            /**
             * 连线法 求解 f(x) == 0
             *
             * 连线法是我自己想的方法，自己取的名字，目前没有找到相应的资料（这方法大家都能够想得到。）
             *
             * 用曲线弧两端的连线来代替曲线弧与X轴交点作为边界来逐步缩小求解区间，最终获得解
             *
             * 通过 A，B两点连线与x轴交点来缩小求解区间最终获得解
             *
             * A，B两点直线方程 f(x) = f(a) + (f(b) - f(a)) / (b - a) * (x-a) ,求 f(x) == 0 解得 x = a - fa * (b - a)/ (fb - fa)
             *
             * @param f 函数f(x)
             * @param a 区间起点
             * @param b 区间终点
             * @param precision 求解精度
             * @param errorcallback  错误回调函数
             *
             * @returns 不存在解时返回 undefined ，存在时返回 解
             */
            EquationSolving.line = function (f, a, b, precision, errorcallback) {
                if (precision === void 0) { precision = 0.0000001; }
                if (!this.hasSolution(f, a, b, errorcallback))
                    return undefined;
                var fa = f(a);
                var fb = f(b);
                if (this.equalNumber(fa, 0, precision)) {
                    return a;
                }
                if (this.equalNumber(fb, 0, precision)) {
                    return b;
                }
                do {
                    // 
                    var x = a - fa * (b - a) / (fb - fa);
                    var fr = f(x);
                    if (fa * fr < 0) {
                        b = x;
                        fb = fr;
                    }
                    else {
                        a = x;
                        fa = fr;
                    }
                } while (!this.equalNumber(fr, 0, precision));
                return x;
            };
            return EquationSolving;
        }());
        framework.EquationSolving = EquationSolving;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * 柏林噪音
         *
         * 用于生产随机的噪音贴图
         *
         * @see http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf
         * @see https://mrl.nyu.edu/~perlin/noise/
         * @see https://gitee.com/feng3d_admin/noise
         */
        var Noise = /** @class */ (function () {
            /**
             * 构建柏林噪音
             *
             * @param seed 随机种子
             */
            function Noise(seed) {
                if (seed === void 0) { seed = 0; }
                this._seed = 0;
                this._p = [];
                this.seed = seed;
            }
            /**
             * 1D 经典噪音
             *
             * @param x X轴数值
             */
            Noise.prototype.perlin1 = function (x) {
                var perm = this._p;
                // Find unit grid cell containing point
                var X = Math.floor(x);
                // Get relative xyz coordinates of point within that cell
                x = x - X;
                // Wrap the integer cells at 255 (smaller integer period can be introduced here)
                X = X & 255;
                // Calculate a set of eight hashed gradient indices
                var gi00 = perm[X] % 2;
                var gi10 = perm[X + 1] % 2;
                // Calculate noise contributions from each of the eight corners
                var n00 = dot1(grad1[gi00], x);
                var n10 = dot1(grad1[gi10], x - 1);
                // Compute the fade curve value for each of x, y
                var u = fade(x);
                // Interpolate along x the contributions from each of the corners
                var nx0 = mix(n00, n10, u);
                return nx0;
            };
            /**
             * 2D 经典噪音
             *
             * @param x X轴数值
             * @param y Y轴数值
             */
            Noise.prototype.perlin2 = function (x, y) {
                var perm = this._p;
                // Find unit grid cell containing point
                var X = Math.floor(x);
                var Y = Math.floor(y);
                // Get relative xyz coordinates of point within that cell
                x = x - X;
                y = y - Y;
                // Wrap the integer cells at 255 (smaller integer period can be introduced here)
                X = X & 255;
                Y = Y & 255;
                // Calculate a set of eight hashed gradient indices
                var gi00 = perm[X + perm[Y]] % 4;
                var gi10 = perm[X + 1 + perm[Y]] % 4;
                var gi01 = perm[X + perm[Y + 1]] % 4;
                var gi11 = perm[X + 1 + perm[Y + 1]] % 4;
                // Calculate noise contributions from each of the eight corners
                var n00 = dot2(grad2[gi00], x, y);
                var n10 = dot2(grad2[gi10], x - 1, y);
                var n01 = dot2(grad2[gi01], x, y - 1);
                var n11 = dot2(grad2[gi11], x - 1, y - 1);
                // Compute the fade curve value for each of x, y
                var u = fade(x);
                var v = fade(y);
                // Interpolate along x the contributions from each of the corners
                var nx0 = mix(n00, n10, u);
                var nx1 = mix(n01, n11, u);
                // Interpolate the four results along y
                var nxy = mix(nx0, nx1, v);
                return nxy;
            };
            /**
             * 3D 经典噪音
             *
             * @param x X轴数值
             * @param y Y轴数值
             * @param z Z轴数值
             */
            Noise.prototype.perlin3 = function (x, y, z) {
                var perm = this._p;
                // Find unit grid cell containing point
                var X = Math.floor(x);
                var Y = Math.floor(y);
                var Z = Math.floor(z);
                // Get relative xyz coordinates of point within that cell
                x = x - X;
                y = y - Y;
                z = z - Z;
                // Wrap the integer cells at 255 (smaller integer period can be introduced here)
                X = X & 255;
                Y = Y & 255;
                Z = Z & 255;
                // Calculate a set of eight hashed gradient indices
                var gi000 = perm[X + perm[Y + perm[Z]]] % 12;
                var gi100 = perm[X + 1 + perm[Y + perm[Z]]] % 12;
                var gi010 = perm[X + perm[Y + 1 + perm[Z]]] % 12;
                var gi110 = perm[X + 1 + perm[Y + 1 + perm[Z]]] % 12;
                var gi001 = perm[X + perm[Y + perm[Z + 1]]] % 12;
                var gi101 = perm[X + 1 + perm[Y + perm[Z + 1]]] % 12;
                var gi011 = perm[X + perm[Y + 1 + perm[Z + 1]]] % 12;
                var gi111 = perm[X + 1 + perm[Y + 1 + perm[Z + 1]]] % 12;
                // Calculate noise contributions from each of the eight corners
                var n000 = dot(grad3[gi000], x, y, z);
                var n100 = dot(grad3[gi100], x - 1, y, z);
                var n010 = dot(grad3[gi010], x, y - 1, z);
                var n110 = dot(grad3[gi110], x - 1, y - 1, z);
                var n001 = dot(grad3[gi001], x, y, z - 1);
                var n101 = dot(grad3[gi101], x - 1, y, z - 1);
                var n011 = dot(grad3[gi011], x, y - 1, z - 1);
                var n111 = dot(grad3[gi111], x - 1, y - 1, z - 1);
                // Compute the fade curve value for each of x, y, z
                var u = fade(x);
                var v = fade(y);
                var w = fade(z);
                // Interpolate along x the contributions from each of the corners
                var nx00 = mix(n000, n100, u);
                var nx01 = mix(n001, n101, u);
                var nx10 = mix(n010, n110, u);
                var nx11 = mix(n011, n111, u);
                // Interpolate the four results along y
                var nxy0 = mix(nx00, nx10, v);
                var nxy1 = mix(nx01, nx11, v);
                // Interpolate the two last results along z
                var nxyz = mix(nxy0, nxy1, w);
                return nxyz;
            };
            /**
             * N阶经典噪音
             *
             * 如果是1D，2D，3D噪音，最好选用对于函数，perlinN中存在for循环因此效率比perlin3等性能差3到5（8）倍！
             *
             * 满足以下运算
             * perlinN(x) == perlin1(x)
             * perlinN(x,y) == perlin2(x,y)
             * perlinN(x,y,z) == perlin3(x,y,z)
             *
             * @param ps 每个轴的数值
             */
            Noise.prototype.perlinN = function () {
                var ps = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    ps[_i] = arguments[_i];
                }
                var perm = this._p;
                var n = ps.length;
                // 在格子内对应每个轴的位置
                var pp = [];
                // 所属格子对应每个轴的索引
                var PS = [];
                // 在格子内对应每个轴的混合权重
                var PF = [];
                for (var i = 0; i < n; i++) {
                    var p = ps[i];
                    // 找到所属单元格
                    var P = Math.floor(p);
                    // 获取所在单元格内的位置
                    p = p - P;
                    // 单元格以255为周期
                    P = P & 255;
                    //
                    pp[i] = p;
                    PS[i] = P;
                    // 分别计算每个轴的混合度
                    PF[i] = fade(p);
                }
                //
                var gradN = createGrad(n);
                // 边的数量
                var numEdge = gradN.length;
                // if (n > 1)
                // {
                //     console.assert(numEdge == Math.pow(2, n - 1) * n, `边的数量不对！`)
                // }
                //
                var bits = getBits(n);
                var dns = [];
                //
                for (var i = 0, len = bits.length; i < len; i++) {
                    var bit = bits[i];
                    var bitn = bit.length;
                    // 计算索引
                    var gi = 0;
                    while (bitn > 0) {
                        bitn--;
                        gi = perm[PS[bitn] + bit[bitn] + gi];
                        // if (isNaN(gi))
                        //     debugger;
                    }
                    // 获取 grad
                    var grad = gradN[gi % numEdge];
                    bitn = bit.length;
                    // 计算点乘 dot运算
                    var dn = 0;
                    while (bitn > 0) {
                        bitn--;
                        dn += grad[bitn] * (pp[bitn] - bit[bitn]);
                    }
                    dns[i] = dn;
                }
                // 进行插值
                for (var i = 0; i < n; i++) {
                    // 每次前后两个插值
                    for (var j = 0, len = dns.length; j < len; j += 2) {
                        dns[j / 2] = mix(dns[j], dns[j + 1], PF[i]);
                    }
                    // 每波插值后 长度减半
                    dns.length = dns.length >> 1;
                }
                // console.assert(dns.length == 1, `结果长度不对！`)
                return dns[0];
            };
            Object.defineProperty(Noise.prototype, "seed", {
                /**
                 * This isn't a very good seeding function, but it works ok. It supports 2^16
                 * different seed values. Write something better if you need more seeds.
                 */
                get: function () {
                    return this._seed;
                },
                set: function (v) {
                    this._seed = v;
                    var p = this._p;
                    if (v > 0 && v < 1) {
                        // Scale the seed out
                        v *= 65536;
                    }
                    v = Math.floor(v);
                    if (v < 256) {
                        v |= v << 8;
                    }
                    for (var i = 0; i < 256; i++) {
                        var v0;
                        if (i & 1) {
                            v0 = permutation[i] ^ (v & 255);
                        }
                        else {
                            v0 = permutation[i] ^ ((v >> 8) & 255);
                        }
                        p[i] = p[i + 256] = v0;
                    }
                },
                enumerable: false,
                configurable: true
            });
            return Noise;
        }());
        framework.Noise = Noise;
        /**
         *
         * @param n
         *
         * len = 2^(n-1) * n
         */
        function createGrad(n) {
            if (createGradCache[n])
                return createGradCache[n];
            var gradBase = createGradBase(n - 1);
            var grad = [];
            if (n > 1) {
                for (var i = n - 1; i >= 0; i--) {
                    for (var j = 0; j < gradBase.length; j++) {
                        var item = gradBase[j].concat();
                        item.splice(i, 0, 0);
                        grad.push(item);
                    }
                }
            }
            else {
                grad = gradBase;
            }
            createGradCache[n] = grad;
            return grad;
        }
        framework.createGrad = createGrad;
        var createGradCache = {};
        function createGradBase(n) {
            if (n < 2)
                return [
                    [1], [-1],
                ];
            var grad = createGradBase(n - 1);
            for (var i = 0, len = grad.length; i < len; i++) {
                var item = grad[i];
                grad[i] = item.concat(1);
                grad[i + len] = item.concat(-1);
            }
            return grad;
        }
        function getBits(n) {
            if (getBitsChace[n])
                return getBitsChace[n];
            if (n < 2)
                return [
                    [0], [1],
                ];
            var grad = getBits(n - 1);
            for (var i = 0, len = grad.length; i < len; i++) {
                var item = grad[i];
                grad[i] = item.concat(0);
                grad[i + len] = item.concat(1);
            }
            getBitsChace[n] = grad;
            return grad;
        }
        framework.getBits = getBits;
        var getBitsChace = {};
        var grad1 = [
            [1], [-1],
        ];
        var grad2 = [
            [1, 0], [-1, 0],
            [0, 1], [0, -1],
        ];
        var grad3 = [
            [1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0],
            [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1],
            [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]
        ];
        var permutation = [
            151, 160, 137, 91, 90, 15,
            131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,
            190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33,
            88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166,
            77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244,
            102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196,
            135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123,
            5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42,
            223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9,
            129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228,
            251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107,
            49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,
            138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180
        ];
        function dot(g, x, y, z) {
            return g[0] * x + g[1] * y + g[2] * z;
        }
        function dot2(g, x, y) {
            return g[0] * x + g[1] * y;
        }
        function dot1(g, x) {
            return g[0] * x;
        }
        function mix(a, b, t) {
            return (1 - t) * a + t * b;
        }
        function fade(t) {
            return t * t * t * (t * (t * 6 - 15) + 10);
        }
        framework.noise = new Noise();
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var math;
    (function (math) {
        /**
         * 用于表示欧拉角的旋转顺序
         *
         * 如果顺序为XYZ，则依次按 ZYZ 轴旋转。为什么循序与定义相反？因为three.js中都这么定义，他们为什么这么定义就不清楚了。
         */
        var RotationOrder;
        (function (RotationOrder) {
            /**
             * 依次按 ZYX 轴旋转。
             *
             * three.js默认旋转顺序。
             */
            RotationOrder[RotationOrder["XYZ"] = 0] = "XYZ";
            /**
             * 依次按 YXZ 轴旋转。
             */
            RotationOrder[RotationOrder["ZXY"] = 1] = "ZXY";
            /**
             * 依次按 XYZ 轴旋转。
             *
             * playcanvas默认旋转顺序。
             */
            RotationOrder[RotationOrder["ZYX"] = 2] = "ZYX";
            /**
             * 依次按 ZXY 轴旋转。
             *
             * unity默认旋转顺序。
             */
            RotationOrder[RotationOrder["YXZ"] = 3] = "YXZ";
            /**
             * 依次按 XZY 轴旋转。
             */
            RotationOrder[RotationOrder["YZX"] = 4] = "YZX";
            /**
             * 依次按 YZX 轴旋转。
             */
            RotationOrder[RotationOrder["XZY"] = 5] = "XZY";
        })(RotationOrder = math.RotationOrder || (math.RotationOrder = {}));
        /**
        * 引擎中使用的旋转顺序。
        *
        * unity YXZ
        * playcanvas ZYX
        * three.js XYZ
        */
        math.defaultRotationOrder = RotationOrder.YXZ;
    })(math = m4m.math || (m4m.math = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var math;
    (function (math) {
        function colorSet(out, r, g, b, a) {
            out.r = r;
            out.g = g;
            out.b = b;
            out.a = a;
        }
        math.colorSet = colorSet;
        function colorSet_White(out) {
            out.r = 1;
            out.g = 1;
            out.b = 1;
            out.a = 1;
        }
        math.colorSet_White = colorSet_White;
        function colorSet_Black(out) {
            out.r = 0;
            out.g = 0;
            out.b = 0;
            out.a = 1;
        }
        math.colorSet_Black = colorSet_Black;
        function colorSet_Gray(out) {
            out.r = 0.5;
            out.g = 0.5;
            out.b = 0.5;
            out.a = 1;
        }
        math.colorSet_Gray = colorSet_Gray;
        function colorMultiply(srca, srcb, out) {
            out.r = srca.r * srcb.r;
            out.g = srca.g * srcb.g;
            out.b = srca.b * srcb.b;
            out.a = srca.a * srcb.a;
        }
        math.colorMultiply = colorMultiply;
        function scaleToRef(src, scale, out) {
            out.r = src.r * scale;
            out.g = src.g * scale;
            out.b = src.b * scale;
            out.a = src.a * scale;
        }
        math.scaleToRef = scaleToRef;
        function colorClone(src, out) {
            out.a = src.a;
            out.r = src.r;
            out.g = src.g;
            out.b = src.b;
            //out.rawData.set(src.rawData);
            // out.rawData[0]=src.rawData[0];
            // out.rawData[1]=src.rawData[1];
            // out.rawData[2]=src.rawData[2];
            // out.rawData[3]=src.rawData[3];
        }
        math.colorClone = colorClone;
        function colorLerp(srca, srcb, t, out) {
            out.a = t * (srcb.a - srca.a) + srca.a;
            out.r = t * (srcb.r - srca.r) + srca.r;
            out.g = t * (srcb.g - srca.g) + srca.g;
            out.b = t * (srcb.b - srca.b) + srca.b;
            // out.a = Math.floor(out.a);
            // out.r = Math.floor(out.r);
            // out.g = Math.floor(out.g);
            // out.b = Math.floor(out.b);
        }
        math.colorLerp = colorLerp;
        function colorEqual(c, c1, threshold) {
            if (threshold === void 0) { threshold = 0.00001; }
            if (c == c1)
                return true;
            if (Math.abs(c.r - c1.r) > threshold)
                return false;
            if (Math.abs(c.g - c1.g) > threshold)
                return false;
            if (Math.abs(c.b - c1.b) > threshold)
                return false;
            if (Math.abs(c.a - c1.a) > threshold)
                return false;
            return true;
        }
        math.colorEqual = colorEqual;
        /**
         * 颜色转成 CSS 格式
         * @param src
         * @param hasAlpha 是否包含Alpha
         * @returns like #ffffffff
         */
        function colorToCSS(src, hasAlpha) {
            if (hasAlpha === void 0) { hasAlpha = true; }
            var r = Math.round(src.r * 255).toString(16);
            var g = Math.round(src.r * 255).toString(16);
            var b = Math.round(src.r * 255).toString(16);
            if (r.length == 1)
                r += "0";
            if (g.length == 1)
                g += "0";
            if (b.length == 1)
                b += "0";
            if (hasAlpha) {
                var a = Math.round(src.r * 255).toString(16);
                if (a.length == 1)
                    a += "0";
                return "#".concat(r).concat(g).concat(b).concat(a);
            }
            else {
                return "#".concat(r).concat(g).concat(b);
            }
        }
        math.colorToCSS = colorToCSS;
    })(math = m4m.math || (m4m.math = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var math;
    (function (math) {
        function calPlaneLineIntersectPoint(planeVector, planePoint, lineVector, linePoint, out) {
            var vp1 = planeVector.x;
            var vp2 = planeVector.y;
            var vp3 = planeVector.z;
            var n1 = planePoint.x;
            var n2 = planePoint.y;
            var n3 = planePoint.z;
            var v1 = lineVector.x;
            var v2 = lineVector.y;
            var v3 = lineVector.z;
            var m1 = linePoint.x;
            var m2 = linePoint.y;
            var m3 = linePoint.z;
            var vpt = v1 * vp1 + v2 * vp2 + v3 * vp3;
            if (vpt === 0) {
                out = null;
            }
            else {
                var t = ((n1 - m1) * vp1 + (n2 - m2) * vp2 + (n3 - m3) * vp3) / vpt;
                out.x = m1 + v1 * t;
                out.y = m2 + v2 * t;
                out.z = m3 + v3 * t;
            }
        }
        math.calPlaneLineIntersectPoint = calPlaneLineIntersectPoint;
        //判断点是否在矩形p1p2p3p4中
        function isContain(p1, p2, p3, p4, mp) {
            if (Multiply(mp, p1, p2) * Multiply(mp, p4, p3) <= 0 && Multiply(mp, p4, p1) * Multiply(mp, p3, p2) <= 0)
                return true;
            return false;
        }
        math.isContain = isContain;
        // 计算叉乘 |P0P1| × |P0P2| 
        function Multiply(p1, p2, p0) {
            return ((p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y));
        }
        math.Multiply = Multiply;
        //待测试
        function getPointByTwoline(index, p2, dir2, outpoint) {
            var matrix = new m4m.math.matrix();
            var dir1;
            if (index == 1) {
                dir1 = new m4m.math.vector3(1, 0, 0);
                matrix.rawData[0] = 1;
            }
            else if (index == 2) {
                dir1 = new m4m.math.vector3(0, 1, 0);
                matrix.rawData[0] = 0;
                matrix.rawData[1] = 1;
            }
            else if (index == 3) {
                dir1 = new m4m.math.vector3(0, 0, 1);
                matrix.rawData[0] = 0;
                matrix.rawData[2] = 1;
            }
            var dirBt = new m4m.math.vector3();
            m4m.math.vec3Cross(dir1, dir2, dirBt);
            matrix.rawData[4] = dirBt.x;
            matrix.rawData[5] = dirBt.y;
            matrix.rawData[6] = dirBt.z;
            matrix.rawData[8] = -dir2.x;
            matrix.rawData[9] = -dir2.y;
            matrix.rawData[10] = -dir2.z;
            m4m.math.matrixInverse(matrix, matrix);
            var outnode = new m4m.math.vector3();
            m4m.math.matrixTransformVector3(p2, matrix, outnode);
            if (index == 1) {
                outpoint = new m4m.math.vector3(outnode.x, 0, 0);
            }
            else if (index == 2) {
                outpoint = new m4m.math.vector3(0, outnode.y, 0);
            }
            else if (index == 3) {
                outpoint = new m4m.math.vector3(0, 0, outnode.z);
            }
        }
    })(math = m4m.math || (m4m.math = {}));
})(m4m || (m4m = {}));
/// <reference path="../../render/struct.ts" />
var m4m;
/// <reference path="../../render/struct.ts" />
(function (m4m) {
    var math;
    (function (math) {
        //临时写在这里
        function floatClamp(v, min, max) {
            if (min === void 0) { min = 0; }
            if (max === void 0) { max = 1; }
            if (v < min)
                return min;
            else if (v > max)
                return max;
            else
                return v;
        }
        math.floatClamp = floatClamp;
        function sign(value) {
            value = +value; // convert to a number
            if (value === 0 || isNaN(value))
                return value;
            return value > 0 ? 1 : -1;
        }
        math.sign = sign;
        function getKeyCodeByAscii(ev) {
            if (ev.shiftKey) {
                return ev.keyCode - 32;
            }
            else {
                return ev.keyCode;
            }
        }
        math.getKeyCodeByAscii = getKeyCodeByAscii;
        math.DEG2RAD = Math.PI / 180;
        math.RAD2DEG = 180 / Math.PI;
        /**
         * 角度转换为弧度
         *
         * @param degrees 角度
         */
        function degToRad(degrees) {
            return degrees * math.DEG2RAD;
        }
        math.degToRad = degToRad;
        /**
         * 弧度转换为角度
         *
         * @param radians 弧度
         */
        function radToDeg(radians) {
            return radians * math.RAD2DEG;
        }
        math.radToDeg = radToDeg;
        /**
         * 使 x 值从区间 <a1, a2> 线性映射到区间 <b1, b2>
         *
         * @param x 第一个区间中值
         * @param a1 第一个区间起始值
         * @param a2 第一个区间终止值
         * @param b1 第二个区间起始值
         * @param b2 第二个区间起始值
         */
        function mapLinear(x, a1, a2, b1, b2) {
            return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
        }
        math.mapLinear = mapLinear;
        function numberLerp(fromV, toV, v) {
            return fromV * (1 - v) + toV * v;
        }
        math.numberLerp = numberLerp;
        function x_AXIS() {
            return commonStatic.x_axis;
        }
        math.x_AXIS = x_AXIS;
        function y_AXIS() {
            return commonStatic.y_axis;
        }
        math.y_AXIS = y_AXIS;
        function z_AXIS() {
            return commonStatic.z_axis;
        }
        math.z_AXIS = z_AXIS;
        var commonStatic = /** @class */ (function () {
            function commonStatic() {
            }
            commonStatic.x_axis = new m4m.math.vector3(1, 0, 0);
            commonStatic.y_axis = new m4m.math.vector3(0, 1, 0);
            commonStatic.z_axis = new m4m.math.vector3(0, 0, 1);
            return commonStatic;
        }());
        math.commonStatic = commonStatic;
    })(math = m4m.math || (m4m.math = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var math;
    (function (math) {
        function quatIdentity(src) {
            src.x = 0;
            src.y = 0;
            src.z = 0;
            src.w = 1;
        }
        math.quatIdentity = quatIdentity;
        function quatNormalize(src, out) {
            var mag = 1 / Math.sqrt(src.x * src.x + src.y * src.y + src.z * src.z + src.w * src.w);
            out.x *= mag;
            out.y *= mag;
            out.z *= mag;
            out.w *= mag;
        }
        math.quatNormalize = quatNormalize;
        function quatTransformVector(src, vector, out) {
            var x1, y1, z1, w1;
            var x2 = vector.x, y2 = vector.y, z2 = vector.z;
            w1 = -src.x * x2 - src.y * y2 - src.z * z2;
            x1 = src.w * x2 + src.y * z2 - src.z * y2;
            y1 = src.w * y2 - src.x * z2 + src.z * x2;
            z1 = src.w * z2 + src.x * y2 - src.y * x2;
            out.x = -w1 * src.x + x1 * src.w - y1 * src.z + z1 * src.y;
            out.y = -w1 * src.y + x1 * src.z + y1 * src.w - z1 * src.x;
            out.z = -w1 * src.z - x1 * src.y + y1 * src.x + z1 * src.w;
        }
        math.quatTransformVector = quatTransformVector;
        function quatTransformVectorDataAndQuat(src, srcseek, vector, out) {
            var x1, y1, z1, w1;
            var x2 = vector.x, y2 = vector.y, z2 = vector.z;
            var srcx = src[srcseek];
            var srcy = src[srcseek + 1];
            var srcz = src[srcseek + 2];
            var srcw = src[srcseek + 3];
            w1 = -srcx * x2 - srcy * y2 - srcz * z2;
            x1 = srcw * x2 + srcy * z2 - srcz * y2;
            y1 = srcw * y2 - srcx * z2 + srcz * x2;
            z1 = srcw * z2 + srcx * y2 - srcy * x2;
            out.x = -w1 * srcx + x1 * srcw - y1 * srcz + z1 * srcy;
            out.y = -w1 * srcy + x1 * srcz + y1 * srcw - z1 * srcx;
            out.z = -w1 * srcz - x1 * srcy + y1 * srcx + z1 * srcw;
        }
        math.quatTransformVectorDataAndQuat = quatTransformVectorDataAndQuat;
        function quatMagnitude(src) {
            return Math.sqrt(src.w * src.w + src.x * src.x + src.y * src.y + src.z * src.z);
        }
        math.quatMagnitude = quatMagnitude;
        function quatClone(src, out) {
            out.x = src.x;
            out.y = src.y;
            out.z = src.z;
            out.w = src.w;
            //out.rawData.set(src.rawData);
            // out.rawData[0]=src.rawData[0];
            // out.rawData[1]=src.rawData[1];
            // out.rawData[2]=src.rawData[2];
            // out.rawData[3]=src.rawData[3];
        }
        math.quatClone = quatClone;
        function quatEqual(quat, quat2, threshold) {
            if (threshold === void 0) { threshold = 0.000001; }
            if (Math.abs(quat.x - quat2.x) > threshold)
                return false;
            if (Math.abs(quat.y - quat2.y) > threshold)
                return false;
            if (Math.abs(quat.z - quat2.z) > threshold)
                return false;
            if (Math.abs(quat.w - quat2.w) > threshold)
                return false;
            return true;
        }
        math.quatEqual = quatEqual;
        function quatToMatrix(src, out) {
            var xy2 = 2.0 * src.x * src.y, xz2 = 2.0 * src.x * src.z, xw2 = 2.0 * src.x * src.w;
            var yz2 = 2.0 * src.y * src.z, yw2 = 2.0 * src.y * src.w, zw2 = 2.0 * src.z * src.w;
            var xx = src.x * src.x, yy = src.y * src.y, zz = src.z * src.z, ww = src.w * src.w;
            out.rawData[0] = xx - yy - zz + ww;
            out.rawData[4] = xy2 - zw2;
            out.rawData[8] = xz2 + yw2;
            out.rawData[12] = 0;
            out.rawData[1] = xy2 + zw2;
            out.rawData[5] = -xx + yy - zz + ww;
            out.rawData[9] = yz2 - xw2;
            out.rawData[13] = 0;
            out.rawData[2] = xz2 - yw2;
            out.rawData[6] = yz2 + xw2;
            out.rawData[10] = -xx - yy + zz + ww;
            out.rawData[14] = 0;
            out.rawData[3] = 0.0;
            out.rawData[7] = 0.0;
            out.rawData[11] = 0;
            out.rawData[15] = 1;
        }
        math.quatToMatrix = quatToMatrix;
        function quatInverse(src, out) {
            var norm = src.w * src.w + src.x * src.x + src.y * src.y + src.z * src.z;
            if (norm > 0.0) {
                var invNorm = 1.0 / norm;
                out.w = src.w * invNorm;
                out.x = -src.x * invNorm;
                out.y = -src.y * invNorm;
                out.z = -src.z * invNorm;
            }
        }
        math.quatInverse = quatInverse;
        function quatFromYawPitchRoll(yaw, pitch, roll, result) {
            // Produces a quaternion from Euler angles in the z-y-x orientation (Tait-Bryan angles)
            var halfRoll = roll * 0.5;
            var halfPitch = pitch * 0.5;
            var halfYaw = yaw * 0.5;
            var sinRoll = Math.sin(halfRoll);
            var cosRoll = Math.cos(halfRoll);
            var sinPitch = Math.sin(halfPitch);
            var cosPitch = Math.cos(halfPitch);
            var sinYaw = Math.sin(halfYaw);
            var cosYaw = Math.cos(halfYaw);
            result.x = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);
            result.y = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);
            result.z = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);
            result.w = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);
        }
        math.quatFromYawPitchRoll = quatFromYawPitchRoll;
        function quatMultiply(srca, srcb, out) {
            var w1 = srca.w, x1 = srca.x, y1 = srca.y, z1 = srca.z;
            var w2 = srcb.w, x2 = srcb.x, y2 = srcb.y, z2 = srcb.z;
            out.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
            out.x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2;
            out.y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2;
            out.z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2;
            math.quatNormalize(out, out);
            // out.w = x1 * x2 - y1 * y2 - z1 * z2 + w1 * w2;
            // out.x = x1 * w2 + y1 * z2 - z1 * y2 + w1 * x2;
            // out.y = -x1 * z2 + y1 * w2 + z1 * x2 + w1 * y2;
            // out.z = x1 * y2 - y1 * x2 + z1 * w2 + w1 * z2;
        }
        math.quatMultiply = quatMultiply;
        function quatMultiplyDataAndQuat(srca, srcaseek, srcb, out) {
            var w1 = srca[srcaseek + 3], x1 = srca[srcaseek + 0], y1 = srca[srcaseek + 1], z1 = srca[srcaseek + 2];
            var w2 = srcb.w, x2 = srcb.x, y2 = srcb.y, z2 = srcb.z;
            out.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
            out.x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2;
            out.y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2;
            out.z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2;
            math.quatNormalize(out, out);
            // out.w = x1 * x2 - y1 * y2 - z1 * z2 + w1 * w2;
            // out.x = x1 * w2 + y1 * z2 - z1 * y2 + w1 * x2;
            // out.y = -x1 * z2 + y1 * w2 + z1 * x2 + w1 * y2;
            // out.z = x1 * y2 - y1 * x2 + z1 * w2 + w1 * z2;
        }
        math.quatMultiplyDataAndQuat = quatMultiplyDataAndQuat;
        function quatMultiplyVector(vector, scr, out) {
            var x2 = vector.x;
            var y2 = vector.y;
            var z2 = vector.z;
            out.w = -scr.x * x2 - scr.y * y2 - scr.z * z2;
            out.x = scr.w * x2 + scr.y * z2 - scr.z * y2;
            out.y = scr.w * y2 - scr.x * z2 + scr.z * x2;
            out.z = scr.w * z2 + scr.x * y2 - scr.y * x2;
        }
        math.quatMultiplyVector = quatMultiplyVector;
        function quatLerp(srca, srcb, out, t) {
            var w1 = srca.w, x1 = srca.x, y1 = srca.y, z1 = srca.z;
            var w2 = srcb.w, x2 = srcb.x, y2 = srcb.y, z2 = srcb.z;
            if (w1 * w2 + x1 * x2 + y1 * y2 + z1 * z2 < 0) {
                w2 = -w2;
                x2 = -x2;
                y2 = -y2;
                z2 = -z2;
            }
            out.w = w1 + t * (w2 - w1);
            out.x = x1 + t * (x2 - x1);
            out.y = y1 + t * (y2 - y1);
            out.z = z1 + t * (z2 - z1);
            var len = 1.0 / Math.sqrt(out.w * out.w + out.x * out.x + out.y * out.y + out.z * out.z);
            out.w *= len;
            out.x *= len;
            out.y *= len;
            out.z *= len;
        }
        math.quatLerp = quatLerp;
        function quatFromAxisAngle(axis, angle, out) {
            angle *= Math.PI / 180.0;
            var halfAngle = angle * 0.5;
            var sin_a = Math.sin(halfAngle);
            math.vec3Normalize(axis, axis);
            out.w = Math.cos(halfAngle);
            out.x = axis.x * sin_a;
            out.y = axis.y * sin_a;
            out.z = axis.z * sin_a;
            // math.quatNormalize(out, out);
        }
        math.quatFromAxisAngle = quatFromAxisAngle;
        function quatToAxisAngle(src, axis) {
            var sqrLength = src.x * src.x + src.y * src.y + src.z * src.z;
            var angle = 0;
            if (sqrLength > 0.0) {
                angle = 2.0 * Math.acos(src.w);
                sqrLength = 1.0 / Math.sqrt(sqrLength);
                axis.x = src.x * sqrLength;
                axis.y = src.y * sqrLength;
                axis.z = src.z * sqrLength;
            }
            else {
                angle = 0;
                axis.x = 1.0;
                axis.y = 0;
                axis.z = 0;
            }
            angle /= Math.PI / 180.0;
            return angle;
        }
        math.quatToAxisAngle = quatToAxisAngle;
        function quatFromEulerAngles(ax, ay, az, out) {
            ax *= Math.PI / 180;
            ay *= Math.PI / 180;
            az *= Math.PI / 180;
            var halfX = ax * 0.5, halfY = ay * 0.5, halfZ = az * 0.5;
            var cosX = Math.cos(halfX), sinX = Math.sin(halfX);
            var cosY = Math.cos(halfY), sinY = Math.sin(halfY);
            var cosZ = Math.cos(halfZ), sinZ = Math.sin(halfZ);
            out.w = cosX * cosY * cosZ + sinX * sinY * sinZ;
            out.x = sinX * cosY * cosZ + cosX * sinY * sinZ;
            out.y = cosX * sinY * cosZ - sinX * cosY * sinZ;
            out.z = cosX * cosY * sinZ - sinX * sinY * cosZ;
            math.quatNormalize(out, out);
        }
        math.quatFromEulerAngles = quatFromEulerAngles;
        function quatToEulerAngles(src, result) {
            var qz = src.z;
            var qx = src.x;
            var qy = src.y;
            var qw = src.w;
            var sqw = qw * qw;
            var sqz = qz * qz;
            var sqx = qx * qx;
            var sqy = qy * qy;
            var zAxisY = qy * qz - qx * qw;
            var limit = .4999999;
            if (zAxisY < -limit) {
                result.y = 2 * Math.atan2(qy, qw);
                result.x = Math.PI / 2;
                result.z = 0;
            }
            else if (zAxisY > limit) {
                result.y = 2 * Math.atan2(qy, qw);
                result.x = -Math.PI / 2;
                result.z = 0;
            }
            else {
                result.z = Math.atan2(2.0 * (qx * qy + qz * qw), (-sqz - sqx + sqy + sqw));
                result.x = Math.asin(-2.0 * (qz * qy - qx * qw));
                result.y = Math.atan2(2.0 * (qz * qx + qy * qw), (sqz - sqx - sqy + sqw));
            }
            result.x /= Math.PI / 180;
            result.y /= Math.PI / 180;
            result.z /= Math.PI / 180;
        }
        math.quatToEulerAngles = quatToEulerAngles;
        function quatReset(src) {
            src.x = 0;
            src.y = 0;
            src.z = 0;
            src.w = 1;
        }
        math.quatReset = quatReset;
        //获取一个注视目标的四元数
        function quatLookat(pos, targetpos, out) {
            var dir = math.pool.new_vector3();
            math.vec3Subtract(targetpos, pos, dir);
            math.vec3Normalize(dir, dir);
            //dir在xz面上的单位投影
            var dirxz = math.pool.new_vector3(dir.x, 0, dir.z);
            math.vec3Normalize(dirxz, dirxz);
            var yaw = Math.acos(dirxz.z); // / Math.PI * 180;
            if (dirxz.x < 0) {
                yaw = -yaw;
            }
            //dir在xz面上的投影
            var dirxz1 = math.pool.new_vector3(dir.x, 0, dir.z);
            var v3length = math.vec3Length(dirxz1);
            if (v3length > 0.9999999999)
                v3length = 1;
            if (v3length < -0.9999999999)
                v3length = -1;
            var pitch = Math.acos(v3length); // / Math.PI * 180;
            if (dir.y > 0) {
                pitch = -pitch;
            }
            quatFromYawPitchRoll(yaw, pitch, 0, out);
            math.quatNormalize(out, out);
            math.pool.delete_vector3(dir);
            math.pool.delete_vector3(dirxz);
            math.pool.delete_vector3(dirxz1);
        }
        math.quatLookat = quatLookat;
        function quat2Lookat(pos, targetpos, out, updir) {
            if (updir === void 0) { updir = m4m.math.pool.vector3_up; }
            var dir = m4m.math.pool.new_vector3();
            math.vec3Subtract(targetpos, pos, dir);
            math.vec3Normalize(dir, dir);
            var dot = m4m.math.vec3Dot(m4m.math.pool.vector3_forward, dir);
            dot = m4m.math.floatClamp(dot, -1, 1);
            var rotangle = Math.acos(dot) * 180 / Math.PI;
            if (rotangle < 0.01) {
                out.x = 0;
                out.y = 0;
                out.z = 0;
                out.w = 1;
                return;
            }
            if (rotangle > 179.9) {
                m4m.math.quatFromAxisAngle(updir, 180, out);
                return;
            }
            var rotAxis = m4m.math.pool.new_vector3();
            m4m.math.vec3Cross(m4m.math.pool.vector3_forward, dir, rotAxis);
            m4m.math.vec3Normalize(rotAxis, rotAxis);
            m4m.math.quatFromAxisAngle(rotAxis, rotangle, out);
        }
        math.quat2Lookat = quat2Lookat;
        function quat2LookRotation(pos, targetpos, upwards, out) {
            var dir = m4m.math.pool.new_vector3();
            math.vec3Subtract(targetpos, pos, dir);
            math.quatLookRotation(dir, upwards, out);
        }
        math.quat2LookRotation = quat2LookRotation;
        function quatLookRotation(dir, upwards, out) {
            math.vec3Normalize(dir, dir);
            var ab = math.vec3Dot(dir, m4m.math.pool.vector3_forward);
            var an_dz = Math.acos(ab);
            var cdz = m4m.math.pool.new_vector3();
            math.vec3Cross(dir, m4m.math.pool.vector3_forward, cdz);
            math.vec3Normalize(cdz, cdz);
            if (math.vec3Dot(cdz, m4m.math.pool.vector3_forward) < 0) {
                an_dz = 2 * Math.PI - an_dz;
            }
            an_dz = 180 / Math.PI * an_dz;
            quatFromAxisAngle(cdz, -an_dz, out);
            var y = m4m.math.pool.new_vector3();
            quatTransformVector(out, m4m.math.pool.vector3_up, y);
            var cyw = cdz;
            math.vec3Cross(dir, upwards, cyw);
            math.vec3Normalize(y, y);
            math.vec3Normalize(cyw, cyw);
            var cos2Y = math.vec3Dot(cyw, y);
            // if(cos2Y>1){
            //     cos2Y=1;
            // }
            // if(cos2Y<-1){
            //     cos2Y=-1;
            // }
            // if(cos2Y>-0.001&&cos2Y<0.001){
            //     cos2Y=0;
            // }
            var sin2Y = Math.sqrt(1 - cos2Y * cos2Y);
            console.log(math.vec3Dot(y, upwards));
            if (math.vec3Dot(y, upwards) <= 0) {
                sin2Y = -sin2Y;
            }
            var siny = Math.sqrt((1 - sin2Y) / 2);
            var cosy = -Math.sqrt((sin2Y + 1) / 2);
            console.log(cos2Y);
            if (cos2Y < 0) {
                cosy = -cosy;
            }
            var yq = m4m.math.pool.new_quaternion();
            yq.x = 0;
            yq.y = 0;
            yq.z = siny;
            yq.w = cosy;
            quatMultiply(out, yq, out);
            m4m.math.pool.delete_vector3(dir);
            m4m.math.pool.delete_vector3(cdz);
            // m4m.math.pool.delete_vector3(y);
            // m4m.math.pool.delete_quaternion(yq);
        }
        math.quatLookRotation = quatLookRotation;
        function quatYAxis(pos, targetpos, out) {
            var dir = math.pool.new_vector3();
            math.vec3Subtract(targetpos, pos, dir);
            math.vec3Normalize(dir, dir);
            //dir在xz面上的单位投影
            var dirxz = math.pool.new_vector3(dir.x, 0, dir.z);
            math.vec3Normalize(dirxz, dirxz);
            var yaw = Math.acos(dirxz.z); // / Math.PI * 180;
            if (dirxz.x < 0) {
                yaw = -yaw;
            }
            // //dir在xz面上的投影
            // var dirxz1 = new vector3(dir.x, 0, dir.z);
            // let v3length = math.vec3Length(dirxz1);
            // if (v3length > 0.999)
            //     v3length = 1;
            // if (v3length < -0.999)
            //     v3length = -1;
            // var pitch = Math.acos(v3length);// / Math.PI * 180;
            // if (dir.y > 0)
            // {
            //     pitch = -pitch;
            // }
            quatFromYawPitchRoll(yaw, 0, 0, out);
            math.quatNormalize(out, out);
            math.pool.delete_vector3(dir);
            math.pool.delete_vector3(dirxz);
        }
        math.quatYAxis = quatYAxis;
        /** 计算 从 start 到 end 旋转的四元数 */
        function quatRotationTo(start, end, out) {
            math.vec3Normalize(start, start);
            math.vec3Normalize(end, end);
            var dot = math.vec3Dot(start, end);
            if (dot >= 0.99999847691) {
                quatIdentity(out);
                return;
            }
            if (dot <= -0.99999847691) {
                var pVec = math.pool.new_vector3();
                math.vec3Perpendicular(start, pVec);
                out.w = 0;
                out.x = pVec.x;
                out.y = pVec.y;
                out.z = pVec.z;
                math.pool.delete_vector3(pVec);
                return;
            }
            var cross_product = math.pool.new_vector3();
            math.vec3Cross(start, end, cross_product);
            out.w = 1 + dot;
            out.x = cross_product.x;
            out.y = cross_product.y;
            out.z = cross_product.z;
            quatNormalize(out, out);
            math.pool.delete_vector3(cross_product);
        }
        math.quatRotationTo = quatRotationTo;
        function myLookRotation(dir, out, up) {
            if (up === void 0) { up = math.pool.vector3_up; }
            if (math.vec3Equal(dir, math.pool.vector3_zero)) {
                console.log("Zero direction in MyLookRotation");
                quatIdentity(out);
                return;
            }
            if (!math.vec3Equal(dir, up)) {
                var tempv = math.pool.new_vector3();
                math.vec3ScaleByNum(up, math.vec3Dot(up, dir), tempv);
                math.vec3Subtract(dir, tempv, tempv);
                var qu = math.pool.new_quaternion();
                this.quatRotationTo(math.pool.vector3_forward, tempv, qu);
                var qu2 = math.pool.new_quaternion();
                this.quatRotationTo(tempv, dir, qu2);
                quatMultiply(qu, qu2, out);
                math.pool.delete_quaternion(qu);
                math.pool.delete_quaternion(qu2);
                math.pool.delete_vector3(tempv);
            }
            else {
                this.quatRotationTo(math.pool.vector3_forward, dir, out);
            }
        }
        math.myLookRotation = myLookRotation;
    })(math = m4m.math || (m4m.math = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var math;
    (function (math) {
        function rectSet_One(out) {
            out.x = 0;
            out.y = 0;
            out.w = 1;
            out.h = 1;
        }
        math.rectSet_One = rectSet_One;
        function rectSet_Zero(out) {
            out.x = 0;
            out.y = 0;
            out.w = 0;
            out.h = 0;
        }
        math.rectSet_Zero = rectSet_Zero;
        function rectEqul(src1, src2) {
            return !((src1.x != src2.x) ||
                (src1.y != src2.y) ||
                (src1.w != src2.w) ||
                (src1.h != src2.h));
        }
        math.rectEqul = rectEqul;
        /**
         * 判断点是否在矩形中
         * @param x 点坐标x
         * @param y 点坐标y
         * @param src 矩形
         */
        function rectInner(x, y, src) {
            if (x < src.x || x > src.x + src.w ||
                y < src.y || y > src.y + src.h) {
                return false;
            }
            return true;
        }
        math.rectInner = rectInner;
        /**
         * 判断两矩形是否重叠
         * @param r1 矩形1
         * @param r2 矩形2
         */
        function rectOverlap(r1, r2) {
            //两矩形中心点距离 小于 半尺寸则重叠了
            //X轴
            if ((r1.x + r1.w) < r2.x || r1.x > (r1.x + r1.w))
                return false;
            //y轴
            if ((r1.y + r1.h) < r2.y || r1.y > (r1.y + r1.h))
                return false;
            return true;
        }
        math.rectOverlap = rectOverlap;
        function rectSet(out, x, y, w, h) {
            out.x = x;
            out.y = y;
            out.w = w;
            out.h = h;
        }
        math.rectSet = rectSet;
        /**
         * 检测两个矩形是否相碰
         * @param r1
         * @param r2
         */
        function rectCollided(r1, r2) {
            return r1.x < r2.x + r2.w && r1.x + r1.w > r2.x && r1.y < r2.y + r2.h && r1.h + r1.y > r2.y;
        }
        math.rectCollided = rectCollided;
        function rectClone(src, out) {
            out.x = src.x;
            out.y = src.y;
            out.h = src.h;
            out.w = src.w;
            // out.rawData[0] = src.rawData[0];
            // out.rawData[1] = src.rawData[1];
            // out.rawData[2] = src.rawData[2];
            // out.rawData[3] = src.rawData[3];
        }
        math.rectClone = rectClone;
    })(math = m4m.math || (m4m.math = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var math;
    (function (math) {
        function caclStringByteLength(value) {
            var total = 0;
            for (var i = 0; i < value.length; i++) {
                var charCode = value.charCodeAt(i);
                if (charCode <= 0x007f) {
                    total += 1;
                }
                else if (charCode <= 0x07ff) {
                    total += 2;
                }
                else if (charCode <= 0xffff) {
                    total += 3;
                }
                else {
                    total += 4;
                }
            }
            return total;
        }
        math.caclStringByteLength = caclStringByteLength;
    })(math = m4m.math || (m4m.math = {}));
})(m4m || (m4m = {}));
//找不到归属的放这里
var m4m;
//找不到归属的放这里
(function (m4m) {
    var math;
    (function (math) {
        //row：图片行数//column:图片列数//index：第几张图片（index从0开始计数）
        function spriteAnimation(row, column, index, out) {
            var width = 1.0 / column;
            var height = 1.0 / row;
            var offsetx = width * (index % column);
            var offsety = height * row - height * (Math.floor(index / column) + 1);
            out.x = width;
            out.y = height;
            out.z = offsetx;
            out.w = offsety;
            // var uvOffset=new m4m.math.vector4(width,height,offsetx,offsety);
            // return  uvOffset;
        }
        math.spriteAnimation = spriteAnimation;
        // int index = Mathf.FloorToInt(this.life01 * data.count);
        // float width = 1.0f / data.column;//width
        // float height = 1.0f / data.row;//height
        // float offsetx = width * (index % data.column);//offsetx
        // float offsety =height * data.row-height * (Mathf.FloorToInt(index / data.column)+1);//offsety
        // this.tex_ST.x = width;
        // this.tex_ST.y = height;
        // this.tex_ST.z = offsetx;
        // this.tex_ST.w = offsety;
        function GetPointAlongCurve(curveStart, curveStartHandle, curveEnd, curveEndHandle, t, out, crease) {
            if (crease === void 0) { crease = 0.3; }
            var oneMinT = 1 - t;
            var oneMinTPow3 = Math.pow(oneMinT, 3);
            var oneMinTPow2 = Math.pow(oneMinT, 2);
            var oneMinCrease = 1 - crease;
            var tempt1 = m4m.math.pool.new_vector3();
            m4m.math.vec3ScaleByNum(curveStart, oneMinTPow3 * oneMinCrease, tempt1);
            var tempt2 = m4m.math.pool.new_vector3();
            m4m.math.vec3ScaleByNum(curveStartHandle, 3 * oneMinTPow2 * t * crease, tempt2);
            var tempt3 = m4m.math.pool.new_vector3();
            m4m.math.vec3ScaleByNum(curveEndHandle, 3 * oneMinT * Math.pow(t, 2) * crease, tempt3);
            var tempt4 = m4m.math.pool.new_vector3();
            m4m.math.vec3ScaleByNum(curveEnd, Math.pow(t, 3) * oneMinCrease, tempt4);
            var tempt5 = m4m.math.pool.new_vector3();
            m4m.math.vec3Add(tempt1, tempt2, tempt5);
            m4m.math.vec3Add(tempt5, tempt3, tempt5);
            m4m.math.vec3Add(tempt5, tempt4, tempt5);
            m4m.math.vec3ScaleByNum(tempt5, 1 / (oneMinTPow3 * oneMinCrease + 3 * oneMinTPow2 * t * crease + 3 * oneMinT * Math.pow(t, 2) * crease + Math.pow(t, 3) * oneMinCrease), out);
            m4m.math.pool.delete_vector3(tempt1);
            m4m.math.pool.delete_vector3(tempt2);
            m4m.math.pool.delete_vector3(tempt3);
            m4m.math.pool.delete_vector3(tempt4);
            m4m.math.pool.delete_vector3(tempt5);
        }
        math.GetPointAlongCurve = GetPointAlongCurve;
        // export function GetPointAlongCurve2(curveStart:vector3,curveStartHandle:vector3,curveEnd:vector3,curveEndHandle:vector3,t:number, out:vector3,crease:number=0.3)
        // {
        //     var oneMinT = 1 - t;
        //     var oneMinTPow3 =Math.pow(oneMinT, 3);
        //     var oneMinTPow2 = Math.pow(oneMinT, 2);
        //     var tempt1=m4m.math.pool.new_vector3();
        //     m4m.math.vec3ScaleByNum(curveStart,oneMinTPow3,tempt1);
        //     var tempt2=m4m.math.pool.new_vector3();
        //     m4m.math.vec3ScaleByNum(curveStartHandle,3*oneMinTPow2*t,tempt2);
        //     var tempt3=m4m.math.pool.new_vector3();
        //     m4m.math.vec3ScaleByNum(curveEndHandle,3*oneMinT*Math.pow(t,2),tempt3);
        //     var tempt4=m4m.math.pool.new_vector3();
        //     m4m.math.vec3ScaleByNum(curveEnd,Math.pow(t,3),tempt4);
        //     var tempt5=m4m.math.pool.new_vector3();
        //     m4m.math.vec3Add(tempt1,tempt2,tempt5);
        //     m4m.math.vec3Add(tempt5,tempt3,tempt5);
        //     m4m.math.vec3Add(tempt5,tempt4,tempt5);
        //     m4m.math.pool.delete_vector3(tempt1);
        //     m4m.math.pool.delete_vector3(tempt2);
        //     m4m.math.pool.delete_vector3(tempt3);
        //     m4m.math.pool.delete_vector3(tempt4);
        //     m4m.math.pool.delete_vector3(tempt5);
        // }
    })(math = m4m.math || (m4m.math = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var math;
    (function (math) {
        function vec2Subtract(a, b, out) {
            out.x = a.x - b.x;
            out.y = a.y - b.y;
        }
        math.vec2Subtract = vec2Subtract;
        function vec2Add(a, b, out) {
            out.x = a.x + b.x;
            out.y = a.y + b.y;
        }
        math.vec2Add = vec2Add;
        function vec2Clone(from, to) {
            to.x = from.x;
            to.y = from.y;
            //to.rawData.set(from.rawData);
            // to.rawData[0]=from.rawData[0];
            // to.rawData[1]=from.rawData[1];
        }
        math.vec2Clone = vec2Clone;
        function vec2Distance(a, b) {
            var out = math.pool.new_vector2();
            vec2Subtract(a, b, out);
            var result = Math.sqrt(out.x * out.x + out.y * out.y);
            math.pool.delete_vector2(out);
            return result;
        }
        math.vec2Distance = vec2Distance;
        function vec2ScaleByNum(from, scale, out) {
            out.x = from.x * scale;
            out.y = from.y * scale;
        }
        math.vec2ScaleByNum = vec2ScaleByNum;
        function vec2ScaleByVec2(from, scale, out) {
            out.x = from.x * scale.x;
            out.y = from.y * scale.y;
        }
        math.vec2ScaleByVec2 = vec2ScaleByVec2;
        function vec2Length(a) {
            return Math.sqrt(a.x * a.x + a.y * a.y);
        }
        math.vec2Length = vec2Length;
        function vec2SLerp(vector, vector2, v, out) {
            out.x = vector.x * (1 - v) + vector2.x * v;
            out.y = vector.y * (1 - v) + vector2.y * v;
        }
        math.vec2SLerp = vec2SLerp;
        function vec2Normalize(from, out) {
            var num = vec2Length(from);
            if (num > Number.MIN_VALUE) {
                out.x = from.x / num;
                out.y = from.y / num;
            }
            else {
                out.x = 0;
                out.y = 0;
            }
        }
        math.vec2Normalize = vec2Normalize;
        function vec2Multiply(a, b) {
            return a.x * b.x + a.y * b.y;
        }
        math.vec2Multiply = vec2Multiply;
        function vec2Dot(lhs, rhs) {
            return lhs.x * rhs.x + lhs.y * rhs.y;
        }
        math.vec2Dot = vec2Dot;
        //阀值先写这里了，回头
        function vec2Equal(vector, vector2, threshold) {
            if (threshold === void 0) { threshold = 0.00001; }
            if (vector == vector2)
                return true;
            if (Math.abs(vector.x - vector2.x) > threshold)
                return false;
            if (Math.abs(vector.y - vector2.y) > threshold)
                return false;
            return true;
        }
        math.vec2Equal = vec2Equal;
        function vec2SetAll(vector, value) {
            vector.x = value;
            vector.y = value;
            // vector.rawData[0] = value;
            // vector.rawData[1] = value;
        }
        math.vec2SetAll = vec2SetAll;
        function vec2Set(vector, x, y) {
            vector.x = x;
            vector.y = y;
            // vector.rawData[0] = x;
            // vector.rawData[1] = y;
        }
        math.vec2Set = vec2Set;
    })(math = m4m.math || (m4m.math = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var math;
    (function (math) {
        //重构原则2，一个函数，一种用法，不给默认值
        //重构原则3，内部不new，所有计算函数需要外部提供out 参数，最后一个参数为out 参数
        // export function vec2Subtract(a: vector2, b: vector2, out: vector2)
        // {
        //     out.x = a.x - b.x;
        //     out.y = a.y - b.y;
        // }
        // export function vec2Add(a: vector2, b: vector2, out: vector2) {
        //     out.x = a.x + b.x;
        //     out.y = a.y + b.y;
        // }
        function vec3Clone(from, to) {
            to.x = from.x;
            to.y = from.y;
            to.z = from.z;
            //to.rawData.set(from.rawData);
            // to.rawData[0]=from.rawData[0];
            // to.rawData[1]=from.rawData[1];
            // to.rawData[2]=from.rawData[2]; 
        }
        math.vec3Clone = vec3Clone;
        // export function vec3ToString(result: string)
        // {
        //     result = this.x + "," + this.y + "," + this.z;
        // }
        function vec3Add(a, b, out) {
            out.x = a.x + b.x;
            out.y = a.y + b.y;
            out.z = a.z + b.z;
            // out.rawData[0] = a.x + b.x;
            // out.rawData[1] = a.y + b.y;
            // out.rawData[2] = a.z + b.z;
        }
        math.vec3Add = vec3Add;
        function vec3Subtract(a, b, out) {
            out.x = a.x - b.x;
            out.y = a.y - b.y;
            out.z = a.z - b.z;
            // out.rawData[0] = a.x - b.x;
            // out.rawData[1] = a.y - b.y;
            // out.rawData[2] = a.z - b.z;
        }
        math.vec3Subtract = vec3Subtract;
        function vec3Minus(a, out) {
            out.x = -a.x;
            out.y = -a.y;
            out.z = -a.z;
            // out.rawData[0] = -a.x;
            // out.rawData[1] = -a.y;
            // out.rawData[2] = -a.z;
        }
        math.vec3Minus = vec3Minus;
        function vec3Length(a) {
            return Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);
        }
        math.vec3Length = vec3Length;
        function vec3SqrLength(value) {
            return value.x * value.x + value.y * value.y + value.z * value.z;
        }
        math.vec3SqrLength = vec3SqrLength;
        function vec3Set_One(out) {
            // out.rawData[0] = out.rawData[1] = out.rawData[2] = 1;
            out.x = out.y = out.z = 1;
        }
        math.vec3Set_One = vec3Set_One;
        function vec3Set_Forward(out) {
            out.x = out.y = 0;
            out.z = 1;
            // out.rawData[0] = out.rawData[1] = 0;
            // out.rawData[2] = 1;
        }
        math.vec3Set_Forward = vec3Set_Forward;
        function vec3Set_Back(out) {
            out.x = out.y = 0;
            out.z = -1;
            // out.rawData[0] = out.rawData[1] = 0;
            // out.rawData[2] = -1;
        }
        math.vec3Set_Back = vec3Set_Back;
        function vec3Set_Up(out) {
            out.x = out.z = 0;
            out.y = 1;
            // out.rawData[0] = out.rawData[2] = 0;
            // out.rawData[1] = 1;
        }
        math.vec3Set_Up = vec3Set_Up;
        function vec3Set_Down(out) {
            out.x = out.z = 0;
            out.y = -1;
            // out.rawData[0] = out.rawData[2] = 0;
            // out.rawData[1] = -1;
        }
        math.vec3Set_Down = vec3Set_Down;
        function vec3Set_Left(out) {
            out.x = -1;
            out.y = out.z = 0;
            // out.rawData[0] = -1;
            // out.rawData[1] = out.rawData[2] = 0;
        }
        math.vec3Set_Left = vec3Set_Left;
        function vec3Set_Right(out) {
            out.x = 1;
            out.y = out.z = 0;
            // out.rawData[0] = 1;
            // out.rawData[1] = out.rawData[2] = 0;
        }
        math.vec3Set_Right = vec3Set_Right;
        function vec3Normalize(value, out) {
            var num = vec3Length(value);
            if (num > Number.MIN_VALUE) {
                out.x = value.x / num;
                out.y = value.y / num;
                out.z = value.z / num;
                // out.rawData[0] = value.x / num;
                // out.rawData[1] = value.y / num;
                // out.rawData[2] = value.z / num;
            }
            else {
                out.x = 0;
                out.y = 0;
                out.z = 0;
                // out.rawData[0] = 0;
                // out.rawData[1] = 0;
                // out.rawData[2] = 0;
            }
        }
        math.vec3Normalize = vec3Normalize;
        function vec3ScaleByVec3(from, scale, out) {
            out.x = from.x * scale.x;
            out.y = from.y * scale.y;
            out.z = from.z * scale.z;
            // out.rawData[0] = from.x * scale.x;
            // out.rawData[1] = from.y * scale.y;
            // out.rawData[2] = from.z * scale.z;
        }
        math.vec3ScaleByVec3 = vec3ScaleByVec3;
        function vec3ScaleByNum(from, scale, out) {
            out.x = from.x * scale;
            out.y = from.y * scale;
            out.z = from.z * scale;
            // out.rawData[0] = from.x * scale;
            // out.rawData[1] = from.y * scale;
            // out.rawData[2] = from.z * scale;
        }
        math.vec3ScaleByNum = vec3ScaleByNum;
        function vec3Product(a, b, out) {
            out.x = a.x * b.x;
            out.y = a.y * b.y;
            out.z = a.z * b.z;
            // out.rawData[0] = a.x * b.x;
            // out.rawData[1] = a.y * b.y;
            // out.rawData[2] = a.z * b.z;
        }
        math.vec3Product = vec3Product;
        function vec3Cross(lhs, rhs, out) {
            var x = lhs.y * rhs.z - lhs.z * rhs.y;
            var y = lhs.z * rhs.x - lhs.x * rhs.z;
            var z = lhs.x * rhs.y - lhs.y * rhs.x;
            // out.rawData[0] = x;
            // out.rawData[1] = y;
            // out.rawData[2] = z;
            out.x = x;
            out.y = y;
            out.z = z;
        }
        math.vec3Cross = vec3Cross;
        /**
         * 指定两个向量是否平行
         *
         * @param lhs 向量
         * @param rhs 向量
         * @param precision 精度
         */
        function vec3IsParallel(lhs, rhs, precision) {
            if (precision === void 0) { precision = 1e-6; }
            var out1 = math.pool.new_vector3(lhs.x, lhs.y, lhs.z);
            var out2 = math.pool.new_vector3(rhs.x, rhs.y, rhs.z);
            math.vec3Normalize(out1, out1);
            math.vec3Normalize(out2, out2);
            var dot = math.vec3Dot(out1, out2);
            dot = Math.abs(dot);
            if (Math.abs(dot - 1) < precision)
                return true;
            return false;
        }
        math.vec3IsParallel = vec3IsParallel;
        function vec3Reflect(inDirection, inNormal, out) {
            //return -2 * vector3.Dot(inNormal, inDirection) * inNormal + inDirection;
            var v1 = 0;
            v1 = vec3Dot(inNormal, inDirection);
            vec3ScaleByNum(out, v1 * -2, out);
            vec3Add(out, inDirection, out);
        }
        math.vec3Reflect = vec3Reflect;
        function vec3Dot(lhs, rhs) {
            return lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z;
        }
        math.vec3Dot = vec3Dot;
        function vec3Project(vector, onNormal, out) {
            var num = 0;
            num = vec3Dot(onNormal, onNormal);
            if (num < Number.MIN_VALUE) {
                // out.rawData[0] = out.rawData[1] = out.rawData[2] = 0;
                out.x = out.y = out.z = 0;
            }
            else {
                //return onNormal * vector3.Dot(vector, onNormal) / num;
                var num2 = 0;
                num2 = vec3Dot(vector, onNormal);
                vec3ScaleByNum(onNormal, num2 / num, out);
            }
        }
        math.vec3Project = vec3Project;
        function vec3ProjectOnPlane(vector, planeNormal, out) {
            //return vector - vector3.Project(vector, planeNormal);
            vec3Project(vector, planeNormal, out);
            vec3Subtract(vector, out, out);
        }
        math.vec3ProjectOnPlane = vec3ProjectOnPlane;
        function vec3Exclude(excludeThis, fromThat, out) {
            vec3Project(fromThat, excludeThis, out);
            vec3Subtract(fromThat, out, out);
            //return fromThat - vector3.Project(fromThat, excludeThis);
        }
        math.vec3Exclude = vec3Exclude;
        function vec3Angle(from, to) {
            var out1 = math.pool.new_vector3();
            var out2 = math.pool.new_vector3();
            vec3Normalize(from, out1);
            vec3Normalize(to, out2);
            var result = vec3Dot(out1, out2);
            result = math.floatClamp(result, -1, 1);
            result = Math.acos(result) * 57.29578;
            math.pool.delete_vector3(out1);
            math.pool.delete_vector3(out1);
            return result;
        }
        math.vec3Angle = vec3Angle;
        function vec3Distance(a, b) {
            var out = math.pool.new_vector3();
            vec3Subtract(a, b, out);
            var result = Math.sqrt(out.x * out.x + out.y * out.y + out.z * out.z);
            math.pool.delete_vector3(out);
            return result;
        }
        math.vec3Distance = vec3Distance;
        function vec3ClampLength(vector, maxLength, out) {
            var val = 0;
            val = vec3SqrLength(vector);
            if (val > maxLength * maxLength) {
                vec3Normalize(vector, out);
                vec3ScaleByNum(out, maxLength, out);
            }
            // out.rawData.set(vector.rawData);
            out.x = vector.x;
            out.y = vector.y;
            out.z = vector.z;
        }
        math.vec3ClampLength = vec3ClampLength;
        function vec3Min(v0, v1, out) {
            out.x = Math.min(v0.x, v1.x);
            out.y = Math.min(v0.y, v1.y);
            out.z = Math.min(v0.z, v1.z);
        }
        math.vec3Min = vec3Min;
        function vec3Max(v0, v1, out) {
            out.x = Math.max(v0.x, v1.x);
            out.y = Math.max(v0.y, v1.y);
            out.z = Math.max(v0.z, v1.z);
        }
        math.vec3Max = vec3Max;
        function vec3AngleBetween(from, to) {
            vec3Normalize(from, from);
            vec3Normalize(to, to);
            var result = vec3Dot(from, to);
            result = math.floatClamp(result, -1, 1);
            result = Math.acos(result);
            return result;
        }
        math.vec3AngleBetween = vec3AngleBetween;
        function vec3Reset(out) {
            out.x = 0;
            out.y = 0;
            out.z = 0;
        }
        math.vec3Reset = vec3Reset;
        function vec3SLerp(vector, vector2, v, out) {
            out.x = vector.x * (1 - v) + vector2.x * v;
            out.y = vector.y * (1 - v) + vector2.y * v;
            out.z = vector.z * (1 - v) + vector2.z * v;
        }
        math.vec3SLerp = vec3SLerp;
        function vec3SetByFloat(x, y, z, out) {
            out.x = x;
            out.y = y;
            out.z = z;
        }
        math.vec3SetByFloat = vec3SetByFloat;
        function vec3Format(vector, maxDot, out) {
            out.x = floatFormat(vector.x, maxDot);
            out.y = floatFormat(vector.y, maxDot);
            out.z = floatFormat(vector.z, maxDot);
        }
        math.vec3Format = vec3Format;
        function quaternionFormat(vector, maxDot, out) {
            out.x = floatFormat(vector.x, maxDot);
            out.y = floatFormat(vector.y, maxDot);
            out.z = floatFormat(vector.z, maxDot);
            out.w = floatFormat(vector.w, maxDot);
        }
        math.quaternionFormat = quaternionFormat;
        function floatFormat(num, maxDot) {
            var vv = Math.pow(10, maxDot);
            return Math.round(num * vv) / vv;
        }
        math.floatFormat = floatFormat;
        //toQuat(dest: Cengine.quaternion = null): Cengine.quaternion {
        //    if (!dest) dest = new Cengine.quaternion();
        //    var c = new vector3();
        //    var s = new vector3();
        //    c.x = Math.cos(this.x * 0.5);
        //    s.x = Math.sin(this.x * 0.5);
        //    c.y = Math.cos(this.y * 0.5);
        //    s.y = Math.sin(this.y * 0.5);
        //    c.z = Math.cos(this.z * 0.5);
        //    s.z = Math.sin(this.z * 0.5);
        //    dest.x = s.x * c.y * c.z - c.x * s.y * s.z;
        //    dest.y = c.x * s.y * c.z + s.x * c.y * s.z;
        //    dest.z = c.x * c.y * s.z - s.x * s.y * c.z;
        //    dest.w = c.x * c.y * c.z + s.x * s.y * s.z;
        //    return dest;
        //}
        //multiplyByMat3(matrix: Matrix3x3): void {
        //    matrix.multiplyVec3(this, this);
        //}
        //multiplyByQuat(quat: Cengine.quaternion): void {
        //    quat.multiplyVec3(this, this);
        //}
        ////又有参数又有返回值的必须是static
        function vec3Equal(vector, vector2, threshold) {
            if (threshold === void 0) { threshold = 0.00001; }
            if (vector == vector2)
                return true;
            if (Math.abs(vector.x - vector2.x) > threshold)
                return false;
            if (Math.abs(vector.y - vector2.y) > threshold)
                return false;
            if (Math.abs(vector.z - vector2.z) > threshold)
                return false;
            return true;
        }
        math.vec3Equal = vec3Equal;
        function vec3SetAll(vector, value) {
            // vector.rawData[0] = value;
            // vector.rawData[1] = value;
            // vector.rawData[2] = value;
            vector.x = value;
            vector.y = value;
            vector.z = value;
        }
        math.vec3SetAll = vec3SetAll;
        function vec3Set(vector, x, y, z) {
            // vector.rawData[0] = x;
            // vector.rawData[1] = y;
            // vector.rawData[2] = z;
            vector.x = x;
            vector.y = y;
            vector.z = z;
        }
        math.vec3Set = vec3Set;
        /** 获取指定 向量的 垂直向量 */
        function vec3Perpendicular(vector, out) {
            m4m.math.vec3Cross(math.pool.vector3_right, vector, out);
            var dot = m4m.math.vec3Dot(out, out);
            if (dot < 0.05) {
                m4m.math.vec3Cross(math.pool.vector3_up, vector, out);
            }
        }
        math.vec3Perpendicular = vec3Perpendicular;
        //static sDirection(vector: vector3, vector2: vector3, dest: vector3 = null): vector3 {
        //    if (!dest) dest = new vector3();
        //    var x = vector.x - vector2.x,
        //        y = vector.y - vector2.y,
        //        z = vector.z - vector2.z;
        //    var length = Math.sqrt(x * x + y * y + z * z);
        //    if (length === 0)
        //    {
        //        dest.x = 0;
        //        dest.y = 0;
        //        dest.z = 0;
        //        return dest;
        //    }
        //    length = 1 / length;
        //    dest.x = x * length;
        //    dest.y = y * length;
        //    dest.z = z * length;
        //    return dest;
        //}
        var tagMap = {};
        var tagMap1 = {};
        function countStart(tag) {
            tagMap[tag] = { count: 0, time: Date.now() };
        }
        math.countStart = countStart;
        function count(tag) {
            ++tagMap[tag].count;
        }
        math.count = count;
        function countEnd(tag) {
            if (tagMap1[tag] == undefined || tagMap1[tag] != tagMap[tag].count) {
                tagMap1[tag] = tagMap[tag].count;
                console.log("tag:".concat(tag, ",count:").concat(tagMap[tag].count, ",time:").concat(Date.now() - tagMap[tag].time, "/ms"));
            }
        }
        math.countEnd = countEnd;
    })(math = m4m.math || (m4m.math = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var math;
    (function (math) {
        function vec4Clone(from, to) {
            to.x = from.x;
            to.y = from.y;
            to.z = from.z;
            to.w = from.w;
            //to.rawData.set(from.rawData);
            // to.rawData[0] = from.rawData[0];
            // to.rawData[1] = from.rawData[1];
            // to.rawData[2] = from.rawData[2];
            // to.rawData[3] = from.rawData[3];
        }
        math.vec4Clone = vec4Clone;
        function vec4SLerp(vector, vector2, v, out) {
            out.x = vector.x * (1 - v) + vector2.x * v;
            out.y = vector.y * (1 - v) + vector2.y * v;
            out.z = vector.z * (1 - v) + vector2.z * v;
            out.w = vector.w * (1 - v) + vector2.w * v;
        }
        math.vec4SLerp = vec4SLerp;
        function vec4Add(a, b, out) {
            // out.rawData[0] = a.rawData[0] + b.rawData[0];
            // out.rawData[1] = a.rawData[1] + b.rawData[1];
            // out.rawData[2] = a.rawData[2] + b.rawData[2];
            // out.rawData[3] = a.rawData[3] + b.rawData[3];
            out.x = a.x + b.x;
            out.y = a.y + b.y;
            out.z = a.z + b.z;
            out.w = a.w + b.w;
        }
        math.vec4Add = vec4Add;
        function vec4ScaleByNum(from, scale, out) {
            // out.rawData[0] = from.rawData[0] * scale;
            // out.rawData[1] = from.rawData[1] * scale;
            // out.rawData[2] = from.rawData[2] * scale;
            // out.rawData[3] = from.rawData[3] * scale;
            out.x = from.x * scale;
            out.y = from.y * scale;
            out.z = from.z * scale;
            out.w = from.w * scale;
        }
        math.vec4ScaleByNum = vec4ScaleByNum;
        function vec4SetAll(vector, value) {
            // vector.rawData[0] = value;
            // vector.rawData[1] = value;
            // vector.rawData[2] = value;
            // vector.rawData[3] = value;
            vector.x = value;
            vector.y = value;
            vector.z = value;
            vector.w = value;
        }
        math.vec4SetAll = vec4SetAll;
        function vec4Set(vector, x, y, z, w) {
            // vector.rawData[0] = x;
            // vector.rawData[1] = y;
            // vector.rawData[2] = z;
            // vector.rawData[3] = w;
            vector.x = x;
            vector.y = y;
            vector.z = z;
            vector.w = w;
        }
        math.vec4Set = vec4Set;
        function vec4Equal(vector, vector2, threshold) {
            if (threshold === void 0) { threshold = 0.00001; }
            if (vector == vector2)
                return true;
            if (Math.abs(vector.x - vector2.x) > threshold)
                return false;
            if (Math.abs(vector.y - vector2.y) > threshold)
                return false;
            if (Math.abs(vector.z - vector2.z) > threshold)
                return false;
            if (Math.abs(vector.w - vector2.w) > threshold)
                return false;
            return true;
        }
        math.vec4Equal = vec4Equal;
    })(math = m4m.math || (m4m.math = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var navVec3 = /** @class */ (function () {
            function navVec3() {
                this.x = 0;
                this.y = 0;
                this.z = 0;
                this.realy = 0;
            }
            navVec3.prototype.clone = function () {
                var navVec = new navVec3();
                navVec.x = this.x;
                navVec.y = this.y;
                navVec.z = this.z;
                navVec.realy = this.realy;
                return navVec;
            };
            navVec3.DistAZ = function (start, end) {
                var num = end.x - start.x;
                var num2 = end.z - start.z;
                return Math.sqrt(num * num + num2 * num2);
            };
            navVec3.NormalAZ = function (start, end) {
                var num = end.x - start.x;
                var num2 = end.z - start.z;
                var num3 = Math.sqrt(num * num + num2 * num2);
                var navVec = new navVec3();
                navVec.x = num / num3;
                navVec.y = 0.0;
                navVec.z = num2 / num3;
                return navVec;
            };
            navVec3.Cross = function (start, end) {
                var navVec = new navVec3();
                navVec.x = start.y * end.z - start.z * end.y;
                navVec.y = start.z * end.x - start.x * end.z;
                navVec.z = start.x * end.y - start.y * end.x;
                return navVec;
            };
            navVec3.DotAZ = function (start, end) {
                return start.x * end.x + start.z * end.z;
            };
            navVec3.Angle = function (start, end) {
                var d = start.x * end.x + start.z * end.z;
                var navVec = navVec3.Cross(start, end);
                var num = Math.acos(d);
                var flag = navVec.y < 0.0;
                if (flag) {
                    num = -num;
                }
                return num;
            };
            navVec3.Border = function (start, end, dist) {
                var navVec = navVec3.NormalAZ(start, end);
                var navVec2 = new navVec3();
                navVec2.x = start.x + navVec.x * dist;
                navVec2.y = start.y + navVec.y * dist;
                navVec2.z = start.z + navVec.z * dist;
                if (end.x == start.x) {
                    navVec2.realy = start.y;
                }
                else {
                    navVec2.realy = start.y + navVec.x * (end.y - start.y) / (end.x - start.x);
                }
                return navVec2;
            };
            navVec3.lerp = function (from, to, lerp, out) {
                out.x = (to.x - from.x) * lerp + from.x;
                out.y = (to.y - from.y) * lerp + from.y;
                out.z = (to.z - from.z) * lerp + from.z;
            };
            return navVec3;
        }());
        framework.navVec3 = navVec3;
        var navNode = /** @class */ (function () {
            function navNode() {
                this.nodeID = 0;
                this.poly = null;
                this.borderByPoly = null;
                this.borderByPoint = null;
                this.center = null;
            }
            navNode.prototype.genBorder = function () {
                var list = [];
                for (var i = 0; i < this.poly.length; i = i + 1) {
                    var num = i;
                    var num2 = i + 1;
                    var flag = num2 >= this.poly.length;
                    if (flag) {
                        num2 = 0;
                    }
                    var num3 = this.poly[num];
                    var num4 = this.poly[num2];
                    var flag2 = num3 < num4;
                    if (flag2) {
                        list.push(num3 + "-" + num4);
                    }
                    else {
                        list.push(num4 + "-" + num3);
                    }
                }
                this.borderByPoint = list;
            };
            navNode.prototype.isLinkTo = function (info, nid) {
                var flag = this.nodeID === nid;
                var result;
                if (flag) {
                    result = null;
                }
                else {
                    var flag2 = nid < 0;
                    if (flag2) {
                        result = null;
                    }
                    else {
                        var array = this.borderByPoly;
                        for (var i = 0; i < array.length; i = i + 1) {
                            var text = array[i];
                            var flag3 = (info.borders[text] == undefined);
                            if (!flag3) {
                                var flag4 = info.borders[text].nodeA === nid || info.borders[text].nodeB === nid;
                                if (flag4) {
                                    result = text;
                                    return result;
                                }
                            }
                        }
                        result = null;
                    }
                }
                return result;
            };
            navNode.prototype.getLinked = function (info) {
                var list = [];
                var array = this.borderByPoly;
                for (var i = 0; i < array.length; i = i + 1) {
                    var key = array[i];
                    var flag = (info.borders[key] == undefined);
                    if (!flag) {
                        var flag2 = info.borders[key].nodeA === this.nodeID;
                        var num;
                        if (flag2) {
                            num = info.borders[key].nodeB;
                        }
                        else {
                            num = info.borders[key].nodeA;
                        }
                        var flag3 = num >= 0;
                        if (flag3) {
                            list.push(num);
                        }
                    }
                }
                return list;
            };
            navNode.prototype.genCenter = function (info) {
                this.center = new navVec3();
                this.center.x = 0.0;
                this.center.y = 0.0;
                this.center.z = 0.0;
                var array = this.poly;
                for (var i = 0; i < array.length; i = i + 1) {
                    var num = array[i];
                    this.center.x += info.vecs[num].x;
                    this.center.y += info.vecs[num].y;
                    this.center.z += info.vecs[num].z;
                }
                this.center.x /= this.poly.length;
                this.center.y /= this.poly.length;
                this.center.z /= this.poly.length;
            };
            return navNode;
        }());
        framework.navNode = navNode;
        var navBorder = /** @class */ (function () {
            function navBorder() {
                this.borderName = null;
                this.nodeA = 0;
                this.nodeB = 0;
                this.pointA = 0;
                this.pointB = 0;
                this.length = 0;
                this.center = null;
            }
            return navBorder;
        }());
        framework.navBorder = navBorder;
        var navMeshInfo = /** @class */ (function () {
            function navMeshInfo() {
                this.vecs = null;
                this.nodes = null;
                this.borders = null;
                this.min = null;
                this.max = null;
            }
            navMeshInfo.prototype.calcBound = function () {
                this.min = new navVec3();
                this.max = new navVec3();
                this.min.x = 1.7976931348623157E+308;
                this.min.y = 1.7976931348623157E+308;
                this.min.z = 1.7976931348623157E+308;
                this.max.x = -1.7976931348623157E+308;
                this.max.y = -1.7976931348623157E+308;
                this.max.z = -1.7976931348623157E+308;
                for (var i = 0; i < this.vecs.length; i = i + 1) {
                    var flag = this.vecs[i].x < this.min.x;
                    if (flag) {
                        this.min.x = this.vecs[i].x;
                    }
                    var flag2 = this.vecs[i].y < this.min.y;
                    if (flag2) {
                        this.min.y = this.vecs[i].y;
                    }
                    var flag3 = this.vecs[i].z < this.min.z;
                    if (flag3) {
                        this.min.z = this.vecs[i].z;
                    }
                    var flag4 = this.vecs[i].x > this.max.x;
                    if (flag4) {
                        this.max.x = this.vecs[i].x;
                    }
                    var flag5 = this.vecs[i].y > this.max.y;
                    if (flag5) {
                        this.max.y = this.vecs[i].y;
                    }
                    var flag6 = this.vecs[i].z > this.max.z;
                    if (flag6) {
                        this.max.z = this.vecs[i].z;
                    }
                }
            };
            navMeshInfo.cross = function (p0, p1, p2) {
                return (p1.x - p0.x) * (p2.z - p0.z) - (p2.x - p0.x) * (p1.z - p0.z);
            };
            navMeshInfo.prototype.inPoly = function (p, poly) {
                var num = 0;
                var flag = poly.length < 3;
                var result;
                if (flag) {
                    result = false;
                }
                else {
                    var flag2 = navMeshInfo.cross(this.vecs[poly[0]], p, this.vecs[poly[1]]) < (-num);
                    if (flag2) {
                        result = false;
                    }
                    else {
                        var flag3 = navMeshInfo.cross(this.vecs[poly[0]], p, this.vecs[poly[poly.length - 1]]) > num;
                        if (flag3) {
                            result = false;
                        }
                        else {
                            var i = 2;
                            var num2 = poly.length - 1;
                            var num3 = -1;
                            while (i <= num2) {
                                var num4 = i + num2 >> 1;
                                var flag4 = navMeshInfo.cross(this.vecs[poly[0]], p, this.vecs[poly[num4]]) < (-num);
                                if (flag4) {
                                    num3 = num4;
                                    num2 = num4 - 1;
                                }
                                else {
                                    i = num4 + 1;
                                }
                            }
                            var num5 = navMeshInfo.cross(this.vecs[poly[num3 - 1]], p, this.vecs[poly[num3]]);
                            result = (num5 > num);
                        }
                    }
                }
                return result;
            };
            navMeshInfo.prototype.genBorder = function () {
                var __border = {};
                for (var i0 = 0; i0 < this.nodes.length; i0 = i0 + 1) {
                    var n = this.nodes[i0];
                    for (var i1 = 0; i1 < n.borderByPoint.length; i1 = i1 + 1) {
                        var b = n.borderByPoint[i1];
                        if (__border[b] == undefined) {
                            __border[b] = new navBorder();
                            __border[b].borderName = b;
                            __border[b].nodeA = n.nodeID;
                            __border[b].nodeB = -1;
                            __border[b].pointA = -1;
                        }
                        else {
                            __border[b].nodeB = n.nodeID;
                            if (__border[b].nodeA > __border[b].nodeB) {
                                __border[b].nodeB = __border[b].nodeA;
                                __border[b].nodeB = n.nodeID;
                            }
                            var na = this.nodes[__border[b].nodeA];
                            var nb = this.nodes[__border[b].nodeB];
                            for (var i2 = 0; i2 < na.poly.length; i2 = i2 + 1) {
                                var i = na.poly[i2];
                                if (nb.poly.indexOf(i) >= 0) {
                                    if (__border[b].pointA == -1)
                                        __border[b].pointA = i;
                                    else
                                        __border[b].pointB = i;
                                }
                            }
                            var left = __border[b].pointA;
                            var right = __border[b].pointB;
                            var xd = this.vecs[left].x - this.vecs[right].x;
                            var yd = this.vecs[left].y - this.vecs[right].y;
                            var zd = this.vecs[left].z - this.vecs[right].z;
                            __border[b].length = Math.sqrt(xd * xd + yd * yd + zd * zd);
                            __border[b].center = new navVec3();
                            __border[b].center.x = this.vecs[left].x * 0.5 + this.vecs[right].x * 0.5;
                            __border[b].center.y = this.vecs[left].y * 0.5 + this.vecs[right].y * 0.5;
                            __border[b].center.z = this.vecs[left].z * 0.5 + this.vecs[right].z * 0.5;
                            __border[b].borderName = __border[b].nodeA + "-" + __border[b].nodeB;
                        }
                    }
                }
                var namechange = {}; // Dictionary< string, string> = new Dictionary<string, string>();
                for (var key in __border) {
                    if (__border[key].nodeB < 0) {
                    }
                    else {
                        namechange[key] = __border[key].borderName;
                    }
                }
                this.borders = {}; // new Dictionary<string, navBorder>();
                for (var key in __border) {
                    if (namechange[key] != undefined) {
                        this.borders[namechange[key]] = __border[key];
                    }
                }
                for (var m = 0; m < this.nodes.length; m = m + 1) {
                    var v = this.nodes[m];
                    var newborder = [];
                    for (var nnn = 0; nnn < v.borderByPoint.length; nnn = nnn + 1) {
                        var b = v.borderByPoint[nnn];
                        if (namechange[b] != undefined) {
                            newborder.push(namechange[b]);
                        }
                    }
                    v.borderByPoly = newborder;
                }
            };
            navMeshInfo.LoadMeshInfo = function (s) {
                var j = JSON.parse(s);
                var info = new navMeshInfo();
                var listVec = []; //new List<navVec3>();
                for (var jsonid in j["v"]) {
                    var v3 = new navVec3();
                    v3.x = j["v"][jsonid][0];
                    v3.y = j["v"][jsonid][1];
                    v3.z = j["v"][jsonid][2];
                    listVec.push(v3);
                }
                info.vecs = listVec;
                var polys = [];
                var list = j["p"];
                for (var i = 0; i < list.length; i++) 
                //foreach (var json in j.asDict()["p"].AsList())
                {
                    var json = list[i];
                    var node = new navNode();
                    node.nodeID = i;
                    var poly = []; //new List<int>();
                    for (var tt in json) {
                        poly.push(json[tt]);
                    }
                    node.poly = poly;
                    node.genBorder(); //这里生成的border 是顶点border
                    node.genCenter(info);
                    polys.push(node);
                }
                info.nodes = polys;
                info.calcBound();
                info.genBorder(); //这里会修改为 polyborder，这是个偷懒的修改
                return info;
            };
            return navMeshInfo;
        }());
        framework.navMeshInfo = navMeshInfo;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var NavMeshLoadManager = /** @class */ (function () {
            function NavMeshLoadManager() {
                /**
                *  navMesh偏移量,为方便地图与NavMesh重合设置的临时变量
                */
                this.navMeshVertexOffset = new m4m.math.vector3(0, 0, 0);
                this._navmeshJson = "";
            }
            Object.defineProperty(NavMeshLoadManager.prototype, "navmeshJson", {
                /**
                 * 导航网格Json数据
                 */
                get: function () { return this._navmeshJson; },
                enumerable: false,
                configurable: true
            });
            /**
            * 加载NavMesh
            * @param navMeshUrl 要加载的navMesh完整路径
            * @param app
            * @param onstate 加载反馈信息
            */
            NavMeshLoadManager.prototype.loadNavMesh = function (navMeshUrl, app, onstate) {
                var _this = this;
                if (!app)
                    return;
                this.app = app;
                if (this.navTrans)
                    this.navTrans.parent.removeChild(this.navTrans);
                app.getAssetMgr().load(navMeshUrl, m4m.framework.AssetTypeEnum.Auto, function (s) {
                    if (s.isfinish) {
                        var data = app.getAssetMgr().getAssetByName(navMeshUrl.substring(navMeshUrl.lastIndexOf("/") + 1));
                        _this.navmeshLoaded(data.content, function () {
                            if (onstate) {
                                onstate(s);
                            }
                        });
                    }
                    else if (s.iserror) {
                        if (onstate) {
                            onstate(s);
                        }
                    }
                });
            };
            /**
            * 通过数据 装载NavMesh
            * @param dataStr navmesh 的字符串数据
            * @param callback 完成回调
            */
            NavMeshLoadManager.prototype.loadNavMeshByDate = function (dataStr, app, callback) {
                if (!app)
                    return;
                this.app = app;
                this.navmeshLoaded(dataStr, callback);
            };
            /**
             * 地图寻路网格加载完成
             * @param dataStr 寻路网格信息
             */
            NavMeshLoadManager.prototype.navmeshLoaded = function (dataStr, callback) {
                console.warn("navmeshLoaded");
                if (dataStr == null || dataStr == "")
                    return;
                this._navmeshJson = dataStr;
                if (this.navTrans != null) {
                    // CScene.Instance.removePICKEvent();
                    if (this.navTrans.parent)
                        this.navTrans.parent.removeChild(this.navTrans);
                    this.navTrans.dispose();
                }
                this.navTrans = new m4m.framework.transform();
                this.navTrans.name = "navMesh";
                var HF = m4m.framework.HideFlags;
                this.navTrans.gameObject.hideFlags = HF.HideInHierarchy | HF.DontSave | HF.NotEditable; //不保存不展示不编辑
                var meshD = new m4m.render.meshData();
                meshD.pos = [];
                meshD.trisindex = [];
                var navinfo = m4m.framework.navMeshInfo.LoadMeshInfo(dataStr);
                //var vertexArray: number[] = [];
                for (var i = 0; i < navinfo.vecs.length; i++) {
                    var v = navinfo.vecs[i];
                    var X = v.x - this.navMeshVertexOffset.x;
                    var Y = v.y - this.navMeshVertexOffset.y;
                    var Z = v.z - this.navMeshVertexOffset.z;
                    meshD.pos[i] = new m4m.math.vector3(X, Y, Z);
                }
                var navindexmap = {};
                var indexDatas = [];
                for (var i = 0; i < navinfo.nodes.length; i++) {
                    var poly = navinfo.nodes[i].poly;
                    for (var fc = 0; fc < poly.length - 2; fc++) {
                        var sindex = indexDatas.length / 3;
                        navindexmap[sindex] = i; //做一个三角形序号映射表
                        /**
                        *此处处理顶点索引时按照画面的模式来的，即不需要重复的顶点，如果要在图上画出正确的线框，就用画线框的模式，即需要重复的顶点。
                        其实无论哪种模式，只要跟webgl的api对应上就好。
                        */
                        indexDatas.push(poly[0]);
                        indexDatas.push(poly[fc + 2]);
                        indexDatas.push(poly[fc + 1]);
                    }
                }
                meshD.trisindex = indexDatas;
                var meshFiter = this.navTrans.gameObject.addComponent("meshFilter");
                this.navMesh = this.createMesh(meshD, this.app.webgl);
                meshFiter.mesh = this.navMesh;
                // let meshR = this.navTrans.gameObject.addComponent("meshRenderer") as m4m.framework.meshRenderer;
                // meshR.materials[0] = new m4m.framework.material();
                // meshR.materials[0].setShader(this.app.getAssetMgr().getShader("shader/def"));
                this.app.getScene().addChild(this.navTrans);
                this.navTrans.markDirty();
                this.navigate = new m4m.framework.Navigate(navinfo, navindexmap);
                callback();
            };
            //构建mesh 并返回
            NavMeshLoadManager.prototype.createMesh = function (meshData, webgl) {
                var _mesh = new m4m.framework.mesh();
                // _mesh.setName("NavMesh" + ".mesh.bin");
                _mesh.data = meshData;
                var vf = m4m.render.VertexFormatMask.Position;
                var v32 = _mesh.data.genVertexDataArray(vf);
                var i16 = _mesh.data.genIndexDataArray();
                _mesh.glMesh = new m4m.render.glMesh();
                _mesh.glMesh.initBuffer(webgl, vf, _mesh.data.getVertexCount());
                _mesh.glMesh.uploadVertexSubData(webgl, v32);
                _mesh.glMesh.addIndex(webgl, i16.length);
                _mesh.glMesh.uploadIndexSubData(webgl, 0, i16);
                _mesh.glMesh.initVAO();
                _mesh.submesh = [];
                {
                    var sm = new m4m.framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.start = 0;
                    sm.size = i16.length;
                    sm.line = false;
                    _mesh.submesh.push(sm);
                }
                return _mesh;
            };
            NavMeshLoadManager.prototype.showNavmesh = function (isshow, material) {
                if (material === void 0) { material = null; }
                if (this.navTrans) {
                    this.navTrans.gameObject.visible = isshow;
                    if (!isshow) {
                        this.navTrans.localTranslate = new m4m.math.vector3(0, 0, 0);
                        this.navTrans.markDirty();
                        return;
                    }
                    var compent = this.navTrans.gameObject.getComponent("meshRenderer");
                    if (compent == null) {
                        compent = this.navTrans.gameObject.addComponent("meshRenderer");
                        if (material) {
                            compent.materials = [];
                            compent.materials[0] = material;
                        }
                    }
                    this.navTrans.localTranslate = new m4m.math.vector3(0, 0, 0);
                    this.navTrans.markDirty();
                }
            };
            NavMeshLoadManager.prototype.dispose = function () {
                if (this.navTrans) {
                    this.navTrans.parent.removeChild(this.navTrans);
                    this.navTrans.dispose();
                    this.navTrans = null;
                    this.navMesh.dispose();
                    this.navMesh = null;
                    this.navigate.dispose();
                    this.navigate = null;
                }
            };
            Object.defineProperty(NavMeshLoadManager, "Instance", {
                get: function () {
                    if (NavMeshLoadManager._instance == null)
                        NavMeshLoadManager._instance = new NavMeshLoadManager();
                    return NavMeshLoadManager._instance;
                },
                enumerable: false,
                configurable: true
            });
            NavMeshLoadManager.prototype.moveToPoints = function (startPos, endPos) {
                var navTrans = NavMeshLoadManager.Instance.navTrans;
                var nav = NavMeshLoadManager.Instance.navigate;
                if (!nav)
                    return;
                var StratIndex = NavMeshLoadManager.findtriIndex(startPos, navTrans);
                if (StratIndex == undefined) {
                    var dir = new m4m.math.vector3();
                    var direc = new m4m.math.vector3();
                    m4m.math.vec3Subtract(endPos, startPos, dir);
                    m4m.math.vec3Normalize(dir, dir);
                    for (var i = 0; i < 5; i++) {
                        m4m.math.vec3Clone(dir, direc);
                        m4m.math.vec3ScaleByNum(direc, (i + 1) * 2, direc);
                        var pos = new m4m.math.vector3();
                        m4m.math.vec3Add(startPos, direc, pos);
                        StratIndex = NavMeshLoadManager.findtriIndex(pos, navTrans);
                        if (StratIndex != undefined)
                            break;
                    }
                }
                var endIndex = NavMeshLoadManager.findtriIndex(endPos, navTrans);
                var points = nav.pathPoints(startPos, endPos, StratIndex, endIndex);
                return points;
            };
            /** 获取指定位置的三角形索引*/
            NavMeshLoadManager.findtriIndex = function (point, trans) {
                var result = -1;
                var ray = new m4m.framework.ray(new m4m.math.vector3(point.x, point.y + 500, point.z), new m4m.math.vector3(0, -1, 0));
                var mesh;
                var meshFilter = trans.gameObject.getComponent("meshFilter");
                if (meshFilter != null) {
                    //3d normal mesh
                    mesh = meshFilter.getMeshOutput();
                }
                if (!mesh)
                    return;
                var tempInfo = m4m.math.pool.new_pickInfo();
                if (mesh.intersects(ray, trans.getWorldMatrix(), tempInfo))
                    result = tempInfo.faceId;
                m4m.math.pool.delete_pickInfo(tempInfo);
                return result;
            };
            return NavMeshLoadManager;
        }());
        framework.NavMeshLoadManager = NavMeshLoadManager;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var Navigate = /** @class */ (function () {
            function Navigate(navinfo, navindexmap) {
                this.navinfo = navinfo;
                this.navindexmap = navindexmap;
            }
            Navigate.prototype.pathPoints = function (start, end, startIndex, endIndex) {
                var startVec = new framework.navVec3();
                startVec.x = start.x;
                startVec.y = start.y;
                startVec.z = start.z;
                var endVec = new framework.navVec3();
                endVec.x = end.x;
                endVec.y = end.y;
                endVec.z = end.z;
                var startPoly = this.navindexmap[startIndex];
                var endPoly = this.navindexmap[endIndex];
                if (startPoly >= 0 && endPoly >= 0) {
                    var polyPath = m4m.framework.pathFinding.calcAStarPolyPath(this.navinfo, startPoly, endPoly, endVec, 0.3);
                }
                if (polyPath) {
                    var wayPoints = m4m.framework.pathFinding.calcWayPoints(this.navinfo, startVec, endVec, polyPath);
                    var navmeshWayPoints = [];
                    for (var i = 0; i < wayPoints.length; i++) {
                        navmeshWayPoints[i] = new m4m.math.vector3(wayPoints[i].x, wayPoints[i].realy, wayPoints[i].z);
                    }
                    return navmeshWayPoints;
                }
                else {
                    return null;
                }
            };
            Navigate.prototype.dispose = function () {
                this.navinfo = null;
                this.navindexmap = null;
            };
            return Navigate;
        }());
        framework.Navigate = Navigate;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
///<reference path="MeshInfo.ts" />
//v0.1
var m4m;
///<reference path="MeshInfo.ts" />
//v0.1
(function (m4m) {
    var framework;
    (function (framework) {
        var FindNode = /** @class */ (function () {
            function FindNode() {
                this.nodeid = 0;
                this.pathSessionId = 0;
                this.ParentID = -1;
                this.Open = false;
                this.HValue = 0;
                this.GValue = 0;
                this.ArrivalWall = 0;
            }
            FindNode.prototype.CalcHeuristic = function (info, endPos) {
                var center = info.nodes[this.nodeid].center;
                var num = Math.abs(center.x - endPos.x);
                var num2 = Math.abs(center.z - endPos.z);
                this.HValue = Math.sqrt(num * num + num2 * num2);
            };
            FindNode.prototype.GetCost = function (info, neighborID) {
                var bc = info.nodes[neighborID].center;
                var nc = info.nodes[this.nodeid].center;
                var xd = bc.x - nc.x;
                var yd = bc.y - nc.y;
                var zd = bc.z - nc.z;
                var d = Math.sqrt(xd * xd + yd * yd + zd * zd);
                return d;
            };
            return FindNode;
        }());
        var pathFinding = /** @class */ (function () {
            function pathFinding() {
            }
            pathFinding.calcAStarPolyPath = function (info, startPoly, endPoly, endPos, offset) {
                if (endPos === void 0) { endPos = null; }
                if (offset === void 0) { offset = 0.1; }
                var nodeFind = []; // new List<FindNode>();
                var nodes = info.nodes;
                for (var i = 0; i < nodes.length; i = i + 1) {
                    var navNode = nodes[i];
                    var findNode = new FindNode();
                    findNode.nodeid = navNode.nodeID;
                    nodeFind.push(findNode);
                }
                var flag = endPos === null;
                if (flag) {
                    endPos = info.nodes[endPoly].center.clone();
                }
                var findNode2 = nodeFind[startPoly];
                findNode2.nodeid = startPoly;
                var num = 1;
                var flag2 = false;
                var openList = []; //new List<number>();
                var list2 = []; //new List<number>();
                findNode2.pathSessionId = num;
                openList.push(startPoly);
                var sortfun = function (x, y) {
                    var xFvalue = nodeFind[x].HValue + nodeFind[x].GValue;
                    var yFvalue = nodeFind[y].HValue + nodeFind[y].GValue;
                    if (xFvalue < yFvalue - 0.001)
                        return 1;
                    if (xFvalue > yFvalue + 0.001)
                        return -1;
                    return 0;
                };
                while (openList.length > 0) {
                    var findNode3 = nodeFind[openList[openList.length - 1]];
                    openList.splice(openList.length - 1, 1);
                    list2.push(findNode3.nodeid);
                    var flag3 = findNode3.nodeid === endPoly;
                    if (flag3) {
                        flag2 = true;
                        break;
                    }
                    var linked = info.nodes[findNode3.nodeid].getLinked(info);
                    for (var j = 0; j < linked.length; j = j + 1) {
                        var num2 = linked[j];
                        var flag4 = num2 < 0;
                        if (!flag4) {
                            var findNode4 = nodeFind[num2];
                            var flag5 = findNode4 === null || findNode4.nodeid !== num2;
                            if (flag5) {
                                return null;
                            }
                            var flag6 = findNode4.pathSessionId !== num;
                            if (flag6) {
                                var text = info.nodes[findNode4.nodeid].isLinkTo(info, findNode3.nodeid);
                                var flag7 = text !== null && info.borders[text].length >= offset * 2;
                                if (flag7) {
                                    findNode4.pathSessionId = num;
                                    findNode4.ParentID = findNode3.nodeid;
                                    findNode4.Open = true;
                                    findNode4.CalcHeuristic(info, endPos);
                                    findNode4.GValue = findNode3.GValue + findNode3.GetCost(info, findNode4.nodeid);
                                    openList.push(findNode4.nodeid);
                                    openList.sort(sortfun);
                                    findNode4.ArrivalWall = findNode3.nodeid;
                                }
                            }
                            else {
                                var open = findNode4.Open;
                                if (open) {
                                    var flag8 = findNode4.GValue + findNode4.GetCost(info, findNode3.nodeid) < findNode3.GValue;
                                    if (flag8) {
                                        findNode3.GValue = findNode4.GValue + findNode4.GetCost(info, findNode3.nodeid);
                                        findNode3.ParentID = findNode4.nodeid;
                                        findNode3.ArrivalWall = findNode4.nodeid;
                                    }
                                }
                            }
                        }
                    }
                }
                var list3 = [];
                var flag9 = list2.length > 0;
                if (flag9) {
                    var findNode5 = nodeFind[list2[list2.length - 1]];
                    list3.push(findNode5.nodeid);
                    while (findNode5.ParentID !== -1) {
                        list3.push(findNode5.ParentID);
                        findNode5 = nodeFind[findNode5.ParentID];
                    }
                }
                // var flag10: boolean = !flag2;
                //if (flag10) {
                //    return null;
                //}
                return list3;
            };
            pathFinding.NearAngle = function (a, b) {
                var num = a;
                var flag = a >= 180.0;
                if (flag) {
                    num = 360.0 - a;
                }
                var num2 = b;
                var flag2 = b >= 180.0;
                if (flag2) {
                    num2 = 360.0 - b;
                }
                var flag3 = num < num2;
                var result;
                if (flag3) {
                    result = a;
                }
                else {
                    result = b;
                }
                return result;
            };
            pathFinding.FindPath = function (info, startPos, endPos, offset) {
                if (offset === void 0) { offset = 0.1; }
                var startPoly = -1;
                var endPoly = -1;
                for (var i = 0; i < info.nodes.length; i = i + 1) {
                    var flag = info.inPoly(startPos, info.nodes[i].poly);
                    if (flag) {
                        startPoly = i;
                    }
                    var flag2 = info.inPoly(startPos, info.nodes[i].poly);
                    if (flag2) {
                        endPoly = i;
                    }
                }
                var polyPath = pathFinding.calcAStarPolyPath(info, startPoly, endPoly, endPos, offset);
                return pathFinding.calcWayPoints(info, startPos, endPos, polyPath, offset);
            };
            pathFinding.calcWayPoints = function (info, startPos, endPos, polyPath, offset) {
                if (offset === void 0) { offset = 0.1; }
                var wayPoints = []; // new List<navVec3>();
                if (polyPath.length == 0 || startPos == null || endPos == null) {
                    return null;
                }
                var lastPoint = startPos;
                var groupborder = [];
                // 保证从起点到终点的顺序
                var triPathList = polyPath.reverse();
                startPos.realy = startPos.y;
                endPos.realy = endPos.y;
                wayPoints.push(startPos);
                var ipoly = 0; //从第0个poly 开始检查
                var dirLeft = null;
                var ipolyLeft = -1;
                var dirRight = null;
                var ipolyRight = -1;
                var breakDir = 0;
                var posLeft = null;
                var posRight = null;
                // let center:navVec3=null;
                var posNow = startPos.clone();
                for (var c = 0; c < 100; c++) //最多循环100次
                 {
                    for (var i = ipoly; i < triPathList.length; i++) {
                        if (i === triPathList.length - 1) //最后一节
                         {
                            if (dirLeft == null || dirRight == null) {
                                breakDir = 0;
                                break;
                            }
                            else {
                                var dirFinal = m4m.framework.navVec3.NormalAZ(posNow, endPos);
                                var a1 = m4m.framework.navVec3.Angle(dirLeft, dirFinal);
                                var b1 = m4m.framework.navVec3.Angle(dirRight, dirFinal);
                                var flag4 = a1 * b1 > 0.0;
                                if (a1 * b1 > 0.0) {
                                    if (a1 > 0.0) {
                                        breakDir = 1;
                                    }
                                    else {
                                        breakDir = -1;
                                    }
                                }
                                else {
                                    breakDir = 0;
                                    break;
                                }
                            }
                        }
                        else //检查是否通过
                         {
                            //寻找边
                            var n1 = triPathList[i];
                            var n2 = triPathList[i + 1];
                            var bname = n1 + "-" + n2;
                            if (n2 < n1) {
                                bname = n2 + "-" + n1;
                            }
                            var border = info.borders[bname];
                            var pointA = m4m.framework.navVec3.Border(info.vecs[border.pointA], info.vecs[border.pointB], offset);
                            var pointB = m4m.framework.navVec3.Border(info.vecs[border.pointB], info.vecs[border.pointA], offset);
                            var dist1 = m4m.framework.navVec3.DistAZ(posNow, pointA);
                            var dist2 = m4m.framework.navVec3.DistAZ(posNow, pointB);
                            if (dist1 < 0.001 || dist2 < 0.001) {
                                continue;
                            }
                            if (dirLeft == null) {
                                dirLeft = m4m.framework.navVec3.NormalAZ(posNow, pointA);
                                posLeft = pointA.clone();
                                ipolyLeft = i;
                            }
                            if (dirRight == null) {
                                dirRight = m4m.framework.navVec3.NormalAZ(posNow, pointB);
                                posRight = pointB.clone();
                                ipolyRight = i;
                            }
                            var adir = m4m.framework.navVec3.Angle(dirLeft, dirRight);
                            if (adir < 0.0) //change
                             {
                                var navVec7 = dirLeft;
                                var navVec8 = posLeft;
                                var num12 = ipolyLeft;
                                dirLeft = dirRight;
                                posLeft = posRight;
                                ipolyLeft = ipolyRight;
                                dirRight = navVec7;
                                posRight = navVec8;
                                ipolyRight = num12;
                            }
                            if (ipolyLeft != i || ipolyRight != i) //检查是否能穿越
                             {
                                var ndirLeft = m4m.framework.navVec3.NormalAZ(posNow, pointA);
                                var ndirRight = m4m.framework.navVec3.NormalAZ(posNow, pointB);
                                var nadir = m4m.framework.navVec3.Angle(ndirLeft, ndirRight);
                                if (nadir < 0.0) //change
                                 {
                                    var navVec11 = ndirLeft;
                                    var navVec12 = pointA;
                                    ndirLeft = ndirRight;
                                    pointA = pointB;
                                    ndirRight = navVec11;
                                    pointB = navVec12;
                                }
                                var aLL = m4m.framework.navVec3.Angle(dirLeft, ndirLeft); //>0 右侧，<0 左侧
                                var aRL = m4m.framework.navVec3.Angle(dirRight, ndirLeft);
                                var aLR = m4m.framework.navVec3.Angle(dirLeft, ndirRight);
                                var aRR = m4m.framework.navVec3.Angle(dirRight, ndirRight);
                                if ((aLL < 0 && aLR < 0)) //无法穿越
                                 {
                                    breakDir = -1;
                                    break;
                                }
                                if (aRL > 0.0 && aRR > 0.0) //无法穿越
                                 {
                                    breakDir = 1;
                                    break;
                                }
                                if (aLL > 0.0 && aRL < 0.0) {
                                    dirLeft = ndirLeft;
                                    posLeft = pointA;
                                    ipolyLeft = i;
                                    //groupborder.push(border);
                                }
                                if (aLR > 0.0 && aRR < 0.0) {
                                    dirRight = ndirRight;
                                    posRight = pointB;
                                    ipolyRight = i;
                                    //groupborder.push(border);
                                }
                            }
                        }
                    }
                    if (breakDir == 0) {
                        break;
                    }
                    else {
                        if (breakDir == -1) {
                            // for(let key in groupborder)
                            // {
                            //     let bor=groupborder[key];
                            //     let point=this.intersectBorder(info.vecs[bor.pointA],info.vecs[bor.pointB],posLeft,lastPoint);
                            //     if(point)
                            //     {
                            //         point.realy=point.y;
                            //         wayPoints.push(point);
                            //     }
                            // }
                            // lastPoint=posLeft;
                            // groupborder=[];
                            wayPoints.push(posLeft.clone());
                            posNow = posLeft;
                            ipoly = ipolyLeft;
                        }
                        else {
                            // for(let key in groupborder)
                            // {
                            //     let bor=groupborder[key];
                            //     let point=this.intersectBorder(info.vecs[bor.pointA],info.vecs[bor.pointB],posLeft,lastPoint);
                            //     if(point)
                            //     {
                            //         point.realy=point.y;
                            //         wayPoints.push(point);
                            //     }
                            // }
                            // lastPoint=posLeft;
                            // groupborder=[];
                            wayPoints.push(posRight.clone());
                            posNow = posRight;
                            ipoly = ipolyRight;
                        }
                        dirLeft = null;
                        dirRight = null;
                        ipolyLeft = -1;
                        ipolyRight = -1;
                    }
                }
                wayPoints.push(endPos);
                return wayPoints;
            };
            pathFinding.intersectBorder = function (a, b, c, d) {
                //线段ab的法线N1  
                var nx1 = (b.z - a.z), ny1 = (a.x - b.x);
                //线段cd的法线N2  
                var nx2 = (d.z - c.z), ny2 = (c.x - d.x);
                //两条法线做叉乘, 如果结果为0, 说明线段ab和线段cd平行或共线,不相交  
                var denominator = nx1 * ny2 - ny1 * nx2;
                if (denominator == 0) {
                    return null;
                }
                //在法线N2上的投影  
                var distC_N2 = nx2 * c.x + ny2 * c.z;
                var distA_N2 = nx2 * a.x + ny2 * a.z - distC_N2;
                var distB_N2 = nx2 * b.x + ny2 * b.z - distC_N2;
                // 点a投影和点b投影在点c投影同侧 (对点在线段上的情况,本例当作不相交处理);  
                if (distA_N2 * distB_N2 >= 0) {
                    return null;
                }
                //  
                //判断点c点d 和线段ab的关系, 原理同上  
                //  
                //在法线N1上的投影  
                var distA_N1 = nx1 * a.x + ny1 * a.z;
                var distC_N1 = nx1 * c.x + ny1 * c.z - distA_N1;
                var distD_N1 = nx1 * d.x + ny1 * d.z - distA_N1;
                if (distC_N1 * distD_N1 >= 0) {
                    return null;
                }
                //计算交点坐标  
                var fraction = distA_N2 / denominator;
                var dx = fraction * ny1, dz = -fraction * nx1;
                var newpoint = new framework.navVec3();
                framework.navVec3.lerp(a, b, -fraction, newpoint);
                return newpoint;
                //return { x: a.x + dx , y: a.z + dz };  
            };
            return pathFinding;
        }());
        framework.pathFinding = pathFinding;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var RVOManager = /** @class */ (function () {
            function RVOManager() {
                this.sim = new RVO.Simulator(1, 60, 20, 20, 5, 1.0, 0.1, [0, 0]);
                this.transforms = [];
                this.goals = [];
                this.radius = [];
                this.attackRanges = [];
                this.speeds = [];
                this.map = {};
                this.isRunning = false;
                this.currMoveDir = new m4m.math.vector2();
                this._RoadPoints = [];
            }
            RVOManager.prototype.setRoadPoints = function (goalQueue) {
                var _this = this;
                if (!goalQueue || goalQueue.length < 1)
                    return;
                //clear history
                this._RoadPoints.forEach(function (sub) {
                    if (sub && sub != _this.lastGoal)
                        m4m.math.pool.delete_vector3(sub);
                });
                this._RoadPoints.length = 0;
                for (var i = 0; i < goalQueue.length; i++) {
                    var v3 = m4m.math.pool.new_vector3();
                    m4m.math.vec3Clone(goalQueue[i], v3);
                    this._RoadPoints.push(v3);
                }
                this.currGoal = this._RoadPoints.pop();
                this.goals[0][0] = this.currGoal.x;
                this.goals[0][1] = this.currGoal.z;
            };
            RVOManager.prototype.addAgent = function (key, transform, radius, attackRanges, speed) {
                var index = this.sim.agents.length;
                var current_position = [transform.localTranslate.x, transform.localTranslate.z];
                this.transforms.push(transform);
                this.attackRanges.push(attackRanges);
                this.radius.push(radius);
                this.speeds.push(speed);
                this.goals.push(current_position);
                this.sim.addAgent(current_position);
                this.sim.agents[index].id = key;
                this.sim.agents[index].radius = radius;
                this.sim.agents[index].maxSpeed = speed;
                this.map[key] = index; // 添加 key
                if (index == 0) {
                    this.sim.agents[0].neighborDist = 0; // 玩家无视小怪
                }
                this.isRunning = true;
            };
            RVOManager.prototype.removeAgent = function (key) {
                var offset = this.map[key];
                this.transforms.splice(offset, 1);
                this.attackRanges.splice(offset, 1);
                this.radius.splice(offset, 1);
                this.speeds.splice(offset, 1);
                this.goals.splice(offset, 1);
                this.sim.agents.splice(offset, 1);
                this.reBuildHashMap();
            };
            RVOManager.prototype.reBuildHashMap = function () {
                for (var i = 0; i < this.sim.agents.length; i++) {
                    this.map[this.sim.agents[i].id] = i;
                }
                this.sim.kdTree.agents = [];
                this.sim.kdTree.agentTree = [];
                this.sim.kdTree.obstacleTree = 0;
            };
            RVOManager.prototype.getTransformByKey = function (key) {
                var offset = this.map[key];
                return this.transforms[offset];
            };
            RVOManager.prototype.setRadius = function (id, value) {
                var i = this.map[id];
                this.sim.agents[i].radius = value;
            };
            RVOManager.prototype.setSpeed = function (id, value) {
                var i = this.map[id];
                this.sim.agents[i].maxSpeed = value;
            };
            RVOManager.prototype.setAttackRange = function (id, value) {
                var i = this.map[id];
                this.attackRanges[i] = value;
            };
            RVOManager.prototype.disable = function () {
                this.isRunning = false;
            };
            RVOManager.prototype.enable = function () {
                this.isRunning = true;
                // 更新位置
                for (var i in this.transforms) {
                    this.sim.agents[i].position = [this.transforms[i].localTranslate.x, this.transforms[i].localTranslate.z];
                }
            };
            RVOManager.prototype.update = function () {
                if (this.isRunning && (this.transforms.length >= 1)) {
                    this.RVO_check(this.sim, this.goals);
                    this.RVO_walking(this.sim, this.goals);
                    this.updateTransform(this.sim);
                }
            };
            RVOManager.prototype.isAlmostStatic = function () {
                var threshold = 0.1;
                var amount = 0;
                for (var i = 0; i < this.sim.agents.length; i++) {
                    if (this.sim.agents[i].prefVelocity != null) {
                        if (this.sim.agents[i].prefVelocity[0] < 0.01 && this.sim.agents[i].prefVelocity[1] < 0.01) {
                            amount++;
                        }
                    }
                }
                if (amount / this.sim.agents.length >= threshold) {
                    return true;
                }
                return false;
            };
            RVOManager.prototype.RVO_walking = function (sim, goals) {
                // 据当前目标重新获取目标方向向量
                for (var i = 0, len = sim.agents.length; i < len; i++) {
                    if (sim.agents[i] != null) {
                        var goalVector = RVO.Vector.subtract(goals[i], sim.agents[i].position);
                        if (RVO.Vector.absSq(goalVector) > 1) {
                            goalVector = RVO.Vector.normalize(goalVector);
                        }
                        sim.agents[i].prefVelocity = goalVector; // 更新速度向量
                    }
                }
                sim.doStep(); // 移动一帧
            };
            RVOManager.prototype.updateTransform = function (sim) {
                for (var i = 0; i < sim.agents.length; i++) {
                    this.transforms[i].localTranslate.x = sim.agents[i].position[0];
                    this.transforms[i].localTranslate.z = sim.agents[i].position[1];
                    // Y轴
                    if (i == 0 && this.currGoal && this.lastGoal) {
                        var pos = this.transforms[i].localTranslate;
                        var nowDir = m4m.math.pool.new_vector2();
                        this.cal2dDir(this.lastGoal, pos, nowDir);
                        var nowLen = m4m.math.vec2Length(nowDir);
                        var tLen = m4m.math.vec2Length(this.currMoveDir);
                        var y = m4m.math.numberLerp(this.lastGoal.y, this.currGoal.y, nowLen / tLen);
                        if (!isNaN(y)) {
                            pos.y = m4m.math.numberLerp(this.lastGoal.y, this.currGoal.y, nowLen / tLen);
                        }
                        //console.error(`nowLen/tLen :${nowLen}/${tLen}   ,  pos y:${pos.y}  ,this.lastGoal: ${this.lastGoal.x} ,${this.lastGoal.y} ,${this.lastGoal.z} `);
                        m4m.math.pool.delete_vector2(nowDir);
                    }
                    this.transforms[i].markDirty();
                }
            };
            // subGoal = [];
            // private generateRandomSubGoal(position, velocity) {
            //     let monster_velocity    = new m4m.math.vector2(velocity[0], velocity[1]);
            //     m4m.math.vec2Normalize(monster_velocity, monster_velocity);
            //     let direction_cos       = m4m.math.vec2Dot(monster_velocity, new m4m.math.vector2(1.0, 0.0));
            //     let direction_sin       = Math.sqrt(1 - direction_cos * direction_cos);
            //     // let monster_direction   = Math.acos(direction_cos);
            //     let monster_position    = new m4m.math.vector3(position[0], position[1], 0);
            //     // let monster_Matrix      = new m4m.math.matrix(new Float32Array([
            //     //     direction_cos, direction_sin, 0, 0,
            //     //     -direction_sin, direction_cos, 0, 0,
            //     //     0, 0, 1, 0,
            //     //     0, 0, 0, 1
            //     // ]));
            //
            //     let subGoal_Position = [
            //         [1.0, 0.0],
            //         [-1.0, 0.0],
            //         [0.0, 1.0],
            //         [0.0, -1.0],
            //     ];
            //     let p = subGoal_Position[Math.round(Math.random() * 6)];
            //     // m4m.math.matrixMultiply(monster_Matrix);
            // }
            RVOManager.prototype.RVO_check = function (sim, goals) {
                // 玩家根据 NavMesh 切换目标
                if (this.currGoal) {
                    var player = this.transforms[0];
                    //达到目标点
                    var v2_0 = m4m.math.pool.new_vector2();
                    v2_0.x = player.localTranslate.x;
                    v2_0.y = player.localTranslate.z;
                    var v2_1 = m4m.math.pool.new_vector2();
                    v2_1.x = this.currGoal.x;
                    v2_1.y = this.currGoal.z;
                    var dis = m4m.math.vec2Distance(v2_0, v2_1);
                    if (dis < 0.01) {
                        if (this.currGoal) {
                            if (this.lastGoal)
                                m4m.math.pool.delete_vector3(this.lastGoal);
                            this.lastGoal = this.currGoal;
                            this.currGoal = null;
                            goals[0] = sim.agents[0].position;
                            sim.agents[0].radius = this.radius[0];
                        }
                        if (this._RoadPoints && this._RoadPoints.length > 0) {
                            this.currGoal = this._RoadPoints.pop();
                            this.cal2dDir(this.lastGoal, this.currGoal, this.currMoveDir);
                            goals[0] = [this.currGoal.x, this.currGoal.z];
                            sim.agents[0].radius = 0.1;
                        }
                    }
                }
                else if (this._RoadPoints && this._RoadPoints.length > 0) {
                    //切换下一目标
                    this.currGoal = this._RoadPoints.pop();
                    goals[0] = [this.currGoal.x, this.currGoal.z];
                    sim.agents[0].radius = 0.1;
                }
                // 小怪的目标
                for (var i = 1, len = sim.agents.length; i < len; i++) {
                    var range = RVO.Vector.absSq(RVO.Vector.subtract(sim.agents[i].position, sim.agents[0].position));
                    if (range < this.attackRanges[i]) {
                        goals[i] = sim.agents[i].position; // Stop
                        sim.agents[i].neighborDist = 0;
                    }
                    else {
                        goals[i] = sim.agents[0].position;
                        sim.agents[i].neighborDist = sim.agentDefaults.neighborDist;
                    }
                }
            };
            RVOManager.prototype.cal2dDir = function (oPos, tPos, out) {
                if (!oPos || !tPos || !out)
                    return;
                var ov2 = m4m.math.pool.new_vector2();
                ov2.x = oPos.x;
                ov2.y = oPos.z;
                var tv2 = m4m.math.pool.new_vector2();
                tv2.x = tPos.x;
                tv2.y = tPos.z;
                m4m.math.vec2Subtract(tv2, ov2, out);
                m4m.math.pool.delete_vector2(ov2);
                m4m.math.pool.delete_vector2(tv2);
            };
            return RVOManager;
        }());
        framework.RVOManager = RVOManager;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @private
         */
        var EffectSystemData = /** @class */ (function () {
            function EffectSystemData() {
                this.beLoop = false;
                this.elementDic = {};
            }
            EffectSystemData.prototype.clone = function () {
                var data = new EffectSystemData();
                data.life = this.life;
                data.beLoop = this.beLoop;
                for (var key in this.elementDic) {
                    data.elementDic[key] = this.elementDic[key].clone();
                }
                return data;
            };
            EffectSystemData.prototype.dispose = function () {
                for (var key in this.elementDic) {
                    this.elementDic[key].dispose();
                    delete this.elementDic[key];
                }
            };
            return EffectSystemData;
        }());
        framework.EffectSystemData = EffectSystemData;
        /**
         * @private
         */
        var EffectElement = /** @class */ (function () {
            function EffectElement(_data) {
                //在effectbatcher中顶点的开始位置
                this.startVboIndex = 0;
                //在effectbatcher中索引的开始位置，用来动态计算当前要渲染到哪个顶点，主要针对delaytime类型的特效重播时的处理
                this.startEboIndex = 0;
                //在effectbatcher中索引的结束位置，用来动态计算当前要渲染到哪个顶点，主要针对delaytime类型的特效重播时的处理
                this.endEboIndex = 0;
                this.delayTime = 0;
                this.actionActive = false; //当前帧action状态
                this.loopFrame = Number.MAX_VALUE; //循环帧数
                this.active = true; //激活状态
                this.data = _data;
                this.name = this.data.name;
                this.timelineFrame = {};
                this.delayTime = _data.delayTime;
                this.initActions();
                this.recordElementLerpAttributes();
            }
            EffectElement.prototype.recordElementLerpAttributes = function () {
                if (this.data.timelineFrame != undefined) {
                    for (var i in this.data.timelineFrame) {
                        var frameData = this.data.timelineFrame[i];
                        if (frameData.frameIndex != -1) {
                            if (frameData.lerpDatas != undefined && frameData.lerpDatas.length != 0) {
                                this.recordLerpValues(frameData);
                            }
                            else if (frameData.attrsData != undefined) {
                                if (this.timelineFrame[frameData.frameIndex] == undefined) {
                                    this.timelineFrame[frameData.frameIndex] = new EffectFrameData();
                                    this.timelineFrame[frameData.frameIndex].attrsData = new EffectAttrsData();
                                    this.timelineFrame[frameData.frameIndex].frameIndex = frameData.frameIndex;
                                }
                                for (var k in frameData.attrsData) {
                                    this.timelineFrame[frameData.frameIndex].attrsData.setLerpAttribute(k, frameData.attrsData.getAttribute(k));
                                }
                            }
                        }
                    }
                }
            };
            /**
             * 录制插值数据
             *
             * @private
             * @param {EffectElementData} elementData
             * @param {EffectFrameData} effectFrameData
             *
             * @memberof effectSystem
             */
            EffectElement.prototype.recordLerpValues = function (effectFrameData) {
                //每一帧所需要进行插值的属性分别进行插值
                for (var i in effectFrameData.lerpDatas) {
                    if (effectFrameData.lerpDatas[i].type == EffectLerpTypeEnum.Linear) {
                        //effectFrameData.lerpDatas[i].attrsList 每一帧中的需要插值的列表
                        for (var key in effectFrameData.lerpDatas[i].attrsList) {
                            //attrname 插值的属性名
                            var attrname = effectFrameData.lerpDatas[i].attrsList[key];
                            //对该属性进行插值
                            this.recordLerp(effectFrameData, effectFrameData.lerpDatas[i], attrname);
                        }
                    }
                }
            };
            // private newFrameData: EffectFrameData;
            /**
             * 记录插值
             */
            EffectElement.prototype.recordLerp = function (effectFrameData, lerpData, key) {
                var fromFrame = lerpData.fromFrame;
                var toFrame = lerpData.toFrame.getValue();
                var toVal = lerpData.attrsData.getAttribute(key);
                if (effectFrameData.attrsData[key] == undefined) {
                    effectFrameData.attrsData.initAttribute(key);
                }
                var fromVal = effectFrameData.attrsData.getAttribute(key);
                //在需要进行插值的帧里面进行插值
                for (var i = fromFrame + 1; i <= toFrame; i++) {
                    var outVal = void 0;
                    if (fromVal instanceof m4m.math.vector3) {
                        outVal = new m4m.math.vector3();
                        m4m.math.vec3SLerp(fromVal, toVal, (i - fromFrame) / (toFrame - fromFrame), outVal);
                    }
                    else if (fromVal instanceof m4m.math.vector2) {
                        outVal = new m4m.math.vector2();
                        m4m.math.vec2SLerp(fromVal, toVal, (i - fromFrame) / (toFrame - fromFrame), outVal);
                    }
                    else if (typeof (fromVal) === 'number') {
                        outVal = m4m.math.numberLerp(fromVal, toVal, (i - fromFrame) / (toFrame - fromFrame));
                    }
                    var newFrameData = this.timelineFrame[i];
                    if (newFrameData == undefined) {
                        newFrameData = new EffectFrameData();
                        newFrameData.attrsData = new EffectAttrsData();
                        newFrameData.frameIndex = i;
                        this.timelineFrame[i] = newFrameData;
                    }
                    newFrameData.attrsData.setLerpAttribute(key, outVal);
                }
            };
            EffectElement.prototype.initActions = function () {
                this.actions = [];
                var action;
                for (var key in this.data.actionData) {
                    var actiondata = this.data.actionData[key];
                    switch (actiondata.actionType) {
                        case "linear":
                            action = new framework.LinearAction();
                            break;
                        case "destroy":
                            action = new framework.DestroyAction();
                            break;
                        case "loop":
                            action = new framework.LoopAction();
                            break;
                        case "destroy":
                            action = new framework.DestroyAction();
                            break;
                        case "rotation":
                            action = new framework.RotationAction();
                            break;
                        case "breath":
                            action = new framework.BreathAction();
                            break;
                        case "uvroll":
                            action = new framework.UVRollAction();
                            break;
                        case "uvsprite":
                            action = new framework.UVSpriteAnimationAction();
                            break;
                        case "rosepath":
                            action = new framework.RoseCurveAction();
                            break;
                        case "trail":
                            action = new framework.TrailAction();
                            break;
                    }
                    action.init(actiondata.startFrame, actiondata.endFrame, actiondata.params, this);
                    this.actions.push(action);
                }
            };
            EffectElement.prototype.update = function () {
                if (this.curAttrData == undefined || this.curAttrData == null)
                    return;
                if (this.active) {
                    // if (this.curAttrData.startEuler)
                    // {
                    //     m4m.math.quatFromEulerAngles(this.curAttrData.startEuler.x, this.curAttrData.startEuler.y, this.curAttrData.startEuler.z, this.curAttrData.startRotation);
                    // }
                    if (this.curAttrData.euler != undefined) {
                        // console.log("euler:" + this.curAttrData.euler.toString());
                        m4m.math.quatFromEulerAngles(this.curAttrData.euler.x, this.curAttrData.euler.y, this.curAttrData.euler.z, this.curAttrData.rotationByEuler);
                    }
                    this.updateElementRotation();
                    m4m.math.matrixMakeTransformRTS(this.curAttrData.pos, this.curAttrData.scale, this.curAttrData.localRotation, this.curAttrData.matrix);
                }
                else {
                    this.curAttrData.resetMatrix();
                }
            };
            EffectElement.prototype.updateElementRotation = function () {
                var cameraTransform = m4m.framework.sceneMgr.app.getScene().mainCamera.gameObject.transform;
                var worldRotation = m4m.math.pool.new_quaternion();
                var localRotation = m4m.math.pool.new_quaternion();
                if (this.curAttrData.renderModel != RenderModel.None) {
                    var invTransformRotation = m4m.math.pool.new_quaternion();
                    var worldTranslation = m4m.math.pool.new_vector3();
                    var translation = m4m.math.pool.new_vector3();
                    m4m.math.vec3Clone(this.curAttrData.pos, translation);
                    if (this.transform != undefined) {
                        m4m.math.matrixTransformVector3(translation, this.transform.getWorldMatrix(), worldTranslation);
                    }
                    if (this.curAttrData.renderModel == RenderModel.BillBoard) {
                        m4m.math.quatLookat(worldTranslation, cameraTransform.getWorldTranslate(), worldRotation);
                    }
                    else if (this.curAttrData.renderModel == RenderModel.HorizontalBillBoard) {
                        worldRotation.x = -0.5;
                        worldRotation.y = 0.5;
                        worldRotation.z = 0.5;
                        worldRotation.w = 0.5;
                    }
                    else if (this.curAttrData.renderModel == RenderModel.VerticalBillBoard) {
                        var forwardTarget = m4m.math.pool.new_vector3();
                        m4m.math.vec3Clone(cameraTransform.getWorldTranslate(), forwardTarget);
                        forwardTarget.y = worldTranslation.y;
                        m4m.math.quatLookat(worldTranslation, forwardTarget, worldRotation);
                        m4m.math.pool.delete_vector3(forwardTarget);
                    }
                    else if (this.curAttrData.renderModel == RenderModel.StretchedBillBoard) {
                        m4m.math.quatMultiply(worldRotation, this.curAttrData.rotationByEuler, this.curAttrData.localRotation);
                        m4m.math.quatLookat(worldTranslation, cameraTransform.getWorldTranslate(), worldRotation);
                        var lookRot = new m4m.math.quaternion();
                        m4m.math.quatClone(this.transform.getWorldRotate(), invTransformRotation);
                        m4m.math.quatInverse(invTransformRotation, invTransformRotation);
                        m4m.math.quatMultiply(invTransformRotation, worldRotation, lookRot);
                        var inverRot = m4m.math.pool.new_quaternion();
                        m4m.math.quatInverse(this.curAttrData.localRotation, inverRot);
                        m4m.math.quatMultiply(inverRot, lookRot, lookRot);
                        var angle = m4m.math.pool.new_vector3();
                        m4m.math.quatToEulerAngles(lookRot, angle);
                        m4m.math.quatFromEulerAngles(0, angle.y, 0, lookRot);
                        m4m.math.quatMultiply(this.curAttrData.localRotation, lookRot, this.curAttrData.localRotation);
                        m4m.math.pool.delete_quaternion(inverRot);
                        m4m.math.pool.delete_vector3(angle);
                        m4m.math.pool.delete_quaternion(lookRot);
                        return;
                    }
                    else if (this.curAttrData.renderModel == RenderModel.Mesh) {
                        framework.EffectUtil.quatLookatZ(worldTranslation, cameraTransform.getWorldTranslate(), worldRotation);
                    }
                    m4m.math.quatMultiply(worldRotation, this.curAttrData.rotationByEuler, worldRotation);
                    //消除transform组件对粒子本身的影响
                    m4m.math.quatClone(this.transform.gameObject.transform.getWorldRotate(), invTransformRotation);
                    m4m.math.quatInverse(invTransformRotation, invTransformRotation);
                    m4m.math.quatMultiply(invTransformRotation, worldRotation, this.curAttrData.localRotation);
                    // m4m.math.quatMultiply(invTransformRotation, worldRotation, localRotation);
                    // m4m.math.quatMultiply(this.curAttrData.startRotation, localRotation, this.curAttrData.localRotation);
                    m4m.math.pool.delete_vector3(translation);
                    m4m.math.pool.delete_vector3(worldTranslation);
                    m4m.math.pool.delete_quaternion(invTransformRotation);
                }
                else {
                    m4m.math.quatMultiply(worldRotation, this.curAttrData.rotationByEuler, this.curAttrData.localRotation);
                    // m4m.math.quatMultiply(worldRotation, this.curAttrData.rotationByEuler, localRotation);
                    // m4m.math.quatMultiply(localRotation, this.curAttrData.startRotation, this.curAttrData.localRotation);
                }
                m4m.math.pool.delete_quaternion(localRotation);
                m4m.math.pool.delete_quaternion(worldRotation);
            };
            /**
             * 当前帧的数据是否有变化，有变化才需要去刷新batcher，否则直接用当前batcher中的数据去提交渲染即可。
             * 在以下三种情况下，数据都是变化的，都需要刷新bacther：
             * 1、timeline中有当前帧
             * 2、renderModel不是none
             * 3、有action在刷新
             * @param frameIndex
             */
            EffectElement.prototype.isCurFrameNeedRefresh = function (frameIndex) {
                if (this.timelineFrame[frameIndex] != undefined) {
                    return true;
                }
                if (this.curAttrData != undefined && this.curAttrData.renderModel != RenderModel.None) {
                    return true;
                }
                return this.actionActive;
            };
            EffectElement.prototype.setActive = function (_active) {
                if (this.active == _active)
                    return;
                this.active = _active;
                if (this.active) {
                }
                else {
                    this.curAttrData.resetMatrix();
                }
            };
            EffectElement.prototype.dispose = function () {
                this.data.dispose();
                this.curAttrData = null;
                this.actions.length = 0;
                delete this.timelineFrame;
            };
            return EffectElement;
        }());
        framework.EffectElement = EffectElement;
        /**
         * @private
         */
        var EffectElementData = /** @class */ (function () {
            function EffectElementData() {
                this.delayTime = 0;
            }
            EffectElementData.prototype.clone = function () {
                var elementdata = new EffectElementData();
                elementdata.name = this.name;
                elementdata.type = this.type;
                elementdata.refFrom = this.refFrom;
                elementdata.beloop = this.beloop;
                elementdata.actionData = [];
                elementdata.timelineFrame = [];
                if (this.initFrameData)
                    elementdata.initFrameData = this.initFrameData.clone();
                if (this.emissionData) {
                    elementdata.emissionData = this.emissionData.clone();
                }
                for (var key in this.timelineFrame) {
                    if (this.timelineFrame[key]) {
                        elementdata.timelineFrame[key] = this.timelineFrame[key].clone();
                    }
                }
                for (var key in this.actionData) {
                    if (this.actionData[key]) {
                        elementdata.actionData[key] = this.actionData[key].clone();
                    }
                }
                return elementdata;
            };
            EffectElementData.prototype.dispose = function () {
                if (this.actionData)
                    this.actionData.length = 0;
                if (this.initFrameData)
                    this.initFrameData.dispose();
                for (var key in this.timelineFrame) {
                    this.timelineFrame[key].dispose();
                }
                delete this.timelineFrame;
            };
            return EffectElementData;
        }());
        framework.EffectElementData = EffectElementData;
        /**
         * @private
         */
        var EffectAttrsData = /** @class */ (function () {
            function EffectAttrsData() {
                this.uv = new m4m.math.vector2(1, 1);
                this.renderModel = RenderModel.None;
                this.matrix = new m4m.math.matrix();
                /**
                 * lerp，action更新euler，再由euler合成rotationByEuler。
                 * 下一步拿rotationByEuler乘以billboard生成的四元数得到最终的localRotation。
                 * 再用localRotation,pos，scale计算出最终的matrix。
                 * matrix作用每个顶点，然后去渲染。
                 *
                 * @type {math.quaternion}
                 * @memberof EffectAttrsData
                 */
                this.rotationByEuler = new m4m.math.quaternion();
                // public startEuler: math.vector3;
                // public startRotation: math.quaternion = new math.quaternion();
                /**
                 * 本地旋转(经过各种lerp和action后计算的最终值)
                 *
                 * @type {math.quaternion}
                 * @memberof EffectAttrsData
                 */
                this.localRotation = new m4m.math.quaternion();
            }
            // public localAxisX:m4m.math.vector3 = new m4m.math.vector3(1,0,0);
            // public localAxisY:m4m.math.vector3 = new m4m.math.vector3(0,1,0);
            // public localAxisZ:m4m.math.vector3 = new m4m.math.vector3(0,0,1);
            /**
             * 将计算出来的插值存入到帧属性数据
             *
             * @param {string} attribute
             * @param {*} val
             *
             * @memberof EffectAttrsData
             */
            EffectAttrsData.prototype.setLerpAttribute = function (attribute, val) {
                switch (attribute) {
                    case "pos":
                        this.pos = val;
                        break;
                    case "scale":
                        this.scale = val;
                        break;
                    case "euler":
                        this.euler = val;
                        break;
                    case "alpha":
                        this.alpha = val;
                        break;
                    case "uv":
                        this.uv = val;
                        break;
                    case "color":
                        this.color = val;
                        break;
                    case "tilling":
                        console.log("tilling 逻辑上不需要插值");
                        break;
                }
            };
            EffectAttrsData.prototype.getAttribute = function (attribute) {
                switch (attribute) {
                    case "pos":
                        return m4m.math.pool.clone_vector3(this.pos);
                    case "scale":
                        return m4m.math.pool.clone_vector3(this.scale);
                    case "euler":
                        return m4m.math.pool.clone_vector3(this.euler);
                    case "alpha":
                        return this.alpha;
                    case "color":
                        return m4m.math.pool.clone_vector3(this.color);
                    case "tilling":
                        return m4m.math.pool.clone_vector2(this.tilling);
                    case "uv":
                        return m4m.math.pool.clone_vector2(this.uv);
                    case "mat":
                        return this.mat.clone();
                    case "renderModel":
                        return this.renderModel;
                    case "rotationByEuler":
                        return m4m.math.pool.clone_quaternion(this.rotationByEuler);
                    case "localRotation":
                        return m4m.math.pool.clone_quaternion(this.localRotation);
                    // case "startRotation":
                    //     return m4m.math.pool.clone_quaternion(this.startRotation);
                    case "matrix":
                        return m4m.math.pool.clone_matrix(this.matrix);
                    case "colorRate":
                        return this.colorRate;
                }
            };
            EffectAttrsData.prototype.initAttribute = function (attribute) {
                switch (attribute) {
                    case "pos":
                        this.pos = new m4m.math.vector3(0, 0, 0);
                        break;
                    case "scale":
                        this.scale = new m4m.math.vector3(1, 1, 1);
                        break;
                    case "euler":
                        this.euler = new m4m.math.vector3(0, 0, 0);
                        break;
                    case "alpha":
                        this.alpha = 0;
                        break;
                    case "color":
                        this.color = new m4m.math.vector3(0, 0, 0);
                        break;
                    case "uv":
                        this.uv = new m4m.math.vector2(0, 0);
                        break;
                    case "tilling":
                        this.tilling = new m4m.math.vector2(1, 1);
                        break;
                    case "colorRate":
                        this.colorRate = 1;
                        break;
                    default:
                        console.log("不支持的属性：" + attribute);
                        break;
                }
            };
            EffectAttrsData.prototype.resetMatrix = function () {
                m4m.math.matrixZero(this.matrix);
            };
            EffectAttrsData.prototype.copyandinit = function () {
                var data = new EffectAttrsData();
                if (this.pos != undefined)
                    data.pos = m4m.math.pool.clone_vector3(this.pos);
                else
                    data.initAttribute("pos");
                if (this.euler != undefined)
                    data.euler = m4m.math.pool.clone_vector3(this.euler);
                else
                    data.initAttribute("euler");
                if (this.color != undefined)
                    data.color = m4m.math.pool.clone_vector3(this.color);
                else
                    data.initAttribute("color");
                if (this.scale != undefined)
                    data.scale = m4m.math.pool.clone_vector3(this.scale);
                else
                    data.initAttribute("scale");
                if (this.uv != undefined)
                    data.uv = m4m.math.pool.clone_vector2(this.uv);
                else
                    data.initAttribute("uv");
                if (this.tilling != undefined)
                    data.tilling = m4m.math.pool.clone_vector2(this.tilling);
                else
                    data.initAttribute("tilling");
                if (this.colorRate != undefined)
                    data.colorRate = this.colorRate;
                else
                    data.initAttribute("colorRate");
                if (this.mat != undefined)
                    data.mat = this.mat.clone();
                if (this.rotationByEuler != undefined)
                    data.rotationByEuler = m4m.math.pool.clone_quaternion(this.rotationByEuler);
                if (this.localRotation != undefined)
                    data.localRotation = m4m.math.pool.clone_quaternion(this.localRotation);
                if (this.meshdataVbo != undefined)
                    data.meshdataVbo = this.meshdataVbo; //这个数组不会被改变，可以直接引用
                // if (this.startEuler != undefined)
                // {
                //     data.startEuler = math.pool.clone_vector3(this.startEuler);
                //     m4m.math.quatFromEulerAngles(data.startEuler.x, data.startEuler.y, data.startEuler.z, data.startRotation);
                //     // data.startRotation = math.pool.clone_quaternion(this.startRotation);
                // }
                // if (this.localAxisX != undefined)
                //     data.localAxisX = math.pool.clone_vector3(this.localAxisX);
                // if (this.localAxisY != undefined)
                //     data.localAxisY = math.pool.clone_vector3(this.localAxisY);
                // if (this.localAxisZ != undefined)
                //     data.localAxisZ = math.pool.clone_vector3(this.localAxisZ);
                data.alpha = this.alpha;
                data.renderModel = this.renderModel;
                data.mesh = this.mesh;
                return data;
            };
            EffectAttrsData.prototype.clone = function () {
                var data = new EffectAttrsData();
                if (this.pos != undefined)
                    data.pos = m4m.math.pool.clone_vector3(this.pos);
                if (this.euler != undefined)
                    data.euler = m4m.math.pool.clone_vector3(this.euler);
                if (this.color != undefined)
                    data.color = m4m.math.pool.clone_vector3(this.color);
                if (this.scale != undefined)
                    data.scale = m4m.math.pool.clone_vector3(this.scale);
                if (this.tilling != undefined)
                    data.tilling = m4m.math.pool.clone_vector2(this.tilling);
                if (this.colorRate != undefined)
                    data.colorRate = this.colorRate;
                if (this.uv != undefined)
                    data.uv = m4m.math.pool.clone_vector2(this.uv);
                if (this.mat != undefined)
                    data.mat = this.mat.clone();
                if (this.rotationByEuler != undefined)
                    data.rotationByEuler = m4m.math.pool.clone_quaternion(this.rotationByEuler);
                if (this.localRotation != undefined)
                    data.localRotation = m4m.math.pool.clone_quaternion(this.localRotation);
                if (this.meshdataVbo != undefined)
                    data.meshdataVbo = this.meshdataVbo; //这个数组不会被改变，可以直接引用
                // if (this.startEuler != undefined)
                // {
                //     data.startEuler = math.pool.clone_vector3(this.startEuler);
                //     m4m.math.quatFromEulerAngles(data.startEuler.x, data.startEuler.y, data.startEuler.z, data.startRotation);
                //     // data.startRotation = math.pool.clone_quaternion(this.startRotation);
                // }
                // if (this.localAxisX != undefined)
                //     data.localAxisX = math.pool.clone_vector3(this.localAxisX);
                // if (this.localAxisY != undefined)
                //     data.localAxisY = math.pool.clone_vector3(this.localAxisY);
                // if (this.localAxisZ != undefined)
                //     data.localAxisZ = math.pool.clone_vector3(this.localAxisZ);
                data.alpha = this.alpha;
                data.renderModel = this.renderModel;
                data.mesh = this.mesh;
                return data;
            };
            return EffectAttrsData;
        }());
        framework.EffectAttrsData = EffectAttrsData;
        /**
         * @private
         */
        var EffectFrameData = /** @class */ (function () {
            function EffectFrameData() {
            }
            EffectFrameData.prototype.clone = function () {
                var framedata = new EffectFrameData();
                framedata.frameIndex = this.frameIndex;
                framedata.attrsData = this.attrsData.clone();
                framedata.lerpDatas = [];
                for (var key in this.lerpDatas) {
                    framedata.lerpDatas[key] = this.lerpDatas[key].clone();
                }
                return framedata;
            };
            EffectFrameData.prototype.dispose = function () {
                this.attrsData = null;
                if (this.lerpDatas)
                    this.lerpDatas.length = 0;
            };
            return EffectFrameData;
        }());
        framework.EffectFrameData = EffectFrameData;
        /**
         * @private
         */
        var EffectLerpData = /** @class */ (function () {
            function EffectLerpData() {
                this.attrsList = [];
            }
            EffectLerpData.prototype.clone = function () {
                var lerpdata = new EffectLerpData();
                lerpdata.type = this.type;
                lerpdata.fromFrame = this.fromFrame;
                lerpdata.toFrame = this.toFrame;
                lerpdata.attrsData = this.attrsData.clone();
                for (var key in this.attrsList) {
                    lerpdata.attrsList[key] = this.attrsList[key];
                }
                return lerpdata;
            };
            return EffectLerpData;
        }());
        framework.EffectLerpData = EffectLerpData;
        /**
         * @private
         */
        var EffectActionData = /** @class */ (function () {
            function EffectActionData() {
            }
            EffectActionData.prototype.clone = function () {
                var actiondata = new EffectActionData();
                actiondata.actionType = this.actionType;
                actiondata.startFrame = this.startFrame;
                actiondata.endFrame = this.endFrame;
                actiondata.params = [];
                for (var key in this.params) {
                    actiondata.params[key] = this.params[key];
                }
                return actiondata;
            };
            return EffectActionData;
        }());
        framework.EffectActionData = EffectActionData;
        /**
         * @private
         */
        var EffectMatData = /** @class */ (function () {
            function EffectMatData() {
            }
            EffectMatData.beEqual = function (data0, data1) {
                return data0.alphaCut === data1.alphaCut && data0.diffuseTexture === data1.diffuseTexture && data0.shader === data1.shader && data0.alphaTexture === data1.alphaTexture;
            };
            EffectMatData.prototype.clone = function () {
                var data = new EffectMatData();
                data.shader = this.shader;
                data.diffuseTexture = this.diffuseTexture;
                data.alphaTexture = this.alphaTexture;
                data.alphaCut = this.alphaCut;
                return data;
            };
            return EffectMatData;
        }());
        framework.EffectMatData = EffectMatData;
        var EffectBatcherState;
        (function (EffectBatcherState) {
            EffectBatcherState[EffectBatcherState["NotInitedStateType"] = 0] = "NotInitedStateType";
            EffectBatcherState[EffectBatcherState["InitedStateType"] = 1] = "InitedStateType";
            EffectBatcherState[EffectBatcherState["ResizeCapacityStateType"] = 2] = "ResizeCapacityStateType";
        })(EffectBatcherState = framework.EffectBatcherState || (framework.EffectBatcherState = {}));
        /**
         * @private
         */
        var EffectBatcher = /** @class */ (function () {
            function EffectBatcher(formate) {
                this.state = EffectBatcherState.NotInitedStateType;
                this.effectElements = [];
                /**
                 * 当前总的顶点数量
                 *
                 * @private
                 * @type {number}
                 * @memberof effect
                 */
                this._totalVertexCount = 0;
                this._indexStartIndex = 0;
                this._vbosize = 0;
                /**
                 * 顶点大小
                 * @public
                 * @type {number}
                 * @memberof effect
                 */
                this.vertexSize = 0;
                this.vertexSize = m4m.render.meshData.calcByteSize(formate) / 4;
            }
            Object.defineProperty(EffectBatcher.prototype, "curTotalVertexCount", {
                get: function () {
                    return this._totalVertexCount;
                },
                set: function (val) {
                    this._totalVertexCount = val;
                    this.resizeVboSize(this._totalVertexCount * this.vertexSize);
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(EffectBatcher.prototype, "indexStartIndex", {
                get: function () {
                    return this._indexStartIndex;
                },
                set: function (value) {
                    this._indexStartIndex = value;
                    if (this.dataForEbo != null) {
                        var ebo = new Uint16Array(this._indexStartIndex);
                        ebo.set(this.dataForEbo, 0);
                        this.dataForEbo = ebo;
                    }
                    else {
                        this.dataForEbo = new Uint16Array(this._indexStartIndex);
                    }
                },
                enumerable: false,
                configurable: true
            });
            /**
             * 动态设定vbo大小
             *
             * @param {number} value
             * @returns
             *
             * @memberof effect
             */
            EffectBatcher.prototype.resizeVboSize = function (value) {
                if (this._vbosize > value)
                    return;
                this._vbosize = value;
                if (this.dataForVbo != null) {
                    var vbo = new Float32Array(this._vbosize);
                    vbo.set(this.dataForVbo, 0);
                    this.dataForVbo = vbo;
                }
                else {
                    this.dataForVbo = new Float32Array(this._vbosize);
                }
            };
            EffectBatcher.prototype.dispose = function () {
                this.mesh.dispose();
                this.mat.dispose();
                this.dataForVbo = null;
                this.dataForEbo = null;
                for (var key in this.effectElements) {
                    this.effectElements[key].dispose();
                }
            };
            return EffectBatcher;
        }());
        framework.EffectBatcher = EffectBatcher;
        /**
         * @private
         */
        var EffectPlayStateEnum;
        (function (EffectPlayStateEnum) {
            EffectPlayStateEnum[EffectPlayStateEnum["None"] = 0] = "None";
            EffectPlayStateEnum[EffectPlayStateEnum["BeReady"] = 1] = "BeReady";
            EffectPlayStateEnum[EffectPlayStateEnum["Play"] = 2] = "Play";
            EffectPlayStateEnum[EffectPlayStateEnum["Pause"] = 3] = "Pause";
            EffectPlayStateEnum[EffectPlayStateEnum["Stop"] = 4] = "Stop";
            EffectPlayStateEnum[EffectPlayStateEnum["Dispose"] = 5] = "Dispose";
        })(EffectPlayStateEnum = framework.EffectPlayStateEnum || (framework.EffectPlayStateEnum = {}));
        /**
         * @private
         */
        var EffectElementTypeEnum;
        (function (EffectElementTypeEnum) {
            EffectElementTypeEnum[EffectElementTypeEnum["SingleMeshType"] = 0] = "SingleMeshType";
            EffectElementTypeEnum[EffectElementTypeEnum["EmissionType"] = 1] = "EmissionType";
            EffectElementTypeEnum[EffectElementTypeEnum["MultiMeshType"] = 2] = "MultiMeshType"; //多mesh
        })(EffectElementTypeEnum = framework.EffectElementTypeEnum || (framework.EffectElementTypeEnum = {}));
        /**
         * @private
         */
        var EffectLerpTypeEnum;
        (function (EffectLerpTypeEnum) {
            EffectLerpTypeEnum[EffectLerpTypeEnum["Linear"] = 0] = "Linear"; //线性插值
        })(EffectLerpTypeEnum = framework.EffectLerpTypeEnum || (framework.EffectLerpTypeEnum = {}));
        /**
         * @private
         */
        var RenderModel;
        (function (RenderModel) {
            RenderModel[RenderModel["None"] = 0] = "None";
            RenderModel[RenderModel["BillBoard"] = 1] = "BillBoard";
            RenderModel[RenderModel["StretchedBillBoard"] = 2] = "StretchedBillBoard";
            RenderModel[RenderModel["HorizontalBillBoard"] = 3] = "HorizontalBillBoard";
            RenderModel[RenderModel["VerticalBillBoard"] = 4] = "VerticalBillBoard";
            RenderModel[RenderModel["Mesh"] = 5] = "Mesh";
        })(RenderModel = framework.RenderModel || (framework.RenderModel = {}));
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @private
         */
        var ParticleEmissionType;
        (function (ParticleEmissionType) {
            ParticleEmissionType[ParticleEmissionType["burst"] = 0] = "burst";
            ParticleEmissionType[ParticleEmissionType["continue"] = 1] = "continue";
        })(ParticleEmissionType = framework.ParticleEmissionType || (framework.ParticleEmissionType = {}));
        /**
         * @private
         */
        var EmissionData = /** @class */ (function () {
            function EmissionData() {
                /**
                * 发射器类型
                */
                this.type = ParticleEmissionType.burst;
            }
            return EmissionData;
        }());
        framework.EmissionData = EmissionData;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @private
         */
        var Emission = /** @class */ (function () {
            function Emission() {
                this.simulateInLocalSpace = true;
                this.renderModel = framework.RenderModel.Mesh;
                this.particleStartData = new m4m.framework.ParticleStartData();
            }
            Emission.prototype.getVboData = function (vf) {
                if (this.dataForVbo == undefined) {
                    this.dataForVbo = this.mesh.data.genVertexDataArray(vf);
                }
                return this.dataForVbo;
            };
            Emission.prototype.clone = function () {
                var emission = new Emission();
                if (this.emissionType != undefined)
                    emission.emissionType = this.emissionType;
                emission.simulateInLocalSpace = this.simulateInLocalSpace;
                if (this.rootpos != undefined) {
                    emission.rootpos = m4m.math.pool.clone_vector3(this.rootpos);
                }
                if (this.rootRotAngle != undefined) {
                    emission.rootRotAngle = m4m.math.pool.clone_vector3(this.rootRotAngle);
                }
                if (this.rootScale != undefined) {
                    emission.rootScale = m4m.math.pool.clone_vector3(this.rootScale);
                }
                if (this.maxEmissionCount != undefined)
                    emission.maxEmissionCount = this.maxEmissionCount;
                if (this.emissionCount != undefined)
                    emission.emissionCount = this.emissionCount;
                if (this.time != undefined)
                    emission.time = this.time;
                if (this.simulationSpeed != undefined) {
                    emission.simulationSpeed = this.simulationSpeed.clone();
                }
                if (this.moveSpeed != undefined)
                    emission.moveSpeed = this.moveSpeed.clone();
                if (this.gravity != undefined)
                    emission.gravity = this.gravity;
                if (this.euler != undefined)
                    emission.euler = this.euler.clone();
                if (this.eulerNodes != undefined)
                    emission.eulerNodes = this.cloneParticleNodeArray(this.eulerNodes);
                if (this.eulerSpeed != undefined)
                    emission.eulerSpeed = this.eulerSpeed.clone();
                if (this.scale != undefined)
                    emission.scale = this.scale.clone();
                if (this.scaleNodes != undefined)
                    emission.scaleNodes = this.cloneParticleNodeNumberArray(this.scaleNodes);
                if (this.scaleSpeed != undefined)
                    emission.scaleSpeed = this.scaleSpeed.clone();
                if (this.color != undefined)
                    emission.color = this.color.clone();
                if (this.colorRate != undefined)
                    emission.colorRate = this.colorRate;
                if (this.colorNodes != undefined)
                    emission.colorNodes = this.cloneParticleNodeArray(this.colorNodes);
                if (this.colorSpeed != undefined)
                    emission.colorSpeed = this.colorSpeed.clone();
                if (this.simulationSpeed != undefined)
                    emission.simulationSpeed = this.simulationSpeed.clone();
                if (this.alpha != undefined)
                    emission.alpha = this.alpha.clone();
                if (this.alphaNodes != undefined)
                    emission.alphaNodes = this.cloneParticleNodeNumberArray(this.alphaNodes);
                if (this.alphaSpeed != undefined)
                    emission.alphaSpeed = this.alphaSpeed.clone();
                if (this.uv != undefined)
                    emission.uv = this.uv.clone();
                if (this.uvType != undefined)
                    emission.uvType = this.uvType;
                if (this.uvRoll != undefined)
                    emission.uvRoll = this.uvRoll.clone();
                if (this.uvSprite != undefined)
                    emission.uvSprite = this.uvSprite.clone();
                if (this.mat != undefined)
                    emission.mat = this.mat.clone();
                if (this.life != undefined)
                    emission.life = this.life.clone();
                if (this.renderModel != undefined)
                    emission.renderModel = this.renderModel;
                if (this.mesh != undefined)
                    emission.mesh = this.mesh;
                if (this.dataForVbo != undefined)
                    emission.dataForVbo = this.dataForVbo;
                if (this.particleStartData != undefined)
                    emission.particleStartData = this.particleStartData.clone();
                return emission;
            };
            Emission.prototype.getworldRotation = function () {
            };
            Emission.prototype.cloneParticleNodeArray = function (_array) {
                var array = new Array();
                for (var i in _array) {
                    array.push(_array[i].clone());
                }
                return array;
            };
            Emission.prototype.cloneParticleNodeNumberArray = function (_array) {
                var array = new Array();
                for (var i in _array) {
                    array.push(_array[i].clone());
                }
                return array;
            };
            return Emission;
        }());
        framework.Emission = Emission;
        var UVSprite = /** @class */ (function () {
            function UVSprite() {
            }
            UVSprite.prototype.clone = function () {
                var sprite = new UVSprite();
                sprite.row = this.row;
                sprite.column = this.column;
                sprite.totalCount = this.totalCount;
                return sprite;
            };
            return UVSprite;
        }());
        framework.UVSprite = UVSprite;
        var UVRoll = /** @class */ (function () {
            function UVRoll() {
            }
            UVRoll.prototype.clone = function () {
                var roll = new UVRoll();
                if (this.uvSpeed != undefined)
                    roll.uvSpeed = this.uvSpeed;
                if (this.uvSpeedNodes != undefined) {
                    var array = new Array();
                    for (var i in this.uvSpeedNodes) {
                        array.push(this.uvSpeedNodes[i].clone());
                    }
                    roll.uvSpeedNodes = array;
                }
                return roll;
            };
            return UVRoll;
        }());
        framework.UVRoll = UVRoll;
        var UVTypeEnum;
        (function (UVTypeEnum) {
            UVTypeEnum[UVTypeEnum["NONE"] = 0] = "NONE";
            UVTypeEnum[UVTypeEnum["UVRoll"] = 1] = "UVRoll";
            UVTypeEnum[UVTypeEnum["UVSprite"] = 2] = "UVSprite";
        })(UVTypeEnum = framework.UVTypeEnum || (framework.UVTypeEnum = {}));
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * 粒子节点
         */
        /**
         * @private
         */
        var ParticleNode = /** @class */ (function () {
            function ParticleNode() {
                this.x = new framework.ValueData();
                this.y = new framework.ValueData();
                this.z = new framework.ValueData();
            }
            ParticleNode.prototype.getValue = function () {
                return new m4m.math.vector3(this.x.getValue(), this.y.getValue(), this.z.getValue());
            };
            ParticleNode.prototype.getValueRandom = function () {
                return new m4m.math.vector3(this.x.getValueRandom(), this.y.getValueRandom(), this.z.getValueRandom());
            };
            ParticleNode.prototype.clone = function () {
                var node = new ParticleNode();
                if (this.x != undefined)
                    node.x = this.x.clone();
                if (this.y != undefined)
                    node.y = this.y.clone();
                if (this.z != undefined)
                    node.z = this.z.clone();
                if (this.key != undefined)
                    node.key = this.key;
                return node;
            };
            return ParticleNode;
        }());
        framework.ParticleNode = ParticleNode;
        /**
         * @private
         */
        var AlphaNode = /** @class */ (function () {
            function AlphaNode() {
                this.alpha = new framework.ValueData();
            }
            AlphaNode.prototype.getValue = function () {
                return this.alpha.getValue();
            };
            return AlphaNode;
        }());
        framework.AlphaNode = AlphaNode;
        /**
         * @private
         */
        var UVSpeedNode = /** @class */ (function () {
            function UVSpeedNode() {
                this.u = new framework.ValueData();
                this.v = new framework.ValueData();
            }
            UVSpeedNode.prototype.getValue = function () {
                return new m4m.math.vector2(this.u.getValue(), this.v.getValue());
            };
            UVSpeedNode.prototype.getValueRandom = function () {
                return new m4m.math.vector2(this.u.getValueRandom(), this.v.getValueRandom());
            };
            UVSpeedNode.prototype.clone = function () {
                var node = new UVSpeedNode();
                node.u = this.u.clone();
                node.v = this.v.clone();
                if (this.key != undefined)
                    node.key = this.key;
                return node;
            };
            return UVSpeedNode;
        }());
        framework.UVSpeedNode = UVSpeedNode;
        /**
         * @private
         */
        var ParticleNodeVec2 = /** @class */ (function () {
            function ParticleNodeVec2() {
                this.x = new framework.ValueData();
                this.y = new framework.ValueData();
            }
            ParticleNodeVec2.prototype.getValue = function () {
                return new m4m.math.vector2(this.x.getValue(), this.y.getValue());
            };
            ParticleNodeVec2.prototype.getValueRandom = function () {
                return new m4m.math.vector2(this.x.getValueRandom(), this.y.getValueRandom());
            };
            ParticleNodeVec2.prototype.clone = function () {
                var vec = new ParticleNodeVec2();
                vec.x = this.x.clone();
                vec.y = this.y.clone();
                if (this.key != undefined)
                    vec.key = this.key;
                return vec;
            };
            return ParticleNodeVec2;
        }());
        framework.ParticleNodeVec2 = ParticleNodeVec2;
        /**
         * @private
         */
        var ParticleNodeNumber = /** @class */ (function () {
            function ParticleNodeNumber() {
                this.num = new framework.ValueData();
            }
            ParticleNodeNumber.prototype.getValue = function () {
                return this.num.getValue();
            };
            ParticleNodeNumber.prototype.getValueRandom = function () {
                return this.num.getValueRandom();
            };
            ParticleNodeNumber.prototype.clone = function () {
                var num = new ParticleNodeNumber();
                num.num = this.num.clone();
                if (this.key != undefined) {
                    num.key = this.key;
                }
                return num;
            };
            return ParticleNodeNumber;
        }());
        framework.ParticleNodeNumber = ParticleNodeNumber;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
        * 粒子初始方向类型
        */
        /**
         * @private
         */
        var ParticleSystemShape;
        (function (ParticleSystemShape) {
            ParticleSystemShape[ParticleSystemShape["NORMAL"] = 0] = "NORMAL";
            ParticleSystemShape[ParticleSystemShape["BOX"] = 1] = "BOX";
            ParticleSystemShape[ParticleSystemShape["SPHERE"] = 2] = "SPHERE";
            ParticleSystemShape[ParticleSystemShape["HEMISPHERE"] = 3] = "HEMISPHERE";
            ParticleSystemShape[ParticleSystemShape["CONE"] = 4] = "CONE";
            ParticleSystemShape[ParticleSystemShape["EDGE"] = 5] = "EDGE";
            ParticleSystemShape[ParticleSystemShape["CIRCLE"] = 6] = "CIRCLE";
        })(ParticleSystemShape = framework.ParticleSystemShape || (framework.ParticleSystemShape = {}));
        /**
         *  粒子初始数据
         */
        /**
         * @private
         */
        var ParticleStartData = /** @class */ (function () {
            function ParticleStartData() {
                this.shapeType = ParticleSystemShape.NORMAL;
                this._position = new m4m.math.vector3(0, 0, 0);
                this._direction = new m4m.math.vector3(0, 1, 0);
                this._width = 0;
                this._height = 0;
                this.depth = 0;
                this._radius = 0;
                this._angle = 0;
                this.emitFrom = emitfromenum.base;
            }
            Object.defineProperty(ParticleStartData.prototype, "position", {
                get: function () {
                    return this._position;
                },
                set: function (_pos) {
                    m4m.math.vec3Clone(_pos, this._position);
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "direction", {
                get: function () {
                    return this._direction;
                },
                set: function (_dir) {
                    m4m.math.vec3Clone(_dir, this._direction);
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "width", {
                get: function () {
                    return this._width;
                },
                set: function (_w) {
                    this._width = _w;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "height", {
                get: function () {
                    return this._height;
                },
                set: function (_h) {
                    this._height = _h;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "radius", {
                get: function () {
                    return this._radius;
                },
                set: function (_r) {
                    this._radius = _r;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "angle", {
                get: function () {
                    return this._angle;
                },
                set: function (_a) {
                    this._angle = _a;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "randomDirection", {
                get: function () {
                    switch (this.shapeType) {
                        case ParticleSystemShape.BOX:
                            return this.boxDirection;
                        case ParticleSystemShape.SPHERE:
                            return this.sphereDirection;
                        case ParticleSystemShape.HEMISPHERE:
                            return this.hemisphereDirection;
                        case ParticleSystemShape.CONE:
                            return this.coneDirection;
                        case ParticleSystemShape.CIRCLE: //todo
                            return this.circleDirection;
                        case ParticleSystemShape.EDGE: //todo
                            return this.edgeDirection;
                        default:
                            return this.direction;
                    }
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "boxDirection", {
                get: function () {
                    this.position.x = framework.ValueData.RandomRange(-this.width / 2, this.width / 2);
                    this.position.y = framework.ValueData.RandomRange(-this.height / 2, this.height / 2);
                    this.position.z = framework.ValueData.RandomRange(-this.depth / 2, this.depth / 2);
                    m4m.math.vec3Normalize(this.position, this.direction);
                    return this.direction;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "sphereDirection", {
                get: function () {
                    var o = Math.random() * Math.PI * 2;
                    var o1 = Math.random() * Math.PI;
                    var radius = Math.random() * this.radius;
                    this.direction.x = Math.sin(o1) * Math.cos(o);
                    this.direction.y = Math.cos(o1);
                    this.direction.z = Math.sin(o1) * Math.sin(o);
                    m4m.math.vec3ScaleByNum(this.direction, radius, this.position);
                    return this.direction;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "hemisphereDirection", {
                get: function () {
                    var o = Math.random() * Math.PI * 2;
                    var o1 = Math.random() * Math.PI * 0.5;
                    var radius = Math.random() * this.radius;
                    this.direction.x = Math.sin(o1) * Math.cos(o);
                    this.direction.y = Math.cos(o1);
                    this.direction.z = Math.sin(o1) * Math.sin(o);
                    m4m.math.vec3ScaleByNum(this.direction, radius, this.position);
                    return this.direction;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "coneDirection", {
                get: function () {
                    var randomAngle = Math.random() * Math.PI * 2; //弧度
                    var randomHeight = Math.random() * this.height;
                    var upradius = randomHeight * Math.tan(this.angle * Math.PI / 180) + this.radius;
                    var radomRadius = Math.random() * upradius;
                    var bottompos = m4m.math.pool.new_vector3();
                    bottompos.x = this.radius * Math.cos(randomAngle);
                    bottompos.y = 0;
                    bottompos.z = this.radius * Math.sin(randomAngle);
                    if (this.emitFrom == emitfromenum.base) {
                        m4m.math.vec3Clone(bottompos, this.position);
                    }
                    else if (this.emitFrom == emitfromenum.volume) {
                        this.position.x = radomRadius * Math.cos(randomAngle);
                        this.position.z = radomRadius * Math.sin(randomAngle);
                        this.position.y = randomHeight;
                    }
                    this.direction.x = Math.cos(randomAngle) * Math.sin(this.angle * Math.PI / 180);
                    this.direction.z = Math.sin(randomAngle) * Math.sin(this.angle * Math.PI / 180);
                    this.direction.y = Math.cos(this.angle * Math.PI / 180);
                    return this.direction;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "circleDirection", {
                get: function () {
                    var _arc = this.angle * (Math.PI / 180);
                    var a = framework.ValueData.RandomRange(-_arc / 2, _arc / 2);
                    var _radius = framework.ValueData.RandomRange(0, this.radius);
                    this.direction.x = _radius * Math.cos(a);
                    this.direction.z = _radius * Math.sin(a);
                    this.direction.y = 0;
                    var length = m4m.math.vec3Length(this.direction);
                    m4m.math.vec3Normalize(this.direction, this.direction);
                    framework.EffectUtil.RotateVector3(this.direction, this.direction, this.direction);
                    this.getposition(this.direction, length);
                    return this.direction;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleStartData.prototype, "edgeDirection", {
                get: function () {
                    var edgePos = new m4m.math.vector3(0, 0, 0);
                    edgePos.y += framework.ValueData.RandomRange(-this.radius / 2, this.radius / 2);
                    var lenght = m4m.math.vec3Length(edgePos);
                    framework.EffectUtil.RotateVector3(edgePos, this.direction, edgePos);
                    m4m.math.vec3Clone(this.direction, this.direction);
                    this.getposition(edgePos, length);
                    return this.direction;
                },
                enumerable: false,
                configurable: true
            });
            ParticleStartData.prototype.getposition = function (dir, length) {
                m4m.math.vec3ScaleByNum(dir, length, dir);
                this.position.x = dir.x;
                this.position.y = dir.y;
                this.position.z = dir.z;
            };
            ParticleStartData.prototype.clone = function () {
                var data = new ParticleStartData();
                data.shapeType = this.shapeType;
                data._position = new m4m.math.vector3();
                m4m.math.vec3Clone(this._position, data._position);
                data._direction = new m4m.math.vector3();
                m4m.math.vec3Clone(this._direction, data._direction);
                data._width = this._width;
                data._height = this._height;
                data.depth = this.depth;
                data._radius = this._radius;
                data._angle = this._angle;
                data.position = new m4m.math.vector3();
                m4m.math.vec3Clone(this.position, data.position);
                data.direction = new m4m.math.vector3();
                m4m.math.vec3Clone(this.direction, data.direction);
                return data;
            };
            return ParticleStartData;
        }());
        framework.ParticleStartData = ParticleStartData;
        /**
         * @private
         */
        var emitfromenum;
        (function (emitfromenum) {
            emitfromenum[emitfromenum["base"] = 0] = "base";
            emitfromenum[emitfromenum["volume"] = 1] = "volume";
        })(emitfromenum = framework.emitfromenum || (framework.emitfromenum = {}));
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @private
         */
        var ValueData = /** @class */ (function () {
            function ValueData() {
                this.isRandom = true;
                this._value = 0;
                this._valueLimitMin = 0;
                this._valueLimitMax = 0;
                this.beInited = false;
            }
            Object.defineProperty(ValueData.prototype, "value", {
                set: function (_v) {
                    this._value = _v;
                    this.isRandom = false;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ValueData.prototype, "valueLimitMin", {
                set: function (_v) {
                    this._valueLimitMin = _v;
                    this.isRandom = true;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ValueData.prototype, "valueLimitMax", {
                set: function (_v) {
                    this._valueLimitMax = _v;
                    this.isRandom = true;
                },
                enumerable: false,
                configurable: true
            });
            ValueData.prototype.clone = function () {
                var valu = new ValueData();
                valu.isRandom = this.isRandom;
                valu._value = this._value;
                valu._valueLimitMin = this._valueLimitMin;
                valu._valueLimitMax = this._valueLimitMax;
                return valu;
            };
            /**
             * 针对随机类型，只要随机过一次就保持这个值不变
             *
             * @returns
             *
             * @memberof ValueData
             */
            ValueData.prototype.getValue = function () {
                if (this.isRandom) {
                    if (!this.beInited) {
                        this._value = ValueData.RandomRange(this._valueLimitMin, this._valueLimitMax);
                        this.beInited = true;
                    }
                }
                return this._value;
            };
            /**
             * 针对随机类型，调用一次就随机一个值
             *
             * @returns
             *
             * @memberof ValueData
             */
            ValueData.prototype.getValueRandom = function () {
                if (this.isRandom) {
                    this._value = ValueData.RandomRange(this._valueLimitMin, this._valueLimitMax);
                }
                return this._value;
            };
            ValueData.RandomRange = function (min, max, isInteger) {
                if (isInteger === void 0) { isInteger = false; }
                if (isInteger) {
                    return Math.floor(Math.random() * (max - min + 1) + min);
                }
                return Math.random() * (max - min) + min;
            };
            return ValueData;
        }());
        framework.ValueData = ValueData;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @private
         */
        var Particle_new = /** @class */ (function () {
            //根据发射器定义 初始化
            function Particle_new(batcher) {
                this.startScale = new m4m.math.vector3();
                this.startRotation = new m4m.math.quaternion();
                this.rotationByShape = new m4m.math.quaternion();
                this.rotAngle = 0;
                this.rotationByEuler = new m4m.math.quaternion();
                this.localMatrix = new m4m.math.matrix();
                this.localTranslate = new m4m.math.vector3();
                this.localRotation = new m4m.math.quaternion();
                this.localScale = new m4m.math.vector3(1, 1, 1);
                this.color = new m4m.math.vector3(1, 1, 1);
                this.tex_ST = new m4m.math.vector4(1, 1, 0, 0);
                this.curLife = 0; //当前经过的生命周期
                this.life = 0; //(0---1)
                this.speedDir = new m4m.math.vector3(0, 0, 0);
                this.actived = true;
                /**
                 * 在emission是在simulate in local space 时候，为matTobathcer
                 * 在emission是在simulate in world space 时候，为matToWorld
                 */
                this.transformVertex = new m4m.math.matrix();
                this.matToworld = new m4m.math.matrix();
                this.batcher = batcher;
                this.emisson = batcher.emission;
                this.gameObject = this.emisson.gameObject;
                this.vertexStartIndex = batcher.curVerCount;
                this.dataForVbo = this.emisson.cloneMeshVBO();
                this.dataForEbo = this.emisson.cloneMeshEBO();
                this.sourceVbo = this.emisson.vbo;
                this.initByData();
                //计算得出初始vbo ebo
            }
            Particle_new.prototype.uploadData = function (array) {
                array.set(this.dataForVbo, this.vertexStartIndex * this.emisson.vertexSize);
            };
            Particle_new.prototype.initByData = function () {
                this.totalLife = this.emisson.lifeTime.getValue();
                //--------------location speed
                framework.effTools.getRandomDirAndPosByZEmission(this.emisson, this.speedDir, this.localTranslate);
                this.simulationSpeed = this.emisson.simulationSpeed.getValue();
                //--------------rotation
                this.Starteuler = this.emisson.startEuler.getValue();
                m4m.math.quatFromEulerAngles(this.Starteuler.x, this.Starteuler.y, this.Starteuler.z, this.rotationByEuler);
                //--------------scale
                this.localScale = this.emisson.startScale.getValue();
                //--------------color
                this.startColor = this.emisson.startColor;
                //-------------------------------------------------可选类型----------------------
                this.sizeNodes = this.emisson.sizeNodes;
                this.colorNodes = this.emisson.colorNodes;
                this.alphaNodes = this.emisson.alphaNodes;
                if (this.emisson.enableVelocityOverLifetime) {
                    this.movespeed = this.emisson.moveSpeed.getValue();
                }
                if (this.emisson.enableRotOverLifeTime) {
                    this.eulerSpeed = this.emisson.angleSpeed.getValue();
                }
                if (this.emisson.rendermodel == framework.RenderModel.StretchedBillBoard) {
                    var localOrgin = m4m.math.pool.vector3_zero;
                    m4m.math.quatLookat(localOrgin, this.speedDir, this.rotationByShape);
                    var initRot = m4m.math.pool.new_quaternion();
                    m4m.math.quatFromEulerAngles(90, 0, 90, initRot);
                    m4m.math.quatMultiply(this.rotationByShape, initRot, this.rotationByShape);
                    m4m.math.quatClone(this.rotationByShape, this.localRotation);
                    m4m.math.pool.delete_quaternion(initRot);
                }
                if (!this.emisson.simulateInLocalSpace) {
                    this.emissionMatToWorld = new m4m.math.matrix();
                    var mat = this.emisson.getmatrixToWorld();
                    m4m.math.matrixClone(mat, this.emissionMatToWorld);
                    this.emissionWorldRotation = new m4m.math.quaternion();
                    var quat = this.emisson.getWorldRotation();
                    m4m.math.quatClone(quat, this.emissionWorldRotation);
                }
            };
            Particle_new.prototype.update = function (delta) {
                if (!this.actived)
                    return;
                this.curLife += delta;
                this.life = this.curLife / this.totalLife;
                m4m.math.floatClamp(this.life, 0, 1);
                if (this.curLife >= this.totalLife) {
                    //矩阵置零
                    m4m.math.matrixZero(this.transformVertex);
                    this._updateVBO();
                    this.emisson.deadParticles.push(this);
                    this.curLife = 0;
                    this.actived = false;
                    return;
                }
                this._updatePos(delta);
                this._updateScale(delta);
                this._updateEuler(delta);
                this._updateRotation(delta);
                this._updateLocalMatrix(delta);
                this._updateColor(delta);
                this._updateUV(delta);
                this._updateVBO();
            };
            Particle_new.prototype._updateLocalMatrix = function (delta) {
                m4m.math.matrixMakeTransformRTS(this.localTranslate, this.localScale, this.localRotation, this.localMatrix);
                if (this.emisson.simulateInLocalSpace) {
                    m4m.math.matrixMultiply(this.emisson.matToObj, this.localMatrix, this.transformVertex);
                }
                else {
                    m4m.math.matrixMultiply(this.emissionMatToWorld, this.localMatrix, this.transformVertex);
                }
            };
            Particle_new.prototype.refreshEmissionData = function () {
                if (this.emisson.simulateInLocalSpace) {
                    this.emissionMatToWorld = this.emisson.getmatrixToWorld();
                    this.emissionWorldRotation = this.emisson.getWorldRotation();
                }
            };
            Particle_new.prototype._updateRotation = function (delta) {
                if (this.emisson.rendermodel == framework.RenderModel.Mesh) {
                    m4m.math.quatFromAxisAngle(m4m.math.pool.vector3_up, this.rotAngle, this.rotationByEuler);
                    m4m.math.quatClone(this.rotationByEuler, this.localRotation);
                }
                else {
                    m4m.math.quatFromAxisAngle(m4m.math.pool.vector3_forward, this.rotAngle, this.rotationByEuler);
                    this.refreshEmissionData();
                    var translation = m4m.math.pool.new_vector3();
                    var worldTranslation = m4m.math.pool.new_vector3();
                    var worldRotation = m4m.math.pool.new_quaternion();
                    var invTransformRotation = m4m.math.pool.new_quaternion();
                    m4m.math.vec3Clone(this.localTranslate, translation);
                    var cam = this.emisson.renderCamera;
                    var camPosInWorld = cam.gameObject.transform.getWorldTranslate();
                    m4m.math.matrixTransformVector3(translation, this.emissionMatToWorld, worldTranslation);
                    if (this.emisson.rendermodel == framework.RenderModel.BillBoard) {
                        m4m.math.quatLookat(worldTranslation, camPosInWorld, worldRotation);
                    }
                    else if (this.emisson.rendermodel == framework.RenderModel.HorizontalBillBoard) {
                        worldRotation.x = -0.5;
                        worldRotation.y = 0.5;
                        worldRotation.z = 0.5;
                        worldRotation.w = 0.5;
                    }
                    else if (this.emisson.rendermodel == framework.RenderModel.VerticalBillBoard) {
                        var forwardTarget = m4m.math.pool.new_vector3();
                        m4m.math.vec3Clone(camPosInWorld, forwardTarget);
                        forwardTarget.y = worldTranslation.y;
                        m4m.math.quatLookat(worldTranslation, forwardTarget, worldRotation);
                        m4m.math.pool.delete_vector3(forwardTarget);
                    }
                    else if (this.emisson.rendermodel == framework.RenderModel.StretchedBillBoard) {
                        m4m.math.matrixMakeTransformRTS(this.localTranslate, this.localScale, this.localRotation, this.localMatrix);
                        m4m.math.matrixMultiply(this.emissionMatToWorld, this.localMatrix, this.matToworld);
                        var xaxis = m4m.math.pool.new_vector3();
                        var yaxis = m4m.math.pool.new_vector3();
                        var zaxis = m4m.math.pool.new_vector3();
                        m4m.math.matrixTransformNormal(m4m.math.pool.vector3_right, this.matToworld, xaxis);
                        m4m.math.vec3Normalize(xaxis, xaxis);
                        m4m.math.matrixTransformNormal(m4m.math.pool.vector3_up, this.matToworld, yaxis);
                        m4m.math.vec3Normalize(yaxis, yaxis);
                        m4m.math.matrixTransformNormal(m4m.math.pool.vector3_forward, this.matToworld, zaxis);
                        m4m.math.vec3Normalize(zaxis, zaxis);
                        framework.EffectUtil.lookatbyXAxis(worldTranslation, xaxis, yaxis, zaxis, camPosInWorld, worldRotation);
                        m4m.math.quatMultiply(this.localRotation, worldRotation, this.localRotation);
                        m4m.math.pool.delete_quaternion(worldRotation);
                        m4m.math.pool.delete_vector3(translation);
                        m4m.math.pool.delete_quaternion(invTransformRotation);
                        m4m.math.pool.delete_vector3(xaxis);
                        m4m.math.pool.delete_vector3(yaxis);
                        m4m.math.pool.delete_vector3(zaxis);
                        return;
                    }
                    //消除transform组件对粒子本身的影响
                    m4m.math.quatClone(this.emissionWorldRotation, invTransformRotation);
                    m4m.math.quatInverse(invTransformRotation, invTransformRotation);
                    m4m.math.quatMultiply(invTransformRotation, worldRotation, this.localRotation);
                    m4m.math.quatMultiply(this.localRotation, this.rotationByEuler, this.localRotation); //eulerrot有的不是必要的，todo
                    m4m.math.pool.delete_vector3(translation);
                    m4m.math.pool.delete_vector3(worldTranslation);
                    m4m.math.pool.delete_quaternion(worldRotation);
                    m4m.math.pool.delete_quaternion(invTransformRotation);
                }
            };
            Particle_new.prototype._updatePos = function (delta) {
                var currentTranslate = framework.EffectUtil.vecMuliNum(this.speedDir, this.simulationSpeed);
                m4m.math.vec3Add(this.localTranslate, currentTranslate, this.localTranslate);
                if (this.emisson.enableVelocityOverLifetime) {
                    this.localTranslate.x += this.movespeed.x * delta;
                    this.localTranslate.y += this.movespeed.y * delta;
                    this.localTranslate.z += this.movespeed.z * delta;
                }
            };
            Particle_new.prototype._updateEuler = function (delta) {
                if (this.emisson.enableRotOverLifeTime) {
                    this.rotAngle = this.eulerSpeed * this.curLife;
                }
            };
            Particle_new.prototype._updateScale = function (delta) {
                if (this.emisson.enableSizeOverLifetime) {
                    for (var i = 0; i < this.sizeNodes.length - 1; i++) {
                        if (this.sizeNodes[i].key <= this.life && this.sizeNodes[i + 1].key >= this.life) {
                            var target = m4m.math.numberLerp(this.sizeNodes[i].value, this.sizeNodes[i + 1].value, (this.life - this.sizeNodes[i].key) / (this.sizeNodes[i + 1].key - this.sizeNodes[i].key));
                            m4m.math.vec3ScaleByNum(this.startScale, target, this.localScale);
                            break;
                        }
                    }
                }
            };
            Particle_new.prototype._updateColor = function (delta) {
                if (this.emisson.enableColorOverLifetime) {
                    if (this.colorNodes != null) {
                        for (var i = 0; i < this.colorNodes.length - 1; i++) {
                            if (this.colorNodes[i].key <= this.life && this.colorNodes[i + 1].key >= this.life) {
                                m4m.math.vec3SLerp(this.colorNodes[i].value, this.colorNodes[i + 1].value, (this.life - this.colorNodes[i].key) / (this.colorNodes[i + 1].key - this.colorNodes[i].key), this.color);
                                break;
                            }
                        }
                    }
                    if (this.alphaNodes != null) {
                        for (var i = 0; i < this.alphaNodes.length - 1; i++) {
                            if (this.alphaNodes[i].key <= this.life && this.alphaNodes[i + 1].key >= this.life) {
                                this.alpha = m4m.math.numberLerp(this.alphaNodes[i].value, this.alphaNodes[i + 1].value, (this.life - this.colorNodes[i].key) / (this.colorNodes[i + 1].key - this.colorNodes[i].key));
                                break;
                            }
                        }
                    }
                }
            };
            Particle_new.prototype._updateUV = function (delta) {
                if (this.emisson.uvType == framework.UVTypeEnum.UVRoll) {
                    this.tex_ST.z = this.emisson.uSpeed * this.curLife;
                    this.tex_ST.w = this.emisson.vSpeed * this.curLife;
                }
                else if (this.emisson.uvType == framework.UVTypeEnum.UVSprite) {
                    var spriteindex = Math.floor(this.life * this.emisson.count);
                    m4m.math.spriteAnimation(this.emisson.row, this.emisson.column, spriteindex, this.tex_ST);
                }
            };
            Particle_new.prototype._updateVBO = function () {
                var vertexSize = this.emisson.vertexSize;
                for (var i = 0; i < this.emisson.perVertexCount; i++) {
                    { //postion
                        var vertex = m4m.math.pool.new_vector3();
                        vertex.x = this.sourceVbo[i * vertexSize + 0];
                        vertex.y = this.sourceVbo[i * vertexSize + 1];
                        vertex.z = this.sourceVbo[i * vertexSize + 2];
                        m4m.math.matrixTransformVector3(vertex, this.transformVertex, vertex);
                        this.dataForVbo[i * vertexSize + 0] = vertex.x;
                        this.dataForVbo[i * vertexSize + 1] = vertex.y;
                        this.dataForVbo[i * vertexSize + 2] = vertex.z;
                        m4m.math.pool.delete_vector3(vertex);
                    }
                    { //color
                        //处理一下颜色，以防灰度值 > 1
                        var r = this.sourceVbo[i * vertexSize + 3] * this.startColor.r;
                        var g = this.sourceVbo[i * vertexSize + 4] * this.startColor.g;
                        var b = this.sourceVbo[i * vertexSize + 5] * this.startColor.b;
                        var a = this.sourceVbo[i * vertexSize + 6] * this.startColor.a;
                        if (this.colorNodes != null) {
                            r = this.color.x;
                            g = this.color.y;
                            b = this.color.z;
                        }
                        if (this.alphaNodes != null) {
                            a = this.alpha;
                        }
                        r *= this.emisson.colorRate;
                        g *= this.emisson.colorRate;
                        b *= this.emisson.colorRate;
                        a *= this.emisson.colorRate;
                        r = m4m.math.floatClamp(r, 0, 3);
                        g = m4m.math.floatClamp(g, 0, 3);
                        b = m4m.math.floatClamp(b, 0, 3);
                        a = m4m.math.floatClamp(a, 0, 3);
                        this.dataForVbo[i * this.emisson.vertexSize + 3] = r;
                        this.dataForVbo[i * this.emisson.vertexSize + 4] = g;
                        this.dataForVbo[i * this.emisson.vertexSize + 5] = b;
                        this.dataForVbo[i * this.emisson.vertexSize + 6] = a;
                    }
                    {
                        //uv
                        this.dataForVbo[i * vertexSize + 7] = this.sourceVbo[i * vertexSize + 7] * this.tex_ST.x + this.tex_ST.z;
                        this.dataForVbo[i * vertexSize + 8] = this.sourceVbo[i * vertexSize + 8] * this.tex_ST.y + this.tex_ST.w;
                    }
                }
            };
            Particle_new.prototype.dispose = function () {
                this.dataForVbo = null;
                this.dataForEbo = null;
                this.startRotation = null;
                this.localRotation = null;
                this.rotationByEuler = null;
                this.rotationByShape = null;
                this.tex_ST = null;
                this.localMatrix = null;
                this.localTranslate = null;
                this.Starteuler = null;
                this.localScale = null;
                this.color = null;
            };
            return Particle_new;
        }());
        framework.Particle_new = Particle_new;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var Vector3AttributeData = /** @class */ (function () {
            function Vector3AttributeData() {
                this.init();
            }
            Vector3AttributeData.prototype.init = function () {
                this.data = {};
                this.frameIndexs = [];
                var keyPoint = new FrameKeyPointData(0, new m4m.math.vector3());
                this.addFramePoint(keyPoint);
            };
            Vector3AttributeData.prototype.addFramePoint = function (data, func) {
                this.data[data.frameIndex] = data;
                if (data.actions != undefined) {
                    if (this.actions == undefined)
                        this.actions = {};
                    this.actions[data.frameIndex] = data.actions;
                }
                AttributeUtil.addFrameIndex(this.frameIndexs, data.frameIndex);
                if (func != null)
                    func();
            };
            Vector3AttributeData.prototype.removeFramePoint = function (frameId, data, func) {
                if (this.data[frameId] == undefined) {
                    console.warn("当前时间线中没有记录这一帧：" + frameId);
                    return;
                }
                else
                    delete this.data[frameId];
                if (this.actions != undefined && this.actions[frameId] != undefined)
                    delete this.actions[frameId];
                if (this.frameIndexs[frameId] != undefined)
                    this.frameIndexs.splice(this.frameIndexs.indexOf(this.frameIndexs[frameId]), 1);
                if (func != null)
                    func();
            };
            Vector3AttributeData.prototype.updateFramePoint = function (data, func) {
                if (this.data[data.frameIndex] == undefined) {
                    if (func != null)
                        func();
                    return;
                }
                this.data[data.frameIndex] = data;
                if (data.actions != undefined)
                    this.actions[data.frameIndex] = data.actions;
                if (func != null)
                    func();
            };
            Vector3AttributeData = __decorate([
                m4m.reflect.SerializeType,
                __metadata("design:paramtypes", [])
            ], Vector3AttributeData);
            return Vector3AttributeData;
        }());
        framework.Vector3AttributeData = Vector3AttributeData;
        var Vector2AttributeData = /** @class */ (function () {
            function Vector2AttributeData() {
                this.init();
            }
            Vector2AttributeData.prototype.init = function () {
                this.data = {};
                this.frameIndexs = [];
                var keyPoint = new FrameKeyPointData(0, new m4m.math.vector2());
                this.addFramePoint(keyPoint);
            };
            Vector2AttributeData.prototype.addFramePoint = function (data, func) {
                this.data[data.frameIndex] = data;
                if (data.actions != undefined) {
                    if (this.actions == undefined)
                        this.actions = {};
                    this.actions[data.frameIndex] = data.actions;
                }
                AttributeUtil.addFrameIndex(this.frameIndexs, data.frameIndex);
                if (func != null)
                    func();
            };
            Vector2AttributeData.prototype.removeFramePoint = function (frameId, data, func) {
                if (this.data[frameId] == undefined) {
                    console.warn("当前时间线中没有记录这一帧：" + frameId);
                    return;
                }
                else
                    delete this.data[frameId];
                if (this.actions != undefined && this.actions[frameId] != undefined)
                    delete this.actions[frameId];
                if (this.frameIndexs[frameId] != undefined)
                    this.frameIndexs.splice(this.frameIndexs.indexOf(this.frameIndexs[frameId]), 1);
                if (func != null)
                    func();
            };
            Vector2AttributeData.prototype.updateFramePoint = function (data, func) {
                if (this.data[data.frameIndex] == undefined) {
                    if (func != null)
                        func();
                    return;
                }
                this.data[data.frameIndex] = data;
                if (data.actions != undefined)
                    this.actions[data.frameIndex] = data.actions;
                if (func != null)
                    func();
            };
            Vector2AttributeData = __decorate([
                m4m.reflect.SerializeType,
                __metadata("design:paramtypes", [])
            ], Vector2AttributeData);
            return Vector2AttributeData;
        }());
        framework.Vector2AttributeData = Vector2AttributeData;
        var NumberAttributeData = /** @class */ (function () {
            function NumberAttributeData() {
                this.init();
            }
            NumberAttributeData.prototype.init = function () {
                this.data = {};
                this.frameIndexs = [];
                var keyPoint = new FrameKeyPointData(0, 0);
                this.addFramePoint(keyPoint, null);
            };
            NumberAttributeData.prototype.addFramePoint = function (data, func) {
                this.data[data.frameIndex] = data;
                if (data.actions != undefined) {
                    if (this.actions == undefined)
                        this.actions = {};
                    this.actions[data.frameIndex] = data.actions;
                }
                AttributeUtil.addFrameIndex(this.frameIndexs, data.frameIndex);
                if (func != null)
                    func();
            };
            NumberAttributeData.prototype.removeFramePoint = function (frameId, data, func) {
                if (this.data[frameId] == undefined) {
                    console.warn("当前时间线中没有记录这一帧：" + frameId);
                    return;
                }
                else
                    delete this.data[frameId];
                if (this.actions != undefined && this.actions[frameId] != undefined)
                    delete this.actions[frameId];
                if (this.frameIndexs[frameId] != undefined)
                    this.frameIndexs.splice(this.frameIndexs.indexOf(this.frameIndexs[frameId]), 1);
                if (func != null)
                    func();
            };
            NumberAttributeData.prototype.updateFramePoint = function (data, func) {
                if (this.data[data.frameIndex] == undefined) {
                    if (func != null)
                        func();
                    return;
                }
                this.data[data.frameIndex] = data;
                if (data.actions != undefined)
                    this.actions[data.frameIndex] = data.actions;
                if (func != null)
                    func();
            };
            NumberAttributeData = __decorate([
                m4m.reflect.SerializeType,
                __metadata("design:paramtypes", [])
            ], NumberAttributeData);
            return NumberAttributeData;
        }());
        framework.NumberAttributeData = NumberAttributeData;
        var AttributeUIState;
        (function (AttributeUIState) {
            AttributeUIState[AttributeUIState["None"] = 0] = "None";
            AttributeUIState[AttributeUIState["Show"] = 1] = "Show";
            AttributeUIState[AttributeUIState["Hide"] = 2] = "Hide";
        })(AttributeUIState = framework.AttributeUIState || (framework.AttributeUIState = {}));
        var AttributeUIType;
        (function (AttributeUIType) {
            AttributeUIType[AttributeUIType["Number"] = 0] = "Number";
            AttributeUIType[AttributeUIType["Vector2"] = 1] = "Vector2";
            AttributeUIType[AttributeUIType["Vector3"] = 2] = "Vector3";
            AttributeUIType[AttributeUIType["Vector4"] = 3] = "Vector4";
        })(AttributeUIType = framework.AttributeUIType || (framework.AttributeUIType = {}));
        var AttributeValType;
        (function (AttributeValType) {
            AttributeValType[AttributeValType["FixedValType"] = 0] = "FixedValType";
            AttributeValType[AttributeValType["LerpType"] = 1] = "LerpType";
        })(AttributeValType = framework.AttributeValType || (framework.AttributeValType = {}));
        var FrameKeyPointData = /** @class */ (function () {
            function FrameKeyPointData(frameIndex, val) {
                this.frameIndex = frameIndex;
                this.val = val;
            }
            return FrameKeyPointData;
        }());
        framework.FrameKeyPointData = FrameKeyPointData;
        var AttributeUtil = /** @class */ (function () {
            function AttributeUtil() {
            }
            AttributeUtil.addFrameIndex = function (datas, index) {
                for (var i = 0; i < datas.length - 1; i++) {
                    if (index > datas[i] && index <= datas[i + 1]) {
                        datas.splice(i, 0, index);
                        return;
                    }
                }
                datas.push(index);
            };
            return AttributeUtil;
        }());
        framework.AttributeUtil = AttributeUtil;
        // export class VectorLerpAttribute implements LerpAttributeInterface
        // {
        //     timeLine: { [frameId: number]: any };
        //     addFramePoint(frameId: number, data: any)
        //     {
        //         if (this.timeLine == undefined)
        //             this.timeLine = {};
        //         this.timeLine[frameId] = data;
        //     }
        //     removeKeyPoint(frameId: number, data: any)
        //     {
        //         if (this.timeLine == undefined || this.timeLine[frameId] == undefined)
        //         {
        //             console.warn("当前时间线中没有记录这一帧：" + frameId);
        //             return;
        //         }
        //         delete this.timeLine[frameId];
        //     }
        // }
        // export class ColorLerpAttribute implements LerpAttributeInterface
        // {
        //     timeLine: { [frameId: number]: m4m.math.color };
        //     addFramePoint(frameId: number, data: any)
        //     {
        //         if (this.timeLine == undefined)
        //             this.timeLine = {};
        //         if (this.timeLine[frameId] == undefined)
        //             this.timeLine[frameId] = new m4m.math.color();
        //         if (typeof (data) === 'number')
        //         {
        //             this.timeLine[frameId].a = data;
        //         } else if (data instanceof m4m.math.vector3)
        //         {
        //             let c = data as m4m.math.vector3;
        //             this.timeLine[frameId].r = c.x;
        //             this.timeLine[frameId].g = c.y;
        //             this.timeLine[frameId].b = c.z;
        //         }
        //     }
        //     removeKeyPoint(frameId: number, data: any)
        //     {
        //         if (this.timeLine == undefined || this.timeLine[frameId] == undefined)
        //         {
        //             console.warn("当前时间线中没有记录这一帧：" + frameId);
        //             return;
        //         }
        //         if (typeof (data) === 'number')
        //         {
        //             this.timeLine[frameId].a = -1;
        //         } else if (data instanceof m4m.math.vector3)
        //         {
        //             this.timeLine[frameId].r = -1;
        //             this.timeLine[frameId].g = -1;
        //             this.timeLine[frameId].b = -1;
        //         }
        //         if (this.timeLine[frameId].r == -1 && this.timeLine[frameId].a == -1)
        //             delete this.timeLine[frameId];
        //     }
        // }
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var AttributeType;
        (function (AttributeType) {
            AttributeType[AttributeType["PositionType"] = 1] = "PositionType";
            AttributeType[AttributeType["EulerType"] = 2] = "EulerType";
            AttributeType[AttributeType["ScaleType"] = 3] = "ScaleType";
            AttributeType[AttributeType["ColorType"] = 4] = "ColorType";
            AttributeType[AttributeType["ColorRateType"] = 5] = "ColorRateType";
            AttributeType[AttributeType["AlphaType"] = 6] = "AlphaType";
            AttributeType[AttributeType["TillingType"] = 7] = "TillingType";
        })(AttributeType = framework.AttributeType || (framework.AttributeType = {}));
        var EffectElementSingleMesh = /** @class */ (function () {
            function EffectElementSingleMesh(sys, data) {
                if (data === void 0) { data = null; }
                this.elementType = m4m.framework.EffectElementTypeEnum.SingleMeshType; //singlemesh,emission....
                this.beloop = false;
                this.delayTime = 0;
                this.life = 5;
                this.colorRate = 1; //几倍颜色叠加
                this.renderModel = m4m.framework.RenderModel.Mesh;
                this.tex_ST = new m4m.math.vector4(1, 1, 0, 0);
                this.position = [];
                this.euler = [];
                this.scale = [];
                this.color = [];
                this.alpha = [];
                //public effectBatcher: EffectBatcherNew;
                this.loopFrame = Number.MAX_VALUE; //循环帧数
                this.active = true; //激活状态
                this.rotationByEuler = new m4m.math.quaternion();
                this.localRotation = new m4m.math.quaternion();
                this.effectSys = sys;
                if (data != null) {
                    this.initByElementdata(data);
                }
                else {
                    this.initByDefData();
                }
            }
            EffectElementSingleMesh.prototype.initByElementdata = function (data) {
            };
            EffectElementSingleMesh.prototype.initByDefData = function () {
                this.mesh = this.mgr.getDefaultMesh("quad");
                var shader = this.mgr.getShader("diffuse.shader.json");
                this.mat.setShader(shader);
            };
            EffectElementSingleMesh.prototype.writeToJson = function (obj) {
            };
            EffectElementSingleMesh.prototype.update = function () {
                if (this.active) {
                    if (this.curAttrData.euler != undefined) {
                        // console.log("euler:" + this.curAttrData.euler.toString());
                        m4m.math.quatFromEulerAngles(this.curAttrData.euler.x, this.curAttrData.euler.y, this.curAttrData.euler.z, this.curAttrData.rotationByEuler);
                    }
                    this.updateElementRotation();
                    m4m.math.matrixMakeTransformRTS(this.curAttrData.pos, this.curAttrData.scale, this.curAttrData.localRotation, this.curAttrData.matrix);
                }
                else {
                    this.curAttrData.resetMatrix();
                }
            };
            EffectElementSingleMesh.prototype.updateElementRotation = function () {
                var cameraTransform = m4m.framework.sceneMgr.app.getScene().mainCamera.gameObject.transform;
                var worldRotation = m4m.math.pool.new_quaternion();
                var localRotation = m4m.math.pool.new_quaternion();
                if (this.curAttrData.renderModel != framework.RenderModel.None) {
                    var invTransformRotation = m4m.math.pool.new_quaternion();
                    var worldTranslation = m4m.math.pool.new_vector3();
                    var translation = m4m.math.pool.new_vector3();
                    m4m.math.vec3Clone(this.curAttrData.pos, translation);
                    if (this.transform != undefined) {
                        m4m.math.matrixTransformVector3(translation, this.transform.getWorldMatrix(), worldTranslation);
                    }
                    if (this.curAttrData.renderModel == framework.RenderModel.BillBoard) {
                        m4m.math.quatLookat(worldTranslation, cameraTransform.getWorldTranslate(), worldRotation);
                    }
                    else if (this.curAttrData.renderModel == framework.RenderModel.HorizontalBillBoard) {
                        worldRotation.x = -0.5;
                        worldRotation.y = 0.5;
                        worldRotation.z = 0.5;
                        worldRotation.w = 0.5;
                    }
                    else if (this.curAttrData.renderModel == framework.RenderModel.VerticalBillBoard) {
                        var forwardTarget = m4m.math.pool.new_vector3();
                        m4m.math.vec3Clone(cameraTransform.getWorldTranslate(), forwardTarget);
                        forwardTarget.y = worldTranslation.y;
                        m4m.math.quatLookat(worldTranslation, forwardTarget, worldRotation);
                        m4m.math.pool.delete_vector3(forwardTarget);
                    }
                    else if (this.curAttrData.renderModel == framework.RenderModel.StretchedBillBoard) {
                        m4m.math.quatMultiply(worldRotation, this.curAttrData.rotationByEuler, this.curAttrData.localRotation);
                        m4m.math.quatLookat(worldTranslation, cameraTransform.getWorldTranslate(), worldRotation);
                        var lookRot = new m4m.math.quaternion();
                        m4m.math.quatClone(this.transform.getWorldRotate(), invTransformRotation);
                        m4m.math.quatInverse(invTransformRotation, invTransformRotation);
                        m4m.math.quatMultiply(invTransformRotation, worldRotation, lookRot);
                        var inverRot = m4m.math.pool.new_quaternion();
                        m4m.math.quatInverse(this.curAttrData.localRotation, inverRot);
                        m4m.math.quatMultiply(inverRot, lookRot, lookRot);
                        var angle = m4m.math.pool.new_vector3();
                        m4m.math.quatToEulerAngles(lookRot, angle);
                        m4m.math.quatFromEulerAngles(0, angle.y, 0, lookRot);
                        m4m.math.quatMultiply(this.curAttrData.localRotation, lookRot, this.curAttrData.localRotation);
                        m4m.math.pool.delete_quaternion(inverRot);
                        m4m.math.pool.delete_vector3(angle);
                        m4m.math.pool.delete_quaternion(lookRot);
                        return;
                    }
                    else if (this.curAttrData.renderModel == framework.RenderModel.Mesh) {
                        framework.EffectUtil.quatLookatZ(worldTranslation, cameraTransform.getWorldTranslate(), worldRotation);
                    }
                    m4m.math.quatMultiply(worldRotation, this.curAttrData.rotationByEuler, worldRotation);
                    //消除transform组件对粒子本身的影响
                    m4m.math.quatClone(this.transform.gameObject.transform.getWorldRotate(), invTransformRotation);
                    m4m.math.quatInverse(invTransformRotation, invTransformRotation);
                    m4m.math.quatMultiply(invTransformRotation, worldRotation, this.curAttrData.localRotation);
                    m4m.math.pool.delete_vector3(translation);
                    m4m.math.pool.delete_vector3(worldTranslation);
                    m4m.math.pool.delete_quaternion(invTransformRotation);
                }
                else {
                    m4m.math.quatMultiply(worldRotation, this.curAttrData.rotationByEuler, this.curAttrData.localRotation);
                }
                m4m.math.pool.delete_quaternion(localRotation);
                m4m.math.pool.delete_quaternion(worldRotation);
            };
            EffectElementSingleMesh.prototype.dispose = function () {
            };
            EffectElementSingleMesh = __decorate([
                m4m.reflect.SerializeType,
                __metadata("design:paramtypes", [framework.TestEffectSystem, framework.EffectElementData])
            ], EffectElementSingleMesh);
            return EffectElementSingleMesh;
        }());
        framework.EffectElementSingleMesh = EffectElementSingleMesh;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var EffectElementEmission = /** @class */ (function () {
            //-----------------------------------------------------------------
            function EffectElementEmission(sys, data) {
                if (data === void 0) { data = null; }
                this.active = true; //激活状态
                //-------静态属性----------------------------
                this.vf = m4m.render.VertexFormatMask.Position | m4m.render.VertexFormatMask.Color | m4m.render.VertexFormatMask.UV0; //法线切线不要
                this.maxVertexCount = 2048; //batcher 最大定点数
                //------------------------------------show  in hierachy--------------------------------------------------
                //----------------root
                this.rotTranslate = new m4m.math.vector3();
                this.rotScale = new m4m.math.vector3(1, 1, 1);
                this.rotRotation = new m4m.math.vector3();
                this.rotQuta = new m4m.math.quaternion();
                this.elementType = framework.EffectElementTypeEnum.EmissionType; //singlemesh,emission....
                this.delayTime = 0;
                this.beloop = true;
                this.lifeTime = new framework.NumberData(5);
                this.simulateInLocalSpace = true; //粒子运动运动空间（世界还是本地)
                this.startScale = new framework.Vector3Data(1, 1, 1);
                this.startEuler = new framework.Vector3Data();
                this.startColor = new m4m.math.color(1, 1, 1, 1);
                this.colorRate = 1;
                //----------------emision
                this.duration = new framework.NumberData();
                this.emissionCount = new framework.NumberData();
                // emitRate:NumberData=new NumberData();
                // burst:{[time:number]:number};
                this.emissionType = framework.ParticleEmissionType.burst;
                //----------------emission shape
                this.shapeType = framework.ParticleSystemShape.NORMAL;
                this.simulationSpeed = new framework.NumberData();
                this.emitFrom = framework.emitfromenum.base;
                //----------------render
                this.rendermodel = framework.RenderModel.BillBoard;
                //----------------------------------------可选类型-----------------------------------------------------------
                //-----------------position over lifetime
                this.enableVelocityOverLifetime = false;
                //-----------------scale over lifetime
                this.enableSizeOverLifetime = false;
                //-----------------rot over lifetime
                this.enableRotOverLifeTime = false;
                //-----------------color over lifetime
                this.enableColorOverLifetime = false;
                //-----------------texture animation
                this.enableTexAnimation = false;
                this.uvType = framework.UVTypeEnum.NONE;
                this.beBurst = false;
                this.beover = false;
                this.worldRotation = new m4m.math.quaternion();
                this.matToObj = new m4m.math.matrix();
                this.matToWorld = new m4m.math.matrix();
                this.webgl = m4m.framework.sceneMgr.app.webgl;
                this.effectSys = sys;
                this.gameObject = sys.gameObject;
                this.vertexSize = m4m.render.meshData.calcByteSize(this.vf) / 4;
                if (data == null) {
                    this.initDefparticleData();
                }
                else {
                    this.initByEmissonData(data);
                }
                this.perVertexCount = this.mesh.data.getVertexCount();
                this.perIndexxCount = this.mesh.data.getTriIndexCount();
                if (this.emissionType == framework.ParticleEmissionType.continue) {
                    this._continueSpaceTime = this.duration.getValue() / this.emissionCount.getValue();
                }
                this.getmatrixToObj();
                this.emissionBatchers = [];
                this.deadParticles = [];
                this.curTime = 0;
                this.numcount = 0;
                this.addBatcher();
            }
            //设置默认值
            EffectElementEmission.prototype.initDefparticleData = function () {
                //emissiontype
                this.duration.setValue(2.0);
                this.emissionCount.setValue(10);
                //emissionShape
                this.shapeType = framework.ParticleSystemShape.CONE;
                this.simulationSpeed.setValue(0.1);
                this.radius = 1.0;
                this.angle = 45;
                this.height = 1.0;
                //render
                this.mat = framework.sceneMgr.app.getAssetMgr().getDefParticleMat();
                this.mesh = framework.sceneMgr.app.getAssetMgr().getDefaultMesh("quad");
            };
            EffectElementEmission.prototype.initByEmissonData = function (data) {
            };
            EffectElementEmission.prototype.getWorldRotation = function () {
                var parRot = this.gameObject.transform.getWorldRotate();
                m4m.math.quatMultiply(parRot, this.rotQuta, this.worldRotation);
                return this.worldRotation;
            };
            EffectElementEmission.prototype.getmatrixToObj = function () {
                m4m.math.quatFromEulerAngles(this.rotRotation.x, this.rotRotation.y, this.rotRotation.z, this.rotQuta);
                m4m.math.matrixMakeTransformRTS(this.rotTranslate, this.rotScale, this.rotQuta, this.matToObj);
            };
            EffectElementEmission.prototype.getmatrixToWorld = function () {
                var mat = this.gameObject.transform.getWorldMatrix();
                m4m.math.matrixMultiply(mat, this.matToObj, this.matToWorld);
                return this.matToWorld;
            };
            EffectElementEmission.prototype.update = function (delta) {
                this.updateLife(delta);
                this.updateBatcher(delta);
            };
            EffectElementEmission.prototype.updateBatcher = function (delta) {
                for (var key in this.emissionBatchers) {
                    this.emissionBatchers[key].update(delta);
                }
            };
            EffectElementEmission.prototype.updateLife = function (delta) {
                if (this.beover)
                    return;
                this.curTime += delta;
                //--------------update in Livelife-------------------
                this.updateEmission();
                if (this.curTime > this.lifeTime.getValue()) {
                    if (this.beloop) {
                        this.reInit();
                    }
                    else {
                        this.beover = true;
                    }
                }
            };
            EffectElementEmission.prototype.reInit = function () {
                this.beover = false;
                this.curTime = 0;
                this.beBurst = false;
            };
            EffectElementEmission.prototype.updateEmission = function () {
                if (this.emissionType == framework.ParticleEmissionType.continue) {
                    var rate = this.curTime / this.duration.getValue();
                    rate = m4m.math.floatClamp(rate, 0, 1);
                    var needCount = Math.floor(rate * this.emissionCount.getValue());
                    needCount = needCount - this.numcount;
                    for (var i = 0; i < needCount; i++) {
                        this.addParticle();
                        this.numcount++;
                    }
                }
                else if (this.emissionType == framework.ParticleEmissionType.burst && !this.beBurst) {
                    this.addParticle(this.emissionCount.getValue());
                    this.beBurst = true;
                }
            };
            EffectElementEmission.prototype.addParticle = function (count) {
                if (count === void 0) { count = 1; }
                for (var i = 0; i < count; i++) {
                    if (this.deadParticles.length > 0) {
                        var particle = this.deadParticles.pop();
                        particle.initByData();
                        particle.actived = true;
                    }
                    else {
                        var total = this.curbatcher.curVerCount + this.perVertexCount;
                        if (total <= this.maxVertexCount) {
                            this.curbatcher.addParticle();
                        }
                        else {
                            this.addBatcher();
                            this.curbatcher.addParticle();
                        }
                    }
                }
            };
            EffectElementEmission.prototype.addBatcher = function () {
                var batcher = new framework.EmissionBatcher_new(this);
                this.emissionBatchers.push(batcher);
                this.curbatcher = batcher;
            };
            Object.defineProperty(EffectElementEmission.prototype, "renderCamera", {
                get: function () {
                    if (this._renderCamera != null) {
                        return this._renderCamera;
                    }
                    else {
                        return m4m.framework.sceneMgr.app.getScene().mainCamera;
                    }
                },
                enumerable: false,
                configurable: true
            });
            EffectElementEmission.prototype.render = function (context, assetmgr, camera) {
                this._renderCamera = camera;
                if (this.simulateInLocalSpace) {
                    context.updateModel(this.gameObject.transform);
                }
                else {
                    context.updateModeTrail();
                }
                for (var key in this.emissionBatchers) {
                    this.emissionBatchers[key].render(context, assetmgr, camera);
                }
            };
            EffectElementEmission.prototype.dispose = function () {
                for (var key in this.emissionBatchers) {
                    this.emissionBatchers[key].dispose();
                }
                this.emissionBatchers.length = 0;
            };
            EffectElementEmission.prototype.getMesh = function () {
                if (this.rendermodel == framework.RenderModel.Mesh) {
                    return this.mesh;
                }
                else if (this.rendermodel == framework.RenderModel.StretchedBillBoard) {
                    this.mesh = m4m.framework.sceneMgr.app.getAssetMgr().getDefaultMesh("quad_particle");
                }
                else {
                    this.mesh = m4m.framework.sceneMgr.app.getAssetMgr().getDefaultMesh("quad");
                }
            };
            EffectElementEmission.prototype.cloneMeshVBO = function () {
                if (this.vbo == null) {
                    this.vbo = this.mesh.data.genVertexDataArray(this.vf);
                }
                return new Float32Array(this.vbo);
            };
            EffectElementEmission.prototype.cloneMeshEBO = function () {
                if (this.ebo == null) {
                    this.ebo = this.mesh.data.genIndexDataArray();
                }
                return new Uint16Array(this.ebo);
            };
            EffectElementEmission.prototype.writeToJson = function (obj) {
                throw new Error("Method not implemented.");
            };
            EffectElementEmission = __decorate([
                m4m.reflect.SerializeType,
                __metadata("design:paramtypes", [framework.TestEffectSystem, framework.EffectElementData])
            ], EffectElementEmission);
            return EffectElementEmission;
        }());
        framework.EffectElementEmission = EffectElementEmission;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @private
         */
        var EmissionBatcher_new = /** @class */ (function () {
            function EmissionBatcher_new(emissionElement) {
                this.particles = [];
                this.curVerCount = 0;
                this.curIndexCount = 0;
                this.emission = emissionElement;
                this.webgl = emissionElement.webgl;
                this.mat = this.emission.mat;
                this.initMesh();
            }
            EmissionBatcher_new.prototype.initMesh = function () {
                this.mesh = new framework.mesh();
                this.mesh.data = new m4m.render.meshData();
                this.mesh.glMesh = new m4m.render.glMesh();
                this.mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.start = 0;
                    sm.size = 0;
                    sm.line = false;
                    this.mesh.submesh.push(sm);
                }
                this.dataForVbo = new Float32Array(128);
                this.dataForEbo = new Uint16Array(128);
                this.mesh.glMesh.initBuffer(this.webgl, this.emission.vf, 128, m4m.render.MeshTypeEnum.Dynamic);
                this.mesh.glMesh.addIndex(this.webgl, this.dataForEbo.length);
                this.mesh.glMesh.initVAO();
            };
            EmissionBatcher_new.prototype.addParticle = function () {
                this.refreshBuffer();
                var p = new framework.Particle_new(this);
                //p.uploadData(this.dataForVbo);
                for (var i = 0; i < p.dataForEbo.length; i++) {
                    this.dataForEbo[this.curIndexCount + i] = p.dataForEbo[i] + this.curVerCount;
                }
                this.particles.push(p);
                this.curVerCount += this.emission.perVertexCount;
                this.curIndexCount += this.emission.perIndexxCount;
                // this.mesh.glMesh.uploadVertexSubData(context.webgl, this.dataForVbo);
                // this.mesh.glMesh.uploadIndexSubData(this.webgl, 0, this.dataForEbo);
                this.mesh.glMesh.uploadIndexData(this.webgl, 0, this.dataForEbo);
                this.mesh.submesh[0].size = this.curIndexCount;
            };
            EmissionBatcher_new.prototype.refreshBuffer = function () {
                var needvercount = this.curVerCount + this.emission.perVertexCount;
                var needIndexCount = this.curIndexCount + this.emission.perIndexxCount;
                if (needvercount * this.emission.vertexSize > this.dataForVbo.length) {
                    var length = this.dataForVbo.length;
                    this.mesh.glMesh.resetVboSize(this.webgl, length * 2);
                    var vbo = new Float32Array(length * 2);
                    vbo.set(this.dataForVbo, 0);
                    this.dataForVbo = vbo;
                }
                if (needIndexCount > this.dataForEbo.length) {
                    var length = this.dataForEbo.length;
                    this.mesh.glMesh.resetEboSize(this.webgl, 0, length * 2);
                    var ebo = new Uint16Array(length * 2);
                    ebo.set(this.dataForEbo, 0);
                    this.dataForEbo = ebo;
                }
            };
            EmissionBatcher_new.prototype.update = function (delta) {
                for (var key in this.particles) {
                    this.particles[key].update(delta);
                    this.particles[key].uploadData(this.dataForVbo);
                }
            };
            EmissionBatcher_new.prototype.render = function (context, assetmgr, camera) {
                var mesh = this.mesh;
                //mesh.glMesh.uploadVertexSubData(context.webgl, this.dataForVbo);
                mesh.glMesh.uploadVertexData(context.webgl, this.dataForVbo);
                if (assetmgr.app.getScene().fog) {
                    // context.fog = assetmgr.app.getScene().fog;
                    this.mat.draw(context, mesh, mesh.submesh[0], "base_fog");
                }
                else {
                    this.mat.draw(context, mesh, mesh.submesh[0], "base");
                }
            };
            EmissionBatcher_new.prototype.dispose = function () {
                this.dataForVbo = null;
                this.dataForEbo = null;
                this.mesh.dispose();
                this.mat.dispose();
                for (var key in this.particles) {
                    this.particles[key].dispose();
                }
            };
            return EmissionBatcher_new;
        }());
        framework.EmissionBatcher_new = EmissionBatcher_new;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        // /**
        //  * @private
        //  */
        // export class NumberData
        // {
        //     public isRandom: boolean = false;
        //     public _value: number = 0;
        //     public _valueLimitMin: number = 0;
        //     public _valueLimitMax: number = 0;
        //     private beInited: boolean = false;
        //     private key:number;//random值（0--1）
        //     setValue(value:number)
        //     {
        //         this._value=value;
        //     }
        //     setRandomValue(max:number,min:number)
        //     {
        //         this._valueLimitMax=max;
        //         this._valueLimitMin=min;
        //         this.isRandom=true;
        //     }
        //     /**
        //      * 针对随机类型，只要随机过一次就返回值不变（rerandom=false），返回新的随机值（rerandom=true）
        //      */
        //     public getValue(reRandom:boolean=false)
        //     {
        //         if (this.isRandom)
        //         {
        //             if(reRandom||!this.beInited)
        //             {
        //                 this.key=Math.random();
        //                 this._value=this.key*(this._valueLimitMax-this._valueLimitMin)+this._valueLimitMin;
        //                 this.beInited = true
        //             }
        //         }
        //         return this._value;
        //     }
        //     constructor(value:number=null)
        //     {
        //         if(value!=null)
        //         {
        //             this._value=value;
        //         }
        //     }
        //     public static RandomRange(min: number, max: number, isInteger: boolean = false)
        //     {
        //         if (isInteger)
        //         {
        //             return Math.floor(Math.random() * (max - min + 1) + min);
        //         }
        //         return Math.random() * (max - min) + min;
        //     }
        // }
        // export class Vector3Data
        // {
        //     x:NumberData=new NumberData();
        //     y:NumberData=new NumberData();
        //     z:NumberData=new NumberData();
        //     constructor(x:number=0,y:number=0,z:number=0)
        //     {
        //         this.x.setValue(x);
        //         this.y.setValue(y);
        //         this.z.setValue(z);
        //     }
        //     getValue():m4m.math.vector3
        //     {
        //         var out:m4m.math.vector3=new m4m.math.vector3();
        //         out.x=this.x.getValue();
        //         out.y=this.y.getValue();
        //         out.z=this.z.getValue();
        //         return out;
        //     }
        // }
        // export class NumberKey
        // {
        //     key:number;
        //     value:number;
        //     constructor(_key:number,_value:number)
        //     {
        //         this.key=_key;
        //         this.value=_value;
        //     }
        // }
        // export class Vector3Key
        // {
        //     key:number;
        //     value:math.vector3;
        //     constructor(_key:number,_value:math.vector3)
        //     {
        //         this.key=_key;
        //         this.value=_value;
        //     }
        // }
        // export class Vector2Key
        // {
        //     key:number;
        //     value:math.vector2;
        //     constructor(_key:number,_value:math.vector2)
        //     {
        //         this.key=_key;
        //         this.value=_value;
        //     }
        // }
        var effTools = /** @class */ (function () {
            function effTools() {
            }
            effTools.getRandomDirAndPosByZEmission = function (emission, outDir, outPos) {
                switch (emission.shapeType) {
                    case framework.ParticleSystemShape.NORMAL:
                        m4m.math.vec3Clone(m4m.math.pool.vector3_zero, outPos);
                        m4m.math.vec3Clone(m4m.math.pool.vector3_up, outDir);
                        break;
                    case framework.ParticleSystemShape.SPHERE:
                        var o = Math.random() * Math.PI * 2;
                        var o1 = Math.random() * Math.PI;
                        outDir.x = Math.sin(o1) * Math.cos(o);
                        outDir.y = Math.cos(o1);
                        outDir.z = Math.sin(o1) * Math.sin(o);
                        var radius = Math.random() * emission.radius;
                        m4m.math.vec3ScaleByNum(outDir, radius, outPos);
                        break;
                    case framework.ParticleSystemShape.HEMISPHERE:
                        var o = Math.random() * Math.PI * 2;
                        var o1 = Math.random() * Math.PI * 0.5;
                        var radius = Math.random() * emission.radius;
                        outDir.x = Math.sin(o1) * Math.cos(o);
                        outDir.y = Math.cos(o1);
                        outDir.z = Math.sin(o1) * Math.sin(o);
                        m4m.math.vec3ScaleByNum(outDir, radius, outPos);
                        break;
                    case framework.ParticleSystemShape.BOX:
                        outPos.x = framework.ValueData.RandomRange(-emission.width / 2, emission.width / 2);
                        outPos.y = framework.ValueData.RandomRange(-emission.height / 2, emission.height / 2);
                        outPos.z = framework.ValueData.RandomRange(-emission.depth / 2, emission.depth / 2);
                        m4m.math.vec3Normalize(outPos, outDir);
                        break;
                    case framework.ParticleSystemShape.CONE:
                        var randomAngle = Math.random() * Math.PI * 2; //弧度
                        var randomHeight = Math.random() * emission.height;
                        var upradius = randomHeight * Math.tan(emission.angle * Math.PI / 180) + emission.radius;
                        var radomRadius = Math.random() * upradius;
                        var bottompos = m4m.math.pool.new_vector3();
                        bottompos.x = emission.radius * Math.cos(randomAngle);
                        bottompos.y = 0;
                        bottompos.z = emission.radius * Math.sin(randomAngle);
                        if (emission.emitFrom == framework.emitfromenum.base) {
                            m4m.math.vec3Clone(bottompos, outPos);
                        }
                        else if (emission.emitFrom == framework.emitfromenum.volume) {
                            outPos.x = radomRadius * Math.cos(randomAngle);
                            outPos.z = radomRadius * Math.sin(randomAngle);
                            outPos.y = randomHeight;
                        }
                        outDir.x = Math.cos(randomAngle) * Math.sin(emission.angle * Math.PI / 180);
                        outDir.z = Math.sin(randomAngle) * Math.sin(emission.angle * Math.PI / 180);
                        outDir.y = Math.cos(emission.angle * Math.PI / 180);
                        break;
                }
            };
            effTools.getTex_ST = function (emission, out_St) {
                if (emission.uvType != framework.UVTypeEnum.UVSprite) {
                    out_St.x = 1;
                    out_St.y = 1;
                    out_St.z = 0;
                    out_St.w = 0;
                }
                else {
                    m4m.math.spriteAnimation(emission.row, emission.column, 0, out_St);
                }
            };
            return effTools;
        }());
        framework.effTools = effTools;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
     * 贝塞尔曲线，目前定义了三种：线性贝塞尔曲线(两个点形成),二次方贝塞尔曲线（三个点形成），三次方贝塞尔曲线（四个点形成）
     */
        /**
         * @private
         */
        var Curve3 = /** @class */ (function () {
            function Curve3(points, nbPoints) {
                this._beizerPoints = points;
                this._bezierPointNum = nbPoints;
            }
            Object.defineProperty(Curve3.prototype, "beizerPoints", {
                get: function () {
                    return this._beizerPoints;
                },
                set: function (value) {
                    this._beizerPoints = value;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(Curve3.prototype, "bezierPointNum", {
                get: function () {
                    return this._bezierPointNum;
                },
                set: function (value) {
                    this._bezierPointNum = value;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * 线性贝塞尔曲线
             * @param start
             * @param end
             * @param indices
             */
            Curve3.CreateLinearBezier = function (start, end, indices) {
                indices = indices > 2 ? indices : 3;
                var bez = new Array();
                var equation = function (t, va10, va11) {
                    var res = (1.0 - t) * va10 + t * va11;
                    return res;
                };
                bez.push(start);
                for (var i = 1; i <= indices; i++) {
                    bez.push(new m4m.math.vector3(equation(i / indices, start.x, end.x), equation(i / indices, start.y, start.y), equation(i / indices, start.z, start.z)));
                }
                return new Curve3(bez, indices);
            };
            Curve3.GetLerpBezier = function (nodes) {
                var beizerPoint = new Array();
                for (var n = 0; n < nodes.length; n++) {
                    beizerPoint.push(nodes[n].getValue());
                }
                return new Curve3(beizerPoint, nodes.length);
            };
            /**
             * 二次方贝塞尔曲线路径
             * @param v0 起始点
             * @param v1 选中的节点
             * @param v2 结尾点
             * @param nbPoints 将贝塞尔曲线拆分nbPoints段，一共有nbPoints+1个点
             */
            Curve3.CreateQuadraticBezier = function (v0, v1, v2, bezierPointNum) {
                bezierPointNum = bezierPointNum > 2 ? bezierPointNum : 3;
                var beizerPoint = new Array();
                var equation = function (t, val0, val1, val2) {
                    var res = (1.0 - t) * (1.0 - t) * val0 + 2.0 * t * (1.0 - t) * val1 + t * t * val2;
                    return res;
                };
                for (var i = 1; i <= bezierPointNum; i++) {
                    beizerPoint.push(new m4m.math.vector3(equation(i / bezierPointNum, v0.x, v1.x, v2.x), equation(i / bezierPointNum, v0.y, v1.y, v2.y), equation(i / bezierPointNum, v0.z, v1.z, v2.z)));
                }
                return new Curve3(beizerPoint, bezierPointNum);
            };
            /**
             * 三次方贝塞尔曲线路径
             * @param v0
             * @param v1
             * @param v2
             * @param v3
             * @param nbPoints
             */
            Curve3.CreateCubicBezier = function (v0, v1, v2, v3, bezierPointNum) {
                bezierPointNum = bezierPointNum > 3 ? bezierPointNum : 4;
                var beizerPoint = new Array();
                var equation = function (t, val0, val1, val2, val3) {
                    var res = (1.0 - t) * (1.0 - t) * (1.0 - t) * val0 + 3.0 * t * (1.0 - t) * (1.0 - t) * val1 + 3.0 * t * t * (1.0 - t) * val2 + t * t * t * val3;
                    return res;
                };
                for (var i = 1; i <= bezierPointNum; i++) {
                    beizerPoint.push(new m4m.math.vector3(equation(i / bezierPointNum, v0.x, v1.x, v2.x, v3.x), equation(i / bezierPointNum, v0.y, v1.y, v2.y, v3.y), equation(i / bezierPointNum, v0.z, v1.z, v2.z, v3.z)));
                }
                return new Curve3(beizerPoint, bezierPointNum);
            };
            /**
             * 贝塞尔曲线上的点
             */
            Curve3.prototype.getPoints = function () {
                return this._beizerPoints;
            };
            return Curve3;
        }());
        framework.Curve3 = Curve3;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @private
         */
        var LinearAction = /** @class */ (function () {
            function LinearAction() {
            }
            LinearAction.prototype.init = function (_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params != undefined) {
                    this.attriname = this.params["name"];
                    switch (this.attriname) {
                        case "pos":
                        case "scale":
                        case "euler":
                        case "color":
                            this.attrival = framework.EffectUtil.parseEffectVec3(this.params["value"]);
                            break;
                        case "uv":
                            this.attrival = framework.EffectUtil.parseEffectUVSpeed(this.params["value"]);
                            break;
                        case "alpha":
                            this.attrival = this.params["value"];
                            break;
                    }
                }
            };
            LinearAction.prototype.update = function (frameIndex) {
                if (this.startFrame > frameIndex || this.endFrame < frameIndex)
                    return;
                var baseValue = this.elements.curAttrData;
                switch (this.attriname) {
                    case "pos":
                        baseValue.pos.x = baseValue.pos.x + this.attrival.x.getValue();
                        baseValue.pos.y = baseValue.pos.y + this.attrival.y.getValue();
                        baseValue.pos.z = baseValue.pos.z + this.attrival.z.getValue();
                        break;
                    case "scale":
                        baseValue.scale.x = baseValue.scale.x + this.attrival.x.getValue();
                        baseValue.scale.y = baseValue.scale.y + this.attrival.y.getValue();
                        baseValue.scale.z = baseValue.scale.z + this.attrival.z.getValue();
                        break;
                    case "euler":
                        baseValue.euler.x = baseValue.euler.x + this.attrival.x.getValue();
                        baseValue.euler.y = baseValue.euler.y + this.attrival.y.getValue();
                        baseValue.euler.z = baseValue.euler.z + this.attrival.z.getValue();
                        break;
                    case "color":
                        baseValue.color.x = baseValue.color.x + this.attrival.x.getValue();
                        baseValue.color.y = baseValue.color.y + this.attrival.y.getValue();
                        baseValue.color.z = baseValue.color.z + this.attrival.z.getValue();
                        break;
                    case "uv":
                        baseValue.uv.x = baseValue.uv.x + this.attrival.u.getValue();
                        baseValue.uv.y = baseValue.uv.y + this.attrival.v.getValue();
                        break;
                    case "alpha":
                        baseValue.alpha = baseValue.alpha + this.attrival;
                        break;
                }
            };
            return LinearAction;
        }());
        framework.LinearAction = LinearAction;
        /**
         * @private
         */
        var DestroyAction = /** @class */ (function () {
            function DestroyAction() {
            }
            DestroyAction.prototype.init = function (_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
            };
            DestroyAction.prototype.update = function (frameIndex) {
                if (frameIndex >= this.startFrame) {
                    this.elements.setActive(false);
                }
            };
            return DestroyAction;
        }());
        framework.DestroyAction = DestroyAction;
        /**
         * @private
         */
        var LoopAction = /** @class */ (function () {
            function LoopAction() {
            }
            LoopAction.prototype.init = function (_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
            };
            LoopAction.prototype.update = function (frameIndex) {
                if (frameIndex == this.startFrame) {
                    this.elements.loopFrame = this.startFrame + 1;
                    this.elements.curAttrData = this.elements.data.initFrameData.attrsData.copyandinit();
                }
            };
            return LoopAction;
        }());
        framework.LoopAction = LoopAction;
        /**
         * @private
         */
        var UVRollAction = /** @class */ (function () {
            function UVRollAction() {
                this.speedu = 0;
                this.speedv = 0;
                this.startu = 0;
                this.startv = 0;
            }
            UVRollAction.prototype.init = function (_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params["speedu"] != undefined) {
                    this.speedu = this.params["speedu"];
                }
                if (this.params["speedv"] != undefined) {
                    this.speedv = this.params["speedv"];
                }
                if (this.params["startu"] != undefined) {
                    this.startu = this.params["startu"];
                }
                if (this.params["startv"] != undefined) {
                    this.startv = this.params["startv"];
                }
            };
            UVRollAction.prototype.update = function (frameIndex) {
                if (this.startFrame > frameIndex || this.endFrame < frameIndex)
                    return;
                if (this.startFrame == frameIndex) {
                    //init
                    this.elements.curAttrData.uv.x = this.startu;
                    this.elements.curAttrData.uv.y = this.startv;
                    return;
                }
                this.elements.curAttrData.uv.x += this.speedu;
                this.elements.curAttrData.uv.y += this.speedv;
            };
            return UVRollAction;
        }());
        framework.UVRollAction = UVRollAction;
        /**
         * @private
         */
        var UVSpriteAnimationAction = /** @class */ (function () {
            function UVSpriteAnimationAction() {
                /**
                 * 控制播放速度
                 *
                 * @type {number}
                 * @memberof UISpriteAnimation
                 */
                this.fps = 30;
                /**
                 * 行
                 *
                 * @type {number}
                 * @memberof UISpriteAnimation
                 */
                this.row = 1;
                /**
                 * 列
                 *
                 * @type {number}
                 * @memberof UISpriteAnimation
                 */
                this.colum = 1;
                this.totalCount = 1;
                this.frameInternal = 1;
                this.spriteIndex = 0;
                this.tex_ST = new m4m.math.vector4(1, 1, 0, 0);
            }
            UVSpriteAnimationAction.prototype.init = function (_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                // if (this.params["fps"] != undefined)
                // {
                //     this.fps = <number>this.params["fps"];
                //     this.frameInternal = effectSystem.fps / this.fps;
                // }
                if (this.params["row"] != undefined) {
                    this.row = this.params["row"];
                }
                if (this.params["colum"] != undefined) {
                    this.colum = this.params["colum"];
                }
                if (this.params["count"] != undefined) {
                    this.totalCount = this.params["count"];
                }
            };
            UVSpriteAnimationAction.prototype.update = function (frameIndex) {
                if (this.startFrame > frameIndex || this.endFrame < frameIndex)
                    return;
                var spriteindex = Math.floor((frameIndex - this.startFrame) / (this.endFrame - this.startFrame) * this.totalCount);
                m4m.math.spriteAnimation(this.row, this.colum, spriteindex, this.tex_ST);
                this.elements.curAttrData.uv.x = this.tex_ST.z;
                this.elements.curAttrData.uv.y = this.tex_ST.w;
                this.elements.curAttrData.tilling.x = this.tex_ST.x;
                this.elements.curAttrData.tilling.y = this.tex_ST.y;
            };
            return UVSpriteAnimationAction;
        }());
        framework.UVSpriteAnimationAction = UVSpriteAnimationAction;
        /**
         * @private
         */
        var RotationAction = /** @class */ (function () {
            function RotationAction() {
            }
            RotationAction.prototype.init = function (_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params["velocity"] != undefined) {
                    this.velocity = framework.EffectUtil.parseEffectVec3(this.params["velocity"]);
                }
                this.frameInternal = 1 / framework.effectSystem.fps;
            };
            RotationAction.prototype.update = function (frameIndex) {
                // // if (this.startFrame > frameIndex || this.endFrame < frameIndex) 
                this.elements.curAttrData.euler.z = this.elements.curAttrData.euler.z + (this.velocity.z.getValue()) * this.frameInternal;
                if (this.elements.curAttrData.renderModel == framework.RenderModel.None) {
                    this.elements.curAttrData.euler.x = this.elements.curAttrData.euler.x + (this.velocity.x.getValue()) * this.frameInternal;
                    this.elements.curAttrData.euler.y = this.elements.curAttrData.euler.y + (this.velocity.y.getValue()) * this.frameInternal;
                }
                // let rotationX = m4m.math.pool.new_quaternion();
                // m4m.math.quatFromAxisAngle(this.elements.curAttrData.localAxisX, this.elements.curAttrData.euler.x, rotationX);
                // let rotationY = m4m.math.pool.new_quaternion();
                // m4m.math.quatFromAxisAngle(this.elements.curAttrData.localAxisY, this.elements.curAttrData.euler.y, rotationY);
                // let rotationZ = m4m.math.pool.new_quaternion();
                // m4m.math.quatFromAxisAngle(this.elements.curAttrData.localAxisZ, this.elements.curAttrData.euler.z, rotationZ);
                // m4m.math.quatMultiply(this.elements.curAttrData.rotationByEuler,rotationZ,this.elements.curAttrData.rotationByEuler);
            };
            return RotationAction;
        }());
        framework.RotationAction = RotationAction;
        /**
         * @private
         */
        var RoseCurveAction = /** @class */ (function () {
            function RoseCurveAction() {
            }
            RoseCurveAction.prototype.init = function (_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params["radius"] != undefined) {
                    this.radius = this.params["radius"];
                }
                if (this.params["level"] != undefined) {
                    this.level = this.params["radius"];
                }
                if (this.params["speed"] != undefined) {
                    this.speed = this.params["speed"];
                }
                if (this.params["polar"] != undefined) {
                    this.polar = framework.EffectUtil.parseEffectVec3(this.params["polar"]);
                }
                this.frameInternal = 1 / framework.effectSystem.fps;
            };
            RoseCurveAction.prototype.update = function (frameIndex) {
                var initFrameDataPos = m4m.math.pool.new_vector3();
                m4m.math.vec3Clone(this.elements.data.initFrameData.attrsData.pos, initFrameDataPos);
                var radius = this.radius;
                var curFrame = frameIndex % 360;
                var x = this.polar.x.getValue();
                var y = this.polar.y.getValue();
                var z = this.polar.z.getValue();
                {
                    var theta = frameIndex * this.speed;
                    this.elements.curAttrData.pos.x = initFrameDataPos.x + radius * Math.cos(3 * theta + x) * Math.cos(theta);
                    this.elements.curAttrData.pos.z = initFrameDataPos.z + radius * Math.cos(3 * theta + x) * Math.sin(theta);
                    this.elements.curAttrData.pos.y = initFrameDataPos.y + y * Math.cos(frameIndex * this.speed);
                }
                {
                    var deltaTheta = frameIndex * this.speed + 0.001;
                    var targetPoint = m4m.math.pool.new_vector3();
                    targetPoint.x = initFrameDataPos.x + radius * Math.cos(3 * deltaTheta + x) * Math.cos(deltaTheta);
                    targetPoint.z = initFrameDataPos.z + radius * Math.cos(3 * deltaTheta + x) * Math.sin(deltaTheta);
                    targetPoint.y = initFrameDataPos.y + y * Math.cos(frameIndex * this.speed);
                    var rotation = m4m.math.pool.new_quaternion();
                    m4m.math.quatLookat(this.elements.curAttrData.pos, targetPoint, rotation);
                    m4m.math.quatToEulerAngles(rotation, this.elements.curAttrData.euler);
                    m4m.math.pool.delete_vector3(targetPoint);
                    m4m.math.pool.delete_quaternion(rotation);
                }
                m4m.math.pool.delete_vector3(initFrameDataPos);
            };
            return RoseCurveAction;
        }());
        framework.RoseCurveAction = RoseCurveAction;
        /**
         * @private
         */
        var TrailAction = /** @class */ (function () {
            function TrailAction() {
                this.offsetTransalte = new m4m.math.vector3();
            }
            TrailAction.prototype.init = function (_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params["pos"] != undefined) {
                    this.position = framework.EffectUtil.parseEffectVec3(this.params["pos"]);
                }
                this.offsetTransalte.x = this.position.x.getValue();
                this.offsetTransalte.y = this.position.y.getValue();
                this.offsetTransalte.z = this.position.z.getValue();
                if (this.params["eular"] != undefined) {
                    this.eular = framework.EffectUtil.parseEffectVec3(this.params["eular"]);
                }
                if (this.params["color"] != undefined) {
                    this.color = framework.EffectUtil.parseEffectVec3(this.params["color"]);
                }
                if (this.params["width"] != undefined) {
                    this.width = this.params["width"];
                }
                if (this.params["speed"] != undefined) {
                    this.speed = this.params["speed"];
                }
                if (this.params["speed"] != undefined) {
                    this.speed = this.params["speed"];
                }
                if (this.params["alpha"] != undefined) {
                    this.alpha = this.params["alpha"];
                }
                var mat = new m4m.framework.material();
                var shader = new m4m.framework.shader();
                var texture = new m4m.framework.texture();
                if (this.params["shader"] != undefined)
                    shader = framework.sceneMgr.app.getAssetMgr().getShader(this.params["shader"]);
                else
                    shader = framework.sceneMgr.app.getAssetMgr().getShader("shader/def");
                mat.setShader(shader);
                if (this.params["diffuseTexture"] != undefined)
                    texture = framework.sceneMgr.app.getAssetMgr().getAssetByName(this.params["diffuseTexture"]);
                mat.setTexture("_MainTex", texture);
                this.frameInternal = 1 / framework.effectSystem.fps;
                this.transform = new m4m.framework.transform();
                framework.sceneMgr.scene.addChild(this.transform);
                var curAttrData = this.elements.data.initFrameData.attrsData.clone();
                var worldTranslate = m4m.math.pool.new_vector3();
                m4m.math.vec3Clone(curAttrData.pos, worldTranslate);
                if (this.elements.transform != undefined) {
                    m4m.math.matrixTransformVector3(worldTranslate, this.elements.transform.getWorldMatrix(), worldTranslate);
                }
                m4m.math.vec3Clone(worldTranslate, this.transform.localTranslate);
                m4m.math.pool.delete_vector3(worldTranslate);
                var trailTransform = new m4m.framework.transform();
                this.transform.addChild(trailTransform);
                var x = this.eular.x.getValue();
                var y = this.eular.y.getValue();
                var z = this.eular.z.getValue();
                this.startRotation = new m4m.math.quaternion();
                m4m.math.quatFromEulerAngles(x, y, z, this.startRotation);
                m4m.math.quatMultiply(this.startRotation, curAttrData.localRotation, this.transform.localRotate);
                this.transform.markDirty();
                trailTransform.markDirty();
                var trailrender = trailTransform.gameObject.addComponent("trailRender");
                trailrender.color = new m4m.math.color(this.color.x.getValue(), this.color.y.getValue(), this.color.z.getValue(), this.alpha);
                trailrender.setspeed(this.speed);
                trailrender.setWidth(this.width);
                trailrender.material = mat;
            };
            TrailAction.prototype.update = function (frameIndex) {
                var worldTranslate = m4m.math.pool.new_vector3();
                m4m.math.vec3Clone(this.elements.curAttrData.pos, worldTranslate);
                if (this.elements.transform != undefined) {
                    m4m.math.matrixTransformVector3(worldTranslate, this.elements.transform.getWorldMatrix(), worldTranslate);
                }
                m4m.math.vec3Clone(worldTranslate, this.transform.localTranslate);
                m4m.math.vec3Add(this.transform.localTranslate, this.offsetTransalte, this.transform.localTranslate);
                m4m.math.pool.delete_vector3(worldTranslate);
                // m4m.math.quatClone(this.elements.curAttrData.localRotation,this.transform.localRotate);
                m4m.math.quatMultiply(this.startRotation, this.elements.curAttrData.localRotation, this.transform.localRotate);
                this.transform.markDirty();
            };
            return TrailAction;
        }());
        framework.TrailAction = TrailAction;
        /**
         * @private
         */
        var BreathAction = /** @class */ (function () {
            function BreathAction() {
            }
            BreathAction.prototype.init = function (_startFrame, _endFrame, _params, _elements) {
                this.startFrame = _startFrame;
                this.endFrame = _endFrame;
                this.params = _params;
                this.elements = _elements;
                if (this.params != undefined) {
                    this.attriname = this.params["name"];
                    this.loopframe = this.params["loopframe"];
                    this.halfloopframe = this.loopframe / 2;
                    this.curTargetFrame = this.startFrame + this.halfloopframe;
                    switch (this.attriname) {
                        case "pos":
                        case "scale":
                        case "euler":
                        case "color":
                            this.startvalue = framework.EffectUtil.parseEffectVec3(this.params["startvalue"]).getValue();
                            this.targetvalue = framework.EffectUtil.parseEffectVec3(this.params["targetvalue"]).getValue();
                            break;
                        case "uv":
                            this.startvalue = framework.EffectUtil.parseEffectUVSpeed(this.params["startvalue"]).getValue();
                            this.targetvalue = framework.EffectUtil.parseEffectUVSpeed(this.params["targetvalue"]).getValue();
                            break;
                        case "alpha":
                            this.startvalue = this.params["startvalue"];
                            this.targetvalue = this.params["targetvalue"];
                            break;
                    }
                }
            };
            BreathAction.prototype.update = function (frameIndex) {
                if (this.startFrame > frameIndex)
                    return; //这里只限制起始
                if (frameIndex >= this.curTargetFrame) {
                    this.swap();
                    this.curTargetFrame += this.halfloopframe;
                }
                var baseValue = this.elements.curAttrData;
                switch (this.attriname) {
                    case "pos":
                        baseValue.pos = this.getLerpValue(frameIndex);
                        break;
                    case "scale":
                        baseValue.scale = this.getLerpValue(frameIndex);
                        break;
                    case "euler":
                        baseValue.euler = this.getLerpValue(frameIndex);
                        break;
                    case "color":
                        baseValue.color = this.getLerpValue(frameIndex);
                        break;
                    case "uv":
                        baseValue.uv = this.getLerpValue(frameIndex);
                        break;
                    case "alpha":
                        baseValue.alpha = this.getLerpValue(frameIndex);
                        break;
                }
            };
            BreathAction.prototype.swap = function () {
                var temp;
                if (this.startvalue instanceof m4m.math.vector3) {
                    temp = m4m.math.pool.clone_vector3(this.startvalue);
                    this.startvalue = m4m.math.pool.clone_vector3(this.targetvalue);
                    this.targetvalue = temp;
                }
                else if (this.startvalue instanceof m4m.math.vector2) {
                    temp = m4m.math.pool.clone_vector2(this.startvalue);
                    this.startvalue = m4m.math.pool.clone_vector2(this.targetvalue);
                    this.targetvalue = temp;
                }
                else {
                    temp = this.startvalue;
                    this.startvalue = this.targetvalue;
                    this.targetvalue = temp;
                }
            };
            BreathAction.prototype.getLerpValue = function (frameIndex) {
                var curframe = (frameIndex - this.startFrame) % this.halfloopframe;
                var outVal;
                if (this.startvalue instanceof m4m.math.vector3) {
                    outVal = new m4m.math.vector3();
                    m4m.math.vec3SLerp(this.startvalue, this.targetvalue, curframe / this.halfloopframe, outVal);
                }
                else if (this.startvalue instanceof m4m.math.vector2) {
                    outVal = new m4m.math.vector2();
                    m4m.math.vec2SLerp(this.startvalue, this.targetvalue, curframe / this.halfloopframe, outVal);
                }
                else {
                    outVal = m4m.math.numberLerp(this.startvalue, this.targetvalue, curframe / this.halfloopframe);
                }
                return outVal;
            };
            return BreathAction;
        }());
        framework.BreathAction = BreathAction;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @private
         */
        var EffectParser = /** @class */ (function () {
            function EffectParser() {
            }
            /**
             * 解析特效数据
             *
             * @param {string} str
             * @param {assetMgr} assetmgr
             * @returns
             *
             * @memberof Effect
             */
            EffectParser.prototype.Parse = function (str, assetmgr) {
                if (str == null)
                    return null;
                this.asMgr = assetmgr;
                var effectData = new framework.EffectSystemData();
                var content = JSON.parse(str);
                if (content["life"] != undefined)
                    effectData.life = content["life"];
                if (content["beloop"] != undefined) {
                    effectData.beLoop = content["beloop"];
                }
                // let list: any[] = [];
                var refOriDic = {};
                var unRefOriDic = {};
                var refCount = 0;
                if (content["elements"] != undefined) {
                    effectData.elementDic = {};
                    var elements = content["elements"];
                    for (var i in elements) {
                        var elementData = elements[i];
                        var name_9 = "";
                        if (elementData["name"] != undefined) {
                            name_9 = elementData["name"];
                            if (effectData.elementDic[name_9] != undefined || refOriDic[name_9] != undefined) {
                                console.error("特效中元素的名字重复：" + name_9);
                                continue;
                            }
                        }
                        else {
                            console.error("未设置特效中元素的名字！");
                            continue;
                        }
                        if (elementData["ref"] != undefined) {
                            // element.refFrom = elementData["ref"];
                            refOriDic[name_9] = elementData;
                            refCount++;
                            continue;
                        }
                        else {
                            effectData.elementDic[name_9] = this._parse(elementData);
                            unRefOriDic[name_9] = elementData;
                        }
                    }
                    while (refCount > 0) {
                        for (var key in refOriDic) {
                            var desOriData = refOriDic[key];
                            if (desOriData == null)
                                continue;
                            var refFrom = desOriData["ref"];
                            if (unRefOriDic[refFrom] != undefined) {
                                var srcOriData = unRefOriDic[refFrom];
                                this.copyAndOverWrite(srcOriData, desOriData);
                                var element = this._parse(desOriData);
                                effectData.elementDic[desOriData["name"]] = element;
                                delete refOriDic[key];
                                refCount--;
                            }
                        }
                    }
                }
                return effectData;
            };
            /**
             * 解析特效中单个元素数据
             * @param elementData
             */
            EffectParser.prototype._parse = function (elementData) {
                var element = new framework.EffectElementData();
                if (elementData["beloop"] != undefined)
                    element.beloop = elementData["beloop"];
                if (elementData["delaytime"] != undefined)
                    element.delayTime = elementData["delaytime"];
                element.name = elementData["name"];
                if (elementData["type"] != undefined) {
                    switch (elementData["type"]) {
                        case "singlemesh":
                            element.type = framework.EffectElementTypeEnum.SingleMeshType;
                            break;
                        case "emission":
                            element.type = framework.EffectElementTypeEnum.EmissionType;
                            break;
                    }
                }
                switch (element.type) {
                    case framework.EffectElementTypeEnum.SingleMeshType:
                        this._parseSingleMeshTypeData(elementData, element);
                        break;
                    case framework.EffectElementTypeEnum.EmissionType:
                        this._parseEmissionTypeData(elementData, element);
                        break;
                }
                return element;
            };
            /**
             * 处理特效中元素之间的ref，同时保留ref出来的数据同样根据配置被随机出来的功能
             * @param srcData
             * @param desData
             */
            EffectParser.prototype.copyAndOverWrite = function (srcData, desData) {
                for (var key in srcData) {
                    var data = srcData[key];
                    if (data != undefined) {
                        var baseType = typeof (data);
                        switch (baseType.toLowerCase()) {
                            case "number":
                            case "string":
                            case "boolean":
                                //对于基础类型，目标data中没有这个字段才赋值，有的话就用目标data中的数据
                                if (desData[key] == undefined)
                                    desData[key] = data;
                                break;
                            default:
                                //对于对象，如果目标中没有这个字段，就直接赋值，有的话，往下继续递归找
                                if (desData[key] == undefined) {
                                    desData[key] = srcData[key];
                                }
                                else {
                                    this.copyAndOverWrite(srcData[key], desData[key]);
                                }
                                break;
                        }
                    }
                }
            };
            /**
             * 解析单mesh类型的特效数据
             */
            EffectParser.prototype._parseSingleMeshTypeData = function (elementData, element) {
                if (elementData["timeline"] != undefined) {
                    element.timelineFrame = {};
                    element.actionData = [];
                    var _timelineArray = elementData["timeline"];
                    for (var j in _timelineArray) {
                        var _timeline = _timelineArray[j];
                        if (_timeline["frame"] == undefined) {
                            console.error("必须要配一个关键帧的索引");
                            continue;
                        }
                        var frame = new framework.EffectFrameData();
                        frame.frameIndex = _timeline["frame"];
                        element.timelineFrame[frame.frameIndex] = frame;
                        frame.attrsData = new framework.EffectAttrsData();
                        if (_timeline["attrs"] != undefined) {
                            var _attrs = _timeline["attrs"];
                            for (var key in _attrs) {
                                var val = this._parseToObjData(key, _attrs[key]);
                                if (key == "mat") {
                                    frame.attrsData.mat = val;
                                }
                                else if (key == "pos") {
                                    frame.attrsData.pos = val.getValue();
                                }
                                else if (key == "scale") {
                                    frame.attrsData.scale = val.getValue();
                                }
                                else if (key == "euler") {
                                    frame.attrsData.euler = val.getValue();
                                }
                                else if (key == "mesh") {
                                    frame.attrsData.mesh = val;
                                }
                                else if (key == "color") {
                                    frame.attrsData.color = val.getValue();
                                }
                                else if (key == "alpha") {
                                    frame.attrsData.alpha = val.getValue();
                                    ;
                                }
                                else if (key == "tilling") {
                                    frame.attrsData.tilling = val.getValue();
                                }
                                else if (key == "billboard") {
                                    frame.attrsData.renderModel = val;
                                }
                                else if (key == "colorRate") {
                                    frame.attrsData.colorRate = val;
                                }
                            }
                        }
                        if (frame.frameIndex == -1) {
                            element.initFrameData = frame;
                        }
                        if (_timeline["lerp"] != undefined) {
                            frame.lerpDatas = [];
                            for (var x in _timeline["lerp"]) {
                                var lerp = new framework.EffectLerpData();
                                lerp.fromFrame = frame.frameIndex;
                                frame.lerpDatas.push(lerp);
                                var _lerp = _timeline["lerp"][x];
                                if (_lerp["type"] != undefined) {
                                    switch (_lerp["type"]) {
                                        case "linear":
                                            lerp.type = framework.EffectLerpTypeEnum.Linear;
                                            break;
                                    }
                                }
                                if (_lerp["to"] != undefined)
                                    lerp.toFrame = this._parseToValueData(_lerp["to"]);
                                if (_lerp["attribute"] != undefined) {
                                    lerp.attrsData = new framework.EffectAttrsData();
                                    var _attribs = _lerp["attribute"];
                                    for (var key in _attribs) {
                                        lerp.attrsList.push(key);
                                        var val = this._parseToObjData(key, _attribs[key]);
                                        if (key == "pos") {
                                            lerp.attrsData.pos = val.getValue();
                                        }
                                        else if (key == "scale") {
                                            lerp.attrsData.scale = val.getValue();
                                        }
                                        else if (key == "euler") {
                                            lerp.attrsData.euler = val.getValue();
                                        }
                                        else if (key == "color") {
                                            lerp.attrsData.color = val.getValue();
                                        }
                                        else if (key == "alpha") {
                                            lerp.attrsData.alpha = val.getValue();
                                        }
                                        else {
                                            console.error("未支持的插值属性：" + key);
                                        }
                                    }
                                }
                            }
                        }
                        if (_timeline["actions"] != undefined) {
                            var _actions = _timeline["actions"];
                            for (var k in _actions) {
                                var action = new framework.EffectActionData();
                                var _action = _actions[k];
                                action.actionType = _action["action"];
                                action.startFrame = frame.frameIndex;
                                if (_action["end"] != undefined) {
                                    action.endFrame = _action["end"];
                                }
                                else {
                                    action.endFrame = -1;
                                }
                                if (_action["param"] != undefined) {
                                    action.params = _action["param"]; //参数action自己解析
                                }
                                element.actionData.push(action);
                            }
                        }
                    }
                }
            };
            EffectParser.prototype._parseEmissionTypeData = function (elementData, element) {
                if (elementData["timeline"] != undefined) {
                    var timelines = elementData["timeline"];
                    if (timelines.length > 0 && timelines[0] != undefined && timelines[0]["attrs"] != undefined) {
                        var _data = timelines[0]["attrs"];
                        var data = new framework.Emission();
                        element.emissionData = data;
                        if (_data["emissionType"] != undefined) {
                            switch (_data["emissionType"]) {
                                case "burst":
                                    data.emissionType = framework.ParticleEmissionType.burst;
                                    break;
                                case "continue":
                                    data.emissionType = framework.ParticleEmissionType.continue;
                                    break;
                            }
                            // if (_data["beloop"] != undefined)
                            // {
                            //     //data.beLoop = <boolean>_data["beloop"];
                            //     data.paricleLoop=<boolean>_data["beloop"];
                            //     if(data.paricleLoop) 
                            //     {
                            //         data.beLoop=true;
                            //     }
                            // }
                            if (_data["simulateinlocal"] != undefined) {
                                data.simulateInLocalSpace = _data["simulateinlocal"];
                            }
                            if (_data["maxcount"] != undefined)
                                data.maxEmissionCount = _data["maxcount"];
                            if (_data["emissioncount"] != undefined)
                                data.emissionCount = _data["emissioncount"];
                            if (_data["time"] != undefined)
                                data.time = _data["time"];
                            if (_data["mesh"] != undefined)
                                data.mesh = this._parseToObjData("mesh", _data["mesh"]);
                            if (_data["mat"] != undefined)
                                data.mat = this._parseToObjData("mat", _data["mat"]);
                            // if (_data["pos"] != undefined)
                            //     data.pos = this._parseToObjData("pos", _data["pos"]);
                            // if (_data["shape"] != undefined)
                            //     data.shape = _data["shape"];
                            if (_data["rootpos"] != undefined) {
                                data.rootpos = framework.EffectUtil.parseVector3(_data["rootpos"]);
                            }
                            else {
                                data.rootpos = new m4m.math.vector3();
                            }
                            if (_data["rootRotAngle"] != undefined) {
                                data.rootRotAngle = framework.EffectUtil.parseVector3(_data["rootRotAngle"]);
                            }
                            else {
                                data.rootRotAngle = new m4m.math.vector3();
                            }
                            if (_data["rootscale"]) {
                                data.rootScale = framework.EffectUtil.parseVector3(_data["rootscale"]);
                            }
                            else {
                                data.rootScale = new m4m.math.vector3(1, 1, 1);
                            }
                            if (_data["moveSpeed"] != undefined)
                                data.moveSpeed = this._parseToObjData("moveSpeed", _data["moveSpeed"]);
                            if (_data["gravity"] != undefined)
                                data.gravity = _data["gravity"];
                            if (_data["euler"] != undefined)
                                data.euler = this._parseToObjData("euler", _data["euler"]);
                            if (_data["eulerSpeed"] != undefined)
                                data.eulerSpeed = this._parseToObjData("eulerSpeed", _data["eulerSpeed"]);
                            if (_data["eulerNodes"] != undefined) {
                                data.eulerNodes = [];
                                if (data.euler != undefined) {
                                    data.eulerNodes.push(data.euler);
                                    data.euler.key = 0;
                                }
                                for (var i in _data["eulerNodes"]) {
                                    var node = framework.EffectUtil.parseEffectVec3(_data["eulerNodes"][i]);
                                    data.eulerNodes.push(node);
                                }
                            }
                            if (_data["scale"] != undefined)
                                data.scale = this._parseToObjData("scale", _data["scale"]);
                            if (_data["scaleSpeed"] != undefined)
                                data.scaleSpeed = this._parseToObjData("scaleSpeed", _data["scaleSpeed"]);
                            if (_data["scaleNodes"] != undefined) {
                                data.scaleNodes = [];
                                //-----------------------------初始scale为1--------------------------------
                                var startscale = new framework.ParticleNodeNumber();
                                startscale.num.value = 1;
                                startscale.key = 0;
                                data.scaleNodes.push(startscale);
                                for (var i in _data["scaleNodes"]) {
                                    var node = framework.EffectUtil.parseEffectNumNode(_data["scaleNodes"][i]);
                                    data.scaleNodes.push(node);
                                }
                            }
                            if (_data["simulationSpeed"] != undefined) {
                                data.simulationSpeed = this._parseToObjData("simulationSpeed", _data["simulationSpeed"]);
                            }
                            if (_data["alpha"] != undefined) {
                                data.alpha = this._parseToObjData("alpha", _data["alpha"]);
                            }
                            if (_data["alphaSpeed"] != undefined)
                                data.alphaSpeed = this._parseToObjData("alphaSpeed", _data["alphaSpeed"]);
                            if (_data["alphaNodes"] != undefined) {
                                data.alphaNodes = [];
                                if (data.alpha != undefined) {
                                    data.alphaNodes.push(data.alpha);
                                    data.alpha.key = 0;
                                }
                                for (var i in _data["alphaNodes"]) {
                                    var node = new framework.ParticleNodeNumber();
                                    var item = _data["alphaNodes"][i];
                                    if (item["key"] != null) {
                                        node.key = item["key"];
                                    }
                                    var alphavalue = item["alpha"];
                                    if (alphavalue != null) {
                                        if (alphavalue instanceof Array) {
                                            node.num.valueLimitMin = alphavalue[0];
                                            node.num.valueLimitMax = alphavalue[1];
                                        }
                                        else {
                                            node.num.value = alphavalue;
                                        }
                                    }
                                    data.alphaNodes.push(node);
                                }
                            }
                            if (_data["color"] != undefined)
                                data.color = this._parseToObjData("color", _data["color"]);
                            if (_data["colorRate"] != undefined)
                                data.colorRate = _data["colorRate"];
                            if (_data["colorSpeed"] != undefined)
                                data.colorSpeed = this._parseToObjData("colorSpeed", _data["colorSpeed"]);
                            if (_data["colorNodes"] != undefined) {
                                data.colorNodes = [];
                                if (data.color != undefined) {
                                    data.colorNodes.push(data.color);
                                    data.color.key = 0;
                                }
                                for (var i in _data["colorNodes"]) {
                                    var node = framework.EffectUtil.parseEffectVec3(_data["colorNodes"][i]);
                                    data.colorNodes.push(node);
                                }
                            }
                            if (_data["uv"] != undefined) {
                                data.uv = framework.EffectUtil.parseEffectVec2(_data["uv"]);
                            }
                            if (_data["uvtype"] != undefined) {
                                switch (_data["uvtype"]) {
                                    case "uvroll":
                                        data.uvType = framework.UVTypeEnum.UVRoll;
                                        if (_data["uvroll"] != undefined) {
                                            data.uvRoll = new framework.UVRoll();
                                            data.uvRoll.uvSpeed = framework.EffectUtil.parseEffectUVSpeed(_data["uvroll"]);
                                        }
                                        break;
                                    case "uvsprite":
                                        var _val = _data["uvsprite"];
                                        data.uvType = framework.UVTypeEnum.UVSprite;
                                        data.uvSprite = new framework.UVSprite();
                                        if (_val["row"] != undefined)
                                            data.uvSprite.row = _val["row"];
                                        if (_val["colum"] != undefined)
                                            data.uvSprite.column = _val["colum"];
                                        if (_val["count"] != undefined)
                                            data.uvSprite.totalCount = _val["count"];
                                        break;
                                    default:
                                        data.uvType = framework.UVTypeEnum.NONE;
                                        break;
                                }
                            }
                            else
                                data.uvType = framework.UVTypeEnum.NONE;
                            if (_data["billboard"] != undefined)
                                data.renderModel = this._parseToObjData("billboard", _data["billboard"]);
                            if (_data["life"] != undefined)
                                data.life = framework.EffectUtil.parseEffectValueData(_data["life"]);
                            if (_data["startpos"] != undefined) {
                                this._parseEmissionShape(_data["startpos"], element);
                            }
                        }
                    }
                }
            };
            EffectParser.prototype._parseEmissionShape = function (_startdata, element) {
                var startdata = element.emissionData.particleStartData;
                switch (_startdata["type"]) {
                    case "normal":
                        startdata.shapeType = m4m.framework.ParticleSystemShape.NORMAL;
                        break;
                    case "box":
                        startdata.shapeType = m4m.framework.ParticleSystemShape.BOX;
                        break;
                    case "sphere":
                        startdata.shapeType = m4m.framework.ParticleSystemShape.SPHERE;
                        break;
                    case "hemisphere":
                        startdata.shapeType = m4m.framework.ParticleSystemShape.HEMISPHERE;
                        break;
                    case "cone":
                        startdata.shapeType = m4m.framework.ParticleSystemShape.CONE;
                        break;
                    case "circle":
                        startdata.shapeType = m4m.framework.ParticleSystemShape.CIRCLE;
                        break;
                    case "edge":
                        startdata.shapeType = m4m.framework.ParticleSystemShape.EDGE;
                        break;
                    default:
                        startdata.shapeType = m4m.framework.ParticleSystemShape.NORMAL;
                        break;
                }
                if (_startdata["width"] != undefined) {
                    startdata.width = _startdata["width"];
                }
                if (_startdata["height"] != undefined) {
                    startdata.height = _startdata["height"];
                }
                if (_startdata["depth"] != undefined) {
                    startdata.depth = _startdata["depth"];
                }
                if (_startdata["angle"] != undefined) {
                    startdata.angle = _startdata["angle"];
                }
                if (_startdata["radius"] != undefined) {
                    startdata.radius = _startdata["radius"];
                }
                if (_startdata["direction"] != undefined) {
                    var _startdir = _startdata["direction"];
                    startdata.direction.x = _startdir["x"];
                    startdata.direction.y = _startdir["y"];
                    startdata.direction.z = _startdir["z"];
                }
            };
            /**
             * 解析属性数据
             *
             * @param {string} attrib
             * @param {*} content
             * @returns
             *
             * @memberof Effect
             */
            EffectParser.prototype._parseToObjData = function (attrib, content) {
                switch (attrib) {
                    case "pos":
                    case "scale":
                    case "euler":
                    case "color":
                    case "moveSpeed":
                    case "eulerSpeed":
                    case "scaleSpeed":
                    case "colorSpeed":
                        return framework.EffectUtil.parseEffectVec3(content);
                    case "":
                        return framework.EffectUtil.parseEffectVec2(content);
                    case "alphaSpeed":
                    case "alpha":
                    case "simulationSpeed":
                        return framework.EffectUtil.parseEffectNum(content);
                    case "tilling":
                        return framework.EffectUtil.parseEffectVec2(content);
                    case "mat":
                        var mat = new framework.EffectMatData();
                        if (content != undefined) {
                            if (content["shader"] != undefined)
                                mat.shader = this.asMgr.getShader(content["shader"]);
                            else
                                mat.shader = this.asMgr.getShader("shader/def");
                            if (content["diffuseTexture"] != undefined)
                                mat.diffuseTexture = this.asMgr.getAssetByName(content["diffuseTexture"]);
                            if (content["alphaCut"] != undefined)
                                mat.alphaCut = content["alphaCut"];
                            if (content["_AlphaTex"] != undefined)
                                mat.alphaTexture = this.asMgr.getAssetByName(content["_AlphaTex"]);
                        }
                        return mat;
                    case "emmision":
                        var emission = new framework.EmissionData();
                        if (content["type"] != undefined)
                            emission.type = content["type"];
                        if (content["time"] != undefined)
                            emission.time = content["time"];
                        if (content["count"] != undefined)
                            emission.count = content["count"];
                        return emission;
                    case "billboard":
                        var billboardType = framework.RenderModel.Mesh;
                        if (content == "billboard") {
                            billboardType = framework.RenderModel.BillBoard;
                        }
                        else if (content == "horizontal") {
                            billboardType = framework.RenderModel.HorizontalBillBoard;
                        }
                        else if (content == "stretched") {
                            billboardType = framework.RenderModel.StretchedBillBoard;
                        }
                        else if (content == "vertical") {
                            billboardType = framework.RenderModel.VerticalBillBoard;
                        }
                        else if (content == "mesh") {
                            billboardType = framework.RenderModel.Mesh;
                        }
                        else {
                            billboardType = framework.RenderModel.None;
                        }
                        return billboardType;
                    case "mesh":
                        var str = content;
                        if (content.toString().indexOf(".mesh.bin") >= 0 || content.toString().indexOf(".cmesh.bin") >= 0)
                            return this.asMgr.getAssetByName(content);
                        else
                            return this.asMgr.getDefaultMesh(content);
                    default:
                        return content;
                }
            };
            /**
             * 字符串解析成ParticleNode
             *
             * @param {string} content
             * @returns {ParticleNode}
             *
             * @memberof Effect
             */
            EffectParser.prototype._parseToParticleNode = function (content) {
                content = framework.StringUtil.replaceAll(content, " ", "");
                var charArray = content.match(framework.RegexpUtil.vector3FloatOrRangeRegexp);
                if (charArray != undefined) {
                    var node = new framework.ParticleNode();
                    for (var i = 1; i < charArray.length; i++) {
                        if (i == 1) {
                            node.x = this._parseToValueData(charArray[i]);
                        }
                        else if (i == 2) {
                            node.y = this._parseToValueData(charArray[i]);
                        }
                        else if (i == 3) {
                            node.z = this._parseToValueData(charArray[i]);
                        }
                    }
                    return node;
                }
                return null;
            };
            /**
             * 字符串转ValueData
             *
             * @param {string} content
             * @returns {ValueData}
             *
             * @memberof Effect
             */
            EffectParser.prototype._parseToValueData = function (content) {
                var data = new framework.ValueData();
                var array = this._parseToNumberArray(content);
                if (array != null) {
                    if (array.length > 1) {
                        data.valueLimitMin = array[0];
                        data.valueLimitMax = array[1];
                        data.isRandom = true;
                    }
                    else {
                        data.value = array[0];
                        data.isRandom = false;
                    }
                }
                return data;
            };
            /**
             * 字符串转number数组
             *
             * @param {string} content
             * @returns {number[]}
             *
             * @memberof Effect
             */
            EffectParser.prototype._parseToNumberArray = function (content) {
                content = framework.StringUtil.trimAll(content);
                content = framework.StringUtil.replaceAll(content, "\\[", "");
                content = framework.StringUtil.replaceAll(content, "\\]", "");
                var _array = content.split(",");
                var result = [];
                for (var i = 0; i < _array.length; i++) {
                    result.push(parseInt(_array[i]));
                }
                return result;
            };
            return EffectParser;
        }());
        framework.EffectParser = EffectParser;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @private
         */
        var EffectUtil = /** @class */ (function () {
            function EffectUtil() {
            }
            EffectUtil.lookatbyXAxis = function (pos, xAxis, yAxis, zAxis, targetpos, quat) {
                var dir = m4m.math.pool.new_vector3();
                m4m.math.vec3Subtract(targetpos, pos, dir);
                m4m.math.vec3Normalize(dir, dir);
                var crossup = m4m.math.pool.new_vector3();
                m4m.math.vec3Cross(dir, xAxis, crossup);
                m4m.math.vec3Normalize(crossup, crossup);
                var anglerot = m4m.math.vec3Dot(yAxis, crossup);
                anglerot = Math.acos(anglerot) * 180 / Math.PI;
                var dot = m4m.math.vec3Dot(zAxis, crossup);
                dot = Math.acos(dot) * 180 / Math.PI;
                if (dot > 90) {
                    anglerot = -anglerot;
                }
                m4m.math.quatFromAxisAngle(m4m.math.pool.vector3_right, anglerot, quat);
                m4m.math.pool.delete_vector3(dir);
                m4m.math.pool.delete_vector3(crossup);
            };
            EffectUtil.eulerFromQuaternion = function (out, q, order) {
                // Borrowed from Three.JS :)
                // q is assumed to be normalized
                // http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m
                var sqx = q.x * q.x;
                var sqy = q.y * q.y;
                var sqz = q.z * q.z;
                var sqw = q.w * q.w;
                if (order === 'XYZ') {
                    out.x = Math.atan2(2 * (q.x * q.w - q.y * q.z), (sqw - sqx - sqy + sqz));
                    out.y = Math.asin(m4m.math.floatClamp(2 * (q.x * q.z + q.y * q.w), -1, 1));
                    out.z = Math.atan2(2 * (q.z * q.w - q.x * q.y), (sqw + sqx - sqy - sqz));
                }
                else if (order === 'YXZ') {
                    out.x = Math.asin(m4m.math.floatClamp(2 * (q.x * q.w - q.y * q.z), -1, 1));
                    out.y = Math.atan2(2 * (q.x * q.z + q.y * q.w), (sqw - sqx - sqy + sqz));
                    out.z = Math.atan2(2 * (q.x * q.y + q.z * q.w), (sqw - sqx + sqy - sqz));
                }
                else if (order === 'ZXY') {
                    out.x = Math.asin(m4m.math.floatClamp(2 * (q.x * q.w + q.y * q.z), -1, 1));
                    out.y = Math.atan2(2 * (q.y * q.w - q.z * q.x), (sqw - sqx - sqy + sqz));
                    out.z = Math.atan2(2 * (q.z * q.w - q.x * q.y), (sqw - sqx + sqy - sqz));
                }
                else if (order === 'ZYX') {
                    out.x = Math.atan2(2 * (q.x * q.w + q.z * q.y), (sqw - sqx - sqy + sqz));
                    out.y = Math.asin(m4m.math.floatClamp(2 * (q.y * q.w - q.x * q.z), -1, 1));
                    out.z = Math.atan2(2 * (q.x * q.y + q.z * q.w), (sqw + sqx - sqy - sqz));
                }
                else if (order === 'YZX') {
                    out.x = Math.atan2(2 * (q.x * q.w - q.z * q.y), (sqw - sqx + sqy - sqz));
                    out.y = Math.atan2(2 * (q.y * q.w - q.x * q.z), (sqw + sqx - sqy - sqz));
                    out.z = Math.asin(m4m.math.floatClamp(2 * (q.x * q.y + q.z * q.w), -1, 1));
                }
                else if (order === 'XZY') {
                    out.x = Math.atan2(2 * (q.x * q.w + q.y * q.z), (sqw - sqx + sqy - sqz));
                    out.y = Math.atan2(2 * (q.x * q.z + q.y * q.w), (sqw + sqx - sqy - sqz));
                    out.z = Math.asin(m4m.math.floatClamp(2 * (q.z * q.w - q.x * q.y), -1, 1));
                }
                else {
                    console.log('No order given for quaternion to euler conversion.');
                    return;
                }
            };
            //范围内随机  isInteger是否为整数
            EffectUtil.RandomRange = function (min, max, isInteger) {
                if (isInteger === void 0) { isInteger = false; }
                if (isInteger) {
                    return Math.floor(Math.random() * (max - min + 1) + min);
                }
                return Math.random() * (max - min) + min;
            };
            EffectUtil.vecMuliNum = function (vec, num) {
                var v = new m4m.math.vector3(vec.x * num, vec.y * num, vec.z * num);
                return v;
            };
            EffectUtil.parseVector3 = function (value) {
                var vector3 = new m4m.math.vector3();
                vector3.x = value["x"];
                vector3.y = value["y"];
                vector3.z = value["z"];
                return vector3;
            };
            EffectUtil.parseEffectVec3 = function (value) {
                var node = new framework.ParticleNode();
                for (var key in value) {
                    if (value[key] instanceof Array) {
                        node[key].valueLimitMin = value[key][0];
                        node[key].valueLimitMax = value[key][1];
                        node[key].isRandom = true;
                    }
                    else {
                        if (key == "key") {
                            node[key] = value[key];
                        }
                        else {
                            node[key].value = value[key];
                            node[key].isRandom = false;
                        }
                    }
                }
                return node;
            };
            EffectUtil.parseEffectVec2 = function (value) {
                var node = new framework.ParticleNodeVec2();
                for (var key in value) {
                    if (value[key] instanceof Array) {
                        node[key].valueLimitMin = value[key][0];
                        node[key].valueLimitMax = value[key][1];
                        node[key].isRandom = true;
                    }
                    else {
                        if (key == "key") {
                            node[key] = value[key];
                        }
                        else {
                            node[key].value = value[key];
                            node[key].isRandom = false;
                        }
                    }
                }
                return node;
            };
            EffectUtil.parseEffectNum = function (value) {
                var node = new framework.ParticleNodeNumber();
                if (value instanceof Array) {
                    node.num.valueLimitMin = value[0];
                    node.num.valueLimitMax = value[1];
                    node.num.isRandom = true;
                }
                else {
                    node.num.value = value;
                    node.num.isRandom = false;
                }
                return node;
            };
            EffectUtil.parseEffectNumNode = function (value) {
                var node = new framework.ParticleNodeNumber();
                for (var key in value) {
                    if (value[key] instanceof Array) {
                        node[key].valueLimitMin = value[key][0];
                        node[key].valueLimitMax = value[key][1];
                    }
                    else {
                        if (key == "key") {
                            node[key] = value[key];
                        }
                        else {
                            node.num.value = value[key];
                        }
                    }
                }
                return node;
            };
            EffectUtil.parseEffectValueData = function (value) {
                var val = new framework.ValueData();
                if (value instanceof Array) {
                    val.valueLimitMin = value[0];
                    val.valueLimitMax = value[1];
                    val.isRandom = true;
                }
                else {
                    val.value = value;
                    val.isRandom = false;
                }
                return val;
            };
            EffectUtil.parseEffectUVSpeed = function (value) {
                var node = new framework.UVSpeedNode();
                for (var key in value) {
                    node[key].value = value[key];
                }
                return node;
            };
            EffectUtil.lookat = function (eye, targetpos, out, up) {
                if (up === void 0) { up = m4m.math.pool.vector3_up; }
                var dir = new m4m.math.vector3();
                m4m.math.vec3Subtract(targetpos, eye, dir);
                m4m.math.vec3Normalize(dir, dir);
                //dir在xz面上的单位投影          
                var unitprojectedXZ = new m4m.math.vector3(dir.x, 0, dir.z);
                m4m.math.vec3Normalize(unitprojectedXZ, unitprojectedXZ);
                var yaw = Math.acos(unitprojectedXZ.z) / Math.PI * 180;
                if (unitprojectedXZ.x < 0) {
                    yaw = -yaw;
                }
                m4m.math.quatFromAxisAngle(up, yaw, out);
                var right = m4m.math.pool.new_vector3();
                m4m.math.vec3Cross(up, dir, right);
                m4m.math.vec3Normalize(right, right);
                //dir在xz面上的投影   
                var projectedXZ = new m4m.math.vector3(dir.x, 0, dir.z);
                var length = m4m.math.vec3Length(projectedXZ);
                var pitch = Math.acos(length) / Math.PI * 180;
                if (dir.y < 0) {
                    pitch = -pitch;
                }
                var quadRight = m4m.math.pool.new_quaternion();
                m4m.math.quatFromAxisAngle(right, pitch, quadRight);
                // math.quatMultiply(quadRight,out,out);
            };
            EffectUtil.RotateVector3 = function (source, direction, out) {
                m4m.math.vec3Normalize(source, source);
                m4m.math.vec3Normalize(direction, direction);
                var forward = new m4m.math.vector3(0, 0, 1);
                var axis = m4m.math.pool.new_vector3();
                m4m.math.vec3Cross(forward, direction, axis);
                m4m.math.vec3Normalize(axis, axis);
                if (axis.x == 0 && axis.y == 0 && axis.z == 0) {
                    // axis = new m4m.math.vector3(1, 0, 0);
                    axis.x = 1;
                    axis.y = 0;
                    axis.z = 0;
                }
                var cos = m4m.math.vec3Dot(forward, direction);
                var angle = Math.acos(cos) * 180 / Math.PI;
                if (cos < 0) {
                    angle = -angle;
                }
                var quatertion = m4m.math.pool.new_quaternion();
                m4m.math.quatFromAxisAngle(axis, angle, quatertion);
                m4m.math.quatTransformVector(quatertion, source, out);
                m4m.math.pool.delete_vector3(axis);
                m4m.math.pool.delete_quaternion(quatertion);
            };
            EffectUtil.bindAxisBillboard = function (localAxis, out) {
                m4m.math.vec3Normalize(localAxis, localAxis);
                var yAxis = m4m.math.pool.vector3_up;
                var normal = m4m.math.pool.new_vector3();
                m4m.math.vec3Cross(yAxis, localAxis, normal);
                m4m.math.vec3Normalize(normal, normal);
                if (normal.x == 0 && normal.y == 0 && normal.z == 0) {
                    // axis = new m4m.math.vector3(1, 0, 0);
                    normal.x = 1;
                    normal.y = 0;
                    normal.z = 0;
                }
                var cos = m4m.math.vec3Dot(yAxis, localAxis);
                var angle = Math.acos(cos) * 180 / Math.PI;
                if (cos < 0) {
                    angle = -angle;
                }
                // let quatertion = m4m.math.pool.new_quaternion();
                m4m.math.quatFromAxisAngle(normal, angle, out);
            };
            EffectUtil.lookatVerticalBillboard = function (eye, targetpos, out, up) {
                if (up === void 0) { up = m4m.math.pool.vector3_up; }
                var dir = new m4m.math.vector3();
                m4m.math.vec3Subtract(targetpos, eye, dir);
                m4m.math.vec3Normalize(dir, dir);
                //dir在xz面上的单位投影          
                var dirxz = new m4m.math.vector3(dir.x, 0, dir.z);
                m4m.math.vec3Normalize(dirxz, dirxz);
                var yaw = Math.acos(dirxz.z) / Math.PI * 180;
                if (dirxz.x < 0) {
                    yaw = -yaw;
                }
                m4m.math.quatFromAxisAngle(up, yaw, out);
            };
            /**
            * 沿Z轴旋转
            * @param eye 注视点
            * @param targetpos 目标点
            * @param forward Z轴朝向
            * @param out 旋转得到的四元数
            */
            EffectUtil.quatLookatZ = function (eye, targetpos, out, forward) {
                if (forward === void 0) { forward = m4m.math.pool.vector3_forward; }
                var dir = new m4m.math.vector3();
                m4m.math.vec3Subtract(targetpos, eye, dir);
                m4m.math.vec3Normalize(dir, dir);
                var dirxy = new m4m.math.vector3(-dir.x, dir.y, 0);
                m4m.math.vec3Normalize(dirxy, dirxy);
                var roll = Math.acos(dirxy.y) / Math.PI * 180;
                if (dirxy.x < 0) {
                    roll = -roll;
                }
                m4m.math.quatFromAxisAngle(forward, roll, out);
            };
            /**
             * 沿X轴旋转
             * @param eye 注视点
             * @param targetpos 目标点
             * @param right X轴朝向
             * @param out 旋转得到的四元数
             */
            EffectUtil.quatLookatX = function (eye, targetpos, out, right) {
                if (right === void 0) { right = m4m.math.pool.vector3_right; }
                // let dir = new m4m.math.vector3();
                var dir = m4m.math.pool.new_vector3();
                m4m.math.vec3Subtract(targetpos, eye, dir);
                m4m.math.vec3Normalize(dir, dir);
                var diryz = new m4m.math.vector3(0, -dir.y, dir.z);
                m4m.math.vec3Normalize(diryz, diryz);
                var pitch = Math.acos(diryz.z) / Math.PI * 180;
                if (diryz.y < 0) {
                    pitch = -pitch;
                }
                m4m.math.quatFromAxisAngle(right, pitch, out);
            };
            return EffectUtil;
        }());
        framework.EffectUtil = EffectUtil;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @private
         */
        var EmissionBatcher = /** @class */ (function () {
            function EmissionBatcher(emissionElement) {
                this.particles = [];
                this.vertexSize = 0;
                this.vf = 0;
                this.curVerCount = 0;
                this.curIndexCount = 0;
                this.emissionElement = emissionElement;
                this.webgl = emissionElement.webgl;
                this.gameObject = emissionElement.gameObject;
                this.vf = emissionElement.vf;
                this.data = emissionElement.emissionData;
                this.vertexSize = m4m.render.meshData.calcByteSize(this.vf) / 4;
                this.initMesh();
                //初始化材质信息
                this.mat = new framework.material();
                if (this.data.mat.shader == null) {
                    this.mat.setShader(framework.sceneMgr.app.getAssetMgr().getShader("diffuse.shader.json"));
                }
                else {
                    this.mat.setShader(this.data.mat.shader);
                }
                if (this.data.mat.alphaCut != undefined)
                    this.mat.setFloat("_AlphaCut", this.data.mat.alphaCut);
                if (this.data.mat.diffuseTexture != null)
                    this.mat.setTexture("_MainTex", this.data.mat.diffuseTexture);
                if (this.data.mat.alphaTexture != null)
                    this.mat.setTexture("_AlphaTex", this.data.mat.alphaTexture);
            }
            EmissionBatcher.prototype.initMesh = function () {
                this.mesh = new framework.mesh();
                this.mesh.data = new m4m.render.meshData();
                this.mesh.glMesh = new m4m.render.glMesh();
                this.mesh.submesh = [];
                {
                    var sm = new framework.subMeshInfo();
                    sm.matIndex = 0;
                    sm.start = 0;
                    sm.size = 0;
                    sm.line = false;
                    this.mesh.submesh.push(sm);
                }
                this.dataForVbo = new Float32Array(128);
                this.dataForEbo = new Uint16Array(128);
                this.mesh.glMesh.initBuffer(this.webgl, this.vf, 128, m4m.render.MeshTypeEnum.Dynamic);
                this.mesh.glMesh.addIndex(this.webgl, this.dataForEbo.length);
                this.mesh.glMesh.initVAO();
            };
            EmissionBatcher.prototype.addParticle = function () {
                this.refreshBuffer();
                var p = new framework.Particle(this);
                p.update(0);
                p.uploadData(this.dataForVbo);
                for (var i = 0; i < p.dataForEbo.length; i++) {
                    this.dataForEbo[this.curIndexCount + i] = p.dataForEbo[i] + this.curVerCount;
                }
                this.particles.push(p);
                this.curVerCount += this.emissionElement.perVertexCount;
                this.curIndexCount += this.emissionElement.perIndexxCount;
                // this.mesh.glMesh.uploadVertexSubData(context.webgl, this.dataForVbo);
                //this.mesh.glMesh.uploadIndexSubData(this.webgl, 0, this.dataForEbo);
                this.mesh.glMesh.uploadIndexData(this.webgl, 0, this.dataForEbo);
                this.mesh.submesh[0].size = this.curIndexCount;
            };
            EmissionBatcher.prototype.refreshBuffer = function () {
                var needvercount = this.curVerCount + this.emissionElement.perVertexCount;
                var needIndexCount = this.curIndexCount + this.emissionElement.perIndexxCount;
                if (needvercount * this.vertexSize > this.dataForVbo.length) {
                    var length = this.dataForVbo.length;
                    this.mesh.glMesh.resetVboSize(this.webgl, length * 2);
                    var vbo = new Float32Array(length * 2);
                    vbo.set(this.dataForVbo, 0);
                    this.dataForVbo = vbo;
                }
                if (needIndexCount > this.dataForEbo.length) {
                    var length = this.dataForEbo.length;
                    this.mesh.glMesh.resetEboSize(this.webgl, 0, length * 2);
                    var ebo = new Uint16Array(length * 2);
                    ebo.set(this.dataForEbo, 0);
                    this.dataForEbo = ebo;
                }
            };
            EmissionBatcher.prototype.update = function (delta) {
                for (var key in this.particles) {
                    this.particles[key].update(delta);
                    this.particles[key].uploadData(this.dataForVbo);
                }
            };
            EmissionBatcher.prototype.render = function (context, assetmgr, camera) {
                var mesh = this.mesh;
                //mesh.glMesh.uploadVertexSubData(context.webgl, this.dataForVbo);
                mesh.glMesh.uploadVertexData(context.webgl, this.dataForVbo);
                if (assetmgr.app.getScene().fog) {
                    // context.fog = assetmgr.app.getScene().fog;
                    this.mat.draw(context, mesh, mesh.submesh[0], "base_fog");
                }
                else {
                    this.mat.draw(context, mesh, mesh.submesh[0], "base");
                }
            };
            EmissionBatcher.prototype.dispose = function () {
                this.dataForVbo = null;
                this.dataForEbo = null;
                this.mesh.dispose();
                this.mat.dispose();
                for (var key in this.particles) {
                    this.particles[key].dispose();
                }
            };
            return EmissionBatcher;
        }());
        framework.EmissionBatcher = EmissionBatcher;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        //还是要抽象出粒子的概念
        //这里根据发射器定义的初始参数  计算当前要提交的数据
        /**
         * @private
         */
        var Particle = /** @class */ (function () {
            //根据发射器定义 初始化
            function Particle(batcher) {
                this.renderModel = framework.RenderModel.Mesh;
                this.startScale = new m4m.math.vector3();
                this.startRotation = new m4m.math.quaternion();
                this.rotationByShape = new m4m.math.quaternion();
                this.rotationByEuler = new m4m.math.quaternion();
                this.localMatrix = new m4m.math.matrix();
                this.localRotation = new m4m.math.quaternion();
                this.tilling = new m4m.math.vector2(1, 1);
                this.speedDir = new m4m.math.vector3(0, 0, 0);
                this.actived = true;
                /**
                 * 在emission是在simulate in local space 时候，为matTobathcer
                 * 在emission是在simulate in world space 时候，为matToWorld
                 */
                this.transformVertex = new m4m.math.matrix();
                this.matToworld = new m4m.math.matrix();
                this.tex_ST = new m4m.math.vector4(1, 1, 0, 0);
                this.batcher = batcher;
                this.gameObject = batcher.gameObject;
                this.emisson = batcher.emissionElement;
                this.vf = batcher.vf;
                this.data = batcher.data.clone(); //--------------------todo
                this.vertexSize = m4m.render.meshData.calcByteSize(this.vf) / 4;
                this.vertexStartIndex = batcher.curVerCount;
                this.vertexCount = this.emisson.perVertexCount;
                this.dataForVbo = new Float32Array(this.vertexCount * this.vertexSize);
                this.dataForEbo = this.data.mesh.data.genIndexDataArray();
                this.dataForVbo.set(this.data.mesh.data.genVertexDataArray(this.vf), 0);
                this.sourceVbo = this.data.getVboData(this.vf);
                this.initByData();
                //计算得出初始vbo ebo
            }
            Particle.prototype.uploadData = function (array) {
                array.set(this.dataForVbo, this.vertexStartIndex * this.vertexSize);
            };
            Particle.prototype.initByData = function () {
                this.totalLife = this.data.life.getValueRandom();
                this.renderModel = this.data.renderModel;
                this.curLife = 0;
                //box方向随着中心轴朝向
                var localRandomDirection = this.data.particleStartData.randomDirection;
                this.speedDir = m4m.math.pool.clone_vector3(localRandomDirection);
                var localRandomTranslate = this.data.particleStartData.position;
                this.localTranslate = m4m.math.pool.clone_vector3(localRandomTranslate);
                this.simulationSpeed = this.data.simulationSpeed != undefined ? this.data.simulationSpeed.getValue() : 0;
                if (this.data.euler == undefined)
                    this.euler = new m4m.math.vector3(0, 0, 0);
                else
                    this.euler = this.data.euler.getValueRandom();
                if (this.data.scale == undefined)
                    this.localScale = new m4m.math.vector3(1, 1, 1);
                else
                    this.localScale = this.data.scale.getValueRandom();
                if (this.data.color == undefined)
                    this.color = new m4m.math.vector3(0, 0, 0);
                else
                    this.color = this.data.color.getValueRandom();
                if (this.data.alpha == undefined)
                    this.alpha = 1;
                else
                    this.alpha = this.data.alpha.getValueRandom();
                if (this.data.uv == undefined)
                    this.uv = new m4m.math.vector2();
                else
                    this.uv = this.data.uv.getValueRandom();
                if (this.data.moveSpeed != undefined) {
                    this.movespeed = this.data.moveSpeed.getValue();
                }
                else {
                    this.movespeed = new m4m.math.vector3();
                }
                if (this.data.colorRate == undefined)
                    this.colorRate = this.data.colorRate;
                else
                    this.colorRate = 1;
                //记下初始scale
                m4m.math.vec3Clone(this.localScale, this.startScale);
                m4m.math.quatFromEulerAngles(this.euler.x, this.euler.y, this.euler.z, this.rotationByEuler);
                //模型初始旋转量
                if (this.renderModel == framework.RenderModel.None || this.renderModel == framework.RenderModel.StretchedBillBoard) {
                    if (this.data.particleStartData.shapeType != framework.ParticleSystemShape.NORMAL) {
                        var localOrgin = m4m.math.pool.vector3_zero;
                        m4m.math.quatLookat(localOrgin, localRandomDirection, this.rotationByShape);
                        var initRot = m4m.math.pool.new_quaternion();
                        m4m.math.quatFromEulerAngles(90, 0, 90, initRot);
                        m4m.math.quatMultiply(this.rotationByShape, initRot, this.rotationByShape);
                        m4m.math.quatClone(this.rotationByShape, this.localRotation);
                        m4m.math.pool.delete_quaternion(initRot);
                    }
                }
                if (!this.emisson.simulateInLocalSpace) {
                    this.emissionMatToWorld = new m4m.math.matrix();
                    var mat = this.emisson.getmatrixToWorld();
                    m4m.math.matrixClone(mat, this.emissionMatToWorld);
                    this.emissionWorldRotation = new m4m.math.quaternion();
                    var quat = this.emisson.getWorldRotation();
                    m4m.math.quatClone(quat, this.emissionWorldRotation);
                }
            };
            Particle.prototype.update = function (delta) {
                if (!this.actived)
                    return;
                this.curLife += delta;
                if (this.curLife >= this.totalLife) {
                    //矩阵置零
                    m4m.math.matrixZero(this.transformVertex);
                    this._updateVBO();
                    this.emisson.deadParticles.push(this);
                    this.curLife = 0;
                    this.actived = false;
                    return;
                }
                this._updatePos(delta);
                this._updateScale(delta);
                this._updateEuler(delta);
                this._updateRotation(delta);
                this._updateLocalMatrix(delta);
                this._updateColor(delta);
                this._updateAlpha(delta);
                this._updateUV(delta);
                this._updateVBO();
            };
            Particle.prototype._updateLocalMatrix = function (delta) {
                m4m.math.matrixMakeTransformRTS(this.localTranslate, this.localScale, this.localRotation, this.localMatrix);
                if (this.emisson.simulateInLocalSpace) {
                    m4m.math.matrixMultiply(this.emisson.matToBatcher, this.localMatrix, this.transformVertex);
                }
                else {
                    m4m.math.matrixMultiply(this.emissionMatToWorld, this.localMatrix, this.transformVertex);
                }
            };
            Particle.prototype.refreshEmissionData = function () {
                if (this.emisson.simulateInLocalSpace) {
                    this.emissionMatToWorld = this.emisson.getmatrixToWorld();
                    this.emissionWorldRotation = this.emisson.getWorldRotation();
                }
            };
            Particle.prototype._updateRotation = function (delta) {
                this._updateElementRotation();
            };
            Particle.prototype._updateElementRotation = function () {
                if (this.renderModel != framework.RenderModel.Mesh) {
                    this.refreshEmissionData();
                    var translation = m4m.math.pool.new_vector3();
                    var worldTranslation = m4m.math.pool.new_vector3();
                    var worldRotation = m4m.math.pool.new_quaternion();
                    var invTransformRotation = m4m.math.pool.new_quaternion();
                    m4m.math.vec3Clone(this.localTranslate, translation);
                    //var cam = m4m.framework.sceneMgr.app.getScene().mainCamera;
                    //var cam = m4m.framework.sceneMgr.camera;
                    var cam = this.batcher.emissionElement.renderCamera;
                    if (cam == null) {
                        cam = m4m.framework.sceneMgr.app.getScene().mainCamera;
                    }
                    var camPosInWorld = cam.gameObject.transform.getWorldTranslate();
                    m4m.math.matrixTransformVector3(translation, this.emissionMatToWorld, worldTranslation);
                    if (this.renderModel == framework.RenderModel.BillBoard) {
                        m4m.math.quatLookat(worldTranslation, camPosInWorld, worldRotation);
                    }
                    else if (this.renderModel == framework.RenderModel.HorizontalBillBoard) {
                        worldRotation.x = -0.5;
                        worldRotation.y = 0.5;
                        worldRotation.z = 0.5;
                        worldRotation.w = 0.5;
                    }
                    else if (this.renderModel == framework.RenderModel.VerticalBillBoard) {
                        var forwardTarget = m4m.math.pool.new_vector3();
                        m4m.math.vec3Clone(camPosInWorld, forwardTarget);
                        forwardTarget.y = worldTranslation.y;
                        m4m.math.quatLookat(worldTranslation, forwardTarget, worldRotation);
                        m4m.math.pool.delete_vector3(forwardTarget);
                    }
                    else if (this.renderModel == framework.RenderModel.StretchedBillBoard) {
                        m4m.math.matrixMakeTransformRTS(this.localTranslate, this.localScale, this.localRotation, this.localMatrix);
                        m4m.math.matrixMultiply(this.emissionMatToWorld, this.localMatrix, this.matToworld);
                        //-------------------------------------------------------------------------------
                        // m4m.math.quatClone(this.rotationByShape, this.localRotation);
                        // m4m.math.quatLookat(worldTranslation, camPosInWorld, worldRotation);
                        // let lookRot = new m4m.math.quaternion();
                        // m4m.math.quatClone(this.emisson.getWorldRotation(), invTransformRotation);
                        // m4m.math.quatInverse(invTransformRotation, invTransformRotation);
                        // m4m.math.quatMultiply(invTransformRotation, worldRotation, lookRot);
                        // let inverRot = m4m.math.pool.new_quaternion();
                        // m4m.math.quatInverse(this.localRotation, inverRot);
                        // m4m.math.quatMultiply(inverRot, lookRot, lookRot);
                        // let angle = m4m.math.pool.new_vector3();
                        // m4m.math.quatToEulerAngles(lookRot, angle);
                        // m4m.math.quatFromEulerAngles(0, angle.x, 0, lookRot);
                        // m4m.math.quatMultiply(this.localRotation, lookRot, this.localRotation);
                        //----------------------------------------------------------------------------
                        var xaxis = m4m.math.pool.new_vector3();
                        var yaxis = m4m.math.pool.new_vector3();
                        var zaxis = m4m.math.pool.new_vector3();
                        m4m.math.matrixTransformNormal(m4m.math.pool.vector3_right, this.matToworld, xaxis);
                        m4m.math.vec3Normalize(xaxis, xaxis);
                        m4m.math.matrixTransformNormal(m4m.math.pool.vector3_up, this.matToworld, yaxis);
                        m4m.math.vec3Normalize(yaxis, yaxis);
                        m4m.math.matrixTransformNormal(m4m.math.pool.vector3_forward, this.matToworld, zaxis);
                        m4m.math.vec3Normalize(zaxis, zaxis);
                        framework.EffectUtil.lookatbyXAxis(worldTranslation, xaxis, yaxis, zaxis, camPosInWorld, worldRotation);
                        m4m.math.quatMultiply(this.localRotation, worldRotation, this.localRotation);
                        m4m.math.pool.delete_quaternion(worldRotation);
                        m4m.math.pool.delete_vector3(translation);
                        m4m.math.pool.delete_quaternion(invTransformRotation);
                        m4m.math.pool.delete_vector3(xaxis);
                        m4m.math.pool.delete_vector3(yaxis);
                        m4m.math.pool.delete_vector3(zaxis);
                        return;
                    }
                    //消除transform组件对粒子本身的影响
                    m4m.math.quatClone(this.emissionWorldRotation, invTransformRotation);
                    m4m.math.quatInverse(invTransformRotation, invTransformRotation);
                    m4m.math.quatMultiply(invTransformRotation, worldRotation, this.localRotation);
                    m4m.math.quatMultiply(this.localRotation, this.rotationByEuler, this.localRotation); //eulerrot有的不是必要的，todo
                    m4m.math.pool.delete_vector3(translation);
                    m4m.math.pool.delete_vector3(worldTranslation);
                    m4m.math.pool.delete_quaternion(worldRotation);
                    m4m.math.pool.delete_quaternion(invTransformRotation);
                }
                else {
                    m4m.math.quatClone(this.rotationByEuler, this.localRotation);
                }
            };
            Particle.prototype._updatePos = function (delta) {
                if (this.data.moveSpeed != undefined) {
                    this.localTranslate.x += this.movespeed.x * delta;
                    this.localTranslate.y += this.movespeed.y * delta;
                    this.localTranslate.z += this.movespeed.z * delta;
                }
                var currentTranslate = framework.EffectUtil.vecMuliNum(this.speedDir, this.simulationSpeed);
                m4m.math.vec3Add(this.localTranslate, currentTranslate, this.localTranslate);
            };
            Particle.prototype._updateEuler = function (delta) {
                var index = 0;
                if (this.data.eulerNodes != undefined && this.data.eulerSpeed != undefined) {
                    console.error("scale只能通过插值或者speed来修改，不能两个同时存在！");
                    return;
                }
                if (this.data.eulerNodes != undefined) {
                    this._updateNode(this.data.eulerNodes, this.totalLife, this.euler);
                    m4m.math.quatFromEulerAngles(this.euler.x, this.euler.y, this.euler.z, this.rotationByEuler);
                }
                else if (this.data.eulerSpeed != undefined) {
                    if (this.data.eulerSpeed.x != undefined)
                        this.euler.x += this.data.eulerSpeed.x.getValue() * delta;
                    if (this.data.eulerSpeed.y != undefined)
                        this.euler.y += this.data.eulerSpeed.y.getValue() * delta;
                    if (this.data.eulerSpeed.z != undefined)
                        this.euler.z += this.data.eulerSpeed.z.getValue() * delta;
                    m4m.math.quatFromEulerAngles(this.euler.x, this.euler.y, this.euler.z, this.rotationByEuler);
                }
            };
            Particle.prototype._updateScale = function (delta) {
                var index = 0;
                if (this.data.scaleNodes != undefined && this.data.scaleSpeed != undefined) {
                    console.error("scale只能通过插值或者speed来修改，不能两个同时存在！");
                    return;
                }
                if (this.data.scaleNodes != undefined) {
                    this._updateNode(this.data.scaleNodes, this.totalLife, this.localScale, nodeType.scale);
                }
                else if (this.data.scaleSpeed != undefined) {
                    if (this.data.scaleSpeed.x != undefined)
                        this.localScale.x += this.data.scaleSpeed.x.getValue() * delta;
                    if (this.data.scaleSpeed.y != undefined)
                        this.localScale.y += this.data.scaleSpeed.y.getValue() * delta;
                    if (this.data.scaleSpeed.z != undefined)
                        this.localScale.z += this.data.scaleSpeed.z.getValue() * delta;
                }
            };
            Particle.prototype._updateColor = function (delta) {
                var index = 0;
                if (this.data.colorNodes != undefined && this.data.colorSpeed != undefined) {
                    console.error("color只能通过插值或者speed来修改，不能两个同时存在！");
                    return;
                }
                if (this.data.colorNodes != undefined) {
                    this._updateNode(this.data.colorNodes, this.totalLife, this.color);
                }
                else if (this.data.colorSpeed != undefined) {
                    if (this.data.colorSpeed.x != undefined)
                        this.color.x += this.data.colorSpeed.x.getValue() * delta;
                    if (this.data.colorSpeed.y != undefined)
                        this.color.y += this.data.colorSpeed.y.getValue() * delta;
                    if (this.data.colorSpeed.z != undefined)
                        this.color.z += this.data.colorSpeed.z.getValue() * delta;
                }
            };
            Particle.prototype._updateNode = function (nodes, life, out, nodetype) {
                if (nodetype === void 0) { nodetype = nodeType.none; }
                var index = 0;
                var duration = 0;
                if (nodes != undefined) {
                    for (var i = 0; i < nodes.length; i++) {
                        if (i + 1 < nodes.length) {
                            if (nodes[i].key * life <= this.curLife && nodes[i + 1].key * life >= this.curLife) {
                                this.tempStartNode = nodes[i];
                                this.tempEndNode = nodes[i + 1];
                                index++;
                                duration = (this.tempEndNode.key - this.tempStartNode.key) * life;
                                break;
                            }
                        }
                        else {
                            if (this.curLife < nodes[i].key * life) {
                                this.tempStartNode = nodes[i - 1];
                                this.tempEndNode = nodes[i];
                                duration = (this.tempEndNode.key - this.tempStartNode.key) * life;
                            }
                        }
                    }
                    if (this.tempStartNode instanceof framework.ParticleNode) {
                        if (duration > 0) {
                            m4m.math.vec3SLerp(this.tempStartNode.getValue(), this.tempEndNode.getValue(), (this.curLife - this.tempStartNode.key * life) / duration, out);
                        }
                    }
                    else if (this.tempStartNode instanceof framework.ParticleNodeNumber) {
                        //目前这里只刷了alpha值，
                        if (duration > 0) {
                            if (nodetype == nodeType.alpha) {
                                this.alpha = m4m.math.numberLerp(this.tempStartNode.getValue(), this.tempEndNode.getValue(), (this.curLife - this.tempStartNode.key * life) / duration);
                            }
                            else if (nodetype = nodeType.scale) {
                                var targetscale = m4m.math.numberLerp(this.tempStartNode.getValue(), this.tempEndNode.getValue(), (this.curLife - this.tempStartNode.key * life) / duration);
                                m4m.math.vec3ScaleByNum(this.startScale, targetscale, out);
                            }
                        }
                    }
                    else if (this.tempStartNode instanceof framework.UVSpeedNode) {
                        if (duration > 0) {
                            m4m.math.vec2SLerp(this.tempStartNode.getValue(), this.tempEndNode.getValue(), (this.curLife - this.tempStartNode.key * life) / duration, out);
                        }
                    }
                }
            };
            Particle.prototype._updateAlpha = function (delta) {
                var index = 0;
                if (this.data.alphaNodes != undefined && this.data.alphaSpeed != undefined) {
                    console.error("color只能通过插值或者speed来修改，不能两个同时存在！");
                    return;
                }
                if (this.data.alphaNodes != undefined) {
                    this._updateNode(this.data.alphaNodes, this.totalLife, this.alpha, nodeType.alpha);
                }
                else if (this.data.alphaSpeed != undefined) {
                    this.alpha += this.data.alphaSpeed.getValue() * delta;
                }
            };
            Particle.prototype._updateUV = function (delta) {
                if (this.uv == undefined)
                    this.uv = new m4m.math.vector2();
                if (this.data.uvType == framework.UVTypeEnum.NONE) {
                    this.uv = this.data.uv.getValue();
                }
                else if (this.data.uvType == framework.UVTypeEnum.UVRoll) {
                    if (this.data.uvRoll != undefined) {
                        if (this.data.uvRoll.uvSpeedNodes != undefined && this.data.uvRoll.uvSpeed != undefined) {
                            console.error("uv只能通过插值或者speed来修改，不能两个同时存在！");
                            return;
                        }
                        var index = 0;
                        if (this.data.uvRoll.uvSpeedNodes != undefined) {
                            this._updateNode(this.data.uvRoll.uvSpeedNodes, this.totalLife, this.uv);
                        }
                        else if (this.data.uvRoll.uvSpeed != undefined) {
                            if (this.data.uvRoll.uvSpeed.u != undefined)
                                this.tex_ST.z += this.data.uvRoll.uvSpeed.u.getValue() * delta;
                            if (this.data.uvRoll.uvSpeed.v != undefined)
                                this.tex_ST.w += this.data.uvRoll.uvSpeed.v.getValue() * delta;
                        }
                    }
                }
                else if (this.data.uvType == framework.UVTypeEnum.UVSprite) {
                    if (this.data.uvSprite != undefined) {
                        var spriteindex = Math.floor(this.curLife / this.totalLife * this.data.uvSprite.totalCount);
                        m4m.math.spriteAnimation(this.data.uvSprite.row, this.data.uvSprite.column, spriteindex, this.tex_ST);
                    }
                }
            };
            Particle.prototype._updateVBO = function () {
                var vertexSize = this.vertexSize;
                for (var i = 0; i < this.vertexCount; i++) {
                    { //postion
                        var vertex = m4m.math.pool.new_vector3();
                        vertex.x = this.sourceVbo[i * vertexSize + 0];
                        vertex.y = this.sourceVbo[i * vertexSize + 1];
                        vertex.z = this.sourceVbo[i * vertexSize + 2];
                        m4m.math.matrixTransformVector3(vertex, this.transformVertex, vertex);
                        this.dataForVbo[i * vertexSize + 0] = vertex.x;
                        this.dataForVbo[i * vertexSize + 1] = vertex.y;
                        this.dataForVbo[i * vertexSize + 2] = vertex.z;
                        m4m.math.pool.delete_vector3(vertex);
                    }
                    { //color
                        //处理一下颜色，以防灰度值 > 1
                        var r = m4m.math.floatClamp(this.sourceVbo[i * vertexSize + 3], 0, 1);
                        var g = m4m.math.floatClamp(this.sourceVbo[i * vertexSize + 4], 0, 1);
                        var b = m4m.math.floatClamp(this.sourceVbo[i * vertexSize + 5], 0, 1);
                        var a = m4m.math.floatClamp(this.sourceVbo[i * vertexSize + 6], 0, 1);
                        if (this.color != undefined) {
                            r = this.color.x;
                            g = this.color.y;
                            b = this.color.z;
                        }
                        if (this.alpha != undefined)
                            a = this.alpha;
                        if (this.colorRate != undefined) {
                            r *= this.colorRate;
                            g *= this.colorRate;
                            b *= this.colorRate;
                            a *= this.colorRate;
                        }
                        r = m4m.math.floatClamp(r, 0, 3);
                        g = m4m.math.floatClamp(g, 0, 3);
                        b = m4m.math.floatClamp(b, 0, 3);
                        a = m4m.math.floatClamp(a, 0, 3);
                        this.dataForVbo[i * this.vertexSize + 3] = r;
                        this.dataForVbo[i * this.vertexSize + 4] = g;
                        this.dataForVbo[i * this.vertexSize + 5] = b;
                        this.dataForVbo[i * this.vertexSize + 6] = a;
                    }
                    {
                        //uv
                        this.dataForVbo[i * vertexSize + 7] = this.sourceVbo[i * vertexSize + 7] * this.tex_ST.x + this.tex_ST.z;
                        this.dataForVbo[i * vertexSize + 8] = this.sourceVbo[i * vertexSize + 8] * this.tex_ST.y + this.tex_ST.w;
                    }
                }
            };
            Particle.prototype.dispose = function () {
                this.dataForVbo = null;
                this.dataForEbo = null;
                this.startRotation = null;
                this.localRotation = null;
                //this.startPitchYawRoll = null;
                this.rotationByEuler = null;
                this.rotationByShape = null;
                this.tilling = null;
                this.localMatrix = null;
                this.localTranslate = null;
                this.euler = null;
                this.localScale = null;
                this.colorRate = 1;
                this.color = null;
                this.uv = null;
            };
            return Particle;
        }());
        framework.Particle = Particle;
        /**
         * @private
         */
        var nodeType;
        (function (nodeType) {
            nodeType[nodeType["none"] = 0] = "none";
            nodeType[nodeType["alpha"] = 1] = "alpha";
            nodeType[nodeType["scale"] = 2] = "scale";
        })(nodeType = framework.nodeType || (framework.nodeType = {}));
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        //特效系统中的发射器都丢在这里
        /**
         * @private
         */
        var Particles = /** @class */ (function () {
            function Particles(sys) {
                this.emissionElements = []; //一个特效系统可以有多个发射器元素
                this.vf = m4m.render.VertexFormatMask.Position | m4m.render.VertexFormatMask.Color | m4m.render.VertexFormatMask.UV0; //法线切线不要
                this.effectSys = sys;
            }
            Particles.prototype.addEmission = function (_emissionNew) {
                var _emissionElement = new EmissionElement(_emissionNew, this.effectSys, this);
                this.emissionElements.push(_emissionElement);
            };
            Particles.prototype.updateForEmission = function (delta) {
                for (var key in this.emissionElements) {
                    this.emissionElements[key].updateForEmission(delta);
                }
            };
            Particles.prototype.update = function (delta) {
                for (var key in this.emissionElements) {
                    this.emissionElements[key].update(delta);
                }
            };
            Particles.prototype.render = function (context, assetmgr, camera) {
                for (var key in this.emissionElements) {
                    this.emissionElements[key].render(context, assetmgr, camera);
                }
            };
            Particles.prototype.dispose = function () {
                for (var key in this.emissionElements) {
                    this.emissionElements[key].dispose();
                }
                this.emissionElements.length = 0;
            };
            return Particles;
        }());
        framework.Particles = Particles;
        //发射器也作为特效系统的一个元素
        /**
         * @private
         */
        var EmissionElement = /** @class */ (function () {
            //-----------------------------------------------------------------
            function EmissionElement(_emission, sys, mgr) {
                //-------静态属性----------------------------
                this.maxVertexCount = 2048; //batcher 最大定点数
                //-------原属性
                this.localtranslate = new m4m.math.vector3();
                this.localScale = new m4m.math.vector3(1, 1, 1);
                this.localrotate = new m4m.math.quaternion();
                this.eluerAngle = new m4m.math.quaternion();
                this.beloop = false;
                this.simulateInLocalSpace = true; //粒子运动运动空间（世界还是本地）
                this.active = true; //激活状态
                this.isover = false;
                this.worldRotation = new m4m.math.quaternion();
                this.matToBatcher = new m4m.math.matrix();
                this.matToWorld = new m4m.math.matrix();
                this.testtime = 0;
                this.webgl = m4m.framework.sceneMgr.app.webgl;
                this.effectSys = sys;
                this.ParticleMgr = mgr;
                this.vf = mgr.vf;
                this.gameObject = mgr.effectSys.gameObject;
                this.beloop = _emission.beloop;
                this.emissionData = _emission.emissionData;
                // this.delayTime = _emission.delayTime;
                // if (this.delayTime > 0)
                // {
                //     this.delayFlag = true;
                // }
                this.perVertexCount = this.emissionData.mesh.data.getVertexCount();
                this.perIndexxCount = this.emissionData.mesh.data.getTriIndexCount();
                this.simulateInLocalSpace = this.emissionData.simulateInLocalSpace;
                switch (this.emissionData.emissionType) {
                    case framework.ParticleEmissionType.burst:
                        break;
                    case framework.ParticleEmissionType.continue:
                        this._continueSpaceTime = this.emissionData.time / (this.emissionData.emissionCount);
                        break;
                }
                m4m.math.vec3Clone(this.emissionData.rootpos, this.localtranslate);
                m4m.math.vec3Clone(this.emissionData.rootRotAngle, this.eluerAngle);
                m4m.math.vec3Clone(this.emissionData.rootScale, this.localScale);
                m4m.math.quatFromEulerAngles(this.eluerAngle.x, this.eluerAngle.y, this.eluerAngle.z, this.localrotate);
                m4m.math.matrixMakeTransformRTS(this.localtranslate, this.localScale, this.localrotate, this.matToBatcher);
                this.emissionBatchers = [];
                this.deadParticles = [];
                this.curTime = 0;
                this.numcount = 0;
                this.addBatcher();
            }
            EmissionElement.prototype.getWorldRotation = function () {
                var parRot = this.gameObject.transform.getWorldRotate();
                m4m.math.quatMultiply(parRot, this.localrotate, this.worldRotation);
                return this.worldRotation;
            };
            EmissionElement.prototype.getmatrixToWorld = function () {
                var mat = this.gameObject.transform.getWorldMatrix();
                m4m.math.matrixMultiply(mat, this.matToBatcher, this.matToWorld);
                return this.matToWorld;
            };
            EmissionElement.prototype.update = function (delta) {
                //this.curTime += delta;
                // if (this.delayTime != undefined && this.curTime < this.delayTime)
                // {
                //     return;
                // } else
                // {
                //     this.curTime = this.curTime - this.delayTime;
                // }
                //this.updateEmission(delta);
                this.updateBatcher(delta);
            };
            EmissionElement.prototype.updateForEmission = function (delta) {
                this.testtime += delta;
                this.curTime += delta;
                this.updateEmission(delta);
            };
            EmissionElement.prototype.updateBatcher = function (delta) {
                for (var key in this.emissionBatchers) {
                    this.emissionBatchers[key].update(delta);
                }
            };
            EmissionElement.prototype.updateEmission = function (delta) {
                if (this.isover)
                    return;
                //detal为 0.01699995994567871  造成短短时间发射大量粒子困难(0.1 发射50)至少需要detal<=0.002,按照detal为0.0169需要0.8左右的时间才能发射完，于是不能deta仅发射一个粒子。
                //改为按照时间比例发射粒子
                if (this.emissionData.emissionType == framework.ParticleEmissionType.continue) {
                    // if (this.numcount == 0) 
                    // {
                    //     this.addParticle();
                    //     this.numcount++;
                    // }
                    // console.log("curtime:"+this.curTime.toString()+"//detaltime:"+delta.toString());
                    // if (this.curTime > this._continueSpaceTime)
                    // {
                    //     if (this.numcount < this.emissionData.emissionCount)
                    //     {
                    //         console.log("addparticle  toteltime:"+this.testtime.toString()+"    //curnumber:"+this.numcount.toString());
                    //         this.addParticle();
                    //         this.curTime = 0;
                    //         this.numcount++;
                    //     }
                    //     else
                    //     {
                    //         if (this.beloop)
                    //         {
                    //             this.curTime = 0;
                    //             this.numcount = 0;
                    //             this.isover = false;
                    //         } else
                    //         {
                    //             this.isover = true;
                    //         }
                    //     }
                    // }
                    var rate = this.curTime / this.emissionData.time;
                    rate = m4m.math.floatClamp(rate, 0, 1);
                    var needCount = Math.floor(rate * this.emissionData.emissionCount);
                    needCount = needCount - this.numcount;
                    for (var i = 0; i < needCount; i++) {
                        this.addParticle();
                        this.numcount++;
                    }
                    if (rate == 1) {
                        if (this.beloop) {
                            this.curTime = 0;
                            this.numcount = 0;
                            this.isover = false;
                        }
                        else {
                            this.isover = true;
                        }
                    }
                }
                else if (this.emissionData.emissionType == framework.ParticleEmissionType.burst) {
                    if (this.curTime > this.emissionData.time) {
                        this.addParticle(this.emissionData.emissionCount);
                        if (this.beloop) {
                            this.curTime = 0;
                            this.isover = false;
                        }
                        else {
                            this.isover = true;
                        }
                    }
                }
            };
            EmissionElement.prototype.addParticle = function (count) {
                if (count === void 0) { count = 1; }
                for (var i = 0; i < count; i++) {
                    if (this.deadParticles.length > 0) {
                        var particle = this.deadParticles.pop();
                        particle.initByData();
                        particle.update(0);
                        particle.actived = true;
                    }
                    else {
                        var total = this.curbatcher.curVerCount + this.perVertexCount;
                        if (total <= this.maxVertexCount) {
                            this.curbatcher.addParticle();
                        }
                        else {
                            this.addBatcher();
                            this.curbatcher.addParticle();
                        }
                    }
                }
            };
            EmissionElement.prototype.addBatcher = function () {
                var batcher = new framework.EmissionBatcher(this);
                this.emissionBatchers.push(batcher);
                this.curbatcher = batcher;
            };
            EmissionElement.prototype.render = function (context, assetmgr, camera) {
                this.renderCamera = camera;
                if (this.simulateInLocalSpace) {
                    context.updateModel(this.gameObject.transform);
                }
                else {
                    context.updateModeTrail();
                }
                for (var key in this.emissionBatchers) {
                    this.emissionBatchers[key].render(context, assetmgr, camera);
                }
            };
            EmissionElement.prototype.dispose = function () {
                for (var key in this.emissionBatchers) {
                    this.emissionBatchers[key].dispose();
                }
                this.emissionBatchers.length = 0;
            };
            EmissionElement.prototype.isOver = function () {
                return this.isover;
            };
            return EmissionElement;
        }());
        framework.EmissionElement = EmissionElement;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * 粒子
         *
         * @author feng3d
         */
        var Particle1 = /** @class */ (function () {
            function Particle1() {
                /**
                 * 出生时间
                 */
                this.birthTime = 0;
                /**
                 * 寿命
                 */
                this.lifetime = 5;
                /**
                 * 位置
                 */
                this.position = new m4m.math.vector3();
                /**
                 * 速度
                 */
                this.velocity = new m4m.math.vector3();
                /**
                 * 加速度
                 */
                this.acceleration = new m4m.math.vector3();
                /**
                 * 旋转角度
                 */
                this.rotation = new m4m.math.vector3();
                /**
                 * 角速度
                 */
                this.angularVelocity = new m4m.math.vector3();
                /**
                 * 尺寸
                 */
                this.size = new m4m.math.vector3(1, 1, 1);
                /**
                 * 起始尺寸
                 */
                this.startSize = new m4m.math.vector3(1, 1, 1);
                /**
                 * 颜色
                 */
                this.color = new m4m.math.color();
                /**
                 * 起始颜色
                 */
                this.startColor = new m4m.math.color();
                /**
                 * 纹理UV缩放和偏移。
                 */
                this.tilingOffset = new m4m.math.vector4(1, 1, 0, 0);
                /**
                 * 在粒子上翻转UV坐标，使它们呈现水平镜像。
                 */
                this.flipUV = new m4m.math.vector2();
                /**
                 * 缓存，用于存储计算时临时数据
                 */
                this.cache = {};
            }
            /**
             * 更新状态
             */
            Particle1.prototype.updateState = function (preTime, time) {
                preTime = Math.max(preTime, this.birthTime);
                time = Math.max(this.birthTime, time);
                var pTime = time - preTime;
                // 计算速度
                this.velocity.x += this.acceleration.x * pTime;
                this.velocity.y += this.acceleration.y * pTime;
                this.velocity.z += this.acceleration.z * pTime;
                // 计算位置
                this.position.x += this.velocity.x * pTime;
                this.position.y += this.velocity.y * pTime;
                this.position.z += this.velocity.z * pTime;
                // 计算角度
                this.rotation.x += this.angularVelocity.x * pTime;
                this.rotation.y += this.angularVelocity.y * pTime;
                this.rotation.z += this.angularVelocity.z * pTime;
            };
            return Particle1;
        }());
        framework.Particle1 = Particle1;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * ui事件
         * @version m4m 1.0
         */
        var ParticleSystemEvent = /** @class */ (function (_super) {
            __extends(ParticleSystemEvent, _super);
            function ParticleSystemEvent() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            ParticleSystemEvent.prototype.On = function (event, func, thisArg) {
                _super.prototype.On.call(this, event, func, thisArg);
            };
            ParticleSystemEvent.prototype.Off = function (event, func, thisArg) {
                _super.prototype.RemoveListener.call(this, event, func, thisArg);
            };
            ParticleSystemEvent.prototype.Emit = function (event, args) {
                _super.prototype.Emit.call(this, event, args);
            };
            return ParticleSystemEvent;
        }(m4m.AEvent));
        framework.ParticleSystemEvent = ParticleSystemEvent;
        /**
         * 粒子系统
         *
         * @author feng3d
         */
        var ParticleSystem = /** @class */ (function () {
            function ParticleSystem() {
                this.layer = framework.RenderLayerEnum.Transparent;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 同场景渲染层级时候先后排序依据
                 * @version m4m 1.0
                 */
                this.queue = 0;
                /**
                 * Biases Particle System sorting amongst other transparencies.
                 *
                 * Use lower (negative) numbers to prioritize the Particle System to draw closer to the front, and use higher numbers to prioritize other transparent objects.
                 */
                this.sortingFudge = 0;
                /**
                 * 参考Unity ParticleSystemRenderer.pivot
                 *
                 * Modify the pivot point used for rotating particles.
                 *
                 * The units are expressed as a multiplier of the particle sizes, relative to their diameters. For example, a value of 0.5 adjusts the pivot by the particle radius, allowing particles to rotate around their edges.
                 */
                this.pivot = new m4m.math.vector3(0, 0, 0);
                this._isPlaying = false;
                /**
                 * Playback position in seconds.
                 *
                 * 回放位置(秒)
                 */
                this.time = 0;
                /**
                 * Start delay in seconds.
                 * 启动延迟(以秒为单位)。在调用.play()时初始化值。
                 */
                this.startDelay = 0;
                /**
                 * 用于处理事件的监听与派发
                 */
                this.aEvent = new ParticleSystemEvent();
                this._startDelay_rate = Math.random();
                this._vbos = [];
                this._attributes = [
                    ["a_particle_position", 4],
                    ["a_particle_scale", 4],
                    ["a_particle_rotation", 4],
                    ["a_particle_color", 4],
                    ["a_particle_tilingOffset", 4],
                    ["a_particle_flipUV", 4],
                ];
                this._awaked = false;
                /**
                 * 当前真实时间（time - startDelay）
                 */
                this._realTime = 0;
                /**
                 * 上次真实时间
                 */
                this._preRealTime = 0;
                /**
                 * 粒子池，用于存放未发射或者死亡粒子
                 */
                this._particlePool = [];
                /**
                 * 活跃的粒子列表
                 */
                this._activeParticles = [];
                this._modules = [];
                /**
                 * 上次移动发射的位置
                 */
                this._preworldPos = new m4m.math.vector3();
                this._isRateOverDistance = false;
                this._leftRateOverDistance = 0;
                //
                this.worldPos = new m4m.math.vector3();
                this.moveVec = new m4m.math.vector3();
                this.speed = new m4m.math.vector3();
                //
                this.localToWorldMatrix = new m4m.math.matrix();
                this.worldToLocalMatrix = new m4m.math.matrix();
                this.main = new framework.ParticleMainModule();
                this.emission = new framework.ParticleEmissionModule();
                this.shape = new framework.ParticleShapeModule();
                this.velocityOverLifetime = new framework.ParticleVelocityOverLifetimeModule();
                this.inheritVelocity = new framework.ParticleInheritVelocityModule();
                this.forceOverLifetime = new framework.ParticleForceOverLifetimeModule();
                this.limitVelocityOverLifetime = new framework.ParticleLimitVelocityOverLifetimeModule();
                this.colorOverLifetime = new framework.ParticleColorOverLifetimeModule();
                this.colorBySpeed = new framework.ParticleColorBySpeedModule();
                this.sizeOverLifetime = new framework.ParticleSizeOverLifetimeModule();
                this.sizeBySpeed = new framework.ParticleSizeBySpeedModule();
                this.rotationOverLifetime = new framework.ParticleRotationOverLifetimeModule();
                this.rotationBySpeed = new framework.ParticleRotationBySpeedModule();
                this.noise = new framework.ParticleNoiseModule();
                this.textureSheetAnimation = new framework.ParticleTextureSheetAnimationModule();
                this.main.enabled = true;
                this.emission.enabled = true;
                this.shape.enabled = true;
            }
            Object.defineProperty(ParticleSystem.prototype, "renderLayer", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 渲染层级
                 * @version m4m 1.0
                 */
                //renderLayer: CullingMask = CullingMask.default;
                get: function () { return this.gameObject.layer; },
                set: function (layer) {
                    this.gameObject.layer = layer;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSystem.prototype, "transform", {
                get: function () {
                    return this.gameObject && this.gameObject.transform;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSystem.prototype, "isPlaying", {
                /**
                 * Is the particle system playing right now ?
                 *
                 * 粒子系统正在运行吗?
                 */
                get: function () {
                    return this._isPlaying;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSystem.prototype, "isStopped", {
                /**
                 * Is the particle system stopped right now ?
                 *
                 * 粒子系统现在停止了吗?
                 */
                get: function () {
                    return !this._isPlaying && this.time == 0;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSystem.prototype, "isPaused", {
                /**
                 * Is the particle system paused right now ?
                 *
                 * 粒子系统现在暂停了吗?
                 */
                get: function () {
                    return !this._isPlaying && this.time != 0;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSystem.prototype, "particleCount", {
                /**
                 * The current number of particles (Read Only).
                 *
                 * 当前粒子数(只读)。
                 */
                get: function () {
                    return this._activeParticles.length;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSystem.prototype, "main", {
                get: function () { return this._main; },
                set: function (v) {
                    framework.ArrayUtil.replace(this._modules, this._main, v);
                    v.particleSystem = this;
                    this._main = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSystem.prototype, "emission", {
                get: function () { return this._emission; },
                set: function (v) {
                    framework.ArrayUtil.replace(this._modules, this._emission, v);
                    v.particleSystem = this;
                    this._emission = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSystem.prototype, "shape", {
                get: function () { return this._shape; },
                set: function (v) {
                    framework.ArrayUtil.replace(this._modules, this._shape, v);
                    v.particleSystem = this;
                    this._shape = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSystem.prototype, "velocityOverLifetime", {
                get: function () { return this._velocityOverLifetime; },
                set: function (v) {
                    framework.ArrayUtil.replace(this._modules, this._velocityOverLifetime, v);
                    v.particleSystem = this;
                    this._velocityOverLifetime = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSystem.prototype, "limitVelocityOverLifetime", {
                get: function () { return this._limitVelocityOverLifetime; },
                set: function (v) {
                    framework.ArrayUtil.replace(this._modules, this._limitVelocityOverLifetime, v);
                    v.particleSystem = this;
                    this._limitVelocityOverLifetime = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSystem.prototype, "inheritVelocity", {
                /**
                 * Script interface for the Particle System velocity inheritance module.
                 *
                 * 粒子系统速度继承模块。
                 */
                get: function () { return this._inheritVelocity; },
                set: function (v) {
                    framework.ArrayUtil.replace(this._modules, this._inheritVelocity, v);
                    v.particleSystem = this;
                    this._inheritVelocity = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSystem.prototype, "forceOverLifetime", {
                get: function () { return this._forceOverLifetime; },
                set: function (v) {
                    framework.ArrayUtil.replace(this._modules, this._forceOverLifetime, v);
                    v.particleSystem = this;
                    this._forceOverLifetime = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSystem.prototype, "colorOverLifetime", {
                get: function () { return this._colorOverLifetime; },
                set: function (v) {
                    framework.ArrayUtil.replace(this._modules, this._colorOverLifetime, v);
                    v.particleSystem = this;
                    this._colorOverLifetime = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSystem.prototype, "colorBySpeed", {
                /**
                 * 颜色随速度变化模块。
                 */
                get: function () { return this._colorBySpeed; },
                set: function (v) {
                    framework.ArrayUtil.replace(this._modules, this._colorBySpeed, v);
                    v.particleSystem = this;
                    this._colorBySpeed = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSystem.prototype, "sizeOverLifetime", {
                get: function () { return this._sizeOverLifetime; },
                set: function (v) {
                    framework.ArrayUtil.replace(this._modules, this._sizeOverLifetime, v);
                    v.particleSystem = this;
                    this._sizeOverLifetime = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSystem.prototype, "sizeBySpeed", {
                /**
                 * 缩放随速度变化模块
                 */
                get: function () { return this._sizeBySpeed; },
                set: function (v) {
                    framework.ArrayUtil.replace(this._modules, this._sizeBySpeed, v);
                    v.particleSystem = this;
                    this._sizeBySpeed = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSystem.prototype, "rotationOverLifetime", {
                get: function () { return this._rotationOverLifetime; },
                set: function (v) {
                    framework.ArrayUtil.replace(this._modules, this._rotationOverLifetime, v);
                    v.particleSystem = this;
                    this._rotationOverLifetime = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSystem.prototype, "rotationBySpeed", {
                /**
                 * 旋转角度随速度变化模块
                 */
                get: function () { return this._rotationBySpeed; },
                set: function (v) {
                    framework.ArrayUtil.replace(this._modules, this._rotationBySpeed, v);
                    v.particleSystem = this;
                    this._rotationBySpeed = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSystem.prototype, "noise", {
                /**
                 * 旋转角度随速度变化模块
                 */
                get: function () { return this._noise; },
                set: function (v) {
                    framework.ArrayUtil.replace(this._modules, this._noise, v);
                    v.particleSystem = this;
                    this._noise = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSystem.prototype, "textureSheetAnimation", {
                /**
                 * 粒子系统纹理表动画模块。
                 */
                get: function () { return this._textureSheetAnimation; },
                set: function (v) {
                    framework.ArrayUtil.replace(this._modules, this._textureSheetAnimation, v);
                    v.particleSystem = this;
                    this._textureSheetAnimation = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSystem.prototype, "mesh", {
                //本意mesh filter 可以弄一点 模型处理，比如lod
                //先直进直出吧
                /**
                 * @private
                 */
                get: function () {
                    return this._mesh;
                },
                /**
                * @public
                * @language zh_CN
                * @param mesh 此组件的mesh
                * @classdesc
                * 设置mesh数据
                * @version m4m 1.0
                */
                set: function (mesh) {
                    if (this._mesh != null) {
                        this._mesh.unuse();
                    }
                    this._mesh = mesh;
                    this._meshAABB = this._mesh.data.getAABB();
                    if (this._mesh != null) {
                        this._mesh.use();
                    }
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSystem.prototype, "single", {
                get: function () { return true; },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSystem.prototype, "particleSystemData", {
                get: function () {
                    return this._particleSystemData;
                },
                set: function (v) {
                    var data = framework.ParticleSystemData.get(v.value);
                    if (data.objectData) {
                        framework.serialization.setValue(this, data.objectData);
                    }
                    else {
                        data.particleSystem = this;
                    }
                    this._particleSystemData = data;
                },
                enumerable: false,
                configurable: true
            });
            /**
            * 添加UI事件监听者
            * @param eventEnum 事件类型
            * @param func 事件触发回调方法 (Warn: 不要使用 func.bind() , 它会导致相等判断失败)
            * @param thisArg 回调方法执行者
            */
            ParticleSystem.prototype.addListener = function (event, func, thisArg) {
                this.aEvent.On(event, func, thisArg);
            };
            /**
             * 移除事件监听者
             * @param event 事件类型
             * @param func 事件触发回调方法
             * @param thisArg 回调方法执行者
             */
            ParticleSystem.prototype.removeListener = function (event, func, thisArg) {
                this.aEvent.Off(event, func, thisArg);
            };
            ParticleSystem.prototype.onPlay = function () {
            };
            ParticleSystem.prototype.start = function () {
                if (!this._mesh) {
                    this._mesh = framework.sceneMgr.app.getAssetMgr().getDefaultMesh(m4m.framework.defMesh.quad);
                    this._meshAABB = this._mesh.data.getAABB();
                }
                if (!this.material) {
                    this.material = framework.sceneMgr.app.getAssetMgr().getDefParticleMat();
                }
            };
            ParticleSystem.prototype.remove = function () {
                console.warn("\u672A\u5B9E\u73B0 ParticleSystem  remove");
                // throw "未实现";
            };
            ParticleSystem.prototype.clone = function () {
                console.warn("\u672A\u5B9E\u73B0 ParticleSystem  clone");
                //throw "未实现";
            };
            ParticleSystem.prototype.update = function (interval) {
                if (!this.isPlaying)
                    return;
                m4m.math.matrixClone(this.transform.getWorldMatrix(), this.localToWorldMatrix);
                m4m.math.matrixInverse(this.localToWorldMatrix, this.worldToLocalMatrix);
                this.time = this.time + this.main.simulationSpeed * interval;
                this._realTime = this.time - this.startDelay;
                // 粒子系统位置
                m4m.math.matrixGetTranslation(this.localToWorldMatrix, this.worldPos);
                // 粒子系统位移
                this.moveVec.x = this.worldPos.x - this._preworldPos.x;
                this.moveVec.y = this.worldPos.y - this._preworldPos.y;
                this.moveVec.z = this.worldPos.z - this._preworldPos.z;
                // 粒子系统速度
                this.speed.x = this.moveVec.x / (this.main.simulationSpeed * interval);
                this.speed.y = this.moveVec.y / (this.main.simulationSpeed * interval);
                this.speed.z = this.moveVec.z / (this.main.simulationSpeed * interval);
                this._updateActiveParticlesState();
                // 完成一个循环
                if (this.main.loop && Math.floor(this._preRealTime / this.main.duration) < Math.floor(this._realTime / this.main.duration)) {
                    // 重新计算喷发概率
                    this.emission.bursts.forEach(function (element) {
                        element.calculateProbability();
                    });
                }
                this._emit();
                this._preRealTime = this._realTime;
                this._preworldPos.x = this.worldPos.x;
                this._preworldPos.y = this.worldPos.y;
                this._preworldPos.z = this.worldPos.z;
                // 判断非循环的效果是否播放结束
                if (!this.main.loop && this._activeParticles.length == 0 && this._realTime > this.main.duration) {
                    this.stop();
                    this.aEvent.Emit("particleCompleted", this);
                }
            };
            /**
             * 停止
             */
            ParticleSystem.prototype.stop = function () {
                this._isPlaying = false;
                this.time = 0;
                this._particlePool = this._particlePool.concat(this._activeParticles);
                this._activeParticles.length = 0;
            };
            /**
             * 播放
             */
            ParticleSystem.prototype.play = function () {
                this._isPlaying = true;
                this.time = 0;
                this._startDelay_rate = Math.random();
                this.updateStartDelay();
                this._preRealTime = 0;
                this._particlePool = this._particlePool.concat(this._activeParticles);
                this._activeParticles.length = 0;
                this._preworldPos.x = this.worldPos.x;
                this._preworldPos.y = this.worldPos.y;
                this._preworldPos.z = this.worldPos.z;
                this._isRateOverDistance = false;
                this._leftRateOverDistance = 0;
                // 重新计算喷发概率
                this.emission.bursts.forEach(function (element) {
                    element.calculateProbability();
                });
            };
            /**
             * @private
             */
            ParticleSystem.prototype.updateStartDelay = function () {
                this.startDelay = this.main.startDelay.getValue(this._startDelay_rate);
            };
            /**
             * 暂停
             */
            ParticleSystem.prototype.pause = function () {
                this._isPlaying = false;
            };
            /**
             * 继续
             */
            ParticleSystem.prototype.continue = function () {
                if (this.time == 0) {
                    this.play();
                }
                else {
                    this._isPlaying = true;
                    this._preRealTime = Math.max(0, this._realTime);
                }
            };
            ParticleSystem.prototype.render = function (context, assetmgr, camera) {
                var _this = this;
                m4m.math.matrixClone(this.transform.getWorldMatrix(), this.localToWorldMatrix);
                m4m.math.matrixInverse(this.localToWorldMatrix, this.worldToLocalMatrix);
                if (!this._awaked) {
                    this._isPlaying = this._isPlaying || this.main.playOnAwake;
                    this._awaked = true;
                }
                if (this.particleCount < 1)
                    return;
                framework.DrawCallInfo.inc.currentState = framework.DrawCallEnum.EffectSystem;
                var go = this.gameObject;
                var tran = go.transform;
                context.updateLightMask(go.layer);
                context.updateModel(tran);
                if (!this.material)
                    return;
                var mesh = this.mesh;
                if (mesh == null || mesh.glMesh == null || mesh.submesh == null)
                    return;
                var subMeshs = mesh.submesh;
                if (subMeshs == null)
                    return;
                // mesh.glMesh.bindVboBuffer(context.webgl);
                // 获取批量渲染扩展
                var isSupportDrawInstancedArrays = !!context.webgl.drawArraysInstanced;
                // isSupportDrawInstancedArrays = false;
                // 计算公告牌矩阵
                var isbillboard = !this.shape.alignToDirection && this.mesh == framework.sceneMgr.app.getAssetMgr().getDefaultMesh(m4m.framework.defMesh.quad);
                var billboardMatrix = new m4m.math.matrix();
                if (isbillboard) {
                    //
                    var cameraForward = new m4m.math.vector3();
                    var cameraUp = new m4m.math.vector3();
                    camera.gameObject.transform.getForwardInWorld(cameraForward);
                    camera.gameObject.transform.getUpInWorld(cameraUp);
                    if (this.main.simulationSpace == framework.ParticleSystemSimulationSpace.Local) {
                        m4m.math.matrixTransformNormal(cameraForward, this.worldToLocalMatrix, cameraForward);
                        m4m.math.matrixTransformNormal(cameraUp, this.worldToLocalMatrix, cameraUp);
                    }
                    m4m.math.matrixLookat(new m4m.math.vector3(), cameraForward, cameraUp, billboardMatrix);
                }
                this.material.setMatrix("u_particle_billboardMatrix", billboardMatrix);
                // 计算中心点偏移
                var pivotOffset = new m4m.math.vector4(this.pivot.x * (this._meshAABB.maximum.x - this._meshAABB.minimum.x), -this.pivot.z * (this._meshAABB.maximum.y - this._meshAABB.minimum.y), this.pivot.y * (this._meshAABB.maximum.z - this._meshAABB.minimum.z), 0);
                this.material.setVector4("u_particle_pivotOffset", pivotOffset);
                if (this.main.simulationSpace == framework.ParticleSystemSimulationSpace.World) {
                    m4m.math.matrixClone(context.matrixViewProject, context.matrixModelViewProject);
                }
                if (!isSupportDrawInstancedArrays) {
                    for (var i = 0, n = this._activeParticles.length; i < n; i++) {
                        var particle = this._activeParticles[i];
                        this.material.setVector4("a_particle_position", new m4m.math.vector4(particle.position.x, particle.position.y, particle.position.z, 1));
                        this.material.setVector4("a_particle_scale", new m4m.math.vector4(particle.size.x, particle.size.y, particle.size.z, 1));
                        this.material.setVector4("a_particle_rotation", new m4m.math.vector4(particle.rotation.x, particle.rotation.y, (isbillboard ? -1 : 1) * particle.rotation.z, 1));
                        this.material.setVector4("a_particle_color", new m4m.math.vector4(particle.color.r, particle.color.g, particle.color.b, particle.color.a));
                        this.material.setVector4("a_particle_tilingOffset", new m4m.math.vector4(particle.tilingOffset.x, particle.tilingOffset.y, particle.tilingOffset.z, particle.tilingOffset.w));
                        this.material.setVector4("a_particle_flipUV", new m4m.math.vector4(particle.flipUV.x, particle.flipUV.y, 0, 0));
                        this.material.draw(context, mesh, subMeshs[0]);
                    }
                }
                else {
                    var data = [];
                    for (var i = 0, n = this._activeParticles.length; i < n; i++) {
                        var particle = this._activeParticles[i];
                        data.push(particle.position.x, particle.position.y, particle.position.z, 1, particle.size.x, particle.size.y, particle.size.z, 1, particle.rotation.x, particle.rotation.y, (isbillboard ? -1 : 1) * particle.rotation.z, 1, particle.color.r, particle.color.g, particle.color.b, particle.color.a, particle.tilingOffset.x, particle.tilingOffset.y, particle.tilingOffset.z, particle.tilingOffset.w, particle.flipUV.x, particle.flipUV.y, 0, 0);
                    }
                    var stride = this._attributes.reduce(function (pv, cv) { return pv += cv[1]; }, 0) * 4;
                    if (isSupportDrawInstancedArrays && this.particleCount > 0) {
                        var vbo = this._getVBO(context.webgl);
                        var drawInstanceInfo = {
                            instanceCount: this.particleCount,
                            initBuffer: function (gl) {
                                gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
                                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);
                            },
                            activeAttributes: function (gl, pass, mat) {
                                var program = pass.program.program;
                                gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
                                var offset = 0;
                                _this._attributes.forEach(function (element) {
                                    var location = gl.getAttribLocation(program, element[0]);
                                    if (location == -1)
                                        return;
                                    gl.enableVertexAttribArray(location);
                                    gl.vertexAttribPointer(location, element[1], gl.FLOAT, false, stride, offset);
                                    gl.vertexAttribDivisor(location, 1);
                                    offset += element[1] * 4;
                                });
                            },
                            disableAttributes: function (gl, pass) {
                                var program = pass.program.program;
                                gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
                                _this._attributes.forEach(function (element) {
                                    var location = gl.getAttribLocation(program, element[0]);
                                    if (location == -1)
                                        return;
                                    gl.vertexAttribDivisor(location, 0);
                                    gl.disableVertexAttribArray(location);
                                });
                            },
                        };
                        var drawtype = framework.meshRenderer.instanceDrawType();
                        this.material.draw(context, mesh, subMeshs[0], drawtype, drawInstanceInfo);
                    }
                }
            };
            ParticleSystem.prototype._getVBO = function (gl) {
                for (var i = 0, n = this._vbos.length; i < n; i++) {
                    if (this._vbos[i][0] == gl)
                        return this._vbos[i][1];
                }
                var vbo = gl.createBuffer();
                this._vbos.push([gl, vbo]);
                return vbo;
            };
            Object.defineProperty(ParticleSystem.prototype, "rateAtDuration", {
                /**
                 * 此时在周期中的位置
                 */
                get: function () {
                    return (this._realTime % this.main.duration) / this.main.duration;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * 发射粒子
             * @param time 当前粒子时间
             */
            ParticleSystem.prototype._emit = function () {
                var _this = this;
                if (!this.emission.enabled)
                    return;
                // 判断是否达到最大粒子数量
                if (this._activeParticles.length >= this.main.maxParticles)
                    return;
                // 判断是否开始发射
                if (this._realTime <= 0)
                    return;
                var loop = this.main.loop;
                var duration = this.main.duration;
                var rateAtDuration = this.rateAtDuration;
                var preRealTime = this._preRealTime;
                // 判断是否结束发射
                if (!loop && preRealTime >= duration)
                    return;
                // 计算最后发射时间
                var realEmitTime = this._realTime;
                if (!loop)
                    realEmitTime = Math.min(realEmitTime, duration);
                // 
                var emits = [];
                // 单粒子发射周期
                var step = 1 / this.emission.rateOverTime.getValue(rateAtDuration);
                var bursts = this.emission.bursts;
                // 处理移动发射粒子
                if (this.main.simulationSpace == framework.ParticleSystemSimulationSpace.World) {
                    if (this._isRateOverDistance) {
                        var moveVec = this.moveVec;
                        var worldPos = this.worldPos;
                        // 本次移动距离
                        if (m4m.math.vec3SqrLength(moveVec) > 0) {
                            // 移动方向
                            var moveDir = new m4m.math.vector3(moveVec.x, moveVec.y, moveVec.z);
                            m4m.math.vec3Normalize(moveDir, moveDir);
                            // 剩余移动量
                            var leftRateOverDistance = this._leftRateOverDistance + m4m.math.vec3Length(moveVec);
                            // 发射频率
                            var rateOverDistance = this.emission.rateOverDistance.getValue(rateAtDuration);
                            // 发射间隔距离
                            var invRateOverDistance = 1 / rateOverDistance;
                            // 发射间隔位移
                            var invRateOverDistanceVec = new m4m.math.vector3(moveDir.x / rateOverDistance, moveDir.y / rateOverDistance, moveDir.z / rateOverDistance);
                            // 上次发射位置
                            var lastRateOverDistance = new m4m.math.vector3(this._preworldPos.x - moveDir.x * this._leftRateOverDistance, this._preworldPos.y - moveDir.y * this._leftRateOverDistance, this._preworldPos.z - moveDir.z * this._leftRateOverDistance);
                            // 发射位置列表
                            var emitPosArr = [];
                            while (invRateOverDistance < leftRateOverDistance) {
                                emitPosArr.push(new m4m.math.vector3(lastRateOverDistance.x + invRateOverDistanceVec.x, lastRateOverDistance.y + invRateOverDistanceVec.y, lastRateOverDistance.z + invRateOverDistanceVec.z));
                                leftRateOverDistance -= invRateOverDistance;
                            }
                            this._leftRateOverDistance = leftRateOverDistance;
                            emitPosArr.forEach(function (p) {
                                emits.push({ time: _this.time, num: 1, position: new m4m.math.vector3(p.x - worldPos.x, p.y - worldPos.y, p.z - worldPos.z) });
                            });
                        }
                    }
                    this._isRateOverDistance = true;
                }
                else {
                    this._isRateOverDistance = false;
                    this._leftRateOverDistance = 0;
                }
                // 遍历所有发射周期
                var cycleStartIndex = Math.floor(preRealTime / duration);
                var cycleEndIndex = Math.ceil(realEmitTime / duration);
                for (var k = cycleStartIndex; k < cycleEndIndex; k++) {
                    var cycleStartTime = k * duration;
                    var cycleEndTime = (k + 1) * duration;
                    // 单个周期内的起始与结束时间
                    var startTime = Math.max(preRealTime, cycleStartTime);
                    var endTime = Math.min(realEmitTime, cycleEndTime);
                    // 处理稳定发射
                    var singleStart = Math.ceil(startTime / step) * step;
                    for (var i = singleStart; i < endTime; i += step) {
                        emits.push({ time: i, num: 1 });
                    }
                    // 处理喷发
                    var inCycleStart = startTime - cycleStartTime;
                    var inCycleEnd = endTime - cycleStartTime;
                    for (var i_10 = 0; i_10 < bursts.length; i_10++) {
                        var burst = bursts[i_10];
                        if (burst.isProbability && inCycleStart <= burst.time && burst.time < inCycleEnd) {
                            emits.push({ time: cycleStartTime + burst.time, num: burst.count.getValue(rateAtDuration) });
                        }
                    }
                }
                emits.sort(function (a, b) { return a.time - b.time; });
                ;
                emits.forEach(function (v) {
                    _this._emitParticles(v);
                });
            };
            /**
             * 发射粒子
             * @param birthTime 发射时间
             * @param num 发射数量
             */
            ParticleSystem.prototype._emitParticles = function (v) {
                var rateAtDuration = this.rateAtDuration;
                var num = v.num;
                var birthTime = v.time;
                var position = v.position || new m4m.math.vector3();
                for (var i = 0; i < num; i++) {
                    if (this._activeParticles.length >= this.main.maxParticles)
                        return;
                    var lifetime = this.main.startLifetime.getValue(rateAtDuration);
                    var birthRateAtDuration = (birthTime - this.startDelay) / this.main.duration;
                    var rateAtLifeTime = (this._realTime - birthTime) / lifetime;
                    if (rateAtLifeTime < 1) {
                        var particle = this._particlePool.pop() || new framework.Particle1();
                        particle.cache = {};
                        particle.position.x = position.x;
                        particle.position.y = position.y;
                        particle.position.z = position.z;
                        particle.birthTime = birthTime;
                        particle.lifetime = lifetime;
                        particle.rateAtLifeTime = rateAtLifeTime;
                        //
                        particle.birthRateAtDuration = birthRateAtDuration - Math.floor(birthRateAtDuration);
                        this._activeParticles.push(particle);
                        this._initParticleState(particle);
                        this._updateParticleState(particle);
                    }
                }
            };
            /**
             * 更新活跃粒子状态
             */
            ParticleSystem.prototype._updateActiveParticlesState = function () {
                for (var i = this._activeParticles.length - 1; i >= 0; i--) {
                    var particle = this._activeParticles[i];
                    particle.rateAtLifeTime = (this._realTime - particle.birthTime) / particle.lifetime;
                    if (particle.rateAtLifeTime < 0 || particle.rateAtLifeTime > 1) {
                        this._activeParticles.splice(i, 1);
                        this._particlePool.push(particle);
                    }
                    else {
                        this._updateParticleState(particle);
                    }
                }
            };
            /**
             * 初始化粒子状态
             * @param particle 粒子
             */
            ParticleSystem.prototype._initParticleState = function (particle) {
                this._modules.forEach(function (v) { v.initParticleState(particle); });
            };
            /**
             * 更新粒子状态
             * @param particle 粒子
             */
            ParticleSystem.prototype._updateParticleState = function (particle) {
                var preTime = Math.max(this._preRealTime, particle.birthTime);
                //
                this._modules.forEach(function (v) { v.updateParticleState(particle); });
                particle.updateState(preTime, this._realTime);
            };
            ParticleSystem.prototype._simulationSpaceChanged = function () {
                if (!this.transform)
                    return;
                if (this._activeParticles.length == 0)
                    return;
                if (this._main.simulationSpace == framework.ParticleSystemSimulationSpace.Local) {
                    var worldToLocalMatrix = this.worldToLocalMatrix;
                    this._activeParticles.forEach(function (p) {
                        m4m.math.matrixTransformVector3(p.position, worldToLocalMatrix, p.position);
                        m4m.math.matrixTransformNormal(p.velocity, worldToLocalMatrix, p.velocity);
                        m4m.math.matrixTransformNormal(p.acceleration, worldToLocalMatrix, p.acceleration);
                    });
                }
                else {
                    var localToWorldMatrix = this.localToWorldMatrix;
                    this._activeParticles.forEach(function (p) {
                        m4m.math.matrixTransformVector3(p.position, localToWorldMatrix, p.position);
                        m4m.math.matrixTransformNormal(p.velocity, localToWorldMatrix, p.velocity);
                        m4m.math.matrixTransformNormal(p.acceleration, localToWorldMatrix, p.acceleration);
                    });
                }
            };
            /**
             * 给指定粒子添加指定空间的位移。
             *
             * @param particle 粒子。
             * @param position 速度。
             * @param space 速度所在空间。
             * @param name  速度名称。如果不为 undefined 时保存，调用 removeParticleVelocity 可以移除该部分速度。
             */
            ParticleSystem.prototype.addParticlePosition = function (particle, position, space, name) {
                if (name != undefined) {
                    this.removeParticleVelocity(particle, name);
                    particle.cache[name] = { value: new m4m.math.vector3(position.x, position.y, position.z), space: space };
                }
                if (space != this.main.simulationSpace) {
                    if (space == framework.ParticleSystemSimulationSpace.World) {
                        m4m.math.matrixTransformVector3(position, this.worldToLocalMatrix, position);
                    }
                    else {
                        m4m.math.matrixTransformVector3(position, this.localToWorldMatrix, position);
                    }
                }
                //
                particle.position.x += position.x;
                particle.position.y += position.y;
                particle.position.z += position.z;
            };
            /**
             * 移除指定粒子上的位移
             *
             * @param particle 粒子。
             * @param name 位移名称。
             */
            ParticleSystem.prototype.removeParticlePosition = function (particle, name) {
                var obj = particle.cache[name];
                if (obj) {
                    delete particle.cache[name];
                    var space = obj.space;
                    var value = obj.value;
                    if (space != this.main.simulationSpace) {
                        if (space == framework.ParticleSystemSimulationSpace.World) {
                            m4m.math.matrixTransformVector3(value, this.worldToLocalMatrix, value);
                        }
                        else {
                            m4m.math.matrixTransformVector3(value, this.localToWorldMatrix, value);
                        }
                    }
                    //
                    particle.position.x -= value.x;
                    particle.position.y -= value.y;
                    particle.position.z -= value.z;
                }
            };
            /**
             * 给指定粒子添加指定空间的速度。
             *
             * @param particle 粒子。
             * @param velocity 速度。
             * @param space 速度所在空间。
             * @param name  速度名称。如果不为 undefined 时保存，调用 removeParticleVelocity 可以移除该部分速度。
             */
            ParticleSystem.prototype.addParticleVelocity = function (particle, velocity, space, name) {
                if (name != undefined) {
                    this.removeParticleVelocity(particle, name);
                    particle.cache[name] = { value: new m4m.math.vector3(velocity.x, velocity.y, velocity.z), space: space };
                }
                if (space != this.main.simulationSpace) {
                    if (space == framework.ParticleSystemSimulationSpace.World) {
                        m4m.math.matrixTransformNormal(velocity, this.worldToLocalMatrix, velocity);
                    }
                    else {
                        m4m.math.matrixTransformNormal(velocity, this.localToWorldMatrix, velocity);
                    }
                }
                //
                particle.velocity.x += velocity.x;
                particle.velocity.y += velocity.y;
                particle.velocity.z += velocity.z;
            };
            /**
             * 移除指定粒子上的速度
             *
             * @param particle 粒子。
             * @param name 速度名称。
             */
            ParticleSystem.prototype.removeParticleVelocity = function (particle, name) {
                var obj = particle.cache[name];
                if (obj) {
                    delete particle.cache[name];
                    var space = obj.space;
                    var value = obj.value;
                    if (space != this.main.simulationSpace) {
                        if (space == framework.ParticleSystemSimulationSpace.World) {
                            m4m.math.matrixTransformNormal(value, this.worldToLocalMatrix, value);
                        }
                        else {
                            m4m.math.matrixTransformNormal(value, this.localToWorldMatrix, value);
                        }
                    }
                    //
                    particle.velocity.x -= value.x;
                    particle.velocity.y -= value.y;
                    particle.velocity.z -= value.z;
                }
            };
            /**
             * 给指定粒子添加指定空间的速度。
             *
             * @param particle 粒子。
             * @param acceleration 加速度。
             * @param space 加速度所在空间。
             * @param name  加速度名称。如果不为 undefined 时保存，调用 removeParticleVelocity 可以移除该部分速度。
             */
            ParticleSystem.prototype.addParticleAcceleration = function (particle, acceleration, space, name) {
                if (name != undefined) {
                    this.removeParticleAcceleration(particle, name);
                    particle.cache[name] = { value: new m4m.math.vector3(acceleration.x, acceleration.y, acceleration.z), space: space };
                }
                if (space != this.main.simulationSpace) {
                    if (space == framework.ParticleSystemSimulationSpace.World) {
                        m4m.math.matrixTransformNormal(acceleration, this.worldToLocalMatrix, acceleration);
                    }
                    else {
                        m4m.math.matrixTransformNormal(acceleration, this.localToWorldMatrix, acceleration);
                    }
                }
                //
                particle.acceleration.x += acceleration.x;
                particle.acceleration.y += acceleration.y;
                particle.acceleration.z += acceleration.z;
            };
            /**
             * 移除指定粒子上的加速度
             *
             * @param particle 粒子。
             * @param name 加速度名称。
             */
            ParticleSystem.prototype.removeParticleAcceleration = function (particle, name) {
                var obj = particle.cache[name];
                if (obj) {
                    delete particle.cache[name];
                    var space = obj.space;
                    var value = obj.value;
                    if (space != this.main.simulationSpace) {
                        if (space == framework.ParticleSystemSimulationSpace.World) {
                            m4m.math.matrixTransformNormal(value, this.worldToLocalMatrix, value);
                        }
                        else {
                            m4m.math.matrixTransformNormal(value, this.localToWorldMatrix, value);
                        }
                    }
                    //
                    particle.acceleration.x -= value.x;
                    particle.acceleration.y -= value.y;
                    particle.acceleration.z -= value.z;
                }
            };
            ParticleSystem.ClassName = "particlesystem";
            __decorate([
                m4m.reflect.Field("mesh"),
                m4m.reflect.UIStyle("WidgetDragSelect"),
                __metadata("design:type", framework.mesh),
                __metadata("design:paramtypes", [framework.mesh])
            ], ParticleSystem.prototype, "mesh", null);
            __decorate([
                m4m.reflect.Field("material"),
                __metadata("design:type", framework.material)
            ], ParticleSystem.prototype, "material", void 0);
            __decorate([
                m4m.reflect.Field("ParticleSystemData"),
                __metadata("design:type", Object),
                __metadata("design:paramtypes", [Object])
            ], ParticleSystem.prototype, "particleSystemData", null);
            ParticleSystem = __decorate([
                m4m.reflect.nodeRender,
                m4m.reflect.nodeComponent,
                __metadata("design:paramtypes", [])
            ], ParticleSystem);
            return ParticleSystem;
        }());
        framework.ParticleSystem = ParticleSystem;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * 粒子系统数据
         */
        var ParticleSystemData = /** @class */ (function () {
            function ParticleSystemData(assetName) {
                if (assetName === void 0) { assetName = null; }
                this.name = null;
                this.id = new framework.resID();
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 是否为默认资源
                 * @version m4m 1.0
                 */
                this.defaultAsset = false;
                if (!assetName) {
                    assetName = "ParticleSystem_" + this.getGUID();
                }
                this.name = new framework.constText(assetName);
            }
            ParticleSystemData_1 = ParticleSystemData;
            /**
             * 获取已经创建了的粒子系统数据
             *
             * @param valueName
             */
            ParticleSystemData.get = function (valueName) {
                return this._datas[valueName];
            };
            Object.defineProperty(ParticleSystemData.prototype, "value", {
                /**
                 * 粒子系统资源名称
                 */
                get: function () {
                    return this._value;
                },
                set: function (v) {
                    this._value = v;
                    if (ParticleSystemData_1._datas[v]) {
                        return;
                    }
                    ParticleSystemData_1._datas[v] = this;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取资源名称
             * @version m4m 1.0
             */
            ParticleSystemData.prototype.getName = function () {
                if (this.name == undefined) {
                    return null;
                }
                return this.name.getText();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取资源唯一id
             * @version m4m 1.0
             */
            ParticleSystemData.prototype.getGUID = function () {
                return this.id.getID();
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 释放资源
             * @version m4m 1.0
             */
            ParticleSystemData.prototype.dispose = function () {
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 引用计数加一
             * @version m4m 1.0
             */
            ParticleSystemData.prototype.use = function () {
                framework.sceneMgr.app.getAssetMgr().use(this);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 引用计数减一
             * @version m4m 1.0
             */
            ParticleSystemData.prototype.unuse = function (disposeNow) {
                if (disposeNow === void 0) { disposeNow = false; }
                framework.sceneMgr.app.getAssetMgr().unuse(this, disposeNow);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 计算资源字节大小
             * @version m4m 1.0
             */
            ParticleSystemData.prototype.caclByteLength = function () {
                var total = 0;
                return total;
            };
            ParticleSystemData.prototype.setData = function (v) {
                this.objectData = JSON.parse(v);
                if (this.particleSystem) {
                    framework.serialization.setValue(this.particleSystem, this.objectData);
                }
            };
            var ParticleSystemData_1;
            ParticleSystemData.ClassName = "ParticleSystemData";
            ParticleSystemData._datas = {};
            __decorate([
                m4m.reflect.Field("constText"),
                __metadata("design:type", framework.constText)
            ], ParticleSystemData.prototype, "name", void 0);
            __decorate([
                m4m.reflect.Field("string"),
                __metadata("design:type", Object),
                __metadata("design:paramtypes", [Object])
            ], ParticleSystemData.prototype, "value", null);
            ParticleSystemData = ParticleSystemData_1 = __decorate([
                m4m.reflect.SerializeType,
                __metadata("design:paramtypes", [String])
            ], ParticleSystemData);
            return ParticleSystemData;
        }());
        framework.ParticleSystemData = ParticleSystemData;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * The animation type.
         *
         * 动画类型。
         *
         * @author feng3d
         */
        var ParticleSystemAnimationType;
        (function (ParticleSystemAnimationType) {
            /**
             * Animate over the whole texture sheet from left to right, top to bottom.
             *
             * 从左到右，从上到下动画整个纹理表。
             */
            ParticleSystemAnimationType[ParticleSystemAnimationType["WholeSheet"] = 0] = "WholeSheet";
            /**
             * Animate a single row in the sheet from left to right.
             *
             * 从左到右移动工作表中的一行。
             */
            ParticleSystemAnimationType[ParticleSystemAnimationType["SingleRow"] = 1] = "SingleRow";
        })(ParticleSystemAnimationType = framework.ParticleSystemAnimationType || (framework.ParticleSystemAnimationType = {}));
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * How to apply emitter velocity to particles.
         *
         * 如何将发射体速度应用于粒子。
         *
         * @author feng3d
         */
        var ParticleSystemInheritVelocityMode;
        (function (ParticleSystemInheritVelocityMode) {
            /**
             * Each particle inherits the emitter's velocity on the frame when it was initially emitted.
             *
             * 每个粒子在最初发射时都继承了发射体在帧上的速度。
             */
            ParticleSystemInheritVelocityMode[ParticleSystemInheritVelocityMode["Initial"] = 0] = "Initial";
            /**
             * Each particle's velocity is set to the emitter's current velocity value, every frame.
             *
             * 每一帧，每个粒子的速度都设定为发射器的当前速度值。
             */
            ParticleSystemInheritVelocityMode[ParticleSystemInheritVelocityMode["Current"] = 1] = "Current";
        })(ParticleSystemInheritVelocityMode = framework.ParticleSystemInheritVelocityMode || (framework.ParticleSystemInheritVelocityMode = {}));
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * The mesh emission type.
         *
         * 网格发射类型。
         *
         * @author feng3d
         */
        var ParticleSystemMeshShapeType;
        (function (ParticleSystemMeshShapeType) {
            /**
             * Emit from the vertices of the mesh.
             *
             * 从网格的顶点发出。
             */
            ParticleSystemMeshShapeType[ParticleSystemMeshShapeType["Vertex"] = 0] = "Vertex";
            /**
             * Emit from the edges of the mesh.
             *
             * 从网格的边缘发出。
             */
            ParticleSystemMeshShapeType[ParticleSystemMeshShapeType["Edge"] = 1] = "Edge";
            /**
             * Emit from the surface of the mesh.
             *
             * 从网格表面发出。
             */
            ParticleSystemMeshShapeType[ParticleSystemMeshShapeType["Triangle"] = 2] = "Triangle";
        })(ParticleSystemMeshShapeType = framework.ParticleSystemMeshShapeType || (framework.ParticleSystemMeshShapeType = {}));
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * The quality of the generated noise.
         *
         * 产生的噪音的质量。
         */
        var ParticleSystemNoiseQuality;
        (function (ParticleSystemNoiseQuality) {
            /**
             * Low quality 1D noise.
             *
             * 低质量的一维噪声。
             */
            ParticleSystemNoiseQuality[ParticleSystemNoiseQuality["Low"] = 0] = "Low";
            /**
             * Medium quality 2D noise.
             *
             * 中等质量2D噪音。
             */
            ParticleSystemNoiseQuality[ParticleSystemNoiseQuality["Medium"] = 1] = "Medium";
            /**
             * High quality 3D noise.
             *
             * 高品质3D噪音。
             */
            ParticleSystemNoiseQuality[ParticleSystemNoiseQuality["High"] = 2] = "High";
        })(ParticleSystemNoiseQuality = framework.ParticleSystemNoiseQuality || (framework.ParticleSystemNoiseQuality = {}));
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * Control how particle systems apply transform scale.
         *
         * 控制粒子系统如何应用变换尺度。
         *
         * @author feng3d
         */
        var ParticleSystemScalingMode;
        (function (ParticleSystemScalingMode) {
            /**
             * Scale the particle system using the entire transform hierarchy.
             *
             * 使用整个转换层次来缩放粒子系统。
             */
            ParticleSystemScalingMode[ParticleSystemScalingMode["Hierarchy"] = 0] = "Hierarchy";
            /**
             * Scale the particle system using only its own transform scale. (Ignores parent scale).
             *
             * 尺度粒子系统只使用自己的变换尺度。(忽略了父母规模)。
             */
            ParticleSystemScalingMode[ParticleSystemScalingMode["Local"] = 1] = "Local";
            /**
             * Only apply transform scale to the shape component, which controls where particles are spawned, but does not affect their size or movement.
             *
             * 只对形状组件应用变换比例，它控制生成粒子的位置，但不影响粒子的大小或移动。
             */
            ParticleSystemScalingMode[ParticleSystemScalingMode["Shape"] = 2] = "Shape";
        })(ParticleSystemScalingMode = framework.ParticleSystemScalingMode || (framework.ParticleSystemScalingMode = {}));
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * 粒子系统圆锥体发射类型，用于定义基于圆锥体的发射类型。
         */
        var ParticleSystemShapeConeEmitFrom;
        (function (ParticleSystemShapeConeEmitFrom) {
            /**
             * 从圆锥体底面发射。
             */
            ParticleSystemShapeConeEmitFrom[ParticleSystemShapeConeEmitFrom["Base"] = 0] = "Base";
            /**
             * 从圆锥体底面边缘沿着曲面发射。
             */
            ParticleSystemShapeConeEmitFrom[ParticleSystemShapeConeEmitFrom["BaseShell"] = 1] = "BaseShell";
            /**
             * 从圆锥体内部发射。
             */
            ParticleSystemShapeConeEmitFrom[ParticleSystemShapeConeEmitFrom["Volume"] = 2] = "Volume";
            /**
             * 从圆锥体曲面沿着曲面发射。
             */
            ParticleSystemShapeConeEmitFrom[ParticleSystemShapeConeEmitFrom["VolumeShell"] = 3] = "VolumeShell";
        })(ParticleSystemShapeConeEmitFrom = framework.ParticleSystemShapeConeEmitFrom || (framework.ParticleSystemShapeConeEmitFrom = {}));
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * The mode used to generate new points in a shape (Shuriken).
         *
         * 用于在形状中生成新点的模式
         */
        var ParticleSystemShapeMultiModeValue;
        (function (ParticleSystemShapeMultiModeValue) {
            /**
             * Generate points randomly. (Default)
             *
             * 生成随机点。(默认)
             */
            ParticleSystemShapeMultiModeValue[ParticleSystemShapeMultiModeValue["Random"] = 0] = "Random";
            /**
             * Animate the emission point around the shape.
             *
             * 使发射点围绕形状运动。
             */
            ParticleSystemShapeMultiModeValue[ParticleSystemShapeMultiModeValue["Loop"] = 1] = "Loop";
            /**
             * Animate the emission point around the shape, alternating between clockwise and counter-clockwise directions.
             *
             * 使发射点围绕形状运动，在顺时针和逆时针方向之间交替。
             */
            ParticleSystemShapeMultiModeValue[ParticleSystemShapeMultiModeValue["PingPong"] = 2] = "PingPong";
            /**
             * Distribute new particles around the shape evenly.
             *
             * 在形状周围均匀分布新粒子。
             *
             * @todo
             */
            ParticleSystemShapeMultiModeValue[ParticleSystemShapeMultiModeValue["BurstSpread"] = 3] = "BurstSpread";
        })(ParticleSystemShapeMultiModeValue = framework.ParticleSystemShapeMultiModeValue || (framework.ParticleSystemShapeMultiModeValue = {}));
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * 发射形状
         *
         * @author feng3d
         */
        var ParticleSystemShapeType;
        (function (ParticleSystemShapeType) {
            /**
             * Emit from a sphere.
             *
             * 从球体的体积中发射。
             */
            ParticleSystemShapeType[ParticleSystemShapeType["Sphere"] = 0] = "Sphere";
            /**
             * Emit from the surface of a sphere.
             *
             * 从球体表面发射。
             */
            ParticleSystemShapeType[ParticleSystemShapeType["SphereShell"] = 1] = "SphereShell";
            /**
             * Emit from a half-sphere.
             *
             * 从半球体的体积发射。
             */
            ParticleSystemShapeType[ParticleSystemShapeType["Hemisphere"] = 2] = "Hemisphere";
            /**
             * Emit from the surface of a half-sphere.
             *
             * 从半球体的表面发射。
             */
            ParticleSystemShapeType[ParticleSystemShapeType["HemisphereShell"] = 3] = "HemisphereShell";
            /**
             * Emit from a cone.
             *
             * 从圆锥体发射。
             */
            ParticleSystemShapeType[ParticleSystemShapeType["Cone"] = 4] = "Cone";
            /**
             * Emit from the base surface of a cone.
             *
             * 从圆锥体的基面发射。
             */
            ParticleSystemShapeType[ParticleSystemShapeType["ConeShell"] = 7] = "ConeShell";
            /**
             * Emit from the volume of a cone.
             *
             * 从一个圆锥体的体积发出。
             */
            ParticleSystemShapeType[ParticleSystemShapeType["ConeVolume"] = 8] = "ConeVolume";
            /**
             * Emit from the surface of a cone.
             *
             * 从一个圆锥体的表面发射。
             */
            ParticleSystemShapeType[ParticleSystemShapeType["ConeVolumeShell"] = 9] = "ConeVolumeShell";
            /**
             * Emit from the volume of a box.
             *
             * 从一个盒子的体积中发出。
             */
            ParticleSystemShapeType[ParticleSystemShapeType["Box"] = 5] = "Box";
            /**
             * Emit from the surface of a box.
             *
             * 从盒子表面发射。
             */
            ParticleSystemShapeType[ParticleSystemShapeType["BoxShell"] = 15] = "BoxShell";
            /**
             * Emit from the edges of a box.
             *
             * 从盒子的边缘发出。
             */
            ParticleSystemShapeType[ParticleSystemShapeType["BoxEdge"] = 16] = "BoxEdge";
            /**
             * Emit from a mesh.
             *
             * 从一个网格中发出。
             *
             * @todo
             */
            ParticleSystemShapeType[ParticleSystemShapeType["Mesh"] = 6] = "Mesh";
            /**
             * Emit from a mesh renderer.
             *
             * 从一个网格渲染器发射。
             *
             * @todo
             */
            ParticleSystemShapeType[ParticleSystemShapeType["MeshRenderer"] = 13] = "MeshRenderer";
            /**
             * Emit from a skinned mesh renderer.
             *
             * 从蒙皮网格渲染器发出。
             *
             * @todo
             */
            ParticleSystemShapeType[ParticleSystemShapeType["SkinnedMeshRenderer"] = 14] = "SkinnedMeshRenderer";
            /**
             * Emit from a circle.
             *
             * 从一个圆发出。
             */
            ParticleSystemShapeType[ParticleSystemShapeType["Circle"] = 10] = "Circle";
            /**
             * Emit from the edge of a circle.
             *
             * 从圆的边缘发出。
             */
            ParticleSystemShapeType[ParticleSystemShapeType["CircleEdge"] = 11] = "CircleEdge";
            /**
             * Emit from an edge.
             *
             * 从边缘发出。
             */
            ParticleSystemShapeType[ParticleSystemShapeType["SingleSidedEdge"] = 12] = "SingleSidedEdge";
        })(ParticleSystemShapeType = framework.ParticleSystemShapeType || (framework.ParticleSystemShapeType = {}));
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * The emission shape (Shuriken).
         *
         * 发射的形状
         *
         * @author feng3d
         */
        var ParticleSystemShapeType1;
        (function (ParticleSystemShapeType1) {
            /**
             * Emit from a sphere.
             *
             * 从球体的体积中发射。
             */
            ParticleSystemShapeType1[ParticleSystemShapeType1["Sphere"] = 0] = "Sphere";
            /**
             * Emit from a half-sphere.
             *
             * 从半球体的体积发射。
             */
            ParticleSystemShapeType1[ParticleSystemShapeType1["Hemisphere"] = 1] = "Hemisphere";
            /**
             * Emit from a cone.
             *
             * 从圆锥体发射。
             */
            ParticleSystemShapeType1[ParticleSystemShapeType1["Cone"] = 2] = "Cone";
            /**
             * Emit from the volume of a box.
             *
             * 从一个盒子的体积中发出。
             */
            ParticleSystemShapeType1[ParticleSystemShapeType1["Box"] = 3] = "Box";
            /**
             * Emit from a mesh.
             *
             * 从一个网格中发出。
             *
             * @todo
             */
            ParticleSystemShapeType1[ParticleSystemShapeType1["Mesh"] = 4] = "Mesh";
            /**
             * Emit from a mesh renderer.
             *
             * 从一个网格渲染器发射。
             *
             * @todo
             */
            ParticleSystemShapeType1[ParticleSystemShapeType1["MeshRenderer"] = 5] = "MeshRenderer";
            /**
             * Emit from a skinned mesh renderer.
             *
             * 从蒙皮网格渲染器发出。
             *
             * @todo
             */
            ParticleSystemShapeType1[ParticleSystemShapeType1["SkinnedMeshRenderer"] = 6] = "SkinnedMeshRenderer";
            /**
             * Emit from a circle.
             *
             * 从一个圆发出。
             */
            ParticleSystemShapeType1[ParticleSystemShapeType1["Circle"] = 7] = "Circle";
            /**
             * Emit from an edge.
             *
             * 从边缘发出。
             */
            ParticleSystemShapeType1[ParticleSystemShapeType1["Edge"] = 8] = "Edge";
        })(ParticleSystemShapeType1 = framework.ParticleSystemShapeType1 || (framework.ParticleSystemShapeType1 = {}));
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * 粒子模拟空间
         *
         * @author feng3d
         */
        var ParticleSystemSimulationSpace;
        (function (ParticleSystemSimulationSpace) {
            /**
             * Simulate particles in local space.
             *
             * 模拟局部空间中的粒子。
             */
            ParticleSystemSimulationSpace[ParticleSystemSimulationSpace["Local"] = 0] = "Local";
            /**
             * Simulate particles in world space.
             *
             * 模拟世界空间中的粒子。
             */
            ParticleSystemSimulationSpace[ParticleSystemSimulationSpace["World"] = 1] = "World";
        })(ParticleSystemSimulationSpace = framework.ParticleSystemSimulationSpace || (framework.ParticleSystemSimulationSpace = {}));
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * A flag representing each UV channel.
         * 一个代表每个紫外线频道的旗子。
         *
         * @author feng3d
         */
        var UVChannelFlags;
        (function (UVChannelFlags) {
            /**
             * 无通道。
             */
            UVChannelFlags[UVChannelFlags["Nothing"] = 0] = "Nothing";
            /**
             * First UV channel.
             * 第一UV通道。
             */
            UVChannelFlags[UVChannelFlags["UV0"] = 1] = "UV0";
            /**
             * Second UV channel.
             * 第二UV通道。
             */
            UVChannelFlags[UVChannelFlags["UV1"] = 2] = "UV1";
            /**
             * Third UV channel.
             * 第三UV通道。
             */
            UVChannelFlags[UVChannelFlags["UV2"] = 4] = "UV2";
            /**
             * Fourth UV channel.
             * 第四UV通道。
             */
            UVChannelFlags[UVChannelFlags["UV3"] = 8] = "UV3";
            /**
             * All channel.
             * 所有通道。
             */
            UVChannelFlags[UVChannelFlags["Everything"] = 15] = "Everything";
        })(UVChannelFlags = framework.UVChannelFlags || (framework.UVChannelFlags = {}));
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * 粒子模块
         *
         * @author feng3d
         */
        var ParticleModule = /** @class */ (function () {
            function ParticleModule() {
                /**
                 * 是否开启
                 */
                this.enabled = false;
            }
            /**
             * 初始化粒子状态
             * @param particle 粒子
             */
            ParticleModule.prototype.initParticleState = function (particle) {
            };
            /**
             * 更新粒子状态
             * @param particle 粒子
             */
            ParticleModule.prototype.updateParticleState = function (particle) {
            };
            return ParticleModule;
        }());
        framework.ParticleModule = ParticleModule;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="ParticleModule.ts" />
var m4m;
/// <reference path="ParticleModule.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * the Color By Speed module.
         *
         * 颜色随速度变化模块。
         */
        var ParticleColorBySpeedModule = /** @class */ (function (_super) {
            __extends(ParticleColorBySpeedModule, _super);
            function ParticleColorBySpeedModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * The gradient controlling the particle colors.
                 *
                 * 控制粒子颜色的梯度。
                 */
                _this.color = new framework.MinMaxGradient();
                /**
                 * Apply the color gradient between these minimum and maximum speeds.
                 *
                 * 在这些最小和最大速度之间应用颜色渐变。
                 */
                _this.range = new m4m.math.vector2(0, 1);
                return _this;
            }
            /**
             * 初始化粒子状态
             * @param particle 粒子
             */
            ParticleColorBySpeedModule.prototype.initParticleState = function (particle) {
                particle[_ColorBySpeed_rate] = Math.random();
            };
            /**
             * 更新粒子状态
             * @param particle 粒子
             */
            ParticleColorBySpeedModule.prototype.updateParticleState = function (particle) {
                if (!this.enabled)
                    return;
                var velocity = m4m.math.vec3Length(particle.velocity);
                var rate = m4m.math.floatClamp((velocity - this.range.x) / (this.range.y - this.range.x), 0, 1);
                var color = this.color.getValue(rate, particle[_ColorBySpeed_rate]);
                m4m.math.colorMultiply(particle.color, color, particle.color);
            };
            return ParticleColorBySpeedModule;
        }(framework.ParticleModule));
        framework.ParticleColorBySpeedModule = ParticleColorBySpeedModule;
        var _ColorBySpeed_rate = "_ColorBySpeed_rate";
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="ParticleModule.ts" />
var m4m;
/// <reference path="ParticleModule.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * 粒子系统 颜色随时间变化模块
         *
         * @author feng3d
         */
        var ParticleColorOverLifetimeModule = /** @class */ (function (_super) {
            __extends(ParticleColorOverLifetimeModule, _super);
            function ParticleColorOverLifetimeModule() {
                /**
                 * The gradient controlling the particle colors.
                 * 控制粒子颜色的梯度。
                 */
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.color = new framework.MinMaxGradient();
                return _this;
            }
            /**
             * 初始化粒子状态
             * @param particle 粒子
             */
            ParticleColorOverLifetimeModule.prototype.initParticleState = function (particle) {
                particle[_ColorOverLifetime_rate] = Math.random();
            };
            /**
             * 更新粒子状态
             * @param particle 粒子
             */
            ParticleColorOverLifetimeModule.prototype.updateParticleState = function (particle) {
                if (!this.enabled)
                    return;
                var color = this.color.getValue(particle.rateAtLifeTime, particle[_ColorOverLifetime_rate]);
                m4m.math.colorMultiply(particle.color, color, particle.color);
            };
            return ParticleColorOverLifetimeModule;
        }(framework.ParticleModule));
        framework.ParticleColorOverLifetimeModule = ParticleColorOverLifetimeModule;
        var _ColorOverLifetime_rate = "_ColorOverLifetime_rate";
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * 粒子系统发射模块。
         *
         * @author feng3d
         */
        var ParticleEmissionModule = /** @class */ (function (_super) {
            __extends(ParticleEmissionModule, _super);
            function ParticleEmissionModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * 随着时间的推移，新粒子产生的速度。
                 */
                _this.rateOverTime = framework.serialization.setValue(new framework.MinMaxCurve(), { between0And1: true, constant: 10, constantMin: 10, constantMax: 10, curveMultiplier: 10 });
                /**
                 * The rate at which new particles are spawned, over distance.
                 * New particles will only be emitted when the emitter moves.
                 *
                 * 产生新粒子的速度，通过距离。
                 * 新粒子只有在发射器移动时才会被发射出来。
                 *
                 * @todo
                 */
                _this.rateOverDistance = framework.serialization.setValue(new framework.MinMaxCurve(), { between0And1: true, constant: 0, constantMin: 0, constantMax: 1 });
                /**
                 * 爆发数组
                 */
                _this.bursts = [];
                return _this;
            }
            Object.defineProperty(ParticleEmissionModule.prototype, "rateOverTimeMultiplier", {
                /**
                 * Change the rate over time multiplier.
                 * This is more efficient than accessing the whole curve, if you only want to change the overall rate multiplier.
                 *
                 * 改变率随时间的乘数。
                 * 如果您只想更改整体的速率乘数，那么这比访问整个曲线更有效。
                 * 只在
                 */
                get: function () {
                    return this.rateOverTime.curveMultiplier;
                },
                set: function (v) {
                    this.rateOverTime.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleEmissionModule.prototype, "rateOverDistanceMultiplier", {
                /**
                 * Change the rate over distance multiplier.
                 * This is more efficient than accessing the whole curve, if you only want to change the overall rate multiplier.
                 *
                 * 改变速率随距离变化的乘数。
                 * 如果您只想更改整体的速率乘数，那么这比访问整个曲线更有效。
                 */
                get: function () {
                    return this.rateOverDistance.curveMultiplier;
                },
                set: function (v) {
                    this.rateOverDistance.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleEmissionModule.prototype, "burstCount", {
                /**
                 * The current number of bursts.
                 *
                 * 当前的爆发次数。
                 */
                get: function () {
                    return this.bursts.length;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * Get the burst array.
             * 获取爆发数组。
             *
             * @param bursts Array of bursts to be filled in.要填充的爆发数组。
             * @returns The number of bursts in the array.数组中的爆发次数。
             */
            ParticleEmissionModule.prototype.getBursts = function (bursts) {
                bursts.length = this.bursts.length;
                for (var i = 0, n = bursts.length; i < n; i++) {
                    bursts[i] = this.bursts[i];
                }
                return bursts.length;
            };
            /**
             * Set the burst array.
             * 设置爆发数组。
             *
             * @param bursts Array of bursts.爆发的数组。
             * @param size Optional array size, if burst count is less than array size.可选的数组大小，如果爆发计数小于数组大小。
             */
            ParticleEmissionModule.prototype.setBursts = function (bursts, size) {
                if (size === void 0) { size = Number.MAX_SAFE_INTEGER; }
                var size = Math.min(bursts.length, size);
                for (var i = 0; i < size; i++) {
                    this.bursts[i] = bursts[i];
                }
            };
            return ParticleEmissionModule;
        }(framework.ParticleModule));
        framework.ParticleEmissionModule = ParticleEmissionModule;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * 粒子系统 作用在粒子上的力随时间变化模块
         *
         * 控制每个粒子在其生命周期内的力。
         * Script interface for the Force Over Lifetime module.
         *
         * @author feng3d
         */
        var ParticleForceOverLifetimeModule = /** @class */ (function (_super) {
            __extends(ParticleForceOverLifetimeModule, _super);
            function ParticleForceOverLifetimeModule() {
                /**
                 * 作用在粒子上的力
                 */
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.force = new framework.MinMaxCurveVector3();
                /**
                 * Are the forces being applied in local or world space?
                 *
                 * 这些力是作用于局部空间还是世界空间
                 */
                _this.space = framework.ParticleSystemSimulationSpace.Local;
                /**
                 * When randomly selecting values between two curves or constants, this flag will cause a new random force to be chosen on each frame.
                 *
                 * 当在两条曲线或常数之间随机选择值时，此标志将导致在每一帧上选择一个新的随机力。
                 *
                 * @todo
                 */
                _this.randomized = false;
                return _this;
            }
            Object.defineProperty(ParticleForceOverLifetimeModule.prototype, "x", {
                /**
                 * The curve defining particle forces in the X axis.
                 *
                 * 在X轴上定义粒子力的曲线。
                 */
                get: function () {
                    return this.force.xCurve;
                },
                set: function (v) {
                    this.force.xCurve = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleForceOverLifetimeModule.prototype, "xMultiplier", {
                /**
                 * Change the X axis mulutiplier.
                 *
                 * 改变X轴的乘数。
                 */
                get: function () {
                    return this.x.curveMultiplier;
                },
                set: function (v) {
                    this.x.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleForceOverLifetimeModule.prototype, "y", {
                /**
                 * The curve defining particle forces in the Y axis.
                 *
                 * 在Y轴上定义粒子力的曲线。
                 */
                get: function () {
                    return this.force.yCurve;
                },
                set: function (v) {
                    this.force.yCurve = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleForceOverLifetimeModule.prototype, "yMultiplier", {
                /**
                 * Change the Y axis mulutiplier.
                 *
                 * 改变Y轴的乘数。
                 */
                get: function () {
                    return this.y.curveMultiplier;
                },
                set: function (v) {
                    this.y.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleForceOverLifetimeModule.prototype, "z", {
                /**
                 * The curve defining particle forces in the Z axis.
                 *
                 * 在Z轴上定义粒子力的曲线。
                 */
                get: function () {
                    return this.force.zCurve;
                },
                set: function (v) {
                    this.force.zCurve = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleForceOverLifetimeModule.prototype, "zMultiplier", {
                /**
                 * Change the Z axis mulutiplier.
                 *
                 * 改变Z轴的乘数。
                 */
                get: function () {
                    return this.z.curveMultiplier;
                },
                set: function (v) {
                    this.z.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * 初始化粒子状态
             * @param particle 粒子
             */
            ParticleForceOverLifetimeModule.prototype.initParticleState = function (particle) {
                particle[_ForceOverLifetime_rate] = Math.random();
            };
            /**
             * 更新粒子状态
             * @param particle 粒子
             */
            ParticleForceOverLifetimeModule.prototype.updateParticleState = function (particle) {
                this.particleSystem.removeParticleAcceleration(particle, _ForceOverLifetime_preForce);
                if (!this.enabled)
                    return;
                var force = this.force.getValue(particle.rateAtLifeTime, particle[_ForceOverLifetime_rate]);
                this.particleSystem.addParticleAcceleration(particle, force, this.space, _ForceOverLifetime_preForce);
            };
            return ParticleForceOverLifetimeModule;
        }(framework.ParticleModule));
        framework.ParticleForceOverLifetimeModule = ParticleForceOverLifetimeModule;
        var _ForceOverLifetime_rate = "_ForceOverLifetime_rate";
        var _ForceOverLifetime_preForce = "_ForceOverLifetime_preForce";
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * The Inherit Velocity Module controls how the velocity of the emitter is transferred to the particles as they are emitted.
         *
         * 遗传速度模块控制发射体的速度在粒子发射时如何传递到粒子上。（只有粒子系统在世界空间中模拟时生效）
         */
        var ParticleInheritVelocityModule = /** @class */ (function (_super) {
            __extends(ParticleInheritVelocityModule, _super);
            function ParticleInheritVelocityModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this["__class__"] = "m4m.framework.ParticleInheritVelocityModule";
                /**
                 * How to apply emitter velocity to particles.
                 *
                 * 如何将发射体速度应用于粒子。
                 */
                _this.mode = framework.ParticleSystemInheritVelocityMode.Initial;
                /**
                 * Curve to define how much emitter velocity is applied during the lifetime of a particle.
                 *
                 * 曲线，用来定义在粒子的生命周期内应用了多少发射速度。
                 */
                _this.multiplier = framework.serialization.setValue(new framework.MinMaxCurve(), { constant: 1, constantMin: 1, constantMax: 1 });
                return _this;
            }
            Object.defineProperty(ParticleInheritVelocityModule.prototype, "curve", {
                /**
                 * Curve to define how much emitter velocity is applied during the lifetime of a particle.
                 *
                 * 曲线，用来定义在粒子的生命周期内应用了多少发射速度。
                 */
                get: function () {
                    return this.multiplier;
                },
                set: function (v) {
                    this.multiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleInheritVelocityModule.prototype, "curveMultiplier", {
                /**
                 * Change the curve multiplier.
                 *
                 * 改变曲线的乘数。
                 */
                get: function () {
                    return this.multiplier.curveMultiplier;
                },
                set: function (v) {
                    this.multiplier.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * 初始化粒子状态
             * @param particle 粒子
             */
            ParticleInheritVelocityModule.prototype.initParticleState = function (particle) {
                particle[_InheritVelocity_rate] = Math.random();
                if (!this.enabled)
                    return;
                if (this.particleSystem.main.simulationSpace == framework.ParticleSystemSimulationSpace.Local)
                    return;
                if (this.mode != framework.ParticleSystemInheritVelocityMode.Initial)
                    return;
                var multiplier = this.multiplier.getValue(particle.rateAtLifeTime, particle[_InheritVelocity_rate]);
                particle.velocity.x += multiplier * this.particleSystem.speed.x;
                particle.velocity.y += multiplier * this.particleSystem.speed.y;
                particle.velocity.z += multiplier * this.particleSystem.speed.z;
            };
            /**
             * 更新粒子状态
             * @param particle 粒子
             */
            ParticleInheritVelocityModule.prototype.updateParticleState = function (particle) {
                if (!this.enabled)
                    return;
                if (this.particleSystem.main.simulationSpace == framework.ParticleSystemSimulationSpace.Local)
                    return;
                if (this.mode != framework.ParticleSystemInheritVelocityMode.Current)
                    return;
                var multiplier = this.multiplier.getValue(particle.rateAtLifeTime, particle[_InheritVelocity_rate]);
                particle.position.x += multiplier * this.particleSystem.moveVec.x;
                particle.position.y += multiplier * this.particleSystem.moveVec.y;
                particle.position.z += multiplier * this.particleSystem.moveVec.z;
            };
            return ParticleInheritVelocityModule;
        }(framework.ParticleModule));
        framework.ParticleInheritVelocityModule = ParticleInheritVelocityModule;
        var _InheritVelocity_rate = "_InheritVelocity_rate";
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * Limit Velocity Over Lifetime module.
         *
         * 基于时间轴限制速度模块。
         *
         * @author feng3d
         */
        var ParticleLimitVelocityOverLifetimeModule = /** @class */ (function (_super) {
            __extends(ParticleLimitVelocityOverLifetimeModule, _super);
            function ParticleLimitVelocityOverLifetimeModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * Set the size over lifetime on each axis separately.
                 *
                 * 在每个轴上分别设置生命周期内的大小。
                 */
                _this.separateAxes = false;
                /**
                 * Maximum velocity curve, when not using one curve per axis.
                 *
                 * 最大速度曲线，当不使用每轴一个曲线时。
                 */
                _this.limit = framework.serialization.setValue(new framework.MinMaxCurve(), { between0And1: true, constant: 1, constantMin: 1, constantMax: 1 });
                /**
                 * Maximum velocity.
                 *
                 * 最高速度。
                 */
                _this.limit3D = framework.serialization.setValue(new framework.MinMaxCurveVector3(), { xCurve: { between0And1: true, constant: 1, constantMin: 1, constantMax: 1 }, yCurve: { between0And1: true, constant: 1, constantMin: 1, constantMax: 1 }, zCurve: { between0And1: true, constant: 1, constantMin: 1, constantMax: 1 } });
                /**
                 * Specifies if the velocities are in local space (rotated with the transform) or world space.
                 *
                 * 指定速度是在局部空间(与变换一起旋转)还是在世界空间。
                 */
                _this.space = framework.ParticleSystemSimulationSpace.Local;
                /**
                 * Controls how much the velocity that exceeds the velocity limit should be dampened.
                 *
                 * 控制多少速度，超过速度限制应该被抑制。
                 */
                _this.dampen = 1;
                return _this;
            }
            Object.defineProperty(ParticleLimitVelocityOverLifetimeModule.prototype, "limitMultiplier", {
                /**
                 * Change the limit multiplier.
                 *
                 * 改变限制乘法因子。
                 */
                get: function () {
                    return this.limit.curveMultiplier;
                },
                set: function (v) {
                    this.limit.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleLimitVelocityOverLifetimeModule.prototype, "limitX", {
                /**
                 * Maximum velocity curve for the X axis.
                 *
                 * X轴的最大速度曲线。
                 */
                get: function () {
                    return this.limit3D.xCurve;
                },
                set: function (v) {
                    this.limit3D.xCurve = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleLimitVelocityOverLifetimeModule.prototype, "limitXMultiplier", {
                /**
                 * Change the limit multiplier on the X axis.
                 *
                 * 改变X轴上的极限乘法器。
                 */
                get: function () {
                    return this.limit3D.xCurve.curveMultiplier;
                },
                set: function (v) {
                    this.limit3D.xCurve.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleLimitVelocityOverLifetimeModule.prototype, "limitY", {
                /**
                 * Maximum velocity curve for the Y axis.
                 *
                 * Y轴的最大速度曲线。
                 */
                get: function () {
                    return this.limit3D.yCurve;
                },
                set: function (v) {
                    this.limit3D.yCurve = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleLimitVelocityOverLifetimeModule.prototype, "limitYMultiplier", {
                /**
                 * Change the limit multiplier on the Y axis.
                 *
                 * 改变Y轴上的极限乘法器。
                 */
                get: function () {
                    return this.limit3D.yCurve.curveMultiplier;
                },
                set: function (v) {
                    this.limit3D.yCurve.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleLimitVelocityOverLifetimeModule.prototype, "limitZ", {
                /**
                 * Maximum velocity curve for the Z axis.
                 *
                 * Z轴的最大速度曲线。
                 */
                get: function () {
                    return this.limit3D.zCurve;
                },
                set: function (v) {
                    this.limit3D.zCurve = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleLimitVelocityOverLifetimeModule.prototype, "limitZMultiplier", {
                /**
                 * Change the limit multiplier on the Z axis.
                 *
                 * 更改Z轴上的极限乘法器。
                 */
                get: function () {
                    return this.limit3D.zCurve.curveMultiplier;
                },
                set: function (v) {
                    this.limit3D.zCurve.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * 初始化粒子状态
             *
             * @param particle 粒子
             */
            ParticleLimitVelocityOverLifetimeModule.prototype.initParticleState = function (particle) {
                particle[_LimitVelocityOverLifetime_rate] = Math.random();
            };
            /**
             * 更新粒子状态
             *
             * @param particle 粒子
             */
            ParticleLimitVelocityOverLifetimeModule.prototype.updateParticleState = function (particle) {
                if (!this.enabled)
                    return;
                var limit3D = this.limit3D.getValue(particle.rateAtLifeTime, particle[_LimitVelocityOverLifetime_rate]);
                var limit = this.limit.getValue(particle.rateAtLifeTime, particle[_LimitVelocityOverLifetime_rate]);
                var pVelocity = new m4m.math.vector3();
                m4m.math.vec3Clone(particle.velocity, pVelocity);
                // 计算变换矩阵
                var mat = new m4m.math.matrix();
                //
                if (this.space != this.particleSystem.main.simulationSpace) {
                    if (this.space == framework.ParticleSystemSimulationSpace.World) {
                        m4m.math.matrixClone(this.particleSystem.localToWorldMatrix, mat);
                    }
                    else {
                        m4m.math.matrixClone(this.particleSystem.worldToLocalMatrix, mat);
                    }
                }
                // 变换到现在空间进行限速
                m4m.math.matrixTransformNormal(pVelocity, mat, pVelocity);
                if (this.separateAxes) {
                    pVelocity.x = m4m.math.floatClamp(pVelocity.x, -limit3D.x, limit3D.x);
                    pVelocity.y = m4m.math.floatClamp(pVelocity.y, -limit3D.y, limit3D.y);
                    pVelocity.z = m4m.math.floatClamp(pVelocity.z, -limit3D.z, limit3D.z);
                }
                else {
                    if (m4m.math.vec3SqrLength(pVelocity) > limit * limit) {
                        m4m.math.vec3Normalize(pVelocity, pVelocity);
                        m4m.math.vec3ScaleByNum(pVelocity, limit, pVelocity);
                    }
                }
                m4m.math.matrixInverse(mat, mat);
                // 还原到原空间
                m4m.math.matrixTransformNormal(pVelocity, mat, pVelocity);
                // 
                m4m.math.vec3SLerp(particle.velocity, pVelocity, this.dampen, particle.velocity);
            };
            return ParticleLimitVelocityOverLifetimeModule;
        }(framework.ParticleModule));
        framework.ParticleLimitVelocityOverLifetimeModule = ParticleLimitVelocityOverLifetimeModule;
        var _LimitVelocityOverLifetime_rate = "_LimitVelocityOverLifetime_rate";
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * 粒子主模块
         *
         * @author feng3d
         */
        var ParticleMainModule = /** @class */ (function (_super) {
            __extends(ParticleMainModule, _super);
            function ParticleMainModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.enabled = true;
                /**
                 * 粒子系统的持续时间(秒)。
                 */
                _this.duration = 5;
                /**
                 * 粒子系统在循环吗?
                 */
                _this.loop = true;
                /**
                 * When looping is enabled, this controls whether this particle system will look like it has already simulated for one loop when first becoming visible.
                 *
                 * 当循环被激活时，它控制这个粒子系统在第一次出现时是否看起来像已经模拟了一个循环。
                 */
                _this.prewarm = false;
                /**
                 * Start delay in seconds.
                 *
                 * 启动延迟(以秒为单位)。
                 */
                _this.startDelay = new framework.MinMaxCurve();
                /**
                 * The total lifetime in seconds that each new particle will have.
                 *
                 * 每个新粒子的总寿命(以秒计)。
                 */
                _this.startLifetime = framework.serialization.setValue(new framework.MinMaxCurve(), { between0And1: true, constant: 5, constantMin: 5, constantMax: 5 });
                /**
                 * The initial speed of particles when emitted.
                 *
                 * 粒子发射时的初始速度。
                 */
                _this.startSpeed = framework.serialization.setValue(new framework.MinMaxCurve(), { constant: 5, constantMin: 5, constantMax: 5 });
                /**
                 * A flag to enable specifying particle size individually for each axis.
                 *
                 * 允许为每个轴分别指定粒度大小的标志。
                 */
                _this.useStartSize3D = false;
                /**
                 * The initial size of particles when emitted.
                 *
                 * 发射时粒子的初始大小。
                 */
                _this.startSize3D = framework.serialization.setValue(new framework.MinMaxCurveVector3(), { xCurve: { between0And1: true, constant: 1, constantMin: 1, constantMax: 1 }, yCurve: { between0And1: true, constant: 1, constantMin: 1, constantMax: 1 }, zCurve: { between0And1: true, constant: 1, constantMin: 1, constantMax: 1 } });
                /**
                 * A flag to enable 3D particle rotation.
                 * 一个启用粒子3D旋转的标记。
                 */
                _this.useStartRotation3D = false;
                /**
                 * The initial rotation of particles when emitted.
                 *
                 * 粒子发射时的初始旋转。
                 */
                _this.startRotation3D = framework.serialization.setValue(new framework.MinMaxCurveVector3(), { xCurve: { curveMultiplier: 180 }, yCurve: { curveMultiplier: 180 }, zCurve: { curveMultiplier: 180 } });
                /**
                 * Cause some particles to spin in the opposite direction. Set between 0 and 1, where higher values will cause a higher proportion of particles to spin in the opposite direction.
                 *
                 * 导致一些粒子向相反的方向旋转。设置在0和1之间，数值越大，粒子朝相反方向旋转的比例越大。
                 */
                _this.randomizeRotationDirection = 0;
                /**
                 * The initial color of particles when emitted.
                 *
                 * 粒子发射时的初始颜色。
                 */
                _this.startColor = new framework.MinMaxGradient();
                /**
                 * Scale applied to the gravity.
                 *
                 * 应用于重力加速度的缩放。
                 */
                _this.gravityModifier = new framework.MinMaxCurve();
                _this._simulationSpace = framework.ParticleSystemSimulationSpace.Local;
                /**
                 * Override the default playback speed of the Particle System.
                 *
                 * 重写粒子系统的默认播放速度。
                 */
                _this.simulationSpeed = 1;
                /**
                 * Control how the particle system's Transform Component is applied to the particle system.
                 *
                 * 控制粒子系统的变换组件如何应用于粒子系统。
                 */
                _this.scalingMode = framework.ParticleSystemScalingMode.Local;
                /**
                 * If set to true, the particle system will automatically start playing on startup.
                 *
                 * 如果设置为真，粒子系统将自动开始播放启动。
                 */
                _this.playOnAwake = true;
                /**
                 * The maximum number of particles to emit.
                 *
                 * 发射粒子的最大数量。
                 */
                _this.maxParticles = 1000;
                return _this;
            }
            Object.defineProperty(ParticleMainModule.prototype, "startDelayMultiplier", {
                /**
                 * Start delay multiplier in seconds.
                 *
                 * 启动延迟乘数(以秒为单位)。
                 */
                get: function () {
                    return this.startDelay.curveMultiplier;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleMainModule.prototype, "startLifetimeMultiplier", {
                /**
                 * Start lifetime multiplier.
                 * This method is more efficient than accessing the whole curve, if you only want to change the overall lifetime multiplier.
                 *
                 * 起始寿命乘数。
                 * 如果您只想更改总体寿命乘数，则此方法比访问整个曲线更有效。
                 */
                get: function () {
                    return this.startLifetime.curveMultiplier;
                },
                set: function (v) {
                    this.startLifetime.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleMainModule.prototype, "startSpeedMultiplier", {
                /**
                 * A multiplier of the initial speed of particles when emitted.
                 * This method is more efficient than accessing the whole curve, if you only want to change the overall speed multiplier.
                 *
                 * 粒子发射时的初始速度的乘子。
                 * 这种方法比访问整个曲线更有效，如果你只想改变整体速度乘数。
                 */
                get: function () {
                    return this.startSpeed.curveMultiplier;
                },
                set: function (v) {
                    this.startSpeed.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleMainModule.prototype, "startSize", {
                /**
                 * The initial size of particles when emitted.
                 *
                 * 粒子发射时的初始大小。
                 */
                get: function () {
                    return this.startSize3D.xCurve;
                },
                set: function (v) {
                    this.startSize3D.xCurve = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleMainModule.prototype, "startSizeMultiplier", {
                /**
                 * Start size multiplier.
                 * This method is more efficient than accessing the whole curve, if you only want to change the overall size multiplier.
                 *
                 * 开始尺寸乘数。
                 * 如果您只想更改整体尺寸倍增器，则此方法比访问整个曲线更有效。
                 */
                get: function () {
                    return this.startSize.curveMultiplier;
                },
                set: function (v) {
                    this.startSize.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleMainModule.prototype, "startSizeX", {
                /**
                 * The initial size of particles along the X axis when emitted.
                 *
                 * 发射时沿X轴的粒子的初始大小。
                 */
                get: function () {
                    return this.startSize3D.xCurve;
                },
                set: function (v) {
                    this.startSize3D.xCurve = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleMainModule.prototype, "startSizeXMultiplier", {
                /**
                 * Start rotation multiplier along the X axis.
                 * This method is more efficient than accessing the whole curve, if you only want to change the overall size multiplier.
                 *
                 * 启动旋转乘法器沿X轴。
                 * 如果您只想更改整体大小倍增器，则此方法比访问整个曲线更有效。
                 */
                get: function () {
                    return this.startSizeX.curveMultiplier;
                },
                set: function (v) {
                    this.startSizeX.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleMainModule.prototype, "startSizeY", {
                /**
                 * The initial size of particles along the Y axis when emitted.
                 *
                 * 发射时沿Y轴的粒子的初始大小。
                 */
                get: function () {
                    return this.startSize3D.yCurve;
                },
                set: function (v) {
                    this.startSize3D.yCurve = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleMainModule.prototype, "startSizeYMultiplier", {
                /**
                 * Start rotation multiplier along the Y axis.
                 * This method is more efficient than accessing the whole curve, if you only want to change the overall size multiplier.
                 *
                 * 启动旋转乘法器沿Y轴。
                 * 如果您只想更改整体大小倍增器，则此方法比访问整个曲线更有效。
                 */
                get: function () {
                    return this.startSizeY.curveMultiplier;
                },
                set: function (v) {
                    this.startSizeY.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleMainModule.prototype, "startSizeZ", {
                /**
                 * The initial size of particles along the Z axis when emitted.
                 *
                 * 发射时沿Z轴的粒子的初始大小。
                 */
                get: function () {
                    return this.startSize3D.zCurve;
                },
                set: function (v) {
                    this.startSize3D.zCurve = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleMainModule.prototype, "startSizeZMultiplier", {
                /**
                 * Start rotation multiplier along the Z axis.
                 * This method is more efficient than accessing the whole curve, if you only want to change the overall size multiplier.
                 *
                 * 启动旋转乘法器沿Z轴。
                 * 如果您只想更改整体大小倍增器，则此方法比访问整个曲线更有效。
                 */
                get: function () {
                    return this.startSizeZ.curveMultiplier;
                },
                set: function (v) {
                    this.startSizeZ.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleMainModule.prototype, "startRotation", {
                /**
                 * The initial rotation of particles when emitted.
                 * 粒子发射时的初始旋转。
                 */
                get: function () {
                    return this.startRotation3D.zCurve;
                },
                set: function (v) {
                    this.startRotation3D.zCurve = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleMainModule.prototype, "startRotationMultiplier", {
                /**
                 * Start rotation multiplier.
                 * This method is more efficient than accessing the whole curve, if you only want to change the overall rotation multiplier.
                 *
                 * 开始旋转乘数。
                 * 这种方法比访问整个曲线更有效，如果你只想改变整体旋转乘数。
                 */
                get: function () {
                    return this.startRotation.curveMultiplier;
                },
                set: function (v) {
                    this.startRotation.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleMainModule.prototype, "startRotationX", {
                /**
                 * The initial rotation of particles around the X axis when emitted.
                 *
                 * 发射时粒子围绕X轴的初始旋转。
                 */
                get: function () {
                    return this.startRotation3D.xCurve;
                },
                set: function (v) {
                    this.startRotation3D.xCurve = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleMainModule.prototype, "startRotationXMultiplier", {
                /**
                 * Start rotation multiplier around the X axis.
                 * This method is more efficient than accessing the whole curve, if you only want to change the overall rotation multiplier.
                 *
                 * 开始绕X轴旋转乘法器。
                 * 这种方法比访问整个曲线更有效，如果你只想改变整体旋转乘数。
                 */
                get: function () {
                    return this.startRotationX.curveMultiplier;
                },
                set: function (v) {
                    this.startRotationX.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleMainModule.prototype, "startRotationY", {
                /**
                 * The initial rotation of particles around the Y axis when emitted.
                 *
                 * 发射时粒子围绕Y轴的初始旋转。
                 */
                get: function () {
                    return this.startRotation3D.yCurve;
                },
                set: function (v) {
                    this.startRotation3D.yCurve = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleMainModule.prototype, "startRotationYMultiplier", {
                /**
                 * Start rotation multiplier around the Y axis.
                 * This method is more efficient than accessing the whole curve, if you only want to change the overall rotation multiplier.
                 *
                 * 开始绕Y轴旋转乘法器。
                 * 这种方法比访问整个曲线更有效，如果你只想改变整体旋转乘数。
                 */
                get: function () {
                    return this.startRotationY.curveMultiplier;
                },
                set: function (v) {
                    this.startRotationY.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleMainModule.prototype, "startRotationZ", {
                /**
                 * The initial rotation of particles around the Z axis when emitted.
                 *
                 * 发射时粒子围绕Z轴的初始旋转。
                 */
                get: function () {
                    return this.startRotation3D.zCurve;
                },
                set: function (v) {
                    this.startRotation3D.zCurve = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleMainModule.prototype, "startRotationZMultiplier", {
                /**
                 * Start rotation multiplier around the Z axis.
                 * This method is more efficient than accessing the whole curve, if you only want to change the overall rotation multiplier.
                 *
                 * 开始绕Z轴旋转乘法器。
                 * 这种方法比访问整个曲线更有效，如果你只想改变整体旋转乘数。
                 */
                get: function () {
                    return this.startRotationZ.curveMultiplier;
                },
                set: function (v) {
                    this.startRotationZ.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleMainModule.prototype, "simulationSpace", {
                /**
                 * This selects the space in which to simulate particles. It can be either world or local space.
                 *
                 * 模拟空间，使粒子位置模拟在世界，本地或自定义空间。在本地空间中，它们相对于自己的转换而存在，在自定义空间中，它们相对于自定义转换。
                 *
                 * @todo
                 */
                get: function () {
                    return this._simulationSpace;
                },
                set: function (v) {
                    if (this._simulationSpace != v) {
                        this._simulationSpace = v;
                        this.particleSystem._simulationSpaceChanged();
                    }
                },
                enumerable: false,
                configurable: true
            });
            /**
             * 初始化粒子状态
             * @param particle 粒子
             */
            ParticleMainModule.prototype.initParticleState = function (particle) {
                //
                var birthRateAtDuration = particle.birthRateAtDuration;
                particle.velocity.x = 0;
                particle.velocity.y = 0;
                particle.velocity.z = 0;
                particle.acceleration.x = 0;
                particle.acceleration.y = 0;
                particle.acceleration.z = 0;
                if (this.useStartSize3D) {
                    m4m.math.vec3Clone(this.startSize3D.getValue(birthRateAtDuration), particle.startSize);
                }
                else {
                    var startSize = this.startSize.getValue(birthRateAtDuration);
                    particle.startSize.x = startSize;
                    particle.startSize.y = startSize;
                    particle.startSize.z = startSize;
                }
                //
                if (this.useStartRotation3D) {
                    m4m.math.vec3Clone(this.startRotation3D.getValue(birthRateAtDuration), particle.rotation);
                }
                else {
                    var startRotation = this.startRotation.getValue(birthRateAtDuration);
                    particle.rotation.x = 0;
                    particle.rotation.y = 0;
                    particle.rotation.z = startRotation;
                }
                particle.angularVelocity.x = 0;
                particle.angularVelocity.y = 0;
                particle.angularVelocity.z = 0;
                //
                m4m.math.colorClone(this.startColor.getValue(birthRateAtDuration), particle.startColor);
            };
            /**
             * 更新粒子状态
             * @param particle 粒子
             */
            ParticleMainModule.prototype.updateParticleState = function (particle) {
                // 加速度
                var gravity = new m4m.math.vector3(world_gravity.x, world_gravity.y, world_gravity.z);
                m4m.math.vec3ScaleByNum(gravity, this.gravityModifier.getValue(this.particleSystem.rateAtDuration), gravity);
                this.particleSystem.addParticleAcceleration(particle, gravity, framework.ParticleSystemSimulationSpace.World, _Main_preGravity);
                //
                m4m.math.vec3Clone(particle.startSize, particle.size);
                m4m.math.colorClone(particle.startColor, particle.color);
            };
            return ParticleMainModule;
        }(framework.ParticleModule));
        framework.ParticleMainModule = ParticleMainModule;
        var world_gravity = new m4m.math.vector3(0, -9.8, 0);
        var _Main_preGravity = "_Main_preGravity";
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * Script interface for the Noise Module.
         *
         * The Noise Module allows you to apply turbulence to the movement of your particles. Use the low quality settings to create computationally efficient Noise, or simulate smoother, richer Noise with the higher quality settings. You can also choose to define the behavior of the Noise individually for each axis.
         *
         * 噪声模块
         *
         * 噪声模块允许你将湍流应用到粒子的运动中。使用低质量设置来创建计算效率高的噪声，或者使用高质量设置来模拟更平滑、更丰富的噪声。您还可以选择为每个轴分别定义噪声的行为。
         */
        var ParticleNoiseModule = /** @class */ (function (_super) {
            __extends(ParticleNoiseModule, _super);
            function ParticleNoiseModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * Control the noise separately for each axis.
                 *
                 * 分别控制每个轴的噪声。
                 */
                _this.separateAxes = false;
                /**
                 * How strong the overall noise effect is.
                 *
                 * 整体噪音效应有多强。
                 */
                _this.strength3D = framework.serialization.setValue(new framework.MinMaxCurveVector3(), { xCurve: { between0And1: true, constant: 1, constantMin: 1, constantMax: 1, curveMultiplier: 1 }, yCurve: { between0And1: true, constant: 1, constantMin: 1, constantMax: 1, curveMultiplier: 1 }, zCurve: { between0And1: true, constant: 1, constantMin: 1, constantMax: 1, curveMultiplier: 1 } });
                /**
                 * Low values create soft, smooth noise, and high values create rapidly changing noise.
                 *
                 * 低值产生柔和、平滑的噪声，高值产生快速变化的噪声。
                 */
                _this.frequency = 0.5;
                /**
                 * Scroll the noise map over the particle system.
                 *
                 * 在粒子系统上滚动噪声图。
                 */
                _this.scrollSpeed = new framework.MinMaxCurve();
                /**
                 * Higher frequency noise will reduce the strength by a proportional amount, if enabled.
                 *
                 * 如果启用高频率噪音，将按比例减少强度。
                 */
                _this.damping = true;
                /**
                 * Layers of noise that combine to produce final noise.
                 *
                 * 一层一层的噪声组合在一起产生最终的噪声。
                 */
                _this.octaveCount = 1;
                /**
                 * When combining each octave, scale the intensity by this amount.
                 *
                 * 当组合每个八度时，按这个比例调整强度。
                 */
                _this.octaveMultiplier = 0.5;
                /**
                 * When combining each octave, zoom in by this amount.
                 *
                 * 当组合每个八度时，放大这个数字。
                 */
                _this.octaveScale = 2;
                /**
                 * Generate 1D, 2D or 3D noise.
                 *
                 * 生成一维、二维或三维噪声。
                 */
                _this.quality = framework.ParticleSystemNoiseQuality.High;
                /**
                 * Enable remapping of the final noise values, allowing for noise values to be translated into different values.
                 *
                 * 允许重新映射最终的噪声值，允许将噪声值转换为不同的值。
                 */
                _this.remapEnabled = false;
                /**
                 * Define how the noise values are remapped.
                 *
                 * 定义如何重新映射噪声值。
                 */
                _this.remap3D = framework.serialization.setValue(new framework.MinMaxCurveVector3(), {
                    xCurve: { between0And1: true, constant: 1, constantMin: 1, constantMax: 1, curveMultiplier: 1 },
                    yCurve: { between0And1: true, constant: 1, constantMin: 1, constantMax: 1, curveMultiplier: 1 },
                    zCurve: { between0And1: true, constant: 1, constantMin: 1, constantMax: 1, curveMultiplier: 1 }
                });
                _this._scrollValue = 0;
                return _this;
            }
            Object.defineProperty(ParticleNoiseModule.prototype, "strength", {
                /**
                 * How strong the overall noise effect is.
                 *
                 * 整体噪音效应有多强。
                 */
                get: function () {
                    return this.strength3D.xCurve;
                },
                set: function (v) {
                    this.strength3D.xCurve = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleNoiseModule.prototype, "strengthX", {
                /**
                 * Define the strength of the effect on the X axis, when using separateAxes option.
                 *
                 * 在使用分别控制每个轴时，在X轴上定义效果的强度。
                 */
                get: function () {
                    return this.strength3D.xCurve;
                },
                set: function (v) {
                    this.strength3D.xCurve = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleNoiseModule.prototype, "strengthY", {
                /**
                 * Define the strength of the effect on the Y axis, when using separateAxes option.
                 *
                 * 在使用分别控制每个轴时，在Y轴上定义效果的强度。
                 */
                get: function () {
                    return this.strength3D.yCurve;
                },
                set: function (v) {
                    this.strength3D.yCurve = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleNoiseModule.prototype, "strengthZ", {
                /**
                 * Define the strength of the effect on the Z axis, when using separateAxes option.
                 *
                 * 在使用分别控制每个轴时，在Z轴上定义效果的强度。
                 */
                get: function () {
                    return this.strength3D.zCurve;
                },
                set: function (v) {
                    this.strength3D.zCurve = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleNoiseModule.prototype, "remap", {
                /**
                 * Define how the noise values are remapped.
                 *
                 * 定义如何重新映射噪声值。
                 */
                get: function () {
                    return this.remap3D.xCurve;
                },
                set: function (v) {
                    this.remap3D.xCurve = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleNoiseModule.prototype, "remapX", {
                /**
                 * Define how the noise values are remapped on the X axis, when using the ParticleSystem.NoiseModule.separateAxes option.
                 *
                 * 在使用分别控制每个轴时，如何在X轴上重新映射噪声值。
                 */
                get: function () {
                    return this.remap3D.xCurve;
                },
                set: function (v) {
                    this.remap3D.xCurve = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleNoiseModule.prototype, "remapY", {
                /**
                 * Define how the noise values are remapped on the Y axis, when using the ParticleSystem.NoiseModule.separateAxes option.
                 *
                 * 在使用分别控制每个轴时，如何在Y轴上重新映射噪声值。
                 */
                get: function () {
                    return this.remap3D.yCurve;
                },
                set: function (v) {
                    this.remap3D.yCurve = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleNoiseModule.prototype, "remapZ", {
                /**
                 * Define how the noise values are remapped on the Z axis, when using the ParticleSystem.NoiseModule.separateAxes option.
                 *
                 * 在使用分别控制每个轴时，如何在Z轴上重新映射噪声值。
                 */
                get: function () {
                    return this.remap3D.zCurve;
                },
                set: function (v) {
                    this.remap3D.zCurve = v;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * 初始化粒子状态
             * @param particle 粒子
             */
            ParticleNoiseModule.prototype.initParticleState = function (particle) {
                particle[_Noise_strength_rate] = Math.random();
                particle[_Noise_particle_rate] = Math.random();
            };
            /**
             * 更新粒子状态
             * @param particle 粒子
             */
            ParticleNoiseModule.prototype.updateParticleState = function (particle) {
                this.particleSystem.removeParticlePosition(particle, _Noise_preOffset);
                if (!this.enabled)
                    return;
                var strengthX = 1;
                var strengthY = 1;
                var strengthZ = 1;
                if (this.separateAxes) {
                    var strength3D = this.strength3D.getValue(particle.rateAtLifeTime, particle[_Noise_strength_rate]);
                    strengthX = strength3D.x;
                    strengthY = strength3D.y;
                    strengthZ = strength3D.z;
                }
                else {
                    strengthX = strengthY = strengthZ = this.strength.getValue(particle.rateAtLifeTime, particle[_Noise_strength_rate]);
                }
                //
                var frequency = ParticleNoiseModule._frequencyScale * this.frequency;
                //
                var offsetPos = new m4m.math.vector3(strengthX, strengthY, strengthZ);
                //
                offsetPos.x *= ParticleNoiseModule._strengthScale;
                offsetPos.y *= ParticleNoiseModule._strengthScale;
                offsetPos.z *= ParticleNoiseModule._strengthScale;
                if (this.damping) {
                    offsetPos.x = offsetPos.x / this.frequency;
                    offsetPos.y = offsetPos.y / this.frequency;
                    offsetPos.z = offsetPos.z / this.frequency;
                }
                var time = particle.rateAtLifeTime * ParticleNoiseModule._timeScale % 1;
                //
                offsetPos.x *= this._getNoiseValue((1 / 3 * 0 + time) * frequency, particle[_Noise_particle_rate] * frequency);
                offsetPos.y *= this._getNoiseValue((1 / 3 * 1 + time) * frequency, particle[_Noise_particle_rate] * frequency);
                offsetPos.z *= this._getNoiseValue((1 / 3 * 2 + time) * frequency, particle[_Noise_particle_rate] * frequency);
                //
                this.particleSystem.addParticlePosition(particle, offsetPos, this.particleSystem.main.simulationSpace, _Noise_preOffset);
            };
            /**
             * 绘制噪音到图片
             *
             * @param image 图片数据
             */
            ParticleNoiseModule.prototype.drawImage = function (image) {
                var strength = this._getDrawImageStrength();
                var strengthX = strength.x;
                var strengthY = strength.y;
                var strengthZ = strength.z;
                //
                strengthX *= ParticleNoiseModule._strengthScale;
                strengthY *= ParticleNoiseModule._strengthScale;
                strengthZ *= ParticleNoiseModule._strengthScale;
                if (this.damping) {
                    strengthX /= this.frequency;
                    strengthY /= this.frequency;
                    strengthZ /= this.frequency;
                }
                //
                var frequency = ParticleNoiseModule._frequencyScale * this.frequency;
                //
                var data = image.data;
                var imageWidth = image.width;
                var imageHeight = image.height;
                // var datas: number[] = [];
                // var min = Number.MAX_VALUE;
                // var max = Number.MIN_VALUE;
                for (var x = 0; x < imageWidth; x++) {
                    for (var y = 0; y < imageHeight; y++) {
                        var xv = x / imageWidth * frequency;
                        var yv = 1 - y / imageHeight * frequency;
                        var value = this._getNoiseValue(xv, yv);
                        // datas.push(value);
                        // if (min > value) min = value;
                        // if (max < value) max = value;
                        if (xv < 1 / 3)
                            value = (value * strengthX + 1) / 2 * 256;
                        else if (xv < 2 / 3)
                            value = (value * strengthY + 1) / 2 * 256;
                        else
                            value = (value * strengthZ + 1) / 2 * 256;
                        var cell = (x + y * imageWidth) * 4;
                        data[cell] = data[cell + 1] = data[cell + 2] = Math.floor(value);
                        data[cell + 3] = 255; // alpha
                    }
                }
                // console.log(datas, min, max);
            };
            ParticleNoiseModule.prototype._getDrawImageStrength = function () {
                var strengthX = 1;
                var strengthY = 1;
                var strengthZ = 1;
                if (this.separateAxes) {
                    if (this.strengthX.mode == framework.MinMaxCurveMode.Curve || this.strengthX.mode == framework.MinMaxCurveMode.TwoCurves)
                        strengthX = this.strengthX.curveMultiplier;
                    else if (this.strengthX.mode == framework.MinMaxCurveMode.Constant)
                        strengthX = this.strengthX.constant;
                    else if (this.strengthX.mode == framework.MinMaxCurveMode.TwoConstants)
                        strengthX = this.strengthX.constantMax;
                    if (this.strengthY.mode == framework.MinMaxCurveMode.Curve || this.strengthY.mode == framework.MinMaxCurveMode.TwoCurves)
                        strengthY = this.strengthY.curveMultiplier;
                    else if (this.strengthY.mode == framework.MinMaxCurveMode.Constant)
                        strengthY = this.strengthY.constant;
                    else if (this.strengthY.mode == framework.MinMaxCurveMode.TwoConstants)
                        strengthY = this.strengthY.constantMax;
                    if (this.strengthZ.mode == framework.MinMaxCurveMode.Curve || this.strengthZ.mode == framework.MinMaxCurveMode.TwoCurves)
                        strengthZ = this.strengthZ.curveMultiplier;
                    else if (this.strengthZ.mode == framework.MinMaxCurveMode.Constant)
                        strengthZ = this.strengthZ.constant;
                    else if (this.strengthZ.mode == framework.MinMaxCurveMode.TwoConstants)
                        strengthZ = this.strengthZ.constantMax;
                }
                else {
                    if (this.strength.mode == framework.MinMaxCurveMode.Curve || this.strength.mode == framework.MinMaxCurveMode.TwoCurves)
                        strengthX = strengthY = strengthZ = this.strength.curveMultiplier;
                    else if (this.strength.mode == framework.MinMaxCurveMode.Constant)
                        strengthX = strengthY = strengthZ = this.strength.constant;
                    else if (this.strength.mode == framework.MinMaxCurveMode.TwoConstants)
                        strengthX = strengthY = strengthZ = this.strength.constantMax;
                }
                return { x: strengthX, y: strengthY, z: strengthZ };
            };
            /**
             * 获取噪音值
             *
             * @param x
             * @param y
             */
            ParticleNoiseModule.prototype._getNoiseValue = function (x, y) {
                var value = this._getNoiseValueBase(x, y);
                for (var l = 1, ln = this.octaveCount; l < ln; l++) {
                    var value0 = this._getNoiseValueBase(x * this.octaveScale, y * this.octaveScale);
                    value += (value0 - value) * this.octaveMultiplier;
                }
                return value;
            };
            /**
             * 获取单层噪音值
             *
             * @param x
             * @param y
             */
            ParticleNoiseModule.prototype._getNoiseValueBase = function (x, y) {
                var scrollValue = this._scrollValue;
                if (this.quality == framework.ParticleSystemNoiseQuality.Low) {
                    return framework.noise.perlin1(x + scrollValue);
                }
                if (this.quality == framework.ParticleSystemNoiseQuality.Medium) {
                    return framework.noise.perlin2(x, y + scrollValue);
                }
                // if (this.quality == ParticleSystemNoiseQuality.High)
                return framework.noise.perlin3(x, y, scrollValue);
            };
            /**
             * 更新
             *
             * @param interval
             */
            ParticleNoiseModule.prototype.update = function (interval) {
                this._scrollValue += this.scrollSpeed.getValue(this.particleSystem.rateAtDuration) * interval / 1000;
            };
            // 以下两个值用于与Unity中数据接近
            ParticleNoiseModule._frequencyScale = 5;
            ParticleNoiseModule._strengthScale = 0.3;
            ParticleNoiseModule._timeScale = 5;
            return ParticleNoiseModule;
        }(framework.ParticleModule));
        framework.ParticleNoiseModule = ParticleNoiseModule;
        var _Noise_strength_rate = "_Noise_strength_rate";
        var _Noise_particle_rate = "_Noise_particle_rate";
        var _Noise_preOffset = "_Noise_preOffset";
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="ParticleModule.ts" />
var m4m;
/// <reference path="ParticleModule.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * 粒子系统 旋转角度随速度变化模块
         */
        var ParticleRotationBySpeedModule = /** @class */ (function (_super) {
            __extends(ParticleRotationBySpeedModule, _super);
            function ParticleRotationBySpeedModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * Set the rotation by speed on each axis separately.
                 * 在每个轴上分别设置随速度变化的旋转。
                 */
                _this.separateAxes = false;
                /**
                 * 角速度，随速度变化的旋转。
                 */
                _this.angularVelocity = framework.serialization.setValue(new framework.MinMaxCurveVector3(), { xCurve: { constant: 45, constantMin: 45, constantMax: 45, curveMultiplier: 45 }, yCurve: { constant: 45, constantMin: 45, constantMax: 45, curveMultiplier: 45 }, zCurve: { constant: 45, constantMin: 45, constantMax: 45, curveMultiplier: 45 } });
                /**
                 * Apply the rotation curve between these minimum and maximum speeds.
                 *
                 * 在这些最小和最大速度之间应用旋转曲线。
                 */
                _this.range = new m4m.math.vector2(0, 1);
                return _this;
            }
            Object.defineProperty(ParticleRotationBySpeedModule.prototype, "x", {
                /**
                 * Rotation by speed curve for the X axis.
                 *
                 * X轴的旋转随速度变化曲线。
                 */
                get: function () {
                    return this.angularVelocity.xCurve;
                },
                set: function (v) {
                    this.angularVelocity.xCurve = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleRotationBySpeedModule.prototype, "xMultiplier", {
                /**
                 * Rotation multiplier around the X axis.
                 *
                 * 绕X轴旋转乘法器
                 */
                get: function () {
                    return this.x.curveMultiplier;
                },
                set: function (v) {
                    this.x.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleRotationBySpeedModule.prototype, "y", {
                /**
                 * Rotation by speed curve for the Y axis.
                 *
                 * Y轴的旋转随速度变化曲线。
                 */
                get: function () {
                    return this.angularVelocity.yCurve;
                },
                set: function (v) {
                    this.angularVelocity.yCurve = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleRotationBySpeedModule.prototype, "yMultiplier", {
                /**
                 * Rotation multiplier around the Y axis.
                 *
                 * 绕Y轴旋转乘法器
                 */
                get: function () {
                    return this.y.curveMultiplier;
                },
                set: function (v) {
                    this.y.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleRotationBySpeedModule.prototype, "z", {
                /**
                 * Rotation by speed curve for the Z axis.
                 *
                 * Z轴的旋转随速度变化曲线。
                 */
                get: function () {
                    return this.angularVelocity.zCurve;
                },
                set: function (v) {
                    this.angularVelocity.zCurve = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleRotationBySpeedModule.prototype, "zMultiplier", {
                /**
                 * Rotation multiplier around the Z axis.
                 *
                 * 绕Z轴旋转乘法器
                 */
                get: function () {
                    return this.z.curveMultiplier;
                },
                set: function (v) {
                    this.z.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * 初始化粒子状态
             * @param particle 粒子
             */
            ParticleRotationBySpeedModule.prototype.initParticleState = function (particle) {
                particle[_RotationBySpeed_rate] = Math.random();
                particle[_RotationBySpeed_preAngularVelocity] = new m4m.math.vector3();
            };
            /**
             * 更新粒子状态
             * @param particle 粒子
             */
            ParticleRotationBySpeedModule.prototype.updateParticleState = function (particle) {
                var preAngularVelocity = particle[_RotationBySpeed_preAngularVelocity];
                particle.angularVelocity.x -= preAngularVelocity.x;
                particle.angularVelocity.y -= preAngularVelocity.y;
                particle.angularVelocity.z -= preAngularVelocity.z;
                preAngularVelocity.x = 0;
                preAngularVelocity.y = 0;
                preAngularVelocity.z = 0;
                if (!this.enabled)
                    return;
                var velocity = m4m.math.vec3Length(particle.velocity);
                var rate = m4m.math.floatClamp((velocity - this.range.x) / (this.range.y - this.range.x), 0, 1);
                var v = this.angularVelocity.getValue(rate, particle[_RotationBySpeed_rate]);
                if (!this.separateAxes) {
                    v.x = v.y = 0;
                }
                particle.angularVelocity.x += v.x;
                particle.angularVelocity.y += v.y;
                particle.angularVelocity.z += v.z;
                preAngularVelocity.x = v.x;
                preAngularVelocity.y = v.x;
                preAngularVelocity.z = v.x;
            };
            return ParticleRotationBySpeedModule;
        }(framework.ParticleModule));
        framework.ParticleRotationBySpeedModule = ParticleRotationBySpeedModule;
        var _RotationBySpeed_rate = "_RotationBySpeed_rate";
        var _RotationBySpeed_preAngularVelocity = "_RotationBySpeed_preAngularVelocity";
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * 粒子系统 旋转角度随时间变化模块
         *
         * @author feng3d
         */
        var ParticleRotationOverLifetimeModule = /** @class */ (function (_super) {
            __extends(ParticleRotationOverLifetimeModule, _super);
            function ParticleRotationOverLifetimeModule() {
                /**
                 * Set the rotation over lifetime on each axis separately.
                 * 在每个轴上分别设置基于生命周期的旋转。
                 */
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.separateAxes = false;
                /**
                 * 角速度，基于生命周期的旋转。
                 */
                _this.angularVelocity = framework.serialization.setValue(new framework.MinMaxCurveVector3(), { xCurve: { constant: 45, constantMin: 45, constantMax: 45, curveMultiplier: 45 }, yCurve: { constant: 45, constantMin: 45, constantMax: 45, curveMultiplier: 45 }, zCurve: { constant: 45, constantMin: 45, constantMax: 45, curveMultiplier: 45 } });
                return _this;
            }
            Object.defineProperty(ParticleRotationOverLifetimeModule.prototype, "x", {
                /**
                 * Rotation over lifetime curve for the X axis.
                 *
                 * X轴的旋转寿命曲线。
                 */
                get: function () {
                    return this.angularVelocity.xCurve;
                },
                set: function (v) {
                    this.angularVelocity.xCurve = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleRotationOverLifetimeModule.prototype, "xMultiplier", {
                /**
                 * Rotation multiplier around the X axis.
                 *
                 * 绕X轴旋转乘法器
                 */
                get: function () {
                    return this.x.curveMultiplier;
                },
                set: function (v) {
                    this.x.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleRotationOverLifetimeModule.prototype, "y", {
                /**
                 * Rotation over lifetime curve for the Y axis.
                 *
                 * Y轴的旋转寿命曲线。
                 */
                get: function () {
                    return this.angularVelocity.yCurve;
                },
                set: function (v) {
                    this.angularVelocity.yCurve = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleRotationOverLifetimeModule.prototype, "yMultiplier", {
                /**
                 * Rotation multiplier around the Y axis.
                 *
                 * 绕Y轴旋转乘法器
                 */
                get: function () {
                    return this.y.curveMultiplier;
                },
                set: function (v) {
                    this.y.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleRotationOverLifetimeModule.prototype, "z", {
                /**
                 * Rotation over lifetime curve for the Z axis.
                 *
                 * Z轴的旋转寿命曲线。
                 */
                get: function () {
                    return this.angularVelocity.zCurve;
                },
                set: function (v) {
                    this.angularVelocity.zCurve = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleRotationOverLifetimeModule.prototype, "zMultiplier", {
                /**
                 * Rotation multiplier around the Z axis.
                 *
                 * 绕Z轴旋转乘法器
                 */
                get: function () {
                    return this.z.curveMultiplier;
                },
                set: function (v) {
                    this.z.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * 初始化粒子状态
             * @param particle 粒子
             */
            ParticleRotationOverLifetimeModule.prototype.initParticleState = function (particle) {
                particle[_RotationOverLifetime_rate] = Math.random();
                particle[_RotationOverLifetime_preAngularVelocity] = new m4m.math.vector3();
            };
            /**
             * 更新粒子状态
             * @param particle 粒子
             */
            ParticleRotationOverLifetimeModule.prototype.updateParticleState = function (particle) {
                var preAngularVelocity = particle[_RotationOverLifetime_preAngularVelocity];
                particle.angularVelocity.x -= preAngularVelocity.x;
                particle.angularVelocity.y -= preAngularVelocity.y;
                particle.angularVelocity.z -= preAngularVelocity.z;
                preAngularVelocity.x = 0;
                preAngularVelocity.y = 0;
                preAngularVelocity.z = 0;
                if (!this.enabled)
                    return;
                var v = this.angularVelocity.getValue(particle.rateAtLifeTime, particle[_RotationOverLifetime_rate]);
                if (!this.separateAxes) {
                    v.x = v.y = 0;
                }
                particle.angularVelocity.x += v.x;
                particle.angularVelocity.y += v.y;
                particle.angularVelocity.z += v.z;
                preAngularVelocity.x = v.x;
                preAngularVelocity.y = v.y;
                preAngularVelocity.z = v.z;
            };
            return ParticleRotationOverLifetimeModule;
        }(framework.ParticleModule));
        framework.ParticleRotationOverLifetimeModule = ParticleRotationOverLifetimeModule;
        var _RotationOverLifetime_rate = "_RotationOverLifetime_rate";
        var _RotationOverLifetime_preAngularVelocity = "_RotationOverLifetime_preAngularVelocity";
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * Shape of the emitter volume, which controls where particles are emitted and their initial direction.
         * 发射体体积的形状，它控制粒子发射的位置和初始方向。
         *
         * @author feng3d
         */
        var ParticleShapeModule = /** @class */ (function (_super) {
            __extends(ParticleShapeModule, _super);
            function ParticleShapeModule() {
                var _this = _super.call(this) || this;
                /**
                 * Align particles based on their initial direction of travel.
                 * 根据粒子的初始运动方向排列粒子。
                 *
                 * Using align to Direction in the Shape module forces the system to be rendered using Local Billboard Alignment.
                 * 在形状模块中使用align to Direction迫使系统使用本地看板对齐方式呈现。
                 */
                _this.alignToDirection = false;
                /**
                 * Randomizes the starting direction of particles.
                 * 随机化粒子的起始方向。
                 */
                _this.randomDirectionAmount = 0;
                /**
                 * Spherizes the starting direction of particles.
                 * 使粒子的起始方向球面化。
                 */
                _this.sphericalDirectionAmount = 0;
                /**
                 * Angle of the cone.
                 *
                 * 圆锥的角度。
                 */
                _this.angle = 25;
                /**
                 * Circle arc angle.
                 *
                 * 圆弧角。
                 */
                _this.arc = 360;
                /**
                 * The mode used for generating particles around the arc.
                 *
                 * 在弧线周围产生粒子的模式。
                 */
                _this.arcMode = framework.ParticleSystemShapeMultiModeValue.Random;
                /**
                 * When using one of the animated modes, how quickly to move the emission position around the arc.
                 *
                 * 当使用一个动画模式时，如何快速移动发射位置周围的弧。
                 */
                _this.arcSpeed = framework.serialization.setValue(new framework.MinMaxCurve(), { constant: 1, constantMin: 1, constantMax: 1 });
                /**
                 * Control the gap between emission points around the arc.
                 *
                 * 控制弧线周围发射点之间的间隙。
                 */
                _this.arcSpread = 0;
                /**
                 * Scale of the box.
                 *
                 * 盒子的缩放。
                 */
                _this.box = new m4m.math.vector3(1, 1, 1);
                /**
                 * Length of the cone.
                 *
                 * 圆锥的长度（高度）。
                 */
                _this.length = 5;
                /**
                 * Apply a scaling factor to the mesh used for generating source positions.
                 *
                 * 对用于生成源位置的网格应用缩放因子。
                 *
                 * @todo
                 */
                _this.meshScale = 1;
                /**
                 * Where on the mesh to emit particles from.
                 *
                 * 从网格的什么地方发射粒子。
                 *
                 * @todo
                 */
                _this.meshShapeType = framework.ParticleSystemMeshShapeType.Vertex;
                /**
                 * Modulate the particle colors with the vertex colors, or the material color if no vertex colors exist.
                 *
                 * 用顶点颜色调节粒子颜色，如果没有顶点颜色，则调节材质颜色。
                 *
                 * @todo
                 */
                _this.useMeshColors = true;
                /**
                 * Move particles away from the surface of the source mesh.
                 *
                 * 将粒子从源网格的表面移开。
                 */
                _this.normalOffset = 0;
                /**
                 * Radius of the shape.
                 *
                 * 形状的半径。
                 */
                _this.radius = 1;
                /**
                 * The mode used for generating particles around the radius.
                 *
                 * 在弧线周围产生粒子的模式。
                 */
                _this.radiusMode = framework.ParticleSystemShapeMultiModeValue.Random;
                /**
                 * When using one of the animated modes, how quickly to move the emission position along the radius.
                 *
                 * 当使用一个动画模式时，如何快速移动发射位置周围的弧。
                 */
                _this.radiusSpeed = framework.serialization.setValue(new framework.MinMaxCurve(), { constant: 1, constantMin: 1, constantMax: 1 });
                /**
                 * Control the gap between emission points around the radius.
                 *
                 * 控制弧线周围发射点之间的间隙。
                 */
                _this.radiusSpread = 0;
                _this._shapeSphere = new framework.ParticleSystemShapeSphere(_this);
                _this._shapeHemisphere = new framework.ParticleSystemShapeHemisphere(_this);
                _this._shapeCone = new framework.ParticleSystemShapeCone(_this);
                _this._shapeBox = new framework.ParticleSystemShapeBox(_this);
                _this._shapeCircle = new framework.ParticleSystemShapeCircle(_this);
                _this._shapeEdge = new framework.ParticleSystemShapeEdge(_this);
                _this.shapeType = framework.ParticleSystemShapeType.Cone;
                return _this;
            }
            Object.defineProperty(ParticleShapeModule.prototype, "shapeType", {
                /**
                 * Type of shape to emit particles from.
                 * 发射粒子的形状类型。
                 */
                get: function () {
                    return this._shapeType;
                },
                set: function (v) {
                    if (this._shapeType == v)
                        return;
                    this._shapeType = v;
                    this._onShapeTypeChanged();
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleShapeModule.prototype, "shape", {
                /**
                 * Type of shape to emit particles from.
                 * 发射粒子的形状类型。
                 */
                get: function () {
                    return this._shape;
                },
                set: function (v) {
                    if (this._shape == v)
                        return;
                    this._shape = v;
                    this._onShapeChanged();
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleShapeModule.prototype, "arcSpeedMultiplier", {
                /**
                 * A multiplier of the arc speed of the emission shape.
                 *
                 * 发射形状的电弧速度的乘数。
                 */
                get: function () {
                    return this.arcSpeed.curveMultiplier;
                },
                set: function (v) {
                    this.arcSpeed.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleShapeModule.prototype, "radiusSpeedMultiplier", {
                /**
                 * A multiplier of the radius speed of the emission shape.
                 *
                 * 发射形状的半径速度的乘法器。
                 */
                get: function () {
                    return this.radiusSpeed.curveMultiplier;
                },
                set: function (v) {
                    this.radiusSpeed.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * 初始化粒子状态
             * @param particle 粒子
             */
            ParticleShapeModule.prototype.initParticleState = function (particle) {
                var startSpeed = this.particleSystem.main.startSpeed.getValue(particle.birthRateAtDuration);
                //
                var position = new m4m.math.vector3(0, 0, 0);
                var dir = new m4m.math.vector3(0, 0, 1);
                //
                if (this.enabled) {
                    this.activeShape.calcParticlePosDir(particle, position, dir);
                }
                dir.x *= startSpeed;
                dir.y *= startSpeed;
                dir.z *= startSpeed;
                if (this.particleSystem.main.simulationSpace == framework.ParticleSystemSimulationSpace.World) {
                    var localToWorldMatrix = this.particleSystem.localToWorldMatrix;
                    m4m.math.matrixTransformVector3(position, localToWorldMatrix, position);
                    m4m.math.matrixTransformNormal(dir, localToWorldMatrix, dir);
                }
                particle.position.x += position.x;
                particle.position.y += position.y;
                particle.position.z += position.z;
                particle.velocity.x += dir.x;
                particle.velocity.y += dir.y;
                particle.velocity.z += dir.z;
                if (!this.enabled)
                    return;
                if (this.alignToDirection) {
                    // 看向矩阵
                    var mat = new m4m.math.matrix();
                    var dir = particle.velocity;
                    m4m.math.matrixLookatLH(dir, new m4m.math.vector3(0, 1, 0), mat);
                    // 旋转矩阵
                    var mat0 = new m4m.math.matrix();
                    var rotation = new m4m.math.vector3(particle.rotation.x, particle.rotation.y, particle.rotation.z);
                    m4m.math.vec3ScaleByNum(rotation, Math.PI / 180, rotation);
                    m4m.math.matrixMakeEuler(rotation, m4m.math.defaultRotationOrder, mat0);
                    //
                    m4m.math.matrixMultiply(mat0, mat, mat0);
                    // 获取被变换后的旋转
                    m4m.math.matrixGetEuler(mat0, m4m.math.defaultRotationOrder, rotation);
                    m4m.math.vec3ScaleByNum(rotation, 180 / Math.PI, rotation);
                    //
                    particle.rotation.x = rotation.x;
                    particle.rotation.y = rotation.y;
                    particle.rotation.z = rotation.z;
                }
                var length = m4m.math.vec3Length(particle.velocity);
                var velocity = new m4m.math.vector3();
                if (this.randomDirectionAmount > 0) {
                    velocity.x = Math.random() * 2 - 1;
                    velocity.y = Math.random() * 2 - 1;
                    velocity.z = Math.random() * 2 - 1;
                    var len = m4m.math.vec3Length(velocity);
                    velocity.x = velocity.x / len * length;
                    velocity.y = velocity.y / len * length;
                    velocity.z = velocity.z / len * length;
                    //
                    m4m.math.vec3SLerp(particle.velocity, velocity, this.randomDirectionAmount, particle.velocity);
                    //
                    var len = m4m.math.vec3Length(particle.velocity);
                    particle.velocity.x = particle.velocity.x / len * length;
                    particle.velocity.y = particle.velocity.y / len * length;
                    particle.velocity.z = particle.velocity.z / len * length;
                }
                if (this.sphericalDirectionAmount > 0) {
                    velocity.x = particle.position.x;
                    velocity.y = particle.position.y;
                    velocity.z = particle.position.z;
                    var len = m4m.math.vec3Length(velocity);
                    velocity.x = velocity.x / len * length;
                    velocity.y = velocity.y / len * length;
                    velocity.z = velocity.z / len * length;
                    //
                    m4m.math.vec3SLerp(particle.velocity, velocity, this.sphericalDirectionAmount, particle.velocity);
                    //
                    var len = m4m.math.vec3Length(particle.velocity);
                    particle.velocity.x = particle.velocity.x / len * length;
                    particle.velocity.y = particle.velocity.y / len * length;
                    particle.velocity.z = particle.velocity.z / len * length;
                }
            };
            ParticleShapeModule.prototype._onShapeTypeChanged = function () {
                var preValue = this.activeShape;
                switch (this.shapeType) {
                    case framework.ParticleSystemShapeType.Sphere:
                        this._shape = framework.ParticleSystemShapeType1.Sphere;
                        this._shapeSphere.emitFromShell = false;
                        this.activeShape = this._shapeSphere;
                        break;
                    case framework.ParticleSystemShapeType.SphereShell:
                        this._shape = framework.ParticleSystemShapeType1.Sphere;
                        this._shapeSphere.emitFromShell = true;
                        this.activeShape = this._shapeSphere;
                        break;
                    case framework.ParticleSystemShapeType.Hemisphere:
                        this._shape = framework.ParticleSystemShapeType1.Hemisphere;
                        this._shapeHemisphere.emitFromShell = false;
                        this.activeShape = this._shapeHemisphere;
                        break;
                    case framework.ParticleSystemShapeType.HemisphereShell:
                        this._shape = framework.ParticleSystemShapeType1.Hemisphere;
                        this._shapeHemisphere.emitFromShell = true;
                        this.activeShape = this._shapeHemisphere;
                        break;
                    case framework.ParticleSystemShapeType.Cone:
                        this._shape = framework.ParticleSystemShapeType1.Cone;
                        this._shapeCone.emitFrom = framework.ParticleSystemShapeConeEmitFrom.Base;
                        this.activeShape = this._shapeCone;
                        break;
                    case framework.ParticleSystemShapeType.ConeShell:
                        this._shape = framework.ParticleSystemShapeType1.Cone;
                        this._shapeCone.emitFrom = framework.ParticleSystemShapeConeEmitFrom.BaseShell;
                        this.activeShape = this._shapeCone;
                        break;
                    case framework.ParticleSystemShapeType.ConeVolume:
                        this._shape = framework.ParticleSystemShapeType1.Cone;
                        this._shapeCone.emitFrom = framework.ParticleSystemShapeConeEmitFrom.Volume;
                        this.activeShape = this._shapeCone;
                        break;
                    case framework.ParticleSystemShapeType.ConeVolumeShell:
                        this._shape = framework.ParticleSystemShapeType1.Cone;
                        this._shapeCone.emitFrom = framework.ParticleSystemShapeConeEmitFrom.VolumeShell;
                        this.activeShape = this._shapeCone;
                        break;
                    case framework.ParticleSystemShapeType.Box:
                        this._shape = framework.ParticleSystemShapeType1.Box;
                        this._shapeBox.emitFrom = framework.ParticleSystemShapeBoxEmitFrom.Volume;
                        this.activeShape = this._shapeBox;
                        break;
                    case framework.ParticleSystemShapeType.BoxShell:
                        this._shape = framework.ParticleSystemShapeType1.Box;
                        this._shapeBox.emitFrom = framework.ParticleSystemShapeBoxEmitFrom.Shell;
                        this.activeShape = this._shapeBox;
                        break;
                    case framework.ParticleSystemShapeType.BoxEdge:
                        this._shape = framework.ParticleSystemShapeType1.Box;
                        this._shapeBox.emitFrom = framework.ParticleSystemShapeBoxEmitFrom.Edge;
                        this.activeShape = this._shapeBox;
                        break;
                    case framework.ParticleSystemShapeType.Mesh:
                        this._shape = framework.ParticleSystemShapeType1.Mesh;
                        console.warn("\u672A\u5B9E\u73B0 ParticleSystemShapeType.Mesh");
                        this.activeShape = null;
                        break;
                    case framework.ParticleSystemShapeType.MeshRenderer:
                        this._shape = framework.ParticleSystemShapeType1.MeshRenderer;
                        console.warn("\u672A\u5B9E\u73B0 ParticleSystemShapeType.Mesh");
                        this.activeShape = null;
                        break;
                    case framework.ParticleSystemShapeType.SkinnedMeshRenderer:
                        this._shape = framework.ParticleSystemShapeType1.SkinnedMeshRenderer;
                        console.warn("\u672A\u5B9E\u73B0 ParticleSystemShapeType.Mesh");
                        this.activeShape = null;
                        break;
                    case framework.ParticleSystemShapeType.Circle:
                        this._shape = framework.ParticleSystemShapeType1.Circle;
                        this._shapeCircle.emitFromEdge = false;
                        this.activeShape = this._shapeCircle;
                        break;
                    case framework.ParticleSystemShapeType.CircleEdge:
                        this._shape = framework.ParticleSystemShapeType1.Circle;
                        this._shapeCircle.emitFromEdge = true;
                        this.activeShape = this._shapeCircle;
                        break;
                    case framework.ParticleSystemShapeType.SingleSidedEdge:
                        this._shape = framework.ParticleSystemShapeType1.Edge;
                        this.activeShape = this._shapeEdge;
                        break;
                    default:
                        console.warn("\u9519\u8BEF ParticleShapeModule.shapeType \u503C ".concat(this.shapeType));
                        break;
                }
                framework.serialization.setValue(this.activeShape, preValue);
            };
            ParticleShapeModule.prototype._onShapeChanged = function () {
                switch (this.shape) {
                    case framework.ParticleSystemShapeType1.Sphere:
                        this.shapeType = this._shapeSphere.emitFromShell ? framework.ParticleSystemShapeType.SphereShell : framework.ParticleSystemShapeType.Sphere;
                        break;
                    case framework.ParticleSystemShapeType1.Hemisphere:
                        this.shapeType = this._shapeHemisphere.emitFromShell ? framework.ParticleSystemShapeType.HemisphereShell : framework.ParticleSystemShapeType.Hemisphere;
                        break;
                    case framework.ParticleSystemShapeType1.Cone:
                        switch (this._shapeCone.emitFrom) {
                            case framework.ParticleSystemShapeConeEmitFrom.Base:
                                this.shapeType = framework.ParticleSystemShapeType.Cone;
                                break;
                            case framework.ParticleSystemShapeConeEmitFrom.BaseShell:
                                this.shapeType = framework.ParticleSystemShapeType.ConeShell;
                                break;
                            case framework.ParticleSystemShapeConeEmitFrom.Volume:
                                this.shapeType = framework.ParticleSystemShapeType.ConeVolume;
                                break;
                            case framework.ParticleSystemShapeConeEmitFrom.VolumeShell:
                                this.shapeType = framework.ParticleSystemShapeType.ConeVolumeShell;
                                break;
                            default:
                                console.warn("\u9519\u8BEFParticleSystemShapeCone.emitFrom\u503C ".concat(this._shapeCone.emitFrom));
                                break;
                        }
                        break;
                    case framework.ParticleSystemShapeType1.Box:
                        switch (this._shapeBox.emitFrom) {
                            case framework.ParticleSystemShapeBoxEmitFrom.Volume:
                                this.shapeType = framework.ParticleSystemShapeType.Box;
                                break;
                            case framework.ParticleSystemShapeBoxEmitFrom.Shell:
                                this.shapeType = framework.ParticleSystemShapeType.BoxShell;
                                break;
                            case framework.ParticleSystemShapeBoxEmitFrom.Edge:
                                this.shapeType = framework.ParticleSystemShapeType.BoxEdge;
                                break;
                            default:
                                console.warn("\u9519\u8BEFParticleSystemShapeCone.emitFrom\u503C ".concat(this._shapeCone.emitFrom));
                                break;
                        }
                        break;
                    case framework.ParticleSystemShapeType1.Mesh:
                        this.shapeType = framework.ParticleSystemShapeType.Mesh;
                        break;
                    case framework.ParticleSystemShapeType1.MeshRenderer:
                        this.shapeType = framework.ParticleSystemShapeType.MeshRenderer;
                        break;
                    case framework.ParticleSystemShapeType1.SkinnedMeshRenderer:
                        this.shapeType = framework.ParticleSystemShapeType.SkinnedMeshRenderer;
                        break;
                    case framework.ParticleSystemShapeType1.Circle:
                        this.shapeType = this._shapeCircle.emitFromEdge ? framework.ParticleSystemShapeType.CircleEdge : framework.ParticleSystemShapeType.Circle;
                        break;
                    case framework.ParticleSystemShapeType1.Edge:
                        this.shapeType = framework.ParticleSystemShapeType.SingleSidedEdge;
                        break;
                    default:
                        console.warn("\u9519\u8BEF ParticleShapeModule.shape \u503C ".concat(this.shape));
                        break;
                }
            };
            return ParticleShapeModule;
        }(framework.ParticleModule));
        framework.ParticleShapeModule = ParticleShapeModule;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="ParticleModule.ts" />
var m4m;
/// <reference path="ParticleModule.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * Script interface for the Size By Speed module.
         *
         * 粒子系统 缩放随速度变化模块
         */
        var ParticleSizeBySpeedModule = /** @class */ (function (_super) {
            __extends(ParticleSizeBySpeedModule, _super);
            function ParticleSizeBySpeedModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * Set the size over speed on each axis separately.
                 *
                 * 在每个轴上分别设置生命周期内的大小。
                 */
                _this.separateAxes = false;
                /**
                 * Curve to control particle size based on speed.
                 *
                 * 基于寿命的粒度控制曲线。
                 */
                _this.size3D = framework.serialization.setValue(new framework.MinMaxCurveVector3(), { xCurve: { between0And1: true, constant: 1, constantMin: 1, constantMax: 1, curveMultiplier: 1 }, yCurve: { between0And1: true, constant: 1, constantMin: 1, constantMax: 1, curveMultiplier: 1 }, zCurve: { between0And1: true, constant: 1, constantMin: 1, constantMax: 1, curveMultiplier: 1 } });
                /**
                 * Apply the size curve between these minimum and maximum speeds.
                 *
                 * 在这些最小和最大速度之间应用尺寸变化。
                 */
                _this.range = new m4m.math.vector2(0, 1);
                return _this;
            }
            Object.defineProperty(ParticleSizeBySpeedModule.prototype, "size", {
                /**
                 * Curve to control particle size based on speed.
                 *
                 * 基于速度的粒度控制曲线。
                 */
                get: function () {
                    return this.size3D.xCurve;
                },
                set: function (v) {
                    this.size3D.xCurve = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSizeBySpeedModule.prototype, "sizeMultiplier", {
                /**
                 * Size multiplier.
                 *
                 * 尺寸的乘数。
                 */
                get: function () {
                    return this.size.curveMultiplier;
                },
                set: function (v) {
                    this.size.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSizeBySpeedModule.prototype, "x", {
                /**
                 * Size over speed curve for the X axis.
                 *
                 * X轴的尺寸随生命周期变化曲线。
                 */
                get: function () {
                    return this.size3D.xCurve;
                },
                set: function (v) {
                    this.size3D.xCurve;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSizeBySpeedModule.prototype, "xMultiplier", {
                /**
                 * X axis size multiplier.
                 *
                 * X轴尺寸的乘数。
                 */
                get: function () {
                    return this.x.curveMultiplier;
                },
                set: function (v) {
                    this.x.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSizeBySpeedModule.prototype, "y", {
                /**
                 * Size over speed curve for the Y axis.
                 *
                 * Y轴的尺寸随生命周期变化曲线。
                 */
                get: function () {
                    return this.size3D.yCurve;
                },
                set: function (v) {
                    this.size3D.yCurve;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSizeBySpeedModule.prototype, "yMultiplier", {
                /**
                 * Y axis size multiplier.
                 *
                 * Y轴尺寸的乘数。
                 */
                get: function () {
                    return this.y.curveMultiplier;
                },
                set: function (v) {
                    this.y.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSizeBySpeedModule.prototype, "z", {
                /**
                 * Size over speed curve for the Z axis.
                 *
                 * Z轴的尺寸随生命周期变化曲线。
                 */
                get: function () {
                    return this.size3D.zCurve;
                },
                set: function (v) {
                    this.size3D.zCurve;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSizeBySpeedModule.prototype, "zMultiplier", {
                /**
                 * Z axis size multiplier.
                 *
                 * Z轴尺寸的乘数。
                 */
                get: function () {
                    return this.z.curveMultiplier;
                },
                set: function (v) {
                    this.z.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * 初始化粒子状态
             * @param particle 粒子
             */
            ParticleSizeBySpeedModule.prototype.initParticleState = function (particle) {
                particle[_SizeBySpeed_rate] = Math.random();
            };
            /**
             * 更新粒子状态
             * @param particle 粒子
             */
            ParticleSizeBySpeedModule.prototype.updateParticleState = function (particle) {
                if (!this.enabled)
                    return;
                var velocity = m4m.math.vec3Length(particle.velocity);
                var rate = m4m.math.floatClamp((velocity - this.range.x) / (this.range.y - this.range.x), 0, 1);
                var size = this.size3D.getValue(rate, particle[_SizeBySpeed_rate]);
                if (!this.separateAxes) {
                    size.y = size.z = size.x;
                }
                particle.size.x *= size.x;
                particle.size.y *= size.y;
                particle.size.z *= size.z;
            };
            return ParticleSizeBySpeedModule;
        }(framework.ParticleModule));
        framework.ParticleSizeBySpeedModule = ParticleSizeBySpeedModule;
        var _SizeBySpeed_rate = "_SizeBySpeed_rate";
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * 粒子系统 缩放随时间变化模块
         *
         * @author feng3d
         */
        var ParticleSizeOverLifetimeModule = /** @class */ (function (_super) {
            __extends(ParticleSizeOverLifetimeModule, _super);
            function ParticleSizeOverLifetimeModule() {
                /**
                 * Set the size over lifetime on each axis separately.
                 *
                 * 在每个轴上分别设置生命周期内的大小。
                 */
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.separateAxes = false;
                /**
                 * Curve to control particle size based on lifetime.
                 *
                 * 基于寿命的粒度控制曲线。
                 */
                _this.size3D = framework.serialization.setValue(new framework.MinMaxCurveVector3(), { xCurve: { between0And1: true, constant: 1, constantMin: 1, constantMax: 1, curveMultiplier: 1 }, yCurve: { between0And1: true, constant: 1, constantMin: 1, constantMax: 1, curveMultiplier: 1 }, zCurve: { between0And1: true, constant: 1, constantMin: 1, constantMax: 1, curveMultiplier: 1 } });
                return _this;
            }
            Object.defineProperty(ParticleSizeOverLifetimeModule.prototype, "size", {
                /**
                 * Curve to control particle size based on lifetime.
                 *
                 * 基于寿命的粒度控制曲线。
                 */
                get: function () {
                    return this.size3D.xCurve;
                },
                set: function (v) {
                    this.size3D.xCurve = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSizeOverLifetimeModule.prototype, "sizeMultiplier", {
                /**
                 * Size multiplier.
                 *
                 * 尺寸的乘数。
                 */
                get: function () {
                    return this.size.curveMultiplier;
                },
                set: function (v) {
                    this.size.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSizeOverLifetimeModule.prototype, "x", {
                /**
                 * Size over lifetime curve for the X axis.
                 *
                 * X轴的尺寸随生命周期变化曲线。
                 */
                get: function () {
                    return this.size3D.xCurve;
                },
                set: function (v) {
                    this.size3D.xCurve;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSizeOverLifetimeModule.prototype, "xMultiplier", {
                /**
                 * X axis size multiplier.
                 *
                 * X轴尺寸的乘数。
                 */
                get: function () {
                    return this.x.curveMultiplier;
                },
                set: function (v) {
                    this.x.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSizeOverLifetimeModule.prototype, "y", {
                /**
                 * Size over lifetime curve for the Y axis.
                 *
                 * Y轴的尺寸随生命周期变化曲线。
                 */
                get: function () {
                    return this.size3D.yCurve;
                },
                set: function (v) {
                    this.size3D.yCurve;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSizeOverLifetimeModule.prototype, "yMultiplier", {
                /**
                 * Y axis size multiplier.
                 *
                 * Y轴尺寸的乘数。
                 */
                get: function () {
                    return this.y.curveMultiplier;
                },
                set: function (v) {
                    this.y.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSizeOverLifetimeModule.prototype, "z", {
                /**
                 * Size over lifetime curve for the Z axis.
                 *
                 * Z轴的尺寸随生命周期变化曲线。
                 */
                get: function () {
                    return this.size3D.zCurve;
                },
                set: function (v) {
                    this.size3D.zCurve;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSizeOverLifetimeModule.prototype, "zMultiplier", {
                /**
                 * Z axis size multiplier.
                 *
                 * Z轴尺寸的乘数。
                 */
                get: function () {
                    return this.z.curveMultiplier;
                },
                set: function (v) {
                    this.z.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * 初始化粒子状态
             * @param particle 粒子
             */
            ParticleSizeOverLifetimeModule.prototype.initParticleState = function (particle) {
                particle[_SizeOverLifetime_rate] = Math.random();
            };
            /**
             * 更新粒子状态
             * @param particle 粒子
             */
            ParticleSizeOverLifetimeModule.prototype.updateParticleState = function (particle) {
                if (!this.enabled)
                    return;
                var size = this.size3D.getValue(particle.rateAtLifeTime, particle[_SizeOverLifetime_rate]);
                if (!this.separateAxes) {
                    size.y = size.z = size.x;
                }
                particle.size.x *= size.x;
                particle.size.y *= size.y;
                particle.size.z *= size.z;
            };
            return ParticleSizeOverLifetimeModule;
        }(framework.ParticleModule));
        framework.ParticleSizeOverLifetimeModule = ParticleSizeOverLifetimeModule;
        var _SizeOverLifetime_rate = "_SizeOverLifetime_rate";
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * 粒子系统纹理表动画模块。
         *
         * @author feng3d
         */
        var ParticleTextureSheetAnimationModule = /** @class */ (function (_super) {
            __extends(ParticleTextureSheetAnimationModule, _super);
            function ParticleTextureSheetAnimationModule() {
                /**
                 * Defines the tiling of the texture.
                 *
                 * 定义纹理的平铺。
                 */
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.tiles = new m4m.math.vector2(1, 1);
                /**
                 * Specifies the animation type.
                 *
                 * 指定动画类型。
                 */
                _this.animation = framework.ParticleSystemAnimationType.WholeSheet;
                /**
                 * Curve to control which frame of the texture sheet animation to play.
                 *
                 * 曲线控制哪个帧的纹理表动画播放。
                 */
                _this.frameOverTime = framework.serialization.setValue(new framework.MinMaxCurve(), { mode: framework.MinMaxCurveMode.Curve, curveMin: { keys: [{ time: 0, value: 0, inTangent: 1, outTangent: 1 }, { time: 1, value: 1, inTangent: 1, outTangent: 1 }] } });
                /**
                 * Use a random row of the texture sheet for each particle emitted.
                 *
                 * 对每个发射的粒子使用纹理表的随机行。
                 */
                _this.useRandomRow = true;
                _this._rowIndex = 0;
                /**
                 * Define a random starting frame for the texture sheet animation.
                 *
                 * 为纹理表动画定义一个随机的起始帧。
                 */
                _this.startFrame = new framework.MinMaxCurve();
                /**
                 * Specifies how many times the animation will loop during the lifetime of the particle.
                 *
                 * 指定在粒子的生命周期内动画将循环多少次。
                 */
                _this.cycleCount = 1;
                /**
                 * Flip the UV coordinate on particles, causing them to appear mirrored.
                 *
                 * 在粒子上翻转UV坐标，使它们呈现镜像翻转。
                 */
                _this.flipUV = new m4m.math.vector2();
                /**
                 * Choose which UV channels will receive texture animation.
                 *
                 * 选择哪个UV通道将接收纹理动画。
                 *
                 * todo 目前引擎中只有一套UV
                 */
                _this.uvChannelMask = framework.UVChannelFlags.Everything;
                return _this;
            }
            Object.defineProperty(ParticleTextureSheetAnimationModule.prototype, "rowIndex", {
                /**
                 * Explicitly select which row of the texture sheet is used, when useRandomRow is set to false.
                 *
                 * 当useRandomRow设置为false时，显式选择使用纹理表的哪一行。
                 */
                get: function () { return this._rowIndex; },
                set: function (v) {
                    this._rowIndex = m4m.math.floatClamp(v, 0, this.tiles.y - 1);
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleTextureSheetAnimationModule.prototype, "flipU", {
                /**
                 * Flip the U coordinate on particles, causing them to appear mirrored horizontally.
                 *
                 * 在粒子上翻转U坐标，使它们呈现水平镜像。
                 */
                get: function () {
                    return this.flipUV.x;
                },
                set: function (v) {
                    this.flipUV.x = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleTextureSheetAnimationModule.prototype, "flipV", {
                /**
                 * Flip the V coordinate on particles, causing them to appear mirrored vertically.
                 *
                 * 在粒子上翻转V坐标，使它们垂直镜像。
                 */
                get: function () {
                    return this.flipUV.y;
                },
                set: function (v) {
                    this.flipUV.y = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleTextureSheetAnimationModule.prototype, "frameOverTimeMultiplier", {
                /**
                 * Frame over time mutiplier.
                 *
                 * 帧随时间变化的乘数。
                 */
                get: function () {
                    return this.frameOverTime.curveMultiplier;
                },
                set: function (v) {
                    this.frameOverTime.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleTextureSheetAnimationModule.prototype, "numTilesX", {
                /**
                 * Defines the tiling of the texture in the X axis.
                 *
                 * 定义纹理在X轴上的平铺。
                 */
                get: function () {
                    return this.tiles.x;
                },
                set: function (v) {
                    this.tiles.x = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleTextureSheetAnimationModule.prototype, "numTilesY", {
                /**
                 * Defines the tiling of the texture in the Y axis.
                 *
                 * 定义纹理在Y轴上的平铺。
                 */
                get: function () {
                    return this.tiles.y;
                },
                set: function (v) {
                    this.tiles.y = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleTextureSheetAnimationModule.prototype, "startFrameMultiplier", {
                /**
                 * Starting frame multiplier.
                 *
                 * 起始帧乘数。
                 */
                get: function () {
                    return this.startFrame.curveMultiplier;
                },
                set: function (v) {
                    this.startFrame.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * 初始化粒子状态
             * @param particle 粒子
             */
            ParticleTextureSheetAnimationModule.prototype.initParticleState = function (particle) {
                particle[_TextureSheetAnimation_frameOverTime] = Math.random();
                particle[_TextureSheetAnimation_startFrame] = Math.random();
                particle[_TextureSheetAnimation_randomRow] = Math.random();
            };
            /**
             * 更新粒子状态
             * @param particle 粒子
             */
            ParticleTextureSheetAnimationModule.prototype.updateParticleState = function (particle) {
                m4m.math.vec4Set(particle.tilingOffset, 1, 1, 0, 0);
                particle.flipUV.x = 0;
                particle.flipUV.y = 0;
                if (!this.enabled)
                    return;
                var segmentsX = this.tiles.x;
                var segmentsY = this.tiles.y;
                var step = new m4m.math.vector2(1 / segmentsX, 1 / segmentsY);
                var uvPos = new m4m.math.vector2();
                var frameOverTime = this.frameOverTime.getValue(particle.rateAtLifeTime, particle[_TextureSheetAnimation_frameOverTime]);
                var frameIndex = this.startFrame.getValue(particle.rateAtLifeTime, particle[_TextureSheetAnimation_startFrame]);
                var rowIndex = this.rowIndex;
                var cycleCount = this.cycleCount;
                if (this.animation == framework.ParticleSystemAnimationType.WholeSheet) {
                    frameIndex = Math.round(frameIndex + frameOverTime * segmentsX * segmentsY * cycleCount);
                    uvPos.x = (frameIndex % segmentsX) * step.x;
                    uvPos.y = (Math.floor(frameIndex / segmentsX) % segmentsY) * step.y;
                }
                else if (this.animation == framework.ParticleSystemAnimationType.SingleRow) {
                    frameIndex = Math.round(frameIndex + frameOverTime * segmentsX * cycleCount);
                    if (this.useRandomRow) {
                        rowIndex = Math.round(segmentsY * particle[_TextureSheetAnimation_randomRow]);
                    }
                    uvPos.x = (frameIndex % segmentsX) * step.x;
                    uvPos.x = rowIndex * step.y;
                }
                m4m.math.vec4Set(particle.tilingOffset, step.x, step.y, uvPos.x, uvPos.y);
                particle.flipUV = this.flipUV;
            };
            return ParticleTextureSheetAnimationModule;
        }(framework.ParticleModule));
        framework.ParticleTextureSheetAnimationModule = ParticleTextureSheetAnimationModule;
        var _TextureSheetAnimation_frameOverTime = "_TextureSheetAnimation_rateAtLifeTime";
        var _TextureSheetAnimation_startFrame = "_TextureSheetAnimation_startFrame";
        var _TextureSheetAnimation_randomRow = "_TextureSheetAnimation_randomRow";
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * 粒子系统 速度随时间变化模块
         *
         * Controls the velocity of each particle during its lifetime.
         * 控制每个粒子在其生命周期内的速度。
         *
         * @author feng3d
         */
        var ParticleVelocityOverLifetimeModule = /** @class */ (function (_super) {
            __extends(ParticleVelocityOverLifetimeModule, _super);
            function ParticleVelocityOverLifetimeModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * Curve to control particle speed based on lifetime.
                 *
                 * 基于寿命的粒子速度控制曲线。
                 */
                _this.velocity = new framework.MinMaxCurveVector3();
                /**
                 * Specifies if the velocities are in local space (rotated with the transform) or world space.
                 *
                 * 指定速度是在局部空间(与变换一起旋转)还是在世界空间。
                 */
                _this.space = framework.ParticleSystemSimulationSpace.Local;
                return _this;
            }
            Object.defineProperty(ParticleVelocityOverLifetimeModule.prototype, "x", {
                /**
                 * Curve to control particle speed based on lifetime, on the X axis.
                 *
                 * 曲线控制粒子速度基于寿命，在X轴上。
                 */
                get: function () {
                    return this.velocity.xCurve;
                },
                set: function (v) {
                    this.velocity.xCurve = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleVelocityOverLifetimeModule.prototype, "xMultiplier", {
                /**
                 * X axis speed multiplier.
                 *
                 * X轴速度倍增器。
                 */
                get: function () {
                    return this.x.curveMultiplier;
                },
                set: function (v) {
                    this.x.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleVelocityOverLifetimeModule.prototype, "y", {
                /**
                 * Curve to control particle speed based on lifetime, on the Y axis.
                 *
                 * 曲线控制粒子速度基于寿命，在Y轴上。
                 */
                get: function () {
                    return this.velocity.yCurve;
                },
                set: function (v) {
                    this.velocity.yCurve = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleVelocityOverLifetimeModule.prototype, "yMultiplier", {
                /**
                 * Y axis speed multiplier.
                 *
                 * Y轴速度倍增器。
                 */
                get: function () {
                    return this.y.curveMultiplier;
                },
                set: function (v) {
                    this.y.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleVelocityOverLifetimeModule.prototype, "z", {
                /**
                 * Curve to control particle speed based on lifetime, on the Z axis.
                 *
                 * 曲线控制粒子速度基于寿命，在Z轴上。
                 */
                get: function () {
                    return this.velocity.zCurve;
                },
                set: function (v) {
                    this.velocity.zCurve = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleVelocityOverLifetimeModule.prototype, "zMultiplier", {
                /**
                 * Z axis speed multiplier.
                 *
                 * Z轴速度倍增器。
                 */
                get: function () {
                    return this.z.curveMultiplier;
                },
                set: function (v) {
                    this.z.curveMultiplier = v;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * 初始化粒子状态
             * @param particle 粒子
             */
            ParticleVelocityOverLifetimeModule.prototype.initParticleState = function (particle) {
                particle[_VelocityOverLifetime_rate] = Math.random();
            };
            /**
             * 更新粒子状态
             * @param particle 粒子
             */
            ParticleVelocityOverLifetimeModule.prototype.updateParticleState = function (particle) {
                this.particleSystem.removeParticleVelocity(particle, _VelocityOverLifetime_preVelocity);
                if (!this.enabled)
                    return;
                var velocity = this.velocity.getValue(particle.rateAtLifeTime, particle[_VelocityOverLifetime_rate]);
                this.particleSystem.addParticleVelocity(particle, velocity, this.space, _VelocityOverLifetime_preVelocity);
            };
            return ParticleVelocityOverLifetimeModule;
        }(framework.ParticleModule));
        framework.ParticleVelocityOverLifetimeModule = ParticleVelocityOverLifetimeModule;
        var _VelocityOverLifetime_rate = "_VelocityOverLifetime_rate";
        var _VelocityOverLifetime_preVelocity = "_VelocityOverLifetime_preVelocity";
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @author feng3d
         */
        var ParticleEmissionBurst = /** @class */ (function () {
            function ParticleEmissionBurst() {
                /**
                 * The time that each burst occurs.
                 * 每次爆炸发生的时间。
                 */
                this.time = 0;
                /**
                 * 要发射的粒子数。
                 */
                this.count = framework.serialization.setValue(new framework.MinMaxCurve(), { constant: 30, constantMin: 30, constantMax: 30, mode: framework.MinMaxCurveMode.TwoConstants });
                /**
                 * How many times to play the burst. (0 means infinitely).
                 * 爆发次数。(0意味着无限)。
                 *
                 * @todo
                 */
                this.cycleCount = 1;
                /**
                 * How often to repeat the burst, in seconds.
                 *
                 * 多久重复一次，以秒为单位。
                 *
                 * @todo
                 */
                this.repeatInterval = 0.01;
                /**
                 * 喷发被触发的几率。
                 */
                this.probability = 1.0;
                this._isProbability = true;
            }
            Object.defineProperty(ParticleEmissionBurst.prototype, "minCount", {
                /**
                 * Minimum number of bursts to be emitted.
                 * 要发射的最小爆发数量。
                 */
                get: function () {
                    return this.count.constantMin;
                },
                set: function (v) {
                    this.count.constantMin = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleEmissionBurst.prototype, "maxCount", {
                /**
                 * Maximum number of bursts to be emitted.
                 *
                 * 要发射的最大爆发数量。
                 */
                get: function () {
                    return this.count.constantMax;
                },
                set: function (v) {
                    this.count.constantMax = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleEmissionBurst.prototype, "isProbability", {
                /**
                 * 是否喷发
                 */
                get: function () {
                    return this._isProbability;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * 通过触发的几率计算是否喷发。
             */
            ParticleEmissionBurst.prototype.calculateProbability = function () {
                this._isProbability = this.probability >= Math.random();
                return this._isProbability;
            };
            return ParticleEmissionBurst;
        }());
        framework.ParticleEmissionBurst = ParticleEmissionBurst;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * 粒子系统 发射形状
         *
         * @author feng3d
         */
        var ParticleSystemShapeBase = /** @class */ (function () {
            function ParticleSystemShapeBase(module) {
                this._module = module;
            }
            /**
             * 计算粒子的发射位置与方向
             *
             * @param particle
             * @param position
             * @param dir
             */
            ParticleSystemShapeBase.prototype.calcParticlePosDir = function (particle, position, dir) {
            };
            return ParticleSystemShapeBase;
        }());
        framework.ParticleSystemShapeBase = ParticleSystemShapeBase;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="ParticleSystemShapeBase.ts" />
var m4m;
/// <reference path="ParticleSystemShapeBase.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @author feng3d
         */
        var ParticleSystemShapeBoxEmitFrom;
        (function (ParticleSystemShapeBoxEmitFrom) {
            /**
             * 从盒子内部发射。
             */
            ParticleSystemShapeBoxEmitFrom[ParticleSystemShapeBoxEmitFrom["Volume"] = 0] = "Volume";
            /**
             * 从盒子外壳发射。
             */
            ParticleSystemShapeBoxEmitFrom[ParticleSystemShapeBoxEmitFrom["Shell"] = 1] = "Shell";
            /**
             * 从盒子边缘发射。
             */
            ParticleSystemShapeBoxEmitFrom[ParticleSystemShapeBoxEmitFrom["Edge"] = 2] = "Edge";
        })(ParticleSystemShapeBoxEmitFrom = framework.ParticleSystemShapeBoxEmitFrom || (framework.ParticleSystemShapeBoxEmitFrom = {}));
        /**
         * 粒子系统 发射盒子
         *
         * @author feng3d
         */
        var ParticleSystemShapeBox = /** @class */ (function (_super) {
            __extends(ParticleSystemShapeBox, _super);
            function ParticleSystemShapeBox() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * 粒子系统盒子发射类型。
                 */
                _this.emitFrom = ParticleSystemShapeBoxEmitFrom.Volume;
                return _this;
            }
            Object.defineProperty(ParticleSystemShapeBox.prototype, "boxX", {
                /**
                 * 盒子X方向缩放。
                 */
                get: function () {
                    return this._module.box.x;
                },
                set: function (v) {
                    this._module.box.x = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSystemShapeBox.prototype, "boxY", {
                /**
                 * 盒子Y方向缩放。
                 */
                get: function () {
                    return this._module.box.y;
                },
                set: function (v) {
                    this._module.box.y = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSystemShapeBox.prototype, "boxZ", {
                /**
                 * 盒子Z方向缩放。
                 */
                get: function () {
                    return this._module.box.z;
                },
                set: function (v) {
                    this._module.box.z = v;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * 计算粒子的发射位置与方向
             *
             * @param particle
             * @param position
             * @param dir
             */
            ParticleSystemShapeBox.prototype.calcParticlePosDir = function (particle, position, dir) {
                // 计算位置
                position.x = Math.random() * 2 - 1;
                position.y = Math.random() * 2 - 1;
                position.z = Math.random() * 2 - 1;
                if (this.emitFrom == ParticleSystemShapeBoxEmitFrom.Shell) {
                    var max = Math.max(Math.abs(position.x), Math.abs(position.y), Math.abs(position.z));
                    if (Math.abs(position.x) == max) {
                        position.x = position.x < 0 ? -1 : 1;
                    }
                    else if (Math.abs(position.y) == max) {
                        position.y = position.y < 0 ? -1 : 1;
                    }
                    else if (Math.abs(position.z) == max) {
                        position.z = position.z < 0 ? -1 : 1;
                    }
                }
                else if (this.emitFrom == ParticleSystemShapeBoxEmitFrom.Edge) {
                    var min = Math.min(Math.abs(position.x), Math.abs(position.y), Math.abs(position.z));
                    if (Math.abs(position.x) == min) {
                        position.y = position.y < 0 ? -1 : 1;
                        position.z = position.z < 0 ? -1 : 1;
                    }
                    else if (Math.abs(position.y) == min) {
                        position.x = position.x < 0 ? -1 : 1;
                        position.z = position.z < 0 ? -1 : 1;
                    }
                    else if (Math.abs(position.z) == min) {
                        position.x = position.x < 0 ? -1 : 1;
                        position.y = position.y < 0 ? -1 : 1;
                    }
                }
                var scale = 0.5;
                position.x = position.x * this.boxX * scale;
                position.y = position.y * this.boxY * scale;
                position.z = position.z * this.boxZ * scale;
                // 计算速度
                dir.x = 0;
                dir.y = 0;
                dir.z = 1;
            };
            return ParticleSystemShapeBox;
        }(framework.ParticleSystemShapeBase));
        framework.ParticleSystemShapeBox = ParticleSystemShapeBox;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="ParticleSystemShapeBase.ts" />
var m4m;
/// <reference path="ParticleSystemShapeBase.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * 粒子系统 发射圆盘
         *
         * @author feng3d
         */
        var ParticleSystemShapeCircle = /** @class */ (function (_super) {
            __extends(ParticleSystemShapeCircle, _super);
            function ParticleSystemShapeCircle() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * 是否从圆形边缘发射。
                 */
                _this.emitFromEdge = false;
                return _this;
            }
            Object.defineProperty(ParticleSystemShapeCircle.prototype, "radius", {
                get: function () {
                    return this._module.radius;
                },
                set: function (v) {
                    this._module.radius = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSystemShapeCircle.prototype, "arc", {
                get: function () {
                    return this._module.arc;
                },
                set: function (v) {
                    this._module.arc = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSystemShapeCircle.prototype, "arcMode", {
                /**
                 * The mode used for generating particles around the arc.
                 *
                 * 在弧线周围产生粒子的模式。
                 */
                get: function () {
                    return this._module.arcMode;
                },
                set: function (v) {
                    this._module.arcMode = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSystemShapeCircle.prototype, "arcSpread", {
                /**
                 * Control the gap between emission points around the arc.
                 *
                 * 控制弧线周围发射点之间的间隙。
                 */
                get: function () {
                    return this._module.arcSpread;
                },
                set: function (v) {
                    this._module.arcSpread = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSystemShapeCircle.prototype, "arcSpeed", {
                /**
                 * When using one of the animated modes, how quickly to move the emission position around the arc.
                 * 当使用一个动画模式时，如何快速移动发射位置周围的弧。
                 */
                get: function () {
                    return this._module.arcSpeed;
                },
                set: function (v) {
                    this._module.arcSpeed = v;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * 计算粒子的发射位置与方向
             *
             * @param particle
             * @param position
             * @param dir
             */
            ParticleSystemShapeCircle.prototype.calcParticlePosDir = function (particle, position, dir) {
                var radius = this.radius;
                var arc = this.arc;
                // 在圆心的方向
                var radiusAngle = 0;
                if (this.arcMode == framework.ParticleSystemShapeMultiModeValue.Random) {
                    radiusAngle = Math.random() * arc;
                }
                else if (this.arcMode == framework.ParticleSystemShapeMultiModeValue.Loop) {
                    var totalAngle = particle.birthTime * this.arcSpeed.getValue(particle.birthRateAtDuration) * 360;
                    radiusAngle = totalAngle % arc;
                }
                else if (this.arcMode == framework.ParticleSystemShapeMultiModeValue.PingPong) {
                    var totalAngle = particle.birthTime * this.arcSpeed.getValue(particle.birthRateAtDuration) * 360;
                    radiusAngle = totalAngle % arc;
                    if (Math.floor(totalAngle / arc) % 2 == 1) {
                        radiusAngle = arc - radiusAngle;
                    }
                }
                if (this.arcSpread > 0) {
                    radiusAngle = Math.floor(radiusAngle / arc / this.arcSpread) * arc * this.arcSpread;
                }
                radiusAngle = m4m.math.degToRad(radiusAngle);
                // 计算位置
                dir.x = Math.cos(radiusAngle);
                dir.y = Math.sin(radiusAngle);
                dir.z = 0;
                //
                position.x = dir.x * radius;
                position.y = dir.y * radius;
                position.z = dir.z * radius;
                if (!this.emitFromEdge) {
                    var rand = Math.random();
                    position.x *= rand;
                    position.y *= rand;
                    position.z *= rand;
                }
            };
            return ParticleSystemShapeCircle;
        }(framework.ParticleSystemShapeBase));
        framework.ParticleSystemShapeCircle = ParticleSystemShapeCircle;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * 粒子系统发射圆锥体，用于定义基于圆锥体的粒子发射时的初始状态。
         *
         * @author feng3d
         */
        var ParticleSystemShapeCone = /** @class */ (function (_super) {
            __extends(ParticleSystemShapeCone, _super);
            function ParticleSystemShapeCone() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * 粒子系统圆锥体发射类型。
                 */
                _this.emitFrom = framework.ParticleSystemShapeConeEmitFrom.Base;
                return _this;
            }
            Object.defineProperty(ParticleSystemShapeCone.prototype, "angle", {
                /**
                 * Angle of the cone.
                 * 圆锥的角度。
                 */
                get: function () {
                    return this._module.angle;
                },
                set: function (v) {
                    this._module.angle = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSystemShapeCone.prototype, "radius", {
                /**
                 * 圆锥体底部半径。
                 */
                get: function () {
                    return this._module.radius;
                },
                set: function (v) {
                    this._module.radius = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSystemShapeCone.prototype, "length", {
                /**
                 * Length of the cone.
                 *
                 * 圆锥的长度（高度）。
                 */
                get: function () {
                    return this._module.length;
                },
                set: function (v) {
                    this._module.length = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSystemShapeCone.prototype, "arc", {
                /**
                 * Circle arc angle.
                 */
                get: function () {
                    return this._module.arc;
                },
                set: function (v) {
                    this._module.arc = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSystemShapeCone.prototype, "arcMode", {
                /**
                 * The mode used for generating particles around the arc.
                 * 在弧线周围产生粒子的模式。
                 */
                get: function () {
                    return this._module.arcMode;
                },
                set: function (v) {
                    this._module.arcMode = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSystemShapeCone.prototype, "arcSpread", {
                /**
                 * Control the gap between emission points around the arc.
                 * 控制弧线周围发射点之间的间隙。
                 */
                get: function () {
                    return this._module.arcSpread;
                },
                set: function (v) {
                    this._module.arcSpread = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSystemShapeCone.prototype, "arcSpeed", {
                /**
                 * When using one of the animated modes, how quickly to move the emission position around the arc.
                 * 当使用一个动画模式时，如何快速移动发射位置周围的弧。
                 */
                get: function () {
                    return this._module.arcSpeed;
                },
                set: function (v) {
                    this._module.arcSpeed = v;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * 计算粒子的发射位置与方向
             *
             * @param particle
             * @param position
             * @param dir
             */
            ParticleSystemShapeCone.prototype.calcParticlePosDir = function (particle, position, dir) {
                var radius = this.radius;
                var angle = this.angle;
                var arc = this.arc;
                angle = m4m.math.floatClamp(angle, 0, 87);
                // 在圆心的方向
                var radiusAngle = 0;
                if (this.arcMode == framework.ParticleSystemShapeMultiModeValue.Random) {
                    radiusAngle = Math.random() * arc;
                }
                else if (this.arcMode == framework.ParticleSystemShapeMultiModeValue.Loop) {
                    var totalAngle = particle.birthTime * this.arcSpeed.getValue(particle.birthRateAtDuration) * 360;
                    radiusAngle = totalAngle % arc;
                }
                else if (this.arcMode == framework.ParticleSystemShapeMultiModeValue.PingPong) {
                    var totalAngle = particle.birthTime * this.arcSpeed.getValue(particle.birthRateAtDuration) * 360;
                    radiusAngle = totalAngle % arc;
                    if (Math.floor(totalAngle / arc) % 2 == 1) {
                        radiusAngle = arc - radiusAngle;
                    }
                }
                if (this.arcSpread > 0) {
                    radiusAngle = Math.floor(radiusAngle / arc / this.arcSpread) * arc * this.arcSpread;
                }
                radiusAngle = m4m.math.degToRad(radiusAngle);
                // 在圆的位置
                var radiusRate = 1;
                if (this.emitFrom == framework.ParticleSystemShapeConeEmitFrom.Base || this.emitFrom == framework.ParticleSystemShapeConeEmitFrom.Volume) {
                    radiusRate = Math.random();
                }
                // 在圆的位置
                var basePos = new m4m.math.vector3(Math.cos(radiusAngle), Math.sin(radiusAngle), 0);
                // 底面位置
                var bottomPos = new m4m.math.vector3(basePos.x * radius * radiusRate, basePos.y * radius * radiusRate, 0);
                // 顶面位置
                var scale = (radius + this.length * Math.tan(m4m.math.degToRad(angle))) * radiusRate;
                var topPos = new m4m.math.vector3(basePos.x * scale, basePos.y * scale, this.length);
                // 计算方向
                m4m.math.vec3Subtract(topPos, bottomPos, dir);
                m4m.math.vec3Normalize(dir, dir);
                // 计算位置
                position.x = bottomPos.x;
                position.y = bottomPos.y;
                position.z = bottomPos.z;
                if (this.emitFrom == framework.ParticleSystemShapeConeEmitFrom.Volume || this.emitFrom == framework.ParticleSystemShapeConeEmitFrom.VolumeShell) {
                    // 上下点进行插值
                    m4m.math.vec3SLerp(position, topPos, Math.random(), position);
                }
            };
            return ParticleSystemShapeCone;
        }(framework.ParticleSystemShapeBase));
        framework.ParticleSystemShapeCone = ParticleSystemShapeCone;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * 粒子系统 发射边
         *
         * @author feng3d
         */
        var ParticleSystemShapeEdge = /** @class */ (function (_super) {
            __extends(ParticleSystemShapeEdge, _super);
            function ParticleSystemShapeEdge() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            Object.defineProperty(ParticleSystemShapeEdge.prototype, "radius", {
                /**
                 * 边长的一半。
                 */
                get: function () {
                    return this._module.radius;
                },
                set: function (v) {
                    this._module.radius = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSystemShapeEdge.prototype, "radiusMode", {
                /**
                 * The mode used for generating particles around the radius.
                 *
                 * 在弧线周围产生粒子的模式。
                 */
                get: function () {
                    return this._module.radiusMode;
                },
                set: function (v) {
                    this._module.radiusMode = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSystemShapeEdge.prototype, "radiusSpread", {
                /**
                 * Control the gap between emission points around the radius.
                 *
                 * 控制弧线周围发射点之间的间隙。
                 */
                get: function () {
                    return this._module.radiusSpread;
                },
                set: function (v) {
                    this._module.radiusSpread = v;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(ParticleSystemShapeEdge.prototype, "radiusSpeed", {
                /**
                 * When using one of the animated modes, how quickly to move the emission position around the radius.
                 *
                 * 当使用一个动画模式时，如何快速移动发射位置周围的弧。
                 */
                get: function () {
                    return this._module.radiusSpeed;
                },
                set: function (v) {
                    this._module.radiusSpeed = v;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * 计算粒子的发射位置与方向
             *
             * @param particle
             * @param position
             * @param dir
             */
            ParticleSystemShapeEdge.prototype.calcParticlePosDir = function (particle, position, dir) {
                var arc = 360 * this.radius;
                // 在圆心的方向
                var radiusAngle = 0;
                if (this.radiusMode == framework.ParticleSystemShapeMultiModeValue.Random) {
                    radiusAngle = Math.random() * arc;
                }
                else if (this.radiusMode == framework.ParticleSystemShapeMultiModeValue.Loop) {
                    var totalAngle = particle.birthTime * this.radiusSpeed.getValue(particle.birthRateAtDuration) * 360;
                    radiusAngle = totalAngle % arc;
                }
                else if (this.radiusMode == framework.ParticleSystemShapeMultiModeValue.PingPong) {
                    var totalAngle = particle.birthTime * this.radiusSpeed.getValue(particle.birthRateAtDuration) * 360;
                    radiusAngle = totalAngle % arc;
                    if (Math.floor(totalAngle / arc) % 2 == 1) {
                        radiusAngle = arc - radiusAngle;
                    }
                }
                if (this.radiusSpread > 0) {
                    radiusAngle = Math.floor(radiusAngle / arc / this.radiusSpread) * arc * this.radiusSpread;
                }
                radiusAngle = radiusAngle / arc;
                // 计算位置
                dir.x = 0;
                dir.x = 1;
                dir.x = 0;
                position.x = this.radius * (radiusAngle * 2 - 1);
                position.y = 0;
                position.z = 0;
            };
            return ParticleSystemShapeEdge;
        }(framework.ParticleSystemShapeBase));
        framework.ParticleSystemShapeEdge = ParticleSystemShapeEdge;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * 从球体的体积中发射。
         *
         * @author feng3d
         */
        var ParticleSystemShapeSphere = /** @class */ (function (_super) {
            __extends(ParticleSystemShapeSphere, _super);
            function ParticleSystemShapeSphere() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * 是否从球面发射
                 */
                _this.emitFromShell = false;
                return _this;
            }
            Object.defineProperty(ParticleSystemShapeSphere.prototype, "radius", {
                /**
                 * 球体半径
                 */
                get: function () {
                    return this._module.radius;
                },
                set: function (v) {
                    this._module.radius = v;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * 计算粒子的发射位置与方向
             *
             * @param particle
             * @param position
             * @param dir
             */
            ParticleSystemShapeSphere.prototype.calcParticlePosDir = function (particle, position, dir) {
                //
                dir.x = Math.random() * 2 - 1;
                dir.y = Math.random() * 2 - 1;
                dir.z = Math.random() * 2 - 1;
                m4m.math.vec3Normalize(dir, dir);
                //
                position.x = this.radius * dir.x;
                position.y = this.radius * dir.y;
                position.z = this.radius * dir.z;
                if (!this.emitFromShell) {
                    var rand = Math.random();
                    position.x *= rand;
                    position.y *= rand;
                    position.z *= rand;
                }
            };
            return ParticleSystemShapeSphere;
        }(framework.ParticleSystemShapeBase));
        framework.ParticleSystemShapeSphere = ParticleSystemShapeSphere;
        /**
         * 从半球体的体积中发出。
         */
        var ParticleSystemShapeHemisphere = /** @class */ (function (_super) {
            __extends(ParticleSystemShapeHemisphere, _super);
            function ParticleSystemShapeHemisphere() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.radius = 1;
                /**
                 * 是否从球面发射
                 */
                _this.emitFromShell = false;
                return _this;
            }
            /**
             * 计算粒子的发射位置与方向
             *
             * @param particle
             * @param position
             * @param dir
             */
            ParticleSystemShapeHemisphere.prototype.calcParticlePosDir = function (particle, position, dir) {
                //
                dir.x = Math.random() * 2 - 1;
                dir.y = Math.random() * 2 - 1;
                dir.z = Math.random() * 2 - 1;
                m4m.math.vec3Normalize(dir, dir);
                dir.z = Math.abs(dir.z);
                //
                position.x = this.radius * dir.x;
                position.y = this.radius * dir.y;
                position.z = this.radius * dir.z;
                if (!this.emitFromShell) {
                    var rand = Math.random();
                    position.x *= rand;
                    position.y *= rand;
                    position.z *= rand;
                }
            };
            return ParticleSystemShapeHemisphere;
        }(framework.ParticleSystemShapeBase));
        framework.ParticleSystemShapeHemisphere = ParticleSystemShapeHemisphere;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var BJSCANNON;
        var CannonJSPlugin = /** @class */ (function () {
            //See https://github.com/schteppe/CANNON.js/blob/gh-pages/demos/collisionFilter.html
            // public BJSCANNON = CANNON;
            function CannonJSPlugin(_useDeltaForWorldStep, iterations) {
                if (_useDeltaForWorldStep === void 0) { _useDeltaForWorldStep = true; }
                if (iterations === void 0) { iterations = 10; }
                this._useDeltaForWorldStep = _useDeltaForWorldStep;
                this.BJSCANNON = CANNON || {};
                this.name = "CannonJSPlugin";
                this._physicsMaterials = new Array();
                this._fixedTimeStep = 1 / 60;
                if (!this.isSupported()) {
                    console.error("CannonJS is not available. Please make sure you included the js file.");
                    return;
                }
                // this._extendNamespace();
                this.world = new BJSCANNON.World();
                this.world.broadphase = new BJSCANNON.NaiveBroadphase();
                this.world.solver.iterations = iterations;
            }
            CannonJSPlugin.prototype.setGravity = function (gravity) {
                this.world.gravity.copy(gravity);
            };
            CannonJSPlugin.prototype.setTimeStep = function (timeStep) {
                this._fixedTimeStep = timeStep;
            };
            CannonJSPlugin.prototype.getTimeStep = function () {
                return this._fixedTimeStep;
            };
            CannonJSPlugin.prototype.executeStep = function (delta, impostors) {
                // this.world.step(this._fixedTimeStep );
                this.world.step(this._fixedTimeStep, this._useDeltaForWorldStep ? delta : 0, 3);
            };
            CannonJSPlugin.prototype.applyImpulse = function (impostor, force, contactPoint) {
                var worldPoint = new BJSCANNON.Vec3(contactPoint.x, contactPoint.y, contactPoint.z);
                var impulse = new BJSCANNON.Vec3(force.x, force.y, force.z);
                impostor.physicsBody.applyImpulse(impulse, worldPoint);
            };
            CannonJSPlugin.prototype.applyForce = function (impostor, force, contactPoint) {
                var worldPoint = new BJSCANNON.Vec3(contactPoint.x, contactPoint.y, contactPoint.z);
                var impulse = new BJSCANNON.Vec3(force.x, force.y, force.z);
                impostor.physicsBody.applyForce(impulse, worldPoint);
            };
            CannonJSPlugin.prototype.generatePhysicsBody = function (impostor) {
                //parent-child relationship. Does this impostor has a parent impostor?
                // if (impostor.parent) {
                //     if (impostor.physicsBody) {
                //         this.removePhysicsBody(impostor);
                //         //TODO is that needed?
                //         impostor.forceUpdate();
                //     }
                //     return;
                // }
                //should a new body be created for this impostor?
                if (impostor.isBodyInitRequired()) {
                    var shape = this._createShape(impostor);
                    //unregister events, if body is being changed
                    var oldBody = impostor.physicsBody;
                    if (oldBody) {
                        this.removePhysicsBody(impostor);
                    }
                    //create the body and material
                    var material = this._addMaterial("mat-" + impostor.uniqueId, impostor.getParam("friction"), impostor.getParam("restitution"));
                    var bodyCreationObject = {
                        mass: impostor.getParam("mass"),
                        material: material
                    };
                    // A simple extend, in case native options were used.
                    var nativeOptions = impostor.getParam("nativeOptions");
                    for (var key in nativeOptions) {
                        if (nativeOptions.hasOwnProperty(key)) {
                            bodyCreationObject[key] = nativeOptions[key];
                        }
                    }
                    impostor.physicsBody = new BJSCANNON.Body(bodyCreationObject);
                    impostor.physicsBody.addEventListener("collide", impostor.onCollide);
                    // this.world.addEventListener("preStep", impostor.beforeStep);
                    // this.world.addEventListener("postStep", impostor.afterStep);
                    impostor.physicsBody.addShape(shape);
                    this.world.add(impostor.physicsBody);
                    //try to keep the body moving in the right direction by taking old properties.
                    //Should be tested!
                    if (oldBody) {
                        ['force', 'torque', 'velocity', 'angularVelocity'].forEach(function (param) {
                            impostor.physicsBody[param].copy(oldBody[param]);
                        });
                    }
                    //this._processChildMeshes(impostor);
                }
                //now update the body's transformation
                // this._updatePhysicsBodyTransformation(impostor);
                impostor.physicsBody.position.copy(impostor.object.localPosition);
                impostor.physicsBody.quaternion.copy(impostor.object.localRotate);
            };
            // private _processChildMeshes(mainImpostor: PhysicsImpostor) {
            //     var meshChildren = mainImpostor.object.getChildMeshes ? mainImpostor.object.getChildMeshes(true) : [];
            //     let currentRotation: Nullable<Quaternion> = mainImpostor.object.rotationQuaternion;
            //     if (meshChildren.length) {
            //         var processMesh = (localPosition: Vector3, mesh: AbstractMesh) => {
            //             if (!currentRotation || !mesh.rotationQuaternion) {
            //                 return;
            //             }
            //             var childImpostor = mesh.getPhysicsImpostor();
            //             if (childImpostor) {
            //                 var parent = childImpostor.parent;
            //                 if (parent !== mainImpostor) {
            //                     var pPosition = mesh.getAbsolutePosition().subtract(mainImpostor.object.getAbsolutePosition());
            //                     let localRotation = mesh.rotationQuaternion.multiply(Quaternion.Inverse(currentRotation));
            //                     if (childImpostor.physicsBody) {
            //                         this.removePhysicsBody(childImpostor);
            //                         childImpostor.physicsBody = null;
            //                     }
            //                     childImpostor.parent = mainImpostor;
            //                     childImpostor.resetUpdateFlags();
            //                     mainImpostor.physicsBody.addShape(this._createShape(childImpostor), new BJSCANNON.Vec3(pPosition.x, pPosition.y, pPosition.z), new BJSCANNON.Quaternion(localRotation.x, localRotation.y, localRotation.z, localRotation.w));
            //                     //Add the mass of the children.
            //                     mainImpostor.physicsBody.mass += childImpostor.getParam("mass");
            //                 }
            //             }
            //             currentRotation.multiplyInPlace(mesh.rotationQuaternion);
            //             mesh.getChildMeshes(true).filter(m => !!m.physicsImpostor).forEach(processMesh.bind(this, mesh.getAbsolutePosition()));
            //         }
            //         meshChildren.filter(m => !!m.physicsImpostor).forEach(processMesh.bind(this, mainImpostor.object.getAbsolutePosition()));
            //     }
            // }
            CannonJSPlugin.prototype.removePhysicsBody = function (impostor) {
                impostor.physicsBody.removeEventListener("collide", impostor.onCollide);
                // this.world.removeEventListener("preStep", impostor.beforeStep);
                // this.world.removeEventListener("postStep", impostor.afterStep);
                this.world.remove(impostor.physicsBody);
            };
            CannonJSPlugin.prototype.generateJoint = function (impostorJoint) {
                var mainBody = impostorJoint.mainImpostor.physicsBody;
                var connectedBody = impostorJoint.connectedImpostor.physicsBody;
                if (!mainBody || !connectedBody) {
                    return;
                }
                var constraint;
                var jointData = impostorJoint.joint.jointData;
                //TODO - https://github.com/schteppe/this.BJSCANNON.js/blob/gh-pages/demos/collisionFilter.html
                var constraintData = {
                    pivotA: jointData.mainPivot ? new BJSCANNON.Vec3().copy(jointData.mainPivot) : null,
                    pivotB: jointData.connectedPivot ? new BJSCANNON.Vec3().copy(jointData.connectedPivot) : null,
                    axisA: jointData.mainAxis ? new BJSCANNON.Vec3().copy(jointData.mainAxis) : null,
                    axisB: jointData.connectedAxis ? new BJSCANNON.Vec3().copy(jointData.connectedAxis) : null,
                    maxForce: jointData.nativeParams.maxForce,
                    collideConnected: !!jointData.collision
                };
                switch (impostorJoint.joint.type) {
                    case framework.PhysicsJoint.HingeJoint:
                    case framework.PhysicsJoint.Hinge2Joint:
                        constraint = new BJSCANNON.HingeConstraint(mainBody, connectedBody, constraintData);
                        break;
                    case framework.PhysicsJoint.DistanceJoint:
                        constraint = new BJSCANNON.DistanceConstraint(mainBody, connectedBody, jointData.maxDistance || 2);
                        break;
                    case framework.PhysicsJoint.SpringJoint:
                        var springData = jointData;
                        constraint = new BJSCANNON.Spring(mainBody, connectedBody, {
                            restLength: springData.length,
                            stiffness: springData.stiffness,
                            damping: springData.damping,
                            localAnchorA: constraintData.pivotA,
                            localAnchorB: constraintData.pivotB
                        });
                        break;
                    case framework.PhysicsJoint.LockJoint:
                        constraint = new BJSCANNON.LockConstraint(mainBody, connectedBody, constraintData);
                        break;
                    case framework.PhysicsJoint.PointToPointJoint:
                    case framework.PhysicsJoint.BallAndSocketJoint:
                    default:
                        constraint = new BJSCANNON.PointToPointConstraint(mainBody, constraintData.pivotA, connectedBody, constraintData.pivotA, constraintData.maxForce);
                        break;
                }
                //set the collideConnected flag after the creation, since DistanceJoint ignores it.
                constraint.collideConnected = !!jointData.collision;
                impostorJoint.joint.physicsJoint = constraint;
                //don't add spring as constraint, as it is not one.
                if (impostorJoint.joint.type !== framework.PhysicsJoint.SpringJoint) {
                    this.world.addConstraint(constraint);
                }
                else {
                    impostorJoint.mainImpostor.registerAfterPhysicsStep(function () {
                        constraint.applyForce();
                    });
                }
            };
            CannonJSPlugin.prototype.removeJoint = function (impostorJoint) {
                this.world.removeConstraint(impostorJoint.joint.physicsJoint);
            };
            CannonJSPlugin.prototype._addMaterial = function (name, friction, restitution) {
                var index;
                var mat;
                for (index = 0; index < this._physicsMaterials.length; index++) {
                    mat = this._physicsMaterials[index];
                    if (mat.friction === friction && mat.restitution === restitution) {
                        return mat;
                    }
                }
                var currentMat = new BJSCANNON.Material(name);
                currentMat.friction = friction;
                currentMat.restitution = restitution;
                this._physicsMaterials.push(currentMat);
                return currentMat;
            };
            CannonJSPlugin.prototype._checkWithEpsilon = function (value) {
                return value < framework.PhysicsEngine.Epsilon ? framework.PhysicsEngine.Epsilon : value;
            };
            CannonJSPlugin.prototype._createShape = function (impostor) {
                var object = impostor.object;
                var returnValue;
                var extendSize = CannonJSPlugin.helpv3;
                m4m.math.vec3Clone(impostor.getObjectExtendSize(), extendSize);
                switch (impostor.type) {
                    case framework.ImpostorType.SphereImpostor:
                        var radiusX = extendSize.x;
                        var radiusY = extendSize.y;
                        var radiusZ = extendSize.z;
                        // let radius =impostor._options.radius;
                        // radius=this._checkWithEpsilon(radius);
                        // returnValue = new BJSCANNON.Sphere(radius);
                        returnValue = new BJSCANNON.Sphere(Math.max(this._checkWithEpsilon(radiusX), this._checkWithEpsilon(radiusY), this._checkWithEpsilon(radiusZ)) / 2);
                        break;
                    //TMP also for cylinder - TODO Cannon supports cylinder natively.
                    case framework.ImpostorType.CylinderImpostor:
                        console.warn("CylinderImpostor not handle yet");
                        //returnValue = new BJSCANNON.Cylinder(this._checkWithEpsilon(extendSize.x) / 2, this._checkWithEpsilon(extendSize.x) / 2, this._checkWithEpsilon(extendSize.y), 16);
                        var nativeParams = impostor.getParam("nativeOptions");
                        if (!nativeParams) {
                            nativeParams = {};
                        }
                        var radiusTop = nativeParams.radiusTop !== undefined ? nativeParams.radiusTop : this._checkWithEpsilon(extendSize.x) / 2;
                        var radiusBottom = nativeParams.radiusBottom !== undefined ? nativeParams.radiusBottom : this._checkWithEpsilon(extendSize.x) / 2;
                        var height = nativeParams.height !== undefined ? nativeParams.height : this._checkWithEpsilon(extendSize.y);
                        var numSegments = nativeParams.numSegments !== undefined ? nativeParams.numSegments : 16;
                        returnValue = new BJSCANNON.Cylinder(radiusTop, radiusBottom, height, numSegments);
                        // Rotate 90 degrees as this shape is horizontal in cannon
                        var quat = new BJSCANNON.Quaternion();
                        quat.setFromAxisAngle(new BJSCANNON.Vec3(1, 0, 0), -Math.PI / 2);
                        var translation = new BJSCANNON.Vec3(0, 0, 0);
                        returnValue.transformAllPoints(translation, quat);
                        break;
                    case framework.ImpostorType.BoxImpostor:
                        // // let box = extendSize.scale(0.5);
                        // let halfwidth=this._checkWithEpsilon(impostor._options.width/2.0);
                        // let halfheight=this._checkWithEpsilon(impostor._options.height/2.0);
                        // let halfdepth=this._checkWithEpsilon(impostor._options.depth/2.0);
                        // returnValue = new BJSCANNON.Box(new BJSCANNON.Vec3(halfwidth, halfheight, halfdepth));
                        m4m.math.vec3ScaleByNum(extendSize, 0.5, extendSize);
                        var box = extendSize;
                        returnValue = new BJSCANNON.Box(new BJSCANNON.Vec3(this._checkWithEpsilon(box.x), this._checkWithEpsilon(box.y), this._checkWithEpsilon(box.z)));
                        break;
                    case framework.ImpostorType.PlaneImpostor:
                        console.warn("Attention, PlaneImposter might not behave as you expect. Consider using BoxImposter instead");
                        returnValue = new BJSCANNON.Plane();
                        break;
                    case framework.ImpostorType.ConvexHullImpostor:
                        if (object && object.gameObject.components.length > 0) {
                            var mr = object.gameObject.getComponent("meshFilter");
                            if (mr) {
                                var verts_1 = [];
                                // mr.mesh.data.pos.forEach(p =>
                                // {
                                //     verts.push(new CANNON.Vec3(p.x, p.y, p.z));
                                // });
                                mr.mesh.data.foreachVertexData(function (v, i) {
                                    var p = v.pos;
                                    verts_1.push(new CANNON.Vec3(p.x, p.y, p.z));
                                });
                                var tris = [];
                                var dataTris = mr.mesh.data.trisindex;
                                var tLen = mr.mesh.data.getTriIndexCount();
                                for (var i = 0; i < tLen; i += 3) {
                                    //tris.push([dataTris[i], dataTris[i +1] ,dataTris[i +2]]);
                                    tris.push([dataTris[i + 2], dataTris[i + 1], dataTris[i]]);
                                }
                                returnValue = new BJSCANNON.ConvexPolyhedron(verts_1, tris);
                            }
                        }
                        break;
                    case framework.ImpostorType.MeshImpostor:
                        console.warn("MeshImpostor not handle yet");
                        // returnValue = new this.BJSCANNON.Trimesh(temp, <number[]>rawFaces);
                        break;
                    case framework.ImpostorType.HeightmapImpostor:
                        console.warn("HeightmapImpostor not handle yet");
                        // let matrix = impostor._options.heightFieldMatrix || [];
                        // let options = impostor._options.heightFieldOptions || {};
                        // returnValue = new CANNON.Heightfield(matrix , options);
                        break;
                    case framework.ImpostorType.ParticleImpostor:
                        returnValue = new BJSCANNON.Particle();
                        break;
                    case framework.ImpostorType.NoImpostor:
                        returnValue = new BJSCANNON.Box(new BJSCANNON.Vec3(0, 0, 0));
                        break;
                }
                return returnValue;
            };
            // private _createHeightmap(object: IPhysicsEnabledObject, pointDepth?: number) {
            //     var pos = <FloatArray>(object.getVerticesData(VertexBuffer.PositionKind));
            //     let transform = object.computeWorldMatrix(true);
            //     // convert rawVerts to object space
            //     var temp = new Array<number>();
            //     var index: number;
            //     for (index = 0; index < pos.length; index += 3) {
            //         Vector3.TransformCoordinates(Vector3.FromArray(pos, index), transform).toArray(temp, index);
            //     }
            //     pos = temp;
            //     var matrix = new Array<Array<any>>();
            //     //For now pointDepth will not be used and will be automatically calculated.
            //     //Future reference - try and find the best place to add a reference to the pointDepth variable.
            //     var arraySize = pointDepth || ~~(Math.sqrt(pos.length / 3) - 1);
            //     let boundingInfo = object.getBoundingInfo();
            //     var dim = Math.min(boundingInfo.boundingBox.extendSizeWorld.x, boundingInfo.boundingBox.extendSizeWorld.y);
            //     var minY = boundingInfo.boundingBox.extendSizeWorld.z;
            //     var elementSize = dim * 2 / arraySize;
            //     for (var i = 0; i < pos.length; i = i + 3) {
            //         var x = Math.round((pos[i + 0]) / elementSize + arraySize / 2);
            //         var z = Math.round(((pos[i + 1]) / elementSize - arraySize / 2) * -1);
            //         var y = -pos[i + 2] + minY;
            //         if (!matrix[x]) {
            //             matrix[x] = [];
            //         }
            //         if (!matrix[x][z]) {
            //             matrix[x][z] = y;
            //         }
            //         matrix[x][z] = Math.max(y, matrix[x][z]);
            //     }
            //     for (var x = 0; x <= arraySize; ++x) {
            //         if (!matrix[x]) {
            //             var loc = 1;
            //             while (!matrix[(x + loc) % arraySize]) {
            //                 loc++;
            //             }
            //             matrix[x] = matrix[(x + loc) % arraySize].slice();
            //             //console.log("missing x", x);
            //         }
            //         for (var z = 0; z <= arraySize; ++z) {
            //             if (!matrix[x][z]) {
            //                 var loc = 1;
            //                 var newValue;
            //                 while (newValue === undefined) {
            //                     newValue = matrix[x][(z + loc++) % arraySize];
            //                 }
            //                 matrix[x][z] = newValue;
            //             }
            //         }
            //     }
            //     var shape = new BJSCANNON.Heightfield(matrix, {
            //         elementSize: elementSize
            //     });
            //     //For future reference, needed for body transformation
            //     shape.minY = minY;
            //     return shape;
            // }
            // private _minus90X = new Quaternion(-0.7071067811865475, 0, 0, 0.7071067811865475);
            // private _plus90X = new Quaternion(0.7071067811865475, 0, 0, 0.7071067811865475);
            // private _tmpPosition: Vector3 = Vector3.Zero();
            // private _tmpDeltaPosition: Vector3 = Vector3.Zero();
            // private _tmpUnityRotation: Quaternion = new Quaternion();
            // private _updatePhysicsBodyTransformation(impostor: PhysicsImpostor) {
            //     var object = impostor.object;
            //     //make sure it is updated...
            //     object.computeWorldMatrix && object.computeWorldMatrix(true);
            //     // The delta between the mesh position and the mesh bounding box center
            //     let bInfo = object.getBoundingInfo();
            //     if (!bInfo) return;
            //     var center = impostor.getObjectCenter();
            //     //m.getAbsolutePosition().subtract(m.getBoundingInfo().boundingBox.centerWorld)
            //     this._tmpDeltaPosition.copyFrom(object.getAbsolutePivotPoint().subtract(center));
            //     this._tmpDeltaPosition.divideInPlace(impostor.object.scaling);
            //     this._tmpPosition.copyFrom(center);
            //     var quaternion = object.rotationQuaternion;
            //     if (!quaternion) {
            //         return;
            //     }
            //     //is shape is a plane or a heightmap, it must be rotated 90 degs in the X axis.
            //     if (impostor.type === PhysicsImpostor.PlaneImpostor || impostor.type === PhysicsImpostor.HeightmapImpostor || impostor.type === PhysicsImpostor.CylinderImpostor) {
            //         //-90 DEG in X, precalculated
            //         quaternion = quaternion.multiply(this._minus90X);
            //         //Invert! (Precalculated, 90 deg in X)
            //         //No need to clone. this will never change.
            //         impostor.setDeltaRotation(this._plus90X);
            //     }
            //     //If it is a heightfield, if should be centered.
            //     if (impostor.type === PhysicsImpostor.HeightmapImpostor) {
            //         var mesh = <AbstractMesh>(<any>object);
            //         let boundingInfo = mesh.getBoundingInfo();
            //         //calculate the correct body position:
            //         var rotationQuaternion = mesh.rotationQuaternion;
            //         mesh.rotationQuaternion = this._tmpUnityRotation;
            //         mesh.computeWorldMatrix(true);
            //         //get original center with no rotation
            //         var c = center.clone();
            //         var oldPivot = mesh.getPivotMatrix() || Matrix.Translation(0, 0, 0);
            //         //calculate the new center using a pivot (since BJSCANNON.js doesn't center height maps)
            //         var p = Matrix.Translation(boundingInfo.boundingBox.extendSizeWorld.x, 0, -boundingInfo.boundingBox.extendSizeWorld.z);
            //         mesh.setPreTransformMatrix(p);
            //         mesh.computeWorldMatrix(true);
            //         //calculate the translation
            //         var translation = boundingInfo.boundingBox.centerWorld.subtract(center).subtract(mesh.position).negate();
            //         this._tmpPosition.copyFromFloats(translation.x, translation.y - boundingInfo.boundingBox.extendSizeWorld.y, translation.z);
            //         //add it inverted to the delta
            //         this._tmpDeltaPosition.copyFrom(boundingInfo.boundingBox.centerWorld.subtract(c));
            //         this._tmpDeltaPosition.y += boundingInfo.boundingBox.extendSizeWorld.y;
            //         //rotation is back
            //         mesh.rotationQuaternion = rotationQuaternion;
            //         mesh.setPreTransformMatrix(oldPivot);
            //         mesh.computeWorldMatrix(true);
            //     } else if (impostor.type === PhysicsImpostor.MeshImpostor) {
            //         this._tmpDeltaPosition.copyFromFloats(0, 0, 0);
            //         //this._tmpPosition.copyFrom(object.position);
            //     }
            //     impostor.setDeltaPosition(this._tmpDeltaPosition);
            //     //Now update the impostor object
            //     impostor.physicsBody.position.copy(this._tmpPosition);
            //     impostor.physicsBody.quaternion.copy(quaternion);
            // }
            CannonJSPlugin.prototype.vec3Copy = function (from, to) {
                // to.rawData[0]=from.x;
                // to.rawData[1]=from.y;
                // to.rawData[2]=from.z;
                to.x = from.x;
                to.y = from.y;
                to.z = from.z;
            };
            CannonJSPlugin.prototype.QuatCopy = function (from, to) {
                // to.rawData[0] = from.x;
                // to.rawData[1] = from.y;
                // to.rawData[2] = from.z;
                // to.rawData[3] = from.w;
                to.x = from.x;
                to.y = from.y;
                to.z = from.z;
                to.w = from.w;
            };
            CannonJSPlugin.prototype.setTransformationFromPhysicsBody = function (impostor) {
                this.vec3Copy(impostor.physicsBody.position, impostor.object.localPosition);
                this.QuatCopy(impostor.physicsBody.quaternion, impostor.object.localRotate);
                // impostor.object.position.copyFrom(impostor.physicsBody.position);
                // if (impostor.object.rotationQuaternion) {
                //     impostor.object.rotationQuaternion.copyFrom(impostor.physicsBody.quaternion);
                // }
            };
            CannonJSPlugin.prototype.setPhysicsBodyTransformation = function (impostor, newPosition, newRotation) {
                impostor.physicsBody.position.copy(newPosition);
                impostor.physicsBody.quaternion.copy(newRotation);
            };
            CannonJSPlugin.prototype.isSupported = function () {
                return BJSCANNON !== undefined;
            };
            CannonJSPlugin.prototype.setLinearVelocity = function (impostor, velocity) {
                impostor.physicsBody.velocity.copy(velocity);
            };
            CannonJSPlugin.prototype.setAngularVelocity = function (impostor, velocity) {
                impostor.physicsBody.angularVelocity.copy(velocity);
            };
            CannonJSPlugin.prototype.getLinearVelocity = function (impostor) {
                var v = impostor.physicsBody.velocity;
                if (!v) {
                    return null;
                }
                return new m4m.math.vector3(v.x, v.y, v.z);
            };
            CannonJSPlugin.prototype.getAngularVelocity = function (impostor) {
                var v = impostor.physicsBody.angularVelocity;
                if (!v) {
                    return null;
                }
                return new m4m.math.vector3(v.x, v.y, v.z);
            };
            CannonJSPlugin.prototype.setBodyMass = function (impostor, mass) {
                impostor.physicsBody.mass = mass;
                impostor.physicsBody.updateMassProperties();
            };
            CannonJSPlugin.prototype.getBodyMass = function (impostor) {
                return impostor.physicsBody.mass;
            };
            CannonJSPlugin.prototype.getBodyFriction = function (impostor) {
                return impostor.physicsBody.material.friction;
            };
            CannonJSPlugin.prototype.setBodyFriction = function (impostor, friction) {
                impostor.physicsBody.material.friction = friction;
            };
            CannonJSPlugin.prototype.getBodyRestitution = function (impostor) {
                return impostor.physicsBody.material.restitution;
            };
            CannonJSPlugin.prototype.setBodyRestitution = function (impostor, restitution) {
                impostor.physicsBody.material.restitution = restitution;
            };
            CannonJSPlugin.prototype.sleepBody = function (impostor) {
                impostor.physicsBody.sleep();
            };
            CannonJSPlugin.prototype.isSleeping = function (impostor) {
                //return impostor.physicsBody.sleeping;
                return false;
            };
            CannonJSPlugin.prototype.wakeUpBody = function (impostor) {
                impostor.physicsBody.wakeUp();
            };
            CannonJSPlugin.prototype.updateDistanceJoint = function (joint, maxDistance, minDistance) {
                joint.physicsJoint.distance = maxDistance;
            };
            // private enableMotor(joint: IMotorEnabledJoint, motorIndex?: number) {
            //     if (!motorIndex) {
            //         joint.physicsJoint.enableMotor();
            //     }
            // }
            // private disableMotor(joint: IMotorEnabledJoint, motorIndex?: number) {
            //     if (!motorIndex) {
            //         joint.physicsJoint.disableMotor();
            //     }
            // }
            CannonJSPlugin.prototype.setMotor = function (joint, speed, maxForce, motorIndex) {
                if (!motorIndex) {
                    joint.physicsJoint.enableMotor();
                    joint.physicsJoint.setMotorSpeed(speed);
                    if (maxForce) {
                        this.setLimit(joint, maxForce);
                    }
                }
            };
            CannonJSPlugin.prototype.setLimit = function (joint, upperLimit, lowerLimit) {
                joint.physicsJoint.motorEquation.maxForce = upperLimit;
                joint.physicsJoint.motorEquation.minForce = lowerLimit === void 0 ? -upperLimit : lowerLimit;
            };
            // public syncMeshWithImpostor(mesh: AbstractMesh, impostor: PhysicsImpostor) {
            //     var body = impostor.physicsBody;
            //     mesh.position.x = body.position.x;
            //     mesh.position.y = body.position.y;
            //     mesh.position.z = body.position.z;
            //     if (mesh.rotationQuaternion) {
            //         mesh.rotationQuaternion.x = body.quaternion.x;
            //         mesh.rotationQuaternion.y = body.quaternion.y;
            //         mesh.rotationQuaternion.z = body.quaternion.z;
            //         mesh.rotationQuaternion.w = body.quaternion.w;
            //     }
            // }
            CannonJSPlugin.prototype.getRadius = function (impostor) {
                var shape = impostor.physicsBody.shapes[0];
                return shape.boundingSphereRadius;
            };
            CannonJSPlugin.prototype.getBoxSizeToRef = function (impostor, result) {
                var shape = impostor.physicsBody.shapes[0];
                result.x = shape.halfExtents.x * 2;
                result.y = shape.halfExtents.y * 2;
                result.z = shape.halfExtents.z * 2;
            };
            CannonJSPlugin.prototype.dispose = function () {
            };
            CannonJSPlugin.prototype._extendNamespace = function () {
                //this will force cannon to execute at least one step when using interpolation
                var step_tmp1 = new BJSCANNON.Vec3();
                var Engine = BJSCANNON;
                BJSCANNON.World.prototype.step = function (dt, timeSinceLastCalled, maxSubSteps) {
                    maxSubSteps = maxSubSteps || 10;
                    timeSinceLastCalled = timeSinceLastCalled || 0;
                    if (timeSinceLastCalled === 0) {
                        this.internalStep(dt);
                        this.time += dt;
                    }
                    else {
                        var internalSteps = Math.floor((this.time + timeSinceLastCalled) / dt) - Math.floor(this.time / dt);
                        internalSteps = Math.min(internalSteps, maxSubSteps) || 1;
                        var t0 = performance.now();
                        for (var i = 0; i !== internalSteps; i++) {
                            this.internalStep(dt);
                            if (performance.now() - t0 > dt * 1000) {
                                break;
                            }
                        }
                        this.time += timeSinceLastCalled;
                        var h = this.time % dt;
                        var h_div_dt = h / dt;
                        var interpvelo = step_tmp1;
                        var bodies = this.bodies;
                        for (var j = 0; j !== bodies.length; j++) {
                            var b = bodies[j];
                            if (b.type !== Engine.Body.STATIC && b.sleepState !== Engine.Body.SLEEPING) {
                                b.position.vsub(b.previousPosition, interpvelo);
                                interpvelo.scale(h_div_dt, interpvelo);
                                b.position.vadd(interpvelo, b.interpolatedPosition);
                            }
                            else {
                                b.interpolatedPosition.copy(b.position);
                                b.interpolatedQuaternion.copy(b.quaternion);
                            }
                        }
                    }
                };
            };
            CannonJSPlugin.helpv3 = new m4m.math.vector3();
            return CannonJSPlugin;
        }());
        framework.CannonJSPlugin = CannonJSPlugin;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /** OimoJS physic engine Plugin  */
        var OimoJSPlugin = /** @class */ (function () {
            // private _raycastResult: PhysicsRaycastResult;
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * OimoJS 物理引擎插件
            * @param option Oimo world 构造选项
            * @param oimoInjection Omio对象
            * @version m4m 1.0
            */
            function OimoJSPlugin(iterations, oimoInjection) {
                if (oimoInjection === void 0) { oimoInjection = OIMO; }
                this.name = "OIMOJSPlugin";
                this._physicsMaterials = new Array();
                this._fixedTimeStep = 1 / 60;
                this._tmpImpostorsArray = [];
                this._tmpPositionVector = new m4m.math.vector3();
                this.BJSOIMO = oimoInjection;
                if (!this.isSupported()) {
                    console.error("OIMO is not available. Please make sure you included the js file.");
                    return;
                }
                var opt = {
                    iterations: iterations,
                };
                this.world = new this.BJSOIMO.World(opt);
                this.world.clear();
                // this.world = new BJSCANNON.World();
                // this.world.broadphase = new BJSCANNON.NaiveBroadphase();
                // this.world.solver.iterations = iterations;
            }
            OimoJSPlugin.prototype.setGravity = function (gravity) {
                this.world.gravity.copy(gravity);
            };
            OimoJSPlugin.prototype.setTimeStep = function (timeStep) {
                this.world.timeStep = timeStep;
            };
            OimoJSPlugin.prototype.getTimeStep = function () {
                return this.world.timeStep;
            };
            OimoJSPlugin.prototype.executeStep = function (delta, impostors) {
                // this.world.step(this._fixedTimeStep , this._useDeltaForWorldStep ? delta : 0, 3);
                var _this = this;
                impostors.forEach(function (impostor) {
                    impostor.beforeStep();
                });
                this.world.step();
                impostors.forEach(function (impostor) {
                    impostor.afterStep();
                    //update the ordered impostors array
                    _this._tmpImpostorsArray[impostor.uniqueId] = impostor;
                });
                //check for collisions
                var contact = this.world.contacts;
                while (contact !== null) {
                    if (contact.touching && !contact.body1.sleeping && !contact.body2.sleeping) {
                        contact = contact.next;
                        continue;
                    }
                    //is this body colliding with any other? get the impostor
                    var mainImpostor = this._tmpImpostorsArray[+contact.body1.name];
                    var collidingImpostor = this._tmpImpostorsArray[+contact.body2.name];
                    if (!mainImpostor || !collidingImpostor) {
                        contact = contact.next;
                        continue;
                    }
                    mainImpostor.onCollide({ body: collidingImpostor.physicsBody });
                    collidingImpostor.onCollide({ body: mainImpostor.physicsBody });
                    contact = contact.next;
                }
            };
            /** 申请 冲量 */
            OimoJSPlugin.prototype.applyImpulse = function (impostor, force, contactPoint) {
                var mass = impostor.physicsBody.mass;
                var _point = OimoJSPlugin.helpv3;
                m4m.math.vec3ScaleByNum(contactPoint, this.world.invScale, _point);
                var _force = OimoJSPlugin.helpv3_1;
                m4m.math.vec3ScaleByNum(force, this.world.invScale * mass, _force);
                impostor.physicsBody.applyImpulse(_point, _force);
            };
            OimoJSPlugin.prototype.applyForce = function (impostor, force, contactPoint) {
                console.warn("Oimo doesn't support applying force. Using impule instead.");
                this.applyImpulse(impostor, force, contactPoint);
            };
            OimoJSPlugin.prototype.checkWithEpsilon = function (value) {
                return Math.max(value, framework.PhysicsEngine.Epsilon);
            };
            OimoJSPlugin.prototype.generatePhysicsBody = function (impostor) {
                var _this = this;
                //parent-child relationship. Does this impostor has a parent impostor?
                if (impostor.parent) {
                    if (impostor.physicsBody) {
                        this.removePhysicsBody(impostor);
                        //TODO is that needed?
                        impostor.forceUpdate();
                    }
                    return;
                }
                if (impostor.isBodyInitRequired()) {
                    var bodyConfig_1 = {
                        name: impostor.uniqueId,
                        //Oimo must have mass, also for static objects.
                        config: [impostor.getParam("mass") || 1, impostor.getParam("friction"), impostor.getParam("restitution")],
                        size: [],
                        type: [],
                        pos: [],
                        posShape: [],
                        rot: [],
                        rotShape: [],
                        move: impostor.getParam("mass") !== 0,
                        density: impostor.getParam("mass"),
                        friction: impostor.getParam("friction"),
                        restitution: impostor.getParam("restitution"),
                        kinematic: impostor.getParam("kinematic"),
                        //Supporting older versions of Oimo
                        world: this.world
                    };
                    var impostors = [impostor];
                    if (impostor.object.children) {
                        impostor.object.children.forEach(function (m) {
                            if (m.physicsImpostor) {
                                impostors.push(m.physicsImpostor);
                                //m.physicsImpostor._init();
                            }
                        });
                    }
                    var globalQuat_1 = OimoJSPlugin.helpquat; //是否能用 缓存？
                    globalQuat_1.x = globalQuat_1.y = globalQuat_1.z = 0;
                    globalQuat_1.w = 1;
                    var wPos_impostor_1 = impostor.object.getWorldPosition();
                    impostors.forEach(function (i) {
                        //get the correct bounding box
                        var oldQuaternion = i.object.localRotate;
                        m4m.math.quatClone(i.object.localRotate, globalQuat_1);
                        var rot = OimoJSPlugin.helpv3;
                        m4m.math.quatToEulerAngles(oldQuaternion, rot);
                        // rot = oldQuaternion.toEulerAngles();
                        console.log(_this._tmpPositionVector);
                        var extendSize = i.getObjectExtendSize();
                        var radToDeg = 57.295779513082320876;
                        if (i === impostor) {
                            var center = impostor.getObjectCenter();
                            // let wpos = impostor.object.getWorldPosition();
                            // let scale = help_v3_1;
                            // math.vec3Clone(impostor.object.getWorldScale(),scale);
                            // scale.x = 1/scale.x ; scale.y = 1/scale.y ; scale.z = 1/scale.z ;
                            // math.vec3Subtract(wpos,center,this._tmpPositionVector);
                            // math.vec3ScaleByVec3(this._tmpPositionVector, scale ,this._tmpPositionVector);
                            // impostor.object.getAbsolutePivotPoint().subtractToRef(center, this._tmpPositionVector);
                            // this._tmpPositionVector.divideInPlace(impostor.object.scaling);
                            //Can also use Array.prototype.push.apply
                            bodyConfig_1.pos.push(center.x);
                            bodyConfig_1.pos.push(center.y);
                            bodyConfig_1.pos.push(center.z);
                            bodyConfig_1.posShape.push(0, 0, 0);
                            bodyConfig_1.rotShape.push(0, 0, 0);
                        }
                        else {
                            // math.vec3Subtract(i.object.getWorldPosition(),impostor.object.getWorldPosition() ,localPosition );
                            // math.vec3Clone(i.object.getWorldPosition() ,localPosition);
                            // let localPosition = i.object.getAbsolutePosition().subtract(impostor.object.getAbsolutePosition());
                            var localPosition = OimoJSPlugin.helpv3_2;
                            m4m.math.vec3Subtract(i.object.getWorldPosition(), wPos_impostor_1, localPosition); //子物体世界坐标 与 主物体世界坐标 的差值
                            // bodyConfig.pos.push(0, 0, 0);
                            bodyConfig_1.posShape.push(localPosition.x);
                            bodyConfig_1.posShape.push(localPosition.y);
                            bodyConfig_1.posShape.push(localPosition.z);
                            bodyConfig_1.rotShape.push(rot.x * radToDeg);
                            bodyConfig_1.rotShape.push(rot.y * radToDeg);
                            bodyConfig_1.rotShape.push(rot.z * radToDeg);
                        }
                        var sizeX, sizeY, sizeZ;
                        // register mesh
                        switch (i.type) {
                            case framework.ImpostorType.ParticleImpostor:
                                console.warn("No Particle support in OIMO.js. using SphereImpostor instead");
                            case framework.ImpostorType.SphereImpostor:
                                var radiusX = extendSize.x;
                                var radiusY = extendSize.y;
                                var radiusZ = extendSize.z;
                                var size = Math.max(_this.checkWithEpsilon(radiusX), _this.checkWithEpsilon(radiusY), _this.checkWithEpsilon(radiusZ)) / 2;
                                bodyConfig_1.type.push('sphere');
                                //due to the way oimo works with compounds, add 3 times
                                bodyConfig_1.size.push(size);
                                bodyConfig_1.size.push(size);
                                bodyConfig_1.size.push(size);
                                break;
                            case framework.ImpostorType.CylinderImpostor:
                                sizeX = _this.checkWithEpsilon(extendSize.x) / 2;
                                sizeY = _this.checkWithEpsilon(extendSize.y);
                                bodyConfig_1.type.push('cylinder');
                                bodyConfig_1.size.push(sizeX);
                                bodyConfig_1.size.push(sizeY);
                                //due to the way oimo works with compounds, add one more value.
                                bodyConfig_1.size.push(sizeY);
                                break;
                            case framework.ImpostorType.PlaneImpostor:
                            case framework.ImpostorType.NoImpostor:
                            case framework.ImpostorType.BoxImpostor:
                            default:
                                sizeX = _this.checkWithEpsilon(extendSize.x);
                                sizeY = _this.checkWithEpsilon(extendSize.y);
                                sizeZ = _this.checkWithEpsilon(extendSize.z);
                                bodyConfig_1.type.push('box');
                                //if (i === impostor) {
                                bodyConfig_1.size.push(sizeX);
                                bodyConfig_1.size.push(sizeY);
                                bodyConfig_1.size.push(sizeZ);
                                //} else {
                                //    bodyConfig.size.push(0,0,0);
                                //}
                                break;
                        }
                        // //actually not needed, but hey...
                        i.object.localRotate = oldQuaternion;
                    });
                    impostor.physicsBody = this.world.add(bodyConfig_1);
                    // set the quaternion, ignoring the previously defined (euler) rotation
                    impostor.physicsBody.resetQuaternion(globalQuat_1);
                    // update with delta 0, so the body will reveive the new rotation.
                    impostor.physicsBody.updatePosition(0);
                    //计算重心对显示模型原点的偏差
                    var massCenter = OimoJSPlugin.helpv3;
                    var p = impostor.physicsBody.position;
                    m4m.math.vec3Set(massCenter, p.x, p.y, p.z);
                    impostor.physicsBody.position;
                    var wpos = impostor.object.getWorldPosition();
                    if (!m4m.math.vec3Equal(massCenter, wpos)) {
                        var scale = OimoJSPlugin.helpv3_1;
                        m4m.math.vec3Clone(impostor.object.getWorldScale(), scale);
                        scale.x = 1 / scale.x;
                        scale.y = 1 / scale.y;
                        scale.z = 1 / scale.z;
                        m4m.math.vec3Subtract(wpos, massCenter, this._tmpPositionVector);
                        m4m.math.vec3ScaleByVec3(this._tmpPositionVector, scale, this._tmpPositionVector);
                    }
                }
                else {
                    this._tmpPositionVector.x = this._tmpPositionVector.y = this._tmpPositionVector.z = 0;
                }
                impostor.setDeltaPosition(this._tmpPositionVector);
            };
            OimoJSPlugin.prototype.removePhysicsBody = function (impostor) {
                // impostor.physicsBody.removeEventListener("collide", impostor.onCollide);
                // this.world.removeEventListener("preStep", impostor.beforeStep);
                // this.world.removeEventListener("postStep", impostor.afterStep);
                this.world.removeRigidBody(impostor.physicsBody);
            };
            OimoJSPlugin.prototype.generateJoint = function (impostorJoint) {
                var mainBody = impostorJoint.mainImpostor.physicsBody;
                var connectedBody = impostorJoint.connectedImpostor.physicsBody;
                if (!mainBody || !connectedBody) {
                    return;
                }
                var jointData = impostorJoint.joint.jointData;
                var options = jointData.nativeParams || {};
                var type;
                var nativeJointData = {
                    body1: mainBody,
                    body2: connectedBody,
                    axe1: options.axe1 || (jointData.mainAxis ? framework.physicTool.vec3AsArray(jointData.mainAxis) : null),
                    axe2: options.axe2 || (jointData.connectedAxis ? framework.physicTool.vec3AsArray(jointData.connectedAxis) : null),
                    pos1: options.pos1 || (jointData.mainPivot ? framework.physicTool.vec3AsArray(jointData.mainPivot) : null),
                    pos2: options.pos2 || (jointData.connectedPivot ? framework.physicTool.vec3AsArray(jointData.connectedPivot) : null),
                    min: options.min,
                    max: options.max,
                    collision: options.collision || jointData.collision,
                    spring: options.spring,
                    //supporting older version of Oimo
                    world: this.world
                };
                switch (impostorJoint.joint.type) {
                    case framework.PhysicsJoint.BallAndSocketJoint:
                        type = "jointBall";
                        break;
                    case framework.PhysicsJoint.SpringJoint:
                        console.warn("OIMO.js doesn't support Spring Constraint. Simulating using DistanceJoint instead");
                        var springData = jointData;
                        nativeJointData.min = springData.length || nativeJointData.min;
                        //Max should also be set, just make sure it is at least min
                        nativeJointData.max = Math.max(nativeJointData.min, nativeJointData.max);
                    case framework.PhysicsJoint.DistanceJoint:
                        type = "jointDistance";
                        nativeJointData.max = jointData.maxDistance;
                        break;
                    case framework.PhysicsJoint.PrismaticJoint:
                        type = "jointPrisme";
                        break;
                    case framework.PhysicsJoint.SliderJoint:
                        type = "jointSlide";
                        break;
                    case framework.PhysicsJoint.WheelJoint:
                        type = "jointWheel";
                        break;
                    case framework.PhysicsJoint.HingeJoint:
                    default:
                        type = "jointHinge";
                        break;
                }
                nativeJointData.type = type;
                impostorJoint.joint.physicsJoint = this.world.add(nativeJointData);
            };
            OimoJSPlugin.prototype.removeJoint = function (impostorJoint) {
                try {
                    this.world.removeConstraint(impostorJoint.joint.physicsJoint);
                }
                catch (e) {
                    console.warn(e);
                }
            };
            OimoJSPlugin.prototype.setTransformationFromPhysicsBody = function (impostor) {
                framework.physicTool.Ivec3Copy(impostor.physicsBody.position, impostor.object.localPosition);
                framework.physicTool.IQuatCopy(impostor.physicsBody.quaternion, impostor.object.localRotate);
                var obj = impostor.object;
                if (obj.parent && obj.parent.parent) { //world 不等同 local 坐标空间时 设置到 世界空间
                    obj.setWorldRotate(obj.localRotate);
                    obj.setWorldPosition(obj.localPosition);
                }
                // impostor.object.position.copyFrom(impostor.physicsBody.position);
                // if (impostor.object.rotationQuaternion) {
                //     impostor.object.rotationQuaternion.copyFrom(impostor.physicsBody.quaternion);
                // }
            };
            OimoJSPlugin.prototype.setPhysicsBodyTransformation = function (impostor, newPosition, newRotation) {
                impostor.physicsBody.position.copy(newPosition);
                impostor.physicsBody.quaternion.copy(newRotation);
                impostor.physicsBody.syncShapes();
                impostor.physicsBody.awake();
            };
            OimoJSPlugin.prototype.isSupported = function () {
                return this.BJSOIMO !== undefined;
            };
            OimoJSPlugin.prototype.setLinearVelocity = function (impostor, velocity) {
                impostor.physicsBody.velocity.copy(velocity);
            };
            OimoJSPlugin.prototype.setAngularVelocity = function (impostor, velocity) {
                impostor.physicsBody.angularVelocity.copy(velocity);
            };
            OimoJSPlugin.prototype.getLinearVelocity = function (impostor) {
                var v = impostor.physicsBody.velocity;
                if (!v) {
                    return null;
                }
                return new m4m.math.vector3(v.x, v.y, v.z);
            };
            OimoJSPlugin.prototype.getAngularVelocity = function (impostor) {
                var v = impostor.physicsBody.angularVelocity;
                if (!v) {
                    return null;
                }
                return new m4m.math.vector3(v.x, v.y, v.z);
            };
            OimoJSPlugin.prototype.setBodyMass = function (impostor, mass) {
                var staticBody = mass === 0;
                //this will actually set the body's density and not its mass.
                //But this is how oimo treats the mass variable.
                impostor.physicsBody.shapes.density = staticBody ? 1 : mass;
                impostor.physicsBody.setupMass(staticBody ? 0x2 : 0x1);
            };
            OimoJSPlugin.prototype.getBodyMass = function (impostor) {
                return impostor.physicsBody.shapes.density;
            };
            OimoJSPlugin.prototype.getBodyFriction = function (impostor) {
                return impostor.physicsBody.shapes.friction;
            };
            OimoJSPlugin.prototype.setBodyFriction = function (impostor, friction) {
                impostor.physicsBody.shapes.friction = friction;
            };
            OimoJSPlugin.prototype.getBodyRestitution = function (impostor) {
                return impostor.physicsBody.shapes.restitution;
            };
            OimoJSPlugin.prototype.setBodyRestitution = function (impostor, restitution) {
                impostor.physicsBody.shapes.restitution = restitution;
            };
            OimoJSPlugin.prototype.sleepBody = function (impostor) {
                impostor.physicsBody.sleep();
            };
            OimoJSPlugin.prototype.isSleeping = function (impostor) {
                return impostor.physicsBody.sleeping;
            };
            OimoJSPlugin.prototype.wakeUpBody = function (impostor) {
                impostor.physicsBody.awake();
            };
            OimoJSPlugin.prototype.updateDistanceJoint = function (joint, maxDistance, minDistance) {
                joint.physicsJoint.limitMotor.upperLimit = maxDistance;
                if (minDistance !== void 0) {
                    joint.physicsJoint.limitMotor.lowerLimit = minDistance;
                }
            };
            OimoJSPlugin.prototype.setMotor = function (joint, speed, force, motorIndex) {
                if (force !== undefined) {
                    console.warn("OimoJS plugin currently has unexpected behavior when using setMotor with force parameter");
                }
                else {
                    force = 1e6;
                }
                speed *= -1;
                //TODO separate rotational and transational motors.
                var motor = motorIndex ? joint.physicsJoint.rotationalLimitMotor2 : joint.physicsJoint.rotationalLimitMotor1 || joint.physicsJoint.rotationalLimitMotor || joint.physicsJoint.limitMotor;
                if (motor) {
                    motor.setMotor(speed, force);
                }
            };
            OimoJSPlugin.prototype.setLimit = function (joint, upperLimit, lowerLimit, motorIndex) {
                //TODO separate rotational and transational motors.
                var motor = motorIndex ? joint.physicsJoint.rotationalLimitMotor2 : joint.physicsJoint.rotationalLimitMotor1 || joint.physicsJoint.rotationalLimitMotor || joint.physicsJoint.limitMotor;
                if (motor) {
                    motor.setLimit(upperLimit, lowerLimit === void 0 ? -upperLimit : lowerLimit);
                }
            };
            // public syncMeshWithImpostor(mesh: AbstractMesh, impostor: PhysicsImpostor) {
            //     var body = impostor.physicsBody;
            //     mesh.position.x = body.position.x;
            //     mesh.position.y = body.position.y;
            //     mesh.position.z = body.position.z;
            //     if (mesh.rotationQuaternion) {
            //         mesh.rotationQuaternion.x = body.orientation.x;
            //         mesh.rotationQuaternion.y = body.orientation.y;
            //         mesh.rotationQuaternion.z = body.orientation.z;
            //         mesh.rotationQuaternion.w = body.orientation.s;
            //     }
            // }
            OimoJSPlugin.prototype.getRadius = function (impostor) {
                return impostor.physicsBody.shapes.radius;
            };
            OimoJSPlugin.prototype.getBoxSizeToRef = function (impostor, result) {
                var shape = impostor.physicsBody.shapes;
                result.x = shape.halfWidth * 2;
                result.y = shape.halfHeight * 2;
                result.z = shape.halfDepth * 2;
            };
            OimoJSPlugin.prototype.dispose = function () {
                this.world.clear();
            };
            OimoJSPlugin.helpquat = new m4m.math.quaternion();
            OimoJSPlugin.helpv3 = new m4m.math.vector3();
            OimoJSPlugin.helpv3_1 = new m4m.math.vector3();
            OimoJSPlugin.helpv3_2 = new m4m.math.vector3();
            return OimoJSPlugin;
        }());
        framework.OimoJSPlugin = OimoJSPlugin;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var PhysicsEngine = /** @class */ (function () {
            /**
             * Creates a new Physics Engine
             * @param gravity defines the gravity vector used by the simulation
             * @param _physicsPlugin defines the plugin to use (CannonJS by default)
             */
            function PhysicsEngine(gravity, _physicsPlugin) {
                if (gravity === void 0) { gravity = null; }
                if (_physicsPlugin === void 0) { _physicsPlugin = new framework.CannonJSPlugin(); }
                this._physicsPlugin = _physicsPlugin;
                //new methods and parameters
                this._impostors = [];
                this._joints = [];
                if (!this._physicsPlugin.isSupported()) {
                    throw new Error("Physics Engine " + this._physicsPlugin.name + " cannot be found. "
                        + "Please make sure it is included.");
                }
                gravity = gravity || new m4m.math.vector3(0, -9.807, 0);
                this.setGravity(gravity);
                this.setTimeStep();
            }
            /**
             * Sets the gravity vector used by the simulation
             * @param gravity defines the gravity vector to use
             */
            PhysicsEngine.prototype.setGravity = function (gravity) {
                this.gravity = gravity;
                this._physicsPlugin.setGravity(this.gravity);
            };
            /**
             * Set the time step of the physics engine.
             * default is 1/60.
             * To slow it down, enter 1/600 for example.
             * To speed it up, 1/30
             * @param {number} newTimeStep the new timestep to apply to this world.
             */
            PhysicsEngine.prototype.setTimeStep = function (newTimeStep) {
                if (newTimeStep === void 0) { newTimeStep = 1 / 60; }
                this._physicsPlugin.setTimeStep(newTimeStep);
            };
            /**
             * Get the time step of the physics engine.
             */
            PhysicsEngine.prototype.getTimeStep = function () {
                return this._physicsPlugin.getTimeStep();
            };
            /**
             * dispose all impostor of the physics engine.
             */
            PhysicsEngine.prototype.dispose = function () {
                this._impostors.forEach(function (impostor) {
                    impostor.dispose();
                });
                this._physicsPlugin.dispose();
            };
            PhysicsEngine.prototype.getPhysicsPluginName = function () {
                return this._physicsPlugin.name;
            };
            /**
             * Adding a new impostor for the impostor tracking.
             * This will be done by the impostor itself.
             * @param {PhysicsImpostor} impostor the impostor to add
             */
            PhysicsEngine.prototype.addImpostor = function (impostor) {
                impostor.uniqueId = this._impostors.push(impostor);
                //if no parent, generate the body
                // if (!impostor.parent) {
                //     this._physicsPlugin.generatePhysicsBody(impostor);
                // }
                this._physicsPlugin.generatePhysicsBody(impostor);
            };
            /**
             * Remove an impostor from the engine.
             * This impostor and its mesh will not longer be updated by the physics engine.
             * @param {PhysicsImpostor} impostor the impostor to remove
             */
            PhysicsEngine.prototype.removeImpostor = function (impostor) {
                var index = this._impostors.indexOf(impostor);
                if (index > -1) {
                    var removed = this._impostors.splice(index, 1);
                    //Is it needed?
                    if (removed.length) {
                        //this will also remove it from the world.
                        removed[0].physicsBody = null;
                    }
                }
            };
            /**
             * Add a joint to the physics engine
             * @param {PhysicsImpostor} mainImpostor the main impostor to which the joint is added.
             * @param {PhysicsImpostor} connectedImpostor the impostor that is connected to the main impostor using this joint
             * @param {PhysicsJoint} the joint that will connect both impostors.
             */
            PhysicsEngine.prototype.addJoint = function (mainImpostor, connectedImpostor, joint) {
                var impostorJoint = {
                    mainImpostor: mainImpostor,
                    connectedImpostor: connectedImpostor,
                    joint: joint
                };
                joint.physicsPlugin = this._physicsPlugin;
                this._joints.push(impostorJoint);
                this._physicsPlugin.generateJoint(impostorJoint);
            };
            /**
             * Removes a joint from the simulation
             * @param mainImpostor defines the impostor used with the joint
             * @param connectedImpostor defines the other impostor connected to the main one by the joint
             * @param joint defines the joint to remove
             */
            PhysicsEngine.prototype.removeJoint = function (mainImpostor, connectedImpostor, joint) {
                var matchingJoints = this._joints.filter(function (impostorJoint) {
                    return (impostorJoint.connectedImpostor === connectedImpostor
                        && impostorJoint.joint === joint
                        && impostorJoint.mainImpostor === mainImpostor);
                });
                if (matchingJoints.length) {
                    this._physicsPlugin.removeJoint(matchingJoints[0]);
                    //TODO remove it from the list as well
                }
            };
            /**
             * Called by the scene. no need to call it.
             */
            PhysicsEngine.prototype._step = function (delta) {
                var _this = this;
                //check if any mesh has no body / requires an update
                this._impostors.forEach(function (impostor) {
                    if (impostor.isBodyInitRequired()) {
                        _this._physicsPlugin.generatePhysicsBody(impostor);
                    }
                });
                if (delta > 0.1) {
                    delta = 0.1;
                }
                else if (delta <= 0) {
                    delta = 1.0 / 60.0;
                }
                this._physicsPlugin.executeStep(delta, this._impostors);
                // this._impostors.forEach((impostor) => {
                //     this._physicsPlugin.setTransformationFromPhysicsBody(impostor);
                // });
            };
            /**
             * Gets the current plugin used to run the simulation
             * @returns current plugin
             */
            PhysicsEngine.prototype.getPhysicsPlugin = function () {
                return this._physicsPlugin;
            };
            /**
             * Gets the list of physic impostors
             * @returns an array of PhysicsImpostor
             */
            PhysicsEngine.prototype.getImpostors = function () {
                return this._impostors;
            };
            /**
             * Gets the impostor for a physics enabled object
             * @param object defines the object impersonated by the impostor
             * @returns the PhysicsImpostor or null if not found
             */
            PhysicsEngine.prototype.getImpostorForPhysicsObject = function (object) {
                for (var i = 0; i < this._impostors.length; ++i) {
                    if (this._impostors[i].object === object) {
                        return this._impostors[i];
                    }
                }
                return null;
            };
            /**
             * Gets the impostor for a physics body object
             * @param body defines physics body used by the impostor
             * @returns the PhysicsImpostor or null if not found
             */
            PhysicsEngine.prototype.getImpostorWithPhysicsBody = function (body) {
                for (var i = 0; i < this._impostors.length; ++i) {
                    if (this._impostors[i].physicsBody === body) {
                        return this._impostors[i];
                    }
                }
                return null;
            };
            // Statics
            PhysicsEngine.Epsilon = 0.001;
            return PhysicsEngine;
        }());
        framework.PhysicsEngine = PhysicsEngine;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var PhysicsImpostor = /** @class */ (function () {
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * PhysicsImpostor
             * @param object    transform 对象
             * @param type  shape types.
             * @param _options Body Parameters
             */
            function PhysicsImpostor(object, type, _options) {
                if (_options === void 0) { _options = { mass: 0 }; }
                var _this = this;
                this.object = object;
                this.type = type;
                this._options = _options;
                this._bodyUpdateRequired = false;
                this._onBeforePhysicsStepCallbacks = new Array();
                this._onAfterPhysicsStepCallbacks = new Array();
                this._onPhysicsCollideCallbacks = [];
                this._deltaPosition = new m4m.math.vector3();
                this._isDisposed = false;
                this._cacheSizeWorld = new m4m.math.vector3();
                this.lastObjwPos = new m4m.math.vector3();
                this.lastObjwRot = new m4m.math.quaternion();
                /**
                 * this function is executed by the physics engine.
                 */
                this.beforeStep = function () {
                    if (!_this._physicsEngine) {
                        return;
                    }
                    var wpos = _this.object.getWorldPosition();
                    var wrot = _this.object.getWorldRotate();
                    var hasDirty = !m4m.math.vec3Equal(wpos, _this.lastObjwPos) || !m4m.math.quatEqual(wrot, _this.lastObjwRot);
                    m4m.math.vec3Clone(wpos, _this.lastObjwPos);
                    m4m.math.quatClone(wrot, _this.lastObjwRot);
                    //处理 质心点 与 模型中心点 的偏移
                    var offset_wpos = PhysicsImpostor.helpv3;
                    m4m.math.vec3Clone(_this._deltaPosition, offset_wpos);
                    m4m.math.vec3ScaleByNum(offset_wpos, -1, offset_wpos);
                    m4m.math.vec3Add(wpos, offset_wpos, offset_wpos);
                    // this._deltaRotationConjugated && this.object.rotationQuaternion && this.object.rotationQuaternion.multiplyToRef(this._deltaRotationConjugated, this.object.rotationQuaternion);
                    // this.object.computeWorldMatrix(false);
                    // if (this.object.parent && this.object.rotationQuaternion) {
                    //     this.getParentsRotation();
                    //     this._tmpQuat.multiplyToRef(this.object.rotationQuaternion, this._tmpQuat);
                    // } else {
                    //     this._tmpQuat.copyFrom(this.object.rotationQuaternion || new Quaternion());
                    // }
                    if (hasDirty && !_this._options.disableBidirectionalTransformation) {
                        _this._physicsEngine.getPhysicsPlugin().setPhysicsBodyTransformation(_this, /*bInfo.boundingBox.centerWorld*/ offset_wpos, wrot);
                    }
                    _this._onBeforePhysicsStepCallbacks.forEach(function (func) {
                        func(_this);
                    });
                };
                this._freezeMask = 0; //位移和旋转冻结 mask
                this.lastbodywPos = new m4m.math.vector3();
                this.lastbodywRot = new m4m.math.quaternion();
                this.lastEuler = new m4m.math.vector3();
                this.lastRotMask = 0;
                /**
                 * this function is executed by the physics engine
                 */
                this.afterStep = function () {
                    if (!_this._physicsEngine) {
                        return;
                    }
                    _this._onAfterPhysicsStepCallbacks.forEach(function (func) {
                        func(_this);
                    });
                    var lwpos = _this.lastbodywPos;
                    var lwrot = _this.lastbodywRot;
                    var posDirty = !framework.physicTool.Ivec3Equal(_this.physicsBody.position, lwpos);
                    var rotDirty = !framework.physicTool.IQuatEqual(_this.physicsBody.quaternion, lwrot);
                    //冻结处理逻辑
                    if (_this._freezeMask > 0) {
                        if (posDirty) {
                            //过滤掉 物理的 位移 影响
                            var pPos = _this._physicsBody.position;
                            //清理 速度
                            var linearVelocity = _this._physicsBody.linearVelocity;
                            if (_this.getFreeze(FreezeType.Position_x)) {
                                pPos.x = lwpos.x;
                                linearVelocity.x = 0;
                            }
                            if (_this.getFreeze(FreezeType.Position_y)) {
                                pPos.y = lwpos.y;
                                linearVelocity.y = 0;
                            }
                            if (_this.getFreeze(FreezeType.Position_z)) {
                                pPos.z = lwpos.z;
                                linearVelocity.z = 0;
                            }
                        }
                        if (rotDirty) {
                            var l_x = _this.getFreeze(FreezeType.Rotation_x);
                            var l_y = _this.getFreeze(FreezeType.Rotation_y);
                            var l_z = _this.getFreeze(FreezeType.Rotation_z);
                            var pRot = _this._physicsBody.quaternion;
                            var angularVelocity = _this._physicsBody.angularVelocity;
                            if (!l_x || !l_y || !l_z) {
                                //过滤掉 物理的 旋转 影响
                                //清理 速度
                                var Euler = PhysicsImpostor.helpv3;
                                var tquat = PhysicsImpostor.helpquat;
                                framework.physicTool.IQuatCopy(pRot, tquat);
                                m4m.math.quatToEulerAngles(tquat, Euler); //物理结算当前 欧拉角
                                var lEuler = _this.lastEuler;
                                var mask_ = l_x ? 1 : 0 | l_y ? 2 : 0 | l_z ? 4 : 0; //优化计算 量
                                if (mask_ != _this.lastRotMask) {
                                    m4m.math.quatToEulerAngles(lwrot, lEuler); //上一次的 欧拉角
                                }
                                _this.lastRotMask = mask_;
                                //逐轴冻结判定                        
                                var t_x = lEuler.x;
                                var t_y = lEuler.y;
                                var t_z = lEuler.z;
                                if (_this.getFreeze(FreezeType.Rotation_x)) {
                                    angularVelocity.x = 0;
                                }
                                else {
                                    t_x = Euler.x;
                                }
                                if (_this.getFreeze(FreezeType.Rotation_y)) {
                                    angularVelocity.y = 0;
                                }
                                else {
                                    t_y = Euler.y;
                                }
                                if (_this.getFreeze(FreezeType.Rotation_z)) {
                                    angularVelocity.z = 0;
                                }
                                else {
                                    t_z = Euler.z;
                                }
                                m4m.math.quatFromEulerAngles(t_x, t_y, t_z, tquat);
                                framework.physicTool.IQuatCopy(tquat, pRot);
                            }
                            else {
                                //全部锁定 , 不用计算旋转
                                angularVelocity.x = angularVelocity.y = angularVelocity.z = 0;
                                framework.physicTool.IQuatCopy(lwrot, pRot);
                            }
                        }
                    }
                    framework.physicTool.Ivec3Copy(_this.physicsBody.position, lwpos);
                    framework.physicTool.IQuatCopy(_this.physicsBody.quaternion, lwrot);
                    if (!posDirty && !rotDirty)
                        return;
                    // object has now its world rotation. needs to be converted to local.
                    // if (this.object.parent && this.object.rotationQuaternion) {
                    //     this.getParentsRotation();
                    //     this._tmpQuat.conjugateInPlace();
                    //     this._tmpQuat.multiplyToRef(this.object.rotationQuaternion, this.object.rotationQuaternion);
                    // }
                    // // take the position set and make it the absolute position of this object.
                    // this.object.setAbsolutePosition(this.object.position);
                    // this._deltaRotation && this.object.rotationQuaternion && this.object.rotationQuaternion.multiplyToRef(this._deltaRotation, this.object.rotationQuaternion);
                    //同步到transform
                    _this._physicsEngine.getPhysicsPlugin().setTransformationFromPhysicsBody(_this);
                    //处理 质心点 与 模型中心点 的偏移
                    var tempv3 = PhysicsImpostor.helpv3;
                    m4m.math.vec3Add(_this.object.getWorldPosition(), _this._deltaPosition, tempv3);
                    _this.object.setWorldPosition(tempv3);
                };
                /**
                 * Legacy collision detection event support
                 */
                this.onCollideEvent = null;
                //event and body object due to cannon's event-based architecture.
                this.onCollide = function (e) {
                    if (!_this._onPhysicsCollideCallbacks.length && !_this.onCollideEvent) {
                        return;
                    }
                    if (!_this._physicsEngine) {
                        return;
                    }
                    var otherImpostor = _this._physicsEngine.getImpostorWithPhysicsBody(e.body);
                    if (otherImpostor) {
                        // Legacy collision detection event support
                        if (_this.onCollideEvent) {
                            _this.onCollideEvent(_this, otherImpostor);
                        }
                        _this._onPhysicsCollideCallbacks.filter(function (obj) {
                            return obj.otherImpostors.indexOf(otherImpostor) !== -1;
                        }).forEach(function (obj) {
                            obj.callback(_this, otherImpostor);
                        });
                    }
                };
                this._physicsEngine = framework.physics;
                if (!this.object) {
                    console.error("No object was provided. A physics object is obligatory");
                    return;
                }
                if (!this._physicsEngine) {
                    console.error("Physics not enabled. Please use scene.enablePhysics(...) before creating impostors.");
                    return;
                }
                {
                    //set the object's quaternion, if not set
                    // if (!this.object.rotationQuaternion) {
                    //     if (this.object.rotation) {
                    //         this.object.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.object.rotation.y, this.object.rotation.x, this.object.rotation.z);
                    //     } else {
                    //         this.object.rotationQuaternion = new Quaternion();
                    //     }
                    // }
                    //default options params
                    this._options.mass = (_options.mass === void 0) ? 0 : _options.mass;
                    this._options.friction = (_options.friction === void 0) ? 0.2 : _options.friction;
                    this._options.restitution = (_options.restitution === void 0) ? 0.2 : _options.restitution;
                    this._joints = [];
                    //If the mesh has a parent and parent is not the scene rootNode , don't initialize the physicsBody. Instead wait for the parent to do that.
                    if (!this.object.parent || (this.object.scene && this.object.parent == this.object.scene.getRoot()) || this._options.ignoreParent) {
                        this._init();
                    }
                    else if (this.object.parent && this.object.parent.physicsImpostor) {
                        console.warn("You must affect impostors to children before affecting impostor to parent.");
                    }
                    //引用到设置到 transform
                    if (this.object)
                        this.object.physicsImpostor = this;
                }
            }
            Object.defineProperty(PhysicsImpostor.prototype, "isDisposed", {
                get: function () {
                    return this._isDisposed;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(PhysicsImpostor.prototype, "mass", {
                get: function () {
                    return this._physicsEngine.getPhysicsPlugin().getBodyMass(this);
                },
                set: function (value) {
                    this.setMass(value);
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(PhysicsImpostor.prototype, "friction", {
                get: function () {
                    return this._physicsEngine.getPhysicsPlugin().getBodyFriction(this);
                },
                set: function (value) {
                    this._physicsEngine.getPhysicsPlugin().setBodyFriction(this, value);
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(PhysicsImpostor.prototype, "restitution", {
                get: function () {
                    return this._physicsEngine.getPhysicsPlugin().getBodyRestitution(this);
                },
                set: function (value) {
                    this._physicsEngine.getPhysicsPlugin().setBodyRestitution(this, value);
                },
                enumerable: false,
                configurable: true
            });
            /**
             * This function will completly initialize this impostor.
             * It will create a new body - but only if this mesh has no parent.
             * If it has, this impostor will not be used other than to define the impostor
             * of the child mesh.
             */
            PhysicsImpostor.prototype._init = function () {
                if (!this._physicsEngine) {
                    return;
                }
                this._physicsEngine.removeImpostor(this);
                this.physicsBody = null;
                this._parent = this._parent || this._getPhysicsParent();
                if (!this._isDisposed && (!this.parent || this._options.ignoreParent)) {
                    this._physicsEngine.addImpostor(this);
                }
            };
            PhysicsImpostor.prototype._getPhysicsParent = function () {
                if (this.object && this.object.parent) {
                    return this.object.parent.physicsImpostor;
                }
                return null;
            };
            /**
             * Should a new body be generated.
             */
            PhysicsImpostor.prototype.isBodyInitRequired = function () {
                return this._bodyUpdateRequired || !this._physicsBody;
            };
            PhysicsImpostor.prototype.setScalingUpdated = function (updated) {
                this.forceUpdate();
            };
            /**
             * Force a regeneration of this or the parent's impostor's body.
             * Use under cautious - This will remove all joints already implemented.
             */
            PhysicsImpostor.prototype.forceUpdate = function () {
                this._init();
                if (this.parent && !this._options.ignoreParent) {
                    this.parent.forceUpdate();
                }
            };
            Object.defineProperty(PhysicsImpostor.prototype, "physicsBody", {
                /*public get mesh(): AbstractMesh {
                    return this._mesh;
                }*/
                /**
                 * Gets the body that holds this impostor. Either its own, or its parent.
                 */
                get: function () {
                    return this._physicsBody;
                },
                /**
                 * Set the physics body. Used mainly by the physics engine/plugin
                 */
                set: function (physicsBody) {
                    if (this._physicsBody && this._physicsEngine) {
                        this._physicsEngine.getPhysicsPlugin().removePhysicsBody(this);
                    }
                    this._physicsBody = physicsBody;
                    this.resetUpdateFlags();
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(PhysicsImpostor.prototype, "parent", {
                /**
                 * Get the parent of the physics imposter
                 * @returns Physics imposter or null
                 */
                get: function () {
                    return !this._options.ignoreParent && this._parent ? this._parent : null;
                },
                /**
                 * Sets the parent of the physics imposter
                 */
                set: function (value) {
                    this._parent = value;
                },
                enumerable: false,
                configurable: true
            });
            PhysicsImpostor.prototype.resetUpdateFlags = function () {
                this._bodyUpdateRequired = false;
            };
            PhysicsImpostor.prototype.getObb = function () {
                if (!this.object || !(this.object instanceof framework.transform)) {
                    return null;
                }
                if (!this._obb) {
                    var go = this.object.gameObject;
                    var mf = go.getComponent("meshFilter");
                    if (!mf)
                        return null;
                    var min = PhysicsImpostor.helpv3;
                    var max = PhysicsImpostor.helpv3_1;
                    mf.getMeshOutput().calcVectexMinMax(min, max);
                    //构建一个 obb
                    this._obb = new framework.obb();
                    this._obb.buildByMaxMin(min, max);
                }
                this._obb.update(this.object.getWorldMatrix());
                return this._obb;
            };
            /**
            * Gets the object extend size
            * @returns the object extend size
            */
            PhysicsImpostor.prototype.getObjectExtendSize = function () {
                var tempObb = this.getObb();
                if (!tempObb)
                    return PhysicsImpostor.DEFAULT_OBJECT_SIZE;
                m4m.math.vec3Clone(tempObb.halfSizeWorld, this._cacheSizeWorld);
                m4m.math.vec3ScaleByNum(this._cacheSizeWorld, 2, this._cacheSizeWorld);
                return this._cacheSizeWorld;
            };
            /**
             * Gets the object center
             * @returns The object center
             */
            PhysicsImpostor.prototype.getObjectCenter = function () {
                var tempObb = this.getObb();
                if (!tempObb)
                    return this.object.getWorldPosition();
                return tempObb.worldCenter;
            };
            // public getObjectCenter(): Vector3 {
            //     if (this.object.getBoundingInfo) {
            //         let boundingInfo = this.object.getBoundingInfo();
            //         return boundingInfo.boundingBox.centerWorld;
            //     } else {
            //         return this.object.position;
            //     }
            // }
            /**
             * Get a specific parametes from the options parameter.
             */
            PhysicsImpostor.prototype.getParam = function (paramName) {
                return this._options[paramName];
            };
            /**
             * Sets a specific parameter in the options given to the physics plugin
             */
            PhysicsImpostor.prototype.setParam = function (paramName, value) {
                this._options[paramName] = value;
                this._bodyUpdateRequired = true;
            };
            /**
             * Specifically change the body's mass option. Won't recreate the physics body object
             */
            PhysicsImpostor.prototype.setMass = function (mass) {
                if (this.getParam("mass") !== mass) {
                    this.setParam("mass", mass);
                }
                if (this._physicsEngine) {
                    this._physicsEngine.getPhysicsPlugin().setBodyMass(this, mass);
                }
            };
            PhysicsImpostor.prototype.getLinearVelocity = function () {
                return this._physicsEngine.getPhysicsPlugin().getLinearVelocity(this);
            };
            PhysicsImpostor.prototype.setLinearVelocity = function (velocity) {
                this._physicsEngine.getPhysicsPlugin().setLinearVelocity(this, velocity);
            };
            PhysicsImpostor.prototype.getAngularVelocity = function () {
                return this._physicsEngine.getPhysicsPlugin().getAngularVelocity(this);
            };
            PhysicsImpostor.prototype.setAngularVelocity = function (velocity) {
                this._physicsEngine.getPhysicsPlugin().setAngularVelocity(this, velocity);
            };
            /**
             * Execute a function with the physics plugin native code.
             * Provide a function the will have two variables - the world object and the physics body object.
             */
            PhysicsImpostor.prototype.executeNativeFunction = function (func) {
                if (this._physicsEngine) {
                    func(this._physicsEngine.getPhysicsPlugin().world, this.physicsBody);
                }
            };
            /**
             * Register a function that will be executed before the physics world is stepping forward.
             */
            PhysicsImpostor.prototype.registerBeforePhysicsStep = function (func) {
                this._onBeforePhysicsStepCallbacks.push(func);
            };
            PhysicsImpostor.prototype.unregisterBeforePhysicsStep = function (func) {
                var index = this._onBeforePhysicsStepCallbacks.indexOf(func);
                if (index > -1) {
                    this._onBeforePhysicsStepCallbacks.splice(index, 1);
                }
                else {
                    console.warn("Function to remove was not found");
                }
            };
            /**
             * Register a function that will be executed after the physics step
             */
            PhysicsImpostor.prototype.registerAfterPhysicsStep = function (func) {
                this._onAfterPhysicsStepCallbacks.push(func);
            };
            PhysicsImpostor.prototype.unregisterAfterPhysicsStep = function (func) {
                var index = this._onAfterPhysicsStepCallbacks.indexOf(func);
                if (index > -1) {
                    this._onAfterPhysicsStepCallbacks.splice(index, 1);
                }
                else {
                    console.warn("Function to remove was not found");
                }
            };
            /**
             * register a function that will be executed when this impostor collides against a different body.
             */
            PhysicsImpostor.prototype.registerOnPhysicsCollide = function (collideAgainst, func) {
                var collidedAgainstList = collideAgainst instanceof Array ? collideAgainst : [collideAgainst];
                this._onPhysicsCollideCallbacks.push({ callback: func, otherImpostors: collidedAgainstList });
            };
            PhysicsImpostor.prototype.unregisterOnPhysicsCollide = function (collideAgainst, func) {
                var collidedAgainstList = collideAgainst instanceof Array ? collideAgainst : [collideAgainst];
                var index = -1;
                var found = this._onPhysicsCollideCallbacks.some(function (cbDef, idx) {
                    if (cbDef.callback === func && cbDef.otherImpostors.length === collidedAgainstList.length) {
                        // chcek the arrays match
                        var sameList = cbDef.otherImpostors.every(function (impostor) {
                            return collidedAgainstList.indexOf(impostor) > -1;
                        });
                        if (sameList) {
                            index = idx;
                        }
                        return sameList;
                    }
                    return false;
                });
                if (found) {
                    this._onPhysicsCollideCallbacks.splice(index, 1);
                }
                else {
                    console.warn("Function to remove was not found");
                }
            };
            /**
             * 设置 位移、旋转 冻结选项
             * @param option 冻结类型
             * @param beSelect 是否选上
             */
            PhysicsImpostor.prototype.setFreeze = function (option, beSelect) {
                if (beSelect) {
                    this._freezeMask |= option;
                }
                else {
                    if (this._freezeMask & option) {
                        this._freezeMask ^= option;
                    }
                }
            };
            /**
             * 获取 位移、旋转 冻结选项
             * @param option 冻结类型
             */
            PhysicsImpostor.prototype.getFreeze = function (option) {
                return this._freezeMask & option;
            };
            /**
             * Apply a force
             */
            PhysicsImpostor.prototype.applyForce = function (force, contactPoint) {
                if (this._physicsEngine) {
                    this._physicsEngine.getPhysicsPlugin().applyForce(this, force, contactPoint);
                }
                return this;
            };
            /**
             * Apply an impulse
             */
            PhysicsImpostor.prototype.applyImpulse = function (force, contactPoint) {
                if (this._physicsEngine) {
                    this._physicsEngine.getPhysicsPlugin().applyImpulse(this, force, contactPoint);
                }
                return this;
            };
            /**
             * A help function to create a joint.
             */
            PhysicsImpostor.prototype.createJoint = function (otherImpostor, jointType, jointData) {
                var joint = new framework.PhysicsJoint(jointType, jointData);
                this.addJoint(otherImpostor, joint);
                return this;
            };
            /**
             * Add a joint to this impostor with a different impostor.
             */
            PhysicsImpostor.prototype.addJoint = function (otherImpostor, joint) {
                this._joints.push({
                    otherImpostor: otherImpostor,
                    joint: joint
                });
                if (this._physicsEngine) {
                    this._physicsEngine.addJoint(this, otherImpostor, joint);
                }
                return this;
            };
            /**
             * Will keep this body still, in a sleep mode.
             */
            PhysicsImpostor.prototype.sleep = function () {
                if (this._physicsEngine) {
                    this._physicsEngine.getPhysicsPlugin().sleepBody(this);
                }
                return this;
            };
            Object.defineProperty(PhysicsImpostor.prototype, "isSleeping", {
                /**
                 * result body is sleeping
                 */
                get: function () {
                    if (this._physicsEngine) {
                        return this._physicsEngine.getPhysicsPlugin().isSleeping(this);
                    }
                    return false;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * Wake the body up.
             */
            PhysicsImpostor.prototype.wakeUp = function () {
                if (this._physicsEngine) {
                    this._physicsEngine.getPhysicsPlugin().wakeUpBody(this);
                }
                return this;
            };
            PhysicsImpostor.prototype.clone = function (newObject) {
                if (!newObject)
                    return null;
                return new PhysicsImpostor(newObject, this.type, this._options);
            };
            PhysicsImpostor.prototype.dispose = function ( /*disposeChildren: boolean = true*/) {
                var _this = this;
                //no dispose if no physics engine is available.
                if (!this._physicsEngine) {
                    return;
                }
                this._joints.forEach(function (j) {
                    if (_this._physicsEngine) {
                        _this._physicsEngine.removeJoint(_this, j.otherImpostor, j.joint);
                    }
                });
                //dispose the physics body
                this._physicsEngine.removeImpostor(this);
                if (this.parent) {
                    this.parent.forceUpdate();
                }
                else {
                    // if(this.object.children){
                    //     this.object.children.forEach(sub=>{
                    //         if(sub && sub.physicsImpostor){
                    //             sub.physicsImpostor.dispose();
                    //             sub.physicsImpostor = null;
                    //         }
                    //     });
                    // }
                }
                this._isDisposed = true;
            };
            PhysicsImpostor.prototype.setDeltaPosition = function (position) {
                m4m.math.vec3Clone(position, this._deltaPosition);
                // this._deltaPosition.copyFrom(position);
            };
            PhysicsImpostor.prototype.setDeltaRotation = function (rotation) {
                if (!this._deltaRotation) {
                    this._deltaRotation = new m4m.math.quaternion();
                }
                // this._deltaRotation.copyFrom(rotation);
                m4m.math.quatClone(rotation, this._deltaRotation);
                // this._deltaRotationConjugated = this._deltaRotation.conjugate();
            };
            PhysicsImpostor.prototype.getBoxSizeToRef = function (result) {
                this._physicsEngine.getPhysicsPlugin().getBoxSizeToRef(this, result);
                return this;
            };
            PhysicsImpostor.prototype.getRadius = function () {
                return this._physicsEngine.getPhysicsPlugin().getRadius(this);
            };
            /**
             * 设置动力学的 位置
             */
            PhysicsImpostor.prototype.kinematicSetPosition = function (position) {
                if (!this._physicsBody || !position)
                    return;
                this._physicsBody.setPosition(position);
            };
            /**
             * 设置动力学的 旋转
             */
            PhysicsImpostor.prototype.kinematicSetRotation = function (rotation) {
                if (!this._physicsBody || !rotation)
                    return;
                this._physicsBody.setQuaternion(rotation);
            };
            PhysicsImpostor.DEFAULT_OBJECT_SIZE = new m4m.math.vector3(0, 0, 0);
            PhysicsImpostor.IDENTITY_QUATERNION = new m4m.math.quaternion();
            PhysicsImpostor._tmpVecs = [new m4m.math.vector3(), new m4m.math.vector3(), new m4m.math.vector3()];
            PhysicsImpostor._tmpQuat = new m4m.math.quaternion();
            PhysicsImpostor.helpquat = new m4m.math.quaternion();
            PhysicsImpostor.helpv3 = new m4m.math.vector3();
            PhysicsImpostor.helpv3_1 = new m4m.math.vector3();
            return PhysicsImpostor;
        }());
        framework.PhysicsImpostor = PhysicsImpostor;
        /** Impostor types */
        var ImpostorType;
        (function (ImpostorType) {
            /** No-Imposter type */
            ImpostorType[ImpostorType["NoImpostor"] = 0] = "NoImpostor";
            /** Sphere-Imposter type */
            ImpostorType[ImpostorType["SphereImpostor"] = 1] = "SphereImpostor";
            /** Box-Imposter type */
            ImpostorType[ImpostorType["BoxImpostor"] = 2] = "BoxImpostor";
            /** Plane-Imposter type */
            ImpostorType[ImpostorType["PlaneImpostor"] = 3] = "PlaneImpostor";
            /** Mesh-Imposter type */
            ImpostorType[ImpostorType["MeshImpostor"] = 4] = "MeshImpostor";
            /** Cylinder-Imposter type */
            ImpostorType[ImpostorType["CylinderImpostor"] = 7] = "CylinderImpostor";
            /** Particle-Imposter type */
            ImpostorType[ImpostorType["ParticleImpostor"] = 8] = "ParticleImpostor";
            /** Heightmap-Imposter type */
            ImpostorType[ImpostorType["HeightmapImpostor"] = 9] = "HeightmapImpostor";
            /** ConvexHull-Imposter type */
            ImpostorType[ImpostorType["ConvexHullImpostor"] = 10] = "ConvexHullImpostor";
            /** Rope-Imposter type */
            ImpostorType[ImpostorType["RopeImpostor"] = 101] = "RopeImpostor";
            /** Cloth-Imposter type */
            ImpostorType[ImpostorType["ClothImpostor"] = 102] = "ClothImpostor";
            /** Softbody-Imposter type */
            ImpostorType[ImpostorType["SoftbodyImpostor"] = 103] = "SoftbodyImpostor";
        })(ImpostorType = framework.ImpostorType || (framework.ImpostorType = {}));
        /**
         * physicImpostor 冻结类型
         */
        var FreezeType;
        (function (FreezeType) {
            FreezeType[FreezeType["Position_x"] = 1] = "Position_x";
            FreezeType[FreezeType["Position_y"] = 2] = "Position_y";
            FreezeType[FreezeType["Position_z"] = 4] = "Position_z";
            FreezeType[FreezeType["Rotation_x"] = 8] = "Rotation_x";
            FreezeType[FreezeType["Rotation_y"] = 16] = "Rotation_y";
            FreezeType[FreezeType["Rotation_z"] = 32] = "Rotation_z";
        })(FreezeType = framework.FreezeType || (framework.FreezeType = {}));
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * This is a holder class for the physics joint created by the physics plugin.
         * It holds a set of functions to control the underlying joint.
         */
        var PhysicsJoint = /** @class */ (function () {
            function PhysicsJoint(type, jointData) {
                this.type = type;
                this.jointData = jointData;
                jointData.nativeParams = jointData.nativeParams || {};
            }
            Object.defineProperty(PhysicsJoint.prototype, "physicsJoint", {
                get: function () {
                    return this._physicsJoint;
                },
                set: function (newJoint) {
                    if (this._physicsJoint) {
                        //remove from the wolrd
                    }
                    this._physicsJoint = newJoint;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(PhysicsJoint.prototype, "physicsPlugin", {
                set: function (physicsPlugin) {
                    this._physicsPlugin = physicsPlugin;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * Execute a function that is physics-plugin specific.
             * @param {Function} func the function that will be executed.
             *                        It accepts two parameters: the physics world and the physics joint.
             */
            PhysicsJoint.prototype.executeNativeFunction = function (func) {
                func(this._physicsPlugin.world, this._physicsJoint);
            };
            //TODO check if the native joints are the same
            //Joint Types
            /**
             * Distance-Joint type
             */
            PhysicsJoint.DistanceJoint = 0;
            /**
             * Hinge-Joint type
             */
            PhysicsJoint.HingeJoint = 1;
            /**
             * Ball-and-Socket joint type
             */
            PhysicsJoint.BallAndSocketJoint = 2;
            /**
             * Wheel-Joint type
             */
            PhysicsJoint.WheelJoint = 3;
            /**
             * Slider-Joint type
             */
            PhysicsJoint.SliderJoint = 4;
            //OIMO
            /**
             * Prismatic-Joint type
             */
            PhysicsJoint.PrismaticJoint = 5;
            //
            /**
             * Universal-Joint type
             */
            PhysicsJoint.UniversalJoint = 6;
            /**
             * Hinge-Joint 2 type
             */
            PhysicsJoint.Hinge2Joint = PhysicsJoint.WheelJoint;
            //Cannon
            /**
             * Point to Point Joint type.  Similar to a Ball-Joint.  Different in parameters
             */
            PhysicsJoint.PointToPointJoint = 8;
            //Cannon only at the moment
            /**
             * Spring-Joint type
             */
            PhysicsJoint.SpringJoint = 9;
            /**
             * Lock-Joint type
             */
            PhysicsJoint.LockJoint = 10;
            return PhysicsJoint;
        }());
        framework.PhysicsJoint = PhysicsJoint;
        /**
         * A class representing a physics distance joint.
         */
        var DistanceJoint = /** @class */ (function (_super) {
            __extends(DistanceJoint, _super);
            function DistanceJoint(jointData) {
                return _super.call(this, PhysicsJoint.DistanceJoint, jointData) || this;
            }
            /**
             * Update the predefined distance.
             */
            DistanceJoint.prototype.updateDistance = function (maxDistance, minDistance) {
                this._physicsPlugin.updateDistanceJoint(this, maxDistance, minDistance);
            };
            return DistanceJoint;
        }(PhysicsJoint));
        framework.DistanceJoint = DistanceJoint;
        /**
         * Represents a Motor-Enabled Joint
         */
        var MotorEnabledJoint = /** @class */ (function (_super) {
            __extends(MotorEnabledJoint, _super);
            function MotorEnabledJoint(type, jointData) {
                return _super.call(this, type, jointData) || this;
            }
            /**
             * Set the motor values.
             * Attention, this function is plugin specific. Engines won't react 100% the same.
             * @param {number} force the force to apply
             * @param {number} maxForce max force for this motor.
             */
            MotorEnabledJoint.prototype.setMotor = function (force, maxForce) {
                this._physicsPlugin.setMotor(this, force || 0, maxForce);
            };
            /**
             * Set the motor's limits.
             * Attention, this function is plugin specific. Engines won't react 100% the same.
             */
            MotorEnabledJoint.prototype.setLimit = function (upperLimit, lowerLimit) {
                this._physicsPlugin.setLimit(this, upperLimit, lowerLimit);
            };
            return MotorEnabledJoint;
        }(PhysicsJoint));
        framework.MotorEnabledJoint = MotorEnabledJoint;
        /**
         * This class represents a single hinge physics joint
         */
        var HingeJoint = /** @class */ (function (_super) {
            __extends(HingeJoint, _super);
            function HingeJoint(jointData) {
                return _super.call(this, PhysicsJoint.HingeJoint, jointData) || this;
            }
            /**
             * Set the motor values.
             * Attention, this function is plugin specific. Engines won't react 100% the same.
             * @param {number} force the force to apply
             * @param {number} maxForce max force for this motor.
             */
            HingeJoint.prototype.setMotor = function (force, maxForce) {
                this._physicsPlugin.setMotor(this, force || 0, maxForce);
            };
            /**
             * Set the motor's limits.
             * Attention, this function is plugin specific. Engines won't react 100% the same.
             */
            HingeJoint.prototype.setLimit = function (upperLimit, lowerLimit) {
                this._physicsPlugin.setLimit(this, upperLimit, lowerLimit);
            };
            return HingeJoint;
        }(MotorEnabledJoint));
        framework.HingeJoint = HingeJoint;
        /**
         * This class represents a dual hinge physics joint (same as wheel joint)
         */
        var Hinge2Joint = /** @class */ (function (_super) {
            __extends(Hinge2Joint, _super);
            function Hinge2Joint(jointData) {
                return _super.call(this, PhysicsJoint.Hinge2Joint, jointData) || this;
            }
            /**
             * Set the motor values.
             * Attention, this function is plugin specific. Engines won't react 100% the same.
             * @param {number} force the force to apply
             * @param {number} maxForce max force for this motor.
             * @param {motorIndex} the motor's index, 0 or 1.
             */
            Hinge2Joint.prototype.setMotor = function (force, maxForce, motorIndex) {
                if (motorIndex === void 0) { motorIndex = 0; }
                this._physicsPlugin.setMotor(this, force || 0, maxForce, motorIndex);
            };
            /**
             * Set the motor limits.
             * Attention, this function is plugin specific. Engines won't react 100% the same.
             * @param {number} upperLimit the upper limit
             * @param {number} lowerLimit lower limit
             * @param {motorIndex} the motor's index, 0 or 1.
             */
            Hinge2Joint.prototype.setLimit = function (upperLimit, lowerLimit, motorIndex) {
                if (motorIndex === void 0) { motorIndex = 0; }
                this._physicsPlugin.setLimit(this, upperLimit, lowerLimit, motorIndex);
            };
            return Hinge2Joint;
        }(MotorEnabledJoint));
        framework.Hinge2Joint = Hinge2Joint;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * tool of physic
         */
        var physicTool = /** @class */ (function () {
            function physicTool() {
            }
            physicTool.Ivec3Equal = function (a, b) {
                return a.x == b.x && a.y == b.y && a.z == b.z;
            };
            physicTool.Ivec2Equal = function (a, b) {
                return a.x == b.x && a.y == b.y;
            };
            physicTool.IQuatEqual = function (a, b) {
                return a.x == b.x && a.y == b.y && a.z == b.z && a.w == b.w;
            };
            physicTool.Ivec3Copy = function (from, to) {
                to.x = from.x;
                to.y = from.y;
                to.z = from.z;
            };
            physicTool.Ivec2Copy = function (from, to) {
                to.x = from.x;
                to.y = from.y;
            };
            physicTool.IQuatCopy = function (from, to) {
                to.x = from.x;
                to.y = from.y;
                to.z = from.z;
                to.w = from.w;
            };
            physicTool.vec3AsArray = function (vec3) {
                var result = [];
                // result[0] = vec3.rawData[0];
                // result[1] = vec3.rawData[1];
                // result[2] = vec3.rawData[2];
                result[0] = vec3.x;
                result[1] = vec3.y;
                result[2] = vec3.z;
                return result;
            };
            return physicTool;
        }());
        framework.physicTool = physicTool;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
/// <reference path="../../io/reflect.ts" />
var m4m;
/// <reference path="../../io/reflect.ts" />
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         */
        var HideFlags;
        (function (HideFlags) {
            //---------------单选项-------------------
            HideFlags[HideFlags["None"] = 0] = "None";
            /** Hierarchy 中隐藏 */
            HideFlags[HideFlags["HideInHierarchy"] = 1] = "HideInHierarchy";
            /** Inspector 中隐藏 */
            HideFlags[HideFlags["HideInInspector"] = 2] = "HideInInspector";
            /** 在Editor中不可保存 */
            HideFlags[HideFlags["DontSaveInEditor"] = 4] = "DontSaveInEditor";
            /** 不可编辑的 */
            HideFlags[HideFlags["NotEditable"] = 8] = "NotEditable";
            /** Build时不保存 */
            HideFlags[HideFlags["DontSaveInBuild"] = 16] = "DontSaveInBuild";
            /** 不卸载 不使用的资源 */
            HideFlags[HideFlags["DontUnloadUnusedAsset"] = 32] = "DontUnloadUnusedAsset";
            /** 不受视锥剔除 */
            HideFlags[HideFlags["DontFrustumCulling"] = 64] = "DontFrustumCulling";
            //--------------组合选项--------------
            /** 不保存 */
            HideFlags[HideFlags["DontSave"] = 52] = "DontSave";
            /** 隐藏并不保存 */
            HideFlags[HideFlags["HideAndDontSave"] = 61] = "HideAndDontSave";
        })(HideFlags = framework.HideFlags || (framework.HideFlags = {}));
        // /**
        //  * @public
        //  * @language zh_CN
        //  * @classdesc
        //  * 组件实例接口
        //  * @version m4m 1.0
        //  */
        // export interface INodeComponent
        // {
        //     onPlay();
        //     start();
        //     update(delta: number);
        //     gameObject: gameObject;
        //     remove();
        //     clone();
        //     // jsonToAttribute(json: any, assetmgr: assetMgr);
        // }
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 组件接口
         * @version m4m 1.0
         */
        var nodeComponent = /** @class */ (function () {
            function nodeComponent(comp, init) {
                if (init === void 0) { init = false; }
                /**
                 * onPlay是否调用过了
                 */
                this.OnPlayed = false;
                this.comp = comp;
                this.init = init;
            }
            nodeComponent.ClassName = "nodeComponent";
            __decorate([
                m4m.reflect.Field("INodeComponent"),
                __metadata("design:type", Object)
            ], nodeComponent.prototype, "comp", void 0);
            nodeComponent = __decorate([
                m4m.reflect.SerializeType,
                __metadata("design:paramtypes", [Object, Boolean])
            ], nodeComponent);
            return nodeComponent;
        }());
        framework.nodeComponent = nodeComponent;
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * gameObject类 对应unity中gameObject概念
         * @version m4m 1.0
         */
        var gameObject = /** @class */ (function () {
            function gameObject() {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 对象layer (取值范围0~31)
                 * @version m4m 1.0
                 */
                this.layer = framework.cullingmaskutil.maskTolayer(framework.CullingMask.default); //物件有一个layer 取值范围0~31，各种功能都可以用layer mask 去过滤作用范围
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 对象字符标签
                 * @version m4m 1.0
                 */
                this.tag = framework.StringUtil.builtinTag_Untagged;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 隐匿标记
                 * @version m4m 1.0
                 */
                this.hideFlags = HideFlags.None;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 对象是静态
                 * @version m4m 1.0
                 */
                this.isStatic = false;
                // dontdestroyonload:boolean = false;//加载新场景的时候是否销毁。
                // transform2d: transform2D;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 组件列表
                 * @version m4m 1.0
                 */
                this.components = [];
                this.componentTypes = {};
                this.componentsInit = [];
                this._visible = true;
            }
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取物体所在场景实例
             * @version m4m 1.0
             */
            gameObject.prototype.getScene = function () {
                return this.transform.scene;
            };
            Object.defineProperty(gameObject.prototype, "visibleInScene", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 获取在场景中的可见状态
                 * @version m4m 1.0
                 */
                get: function () {
                    var obj = this;
                    while (obj.visible && obj.transform.parent) {
                        obj = obj.transform.parent.gameObject;
                    }
                    return obj.visible;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(gameObject.prototype, "visible", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 获取自身的可见状态
                 * @version m4m 1.0
                 */
                get: function () {
                    return this._visible;
                },
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 设置自身的可见状态
                 * @param val
                 * @version m4m 1.0
                 */
                set: function (val) {
                    if (val != this._visible) {
                        this._visible = val;
                        framework.sceneMgr.app.markNotify(this.transform, framework.NotifyType.ChangeVisible);
                    }
                },
                enumerable: false,
                configurable: true
            });
            ;
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取对应transform的name
             * @version m4m 1.0
             */
            gameObject.prototype.getName = function () {
                return this.transform.name;
                // return this.transform != null ? this.transform.name : this.transform2d.name;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 初始化 主要是组件的初始化
             * @version m4m 1.0
             */
            gameObject.prototype.init = function (bePlay) {
                if (bePlay === void 0) { bePlay = false; }
                var comps = this.componentsInit;
                if (comps.length <= 0)
                    return;
                while (comps.length > 0) { //这里不要再改回 for循环 , 当组件init 时添加其他组件时，会造成问题
                    var c = comps.shift();
                    c.comp.start();
                    c.init = true;
                    if (bePlay) {
                        if ((framework.StringUtil.ENABLED in c.comp) && !c.comp[framework.StringUtil.ENABLED])
                            continue; //组件enable影响
                        c.comp.onPlay();
                        c.OnPlayed = true;
                    }
                }
                this.transform.hasInitCompChild = false;
                this.transform.hasInitComp = false;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 主update
             * @param delta
             * @version m4m 1.0
             */
            gameObject.prototype.update = function (delta) {
                var len = this.components.length;
                for (var i = 0; i < len; i++) {
                    var c = this.components[i];
                    if (!c)
                        continue;
                    if (framework.StringUtil.ENABLED in c.comp && !c.comp[framework.StringUtil.ENABLED])
                        continue;
                    if (!c.OnPlayed) //还没有 调用 OnPlayed 
                     {
                        c.comp.onPlay(); //运行时的 enabled 开启 后调用 onPlay()
                        c.OnPlayed = true;
                    }
                    this.transform.hasOnPlayComp = false;
                    this.transform.hasOnPlayCompChild = false;
                    if (c.comp.update)
                        c.comp.update(delta);
                }
                if (len < 1) {
                    this.transform.hasOnPlayCompChild = false;
                }
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 添加组件实例
             * @param comp 组件实例
             * @version m4m 1.0
             */
            gameObject.prototype.addComponentDirect = function (comp) {
                if (!comp) {
                    console.error("this component is null");
                    return;
                }
                if (comp.gameObject != null) {
                    console.error("this components has added to a  gameObject");
                    return;
                }
                comp.gameObject = this;
                var typeStr = framework.getClassName(comp);
                if (this.componentTypes[typeStr]) {
                    console.error(this.getName() + "   已经有一个" + typeStr + "的组件了，不能俩");
                    return;
                }
                // if (this.components == null)
                //     this.components = [];
                //这种不明确的初始化以后不要用，反射识别不到类型。一定要构建类型
                //this.components.push({ comp: comp, init: false });
                var nodeObj = new nodeComponent(comp, false);
                var add = true;
                if (m4m.reflect.getClassTag(comp["__proto__"], "renderer") == "1" || m4m.reflect.getClassTag(comp["__proto__"], "effectbatcher") == "1") { //comp是个渲染器
                    if (this.renderer == null) {
                        this.renderer = comp;
                        // console.warn("add renderer:" + this.transform.name);
                        this.transform.markHaveRendererComp();
                    }
                    else {
                        add = false;
                        console.warn("已经有一个渲染器的组件了，不能俩");
                        //throw new Error("已经有一个渲染器的组件了，不能俩");
                    }
                }
                if (m4m.reflect.getClassTag(comp["__proto__"], "camera") == "1") { //comp是个摄像机
                    if (this.camera == null) {
                        this.camera = comp;
                        // console.warn("add camera:" + this.transform.name);
                    }
                    else {
                        add = false;
                        console.warn("已经有一个摄像机的组件了，不能俩");
                        //throw new Error("已经有一个摄像机的组件了，不能俩");
                    }
                }
                if (m4m.reflect.getClassTag(comp["__proto__"], "light") == "1") { //comp是个light
                    if (this.light == null) {
                        this.light = comp;
                        //console.warn("add light:" + this.transform.name);
                    }
                    else {
                        add = false;
                        console.warn("已经有一个灯光的组件了，不能俩");
                        //throw new Error("已经有一个灯光的组件了，不能俩");
                    }
                }
                if (m4m.reflect.getClassTag(comp["__proto__"], "boxcollider") == "1" || m4m.reflect.getClassTag(comp["__proto__"], "meshcollider") == "1" || m4m.reflect.getClassTag(comp["__proto__"], "canvasRenderer") == "1" || m4m.reflect.getClassTag(comp["__proto__"], "spherecollider") == "1") { //comp是个collider
                    if (this.collider == null) {
                        this.collider = comp;
                        // console.warn("add collider:" + this.transform.name);
                    }
                    else {
                        add = false;
                        console.warn("已经有一个碰撞盒的组件了，不能俩");
                        //throw new Error("已经有一个碰撞盒的组件了，不能俩");
                    }
                }
                if (framework.functionIsEmpty(comp.update)) {
                    comp.update = undefined; //update空转
                }
                else {
                    this.transform.markHaveUpdateComp();
                }
                // if (comp.update.toString().length < 35)
                // {
                //     //update 空转
                //     comp.update = undefined;                
                // }
                if (add) {
                    this.components.push(nodeObj);
                    this.componentsInit.push(nodeObj);
                    if (m4m.reflect.getClassTag(comp["__proto__"], "camera") == "1")
                        framework.sceneMgr.app.markNotify(this.transform, framework.NotifyType.AddCamera);
                    if (m4m.reflect.getClassTag(comp["__proto__"], "canvasRenderer") == "1")
                        framework.sceneMgr.app.markNotify(this.transform, framework.NotifyType.AddCanvasRender);
                    this.transform.markHaveInitComp();
                    this.transform.markHaveOnplayComp();
                    // this.transform.markHaveComponent();
                }
                this.componentTypes[typeStr] = true;
                return comp;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 根据类型获取组件 只是自己身上找到的第一个
             * @param type 组件类型
             * @version m4m 1.0
             */
            gameObject.prototype.getComponent = function (type) {
                for (var i = 0; i < this.components.length; i++) {
                    // var cname = m4m.reflect.getClassName(this.components[i].comp["__proto__"]);
                    var comp = this.components[i].comp;
                    var cname = framework.getClassName(comp);
                    if (cname == type) {
                        return comp;
                    }
                }
                return null;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取身上所有的组件
             * @version m4m 1.0
             */
            gameObject.prototype.getComponents = function () {
                var components = [];
                for (var i = 0; i < this.components.length; i++) {
                    components.push(this.components[i].comp);
                }
                return components;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取自己和所有子物体中 所有该类型的组件
             * @param type 组件类型
             * @version m4m 1.0
             */
            gameObject.prototype.getComponentsInChildren = function (type) {
                var components = [];
                this._getComponentsInChildren(type, this, components);
                return components;
            };
            gameObject.prototype._getComponentsInChildren = function (type, obj, array) {
                var len = obj.components.length;
                for (var i = 0; i < len; i++) {
                    var comp = obj.components[i].comp;
                    var cname = framework.getClassName(comp);
                    if (cname == type) {
                        array.push(comp);
                    }
                }
                var children = obj.transform.children;
                if (children != null) {
                    var len_2 = children.length;
                    for (var i = 0; i < len_2; i++) {
                        var _obj = children[i].gameObject;
                        this._getComponentsInChildren(type, _obj, array);
                    }
                }
            };
            /**
            * 获取当前节点下及子节点第一个能找到的组件
            * @param type 组件名称
            */
            gameObject.prototype.getFirstComponentInChildren = function (type) {
                return this.getNodeFirstComponent(this, type);
            };
            /**
             * 获取节点的第一个组件
             * @param node
             * @param _type
             */
            gameObject.prototype.getNodeFirstComponent = function (node, type) {
                var len = node.components.length;
                // for (var i in node.components)
                for (var i = 0; i < len; i++) {
                    var comp = node.components[i].comp;
                    var cname = framework.getClassName(comp);
                    if (cname == type) {
                        return comp;
                    }
                }
                var children = node.transform.children;
                if (children != null) {
                    var len_1 = children.length;
                    for (var j = 0; j < len_1; j++) {
                        var result = node.getNodeFirstComponent(children[j].gameObject, type);
                        if (result)
                            return result;
                    }
                }
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 根据组件类型获取自己这条分支上父物体中该类型的组件 一直上溯到根节点
             * @param type 组件类型
             * @version m4m 1.0
             */
            gameObject.prototype.getComponentInParent = function (type) {
                var result = null;
                var _parent = this.transform.parent;
                while (result == null && _parent != null) {
                    result = _parent.gameObject.getComponent(type);
                    _parent = _parent.parent;
                }
                return result;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 根据组件类型添加一个组件
             * @param type 组件类型
             * @version m4m 1.0
             */
            gameObject.prototype.addComponent = function (type) {
                // if (this.componentTypes[type])
                //     throw new Error("已经有一个" + type + "的组件了，不能俩");
                var pp = m4m.reflect.getPrototype(type);
                if (!pp)
                    throw new Error("get null of ".concat(type, " to getPrototype"));
                var comp = m4m.reflect.createInstance(pp, { "nodecomp": "1" });
                // this.componentTypes[type] = true;
                return this.addComponentDirect(comp);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 根据组件实例移出组件
             * @param comp 组件实例
             * @version m4m 1.0
             */
            gameObject.prototype.removeComponent = function (comp) {
                if (!comp)
                    return;
                // let type = reflect.getClassName(comp); //组件继承时remove fial
                var constructor = Object.getPrototypeOf(comp).constructor;
                if (!constructor)
                    return;
                var type = constructor.name;
                if (!this.componentTypes[type])
                    return;
                delete this.componentTypes[type];
                var i = 0, len = this.components.length;
                while (i < len) {
                    if (this.components[i].comp == comp) {
                        // if (this.components[i].init)
                        // {//已经初始化过
                        //     comp.remove();
                        //     comp.gameObject = null;
                        // }
                        // this.remove(comp);
                        this.clearOfCompRemove(this.components[i]);
                        this.components.splice(i, 1);
                        break;
                    }
                    ++i;
                }
                if (this.components.length < 1) {
                    this.transform.hasUpdateComp = false;
                }
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 根据组件类型移出组件
             * @param type 组件类型
             * @version m4m 1.0
             */
            gameObject.prototype.removeComponentByTypeName = function (type) {
                if (!this.componentTypes[type])
                    return;
                delete this.componentTypes[type];
                var result = null;
                var i = 0, len = this.components.length;
                while (i < len) {
                    // if (reflect.getClassName(this.components[i].comp) == type)
                    if (framework.getClassName(this.components[i].comp) == type) {
                        // if (this.components[i].init)
                        // {//已经初始化过
                        //     this.components[i].comp.remove();
                        //     this.components[i].comp.gameObject = null;
                        // }
                        // this.remove(this.components[i].comp);
                        this.clearOfCompRemove(this.components[i]);
                        var results = this.components.splice(i, 1);
                        if (results[0].comp)
                            result = results[0].comp;
                        break;
                    }
                    ++i;
                }
                if (this.components.length < 1) {
                    this.transform.hasUpdateComp = false;
                }
                return result;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 移出所有组件
             * @version m4m 1.0
             */
            gameObject.prototype.removeAllComponents = function () {
                this.componentsInit.length = 0;
                var len = this.components.length;
                for (var i = 0; i < len; i++) {
                    var comp = this.components[i].comp;
                    comp.remove();
                    comp.gameObject = null;
                }
                this.camera = null;
                this.renderer = null;
                this.light = null;
                this.collider = null;
                this.components.length = 0;
                this.componentTypes = {};
                var tran = this.transform;
                tran.hasUpdateComp = false;
                tran.hasRendererComp = false;
                tran.hasInitComp = false;
                tran.hasOnPlayComp = false;
            };
            gameObject.prototype.clearOfCompRemove = function (cComp) {
                var comp = cComp.comp;
                if (cComp.init) {
                    comp.remove();
                }
                else {
                    var i = this.componentsInit.indexOf(cComp);
                    if (i != -1)
                        this.componentsInit.splice(i, 1);
                }
                if (comp == this.camera)
                    this.camera = null;
                if (comp == this.renderer) {
                    this.transform.hasRendererComp = false;
                    this.renderer = null;
                }
                if (comp == this.light)
                    this.light = null;
                if (comp == this.collider)
                    this.collider = null;
                comp.gameObject = null;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 释放gameObject
             * @version m4m 1.0
             */
            gameObject.prototype.dispose = function () {
                this.removeAllComponents();
            };
            gameObject.ClassName = "gameObject";
            __decorate([
                m4m.reflect.Field("number"),
                m4m.reflect.UIStyle("enum"),
                __metadata("design:type", Number)
            ], gameObject.prototype, "layer", void 0);
            __decorate([
                m4m.reflect.Field("string"),
                __metadata("design:type", String)
            ], gameObject.prototype, "tag", void 0);
            __decorate([
                m4m.reflect.Field("number"),
                __metadata("design:type", Number)
            ], gameObject.prototype, "hideFlags", void 0);
            __decorate([
                m4m.reflect.Field("boolean"),
                __metadata("design:type", Boolean)
            ], gameObject.prototype, "isStatic", void 0);
            __decorate([
                m4m.reflect.Field("nodeComponent[]"),
                __metadata("design:type", Array)
            ], gameObject.prototype, "components", void 0);
            __decorate([
                m4m.reflect.Field("boolean"),
                __metadata("design:type", Object)
            ], gameObject.prototype, "_visible", void 0);
            gameObject = __decorate([
                m4m.reflect.SerializeType
            ], gameObject);
            return gameObject;
        }());
        framework.gameObject = gameObject;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @private
         */
        var renderContext = /** @class */ (function () {
            function renderContext(webgl) {
                this.viewPortPixel = new m4m.math.rect(0, 0, 0, 0); //像素的viewport
                this.eyePos = new m4m.math.vector4();
                this.matrixView = new m4m.math.matrix();
                this.matrixProject = new m4m.math.matrix();
                this.matrixModel = new m4m.math.matrix();
                this._lastM_IT = new m4m.math.matrix();
                this._matrixWorld2Object = new m4m.math.matrix();
                this.matrixModelViewProject = new m4m.math.matrix;
                this._matrixModelView = new m4m.math.matrix;
                this._matrixInverseModelView = new m4m.math.matrix;
                this._lastMV_IT = new m4m.math.matrix;
                this.matrixViewProject = new m4m.math.matrix;
                //matrixNormal: m4m.math.matrix = new m4m.math.matrix();
                this.floatTimer = 0;
                //最多8灯，再多不管
                this.intLightCount = 0;
                this.vec4LightPos = new Float32Array(32);
                this.vec4LightDir = new Float32Array(32);
                this.vec4LightColor = new Float32Array(32);
                this.floatLightRange = new Float32Array(8);
                this.floatLightIntensity = new Float32Array(8);
                this.floatLightSpotAngleCos = new Float32Array(8);
                this._intLightCount = 0;
                this._lightCullingMask = [];
                this._vec4LightPos = new Float32Array(32);
                this._vec4LightDir = new Float32Array(32);
                this._vec4LightColor = new Float32Array(32);
                this._floatLightRange = new Float32Array(8);
                this._floatLightIntensity = new Float32Array(8);
                this._floatLightSpotAngleCos = new Float32Array(8);
                this.lightmap = null;
                this.lightmap_01 = null;
                this.lightmapUV = 1;
                this.lightmapRGBAF16 = 0; //是否为RGBA16 纹理，0: 不是 1：是
                this.lightmapOffset = new m4m.math.vector4(1, 1, 0, 0);
                this.webgl = webgl;
            }
            Object.defineProperty(renderContext.prototype, "matrixWorld2Object", {
                /** M 矩阵的逆矩阵 */
                get: function () {
                    if (!m4m.math.matrixEqual(this._lastM_IT, this.matrixModel, 0)) {
                        m4m.math.matrixInverse(this.matrixModel, this._matrixWorld2Object);
                        m4m.math.matrixClone(this.matrixModel, this._lastM_IT);
                    }
                    return this._matrixWorld2Object;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(renderContext.prototype, "matrixModelView", {
                get: function () {
                    m4m.math.matrixMultiply(this.matrixView, this.matrixModel, this._matrixModelView);
                    return this._matrixModelView;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(renderContext.prototype, "matrixInverseModelView", {
                /** MV 矩阵的逆转置矩阵 */
                get: function () {
                    // if(!m4m.math.matrixEqual(this._lastMV_IT , this.matrixModelView , 0)){
                    m4m.math.matrixInverse(this.matrixModel, this._matrixInverseModelView);
                    m4m.math.matrixTranspose(this._matrixInverseModelView, this._matrixInverseModelView);
                    // m4m.math.matrixClone(this._matrixInverseModelView ,this._lastMV_IT);
                    // }
                    return this._matrixInverseModelView;
                },
                enumerable: false,
                configurable: true
            });
            renderContext.prototype.updateCamera = function (app, camera) {
                // camera.calcViewPortPixel(app, this.viewPortPixel);
                // var asp = this.viewPortPixel.w / this.viewPortPixel.h;
                //update viewport
                // camera.calcViewMatrix(this.matrixView);
                // camera.calcProjectMatrix(asp, this.matrixProject);
                // m4m.math.matrixMultiply(this.matrixProject, this.matrixView, this.matrixViewProject);
                camera.calcViewProjectMatrix(app, this.matrixViewProject, this.matrixView, this.matrixProject);
                this.floatTimer = app.getTotalTime();
                var pso = camera.gameObject.transform.getWorldTranslate();
                this.eyePos.x = pso.x;
                this.eyePos.y = pso.y;
                this.eyePos.z = pso.z;
            };
            renderContext.prototype.updateLights = function (lights) {
                this._intLightCount = lights.length;
                if (this._intLightCount < 1)
                    return;
                this._lightCullingMask.length = 0;
                var dirt = m4m.math.pool.new_vector3();
                for (var i = 0, len = lights.length; i < len; i++) {
                    this._lightCullingMask.push(lights[i].cullingMask);
                    {
                        var pos = lights[i].gameObject.transform.getWorldTranslate();
                        this._vec4LightPos[i * 4 + 0] = pos.x;
                        this._vec4LightPos[i * 4 + 1] = pos.y;
                        this._vec4LightPos[i * 4 + 2] = pos.z;
                        this._vec4LightPos[i * 4 + 3] = lights[i].type == framework.LightTypeEnum.Direction ? 0 : 1;
                        lights[i].gameObject.transform.getForwardInWorld(dirt);
                        this._vec4LightDir[i * 4 + 0] = dirt.x;
                        this._vec4LightDir[i * 4 + 1] = dirt.y;
                        this._vec4LightDir[i * 4 + 2] = dirt.z;
                        this._vec4LightDir[i * 4 + 3] = lights[i].type == framework.LightTypeEnum.Point ? 0 : 1;
                        //dir.w=1 && pos.w=1 表示聚光灯
                        //dir.w=0 && pos.w=1 表示点光源
                        //dir.w=1 && pos.w=0 表示方向光
                        this._floatLightSpotAngleCos[i] = lights[i].spotAngelCos;
                        this._vec4LightColor[i * 4 + 0] = lights[i].color.r;
                        this._vec4LightColor[i * 4 + 1] = lights[i].color.g;
                        this._vec4LightColor[i * 4 + 2] = lights[i].color.b;
                        this._vec4LightColor[i * 4 + 3] = lights[i].color.a;
                        this._floatLightRange[i] = lights[i].range;
                        this._floatLightIntensity[i] = lights[i].intensity;
                    }
                }
                m4m.math.pool.delete_vector3(dirt);
                //收集灯光参数
            };
            renderContext.prototype.updateOverlay = function () {
                //v 特殊
                //m4m.math.matrixMakeIdentity(this.matrixView);//v
                //m4m.math.matrixMakeIdentity(this.matrixProject);//p
                //m4m.math.matrixMultiply(this.matrixProject, this.matrixView, this.matrixViewProject);//vp
                //m4m.math.matrixMakeIdentity(this.matrixModel);//m
                //m4m.math.matrixMultiply(this.matrixView, this.matrixModel, this.matrixModelView);//mv
                //m4m.math.matrixMultiply(this.matrixViewProject, this.matrixModel, this.matrixModelViewProject);//mvp
                m4m.math.matrixMakeIdentity(this.matrixModelViewProject);
            };
            renderContext.prototype.updateModel = function (model) {
                this.updateModelByMatrix(model.getWorldMatrix());
            };
            renderContext.prototype.updateModelByMatrix = function (m_matrix) {
                //注意，这tm是个引用
                m4m.math.matrixClone(m_matrix, this.matrixModel);
                m4m.math.matrixMultiply(this.matrixViewProject, this.matrixModel, this.matrixModelViewProject);
            };
            //为特效拖尾服务
            renderContext.prototype.updateModeTrail = function () {
                m4m.math.matrixClone(this.matrixView, this.matrixModelView);
                m4m.math.matrixClone(this.matrixViewProject, this.matrixModelViewProject);
            };
            //更新 光照剔除mask
            renderContext.prototype.updateLightMask = function (layer) {
                this.intLightCount = 0;
                if (this._intLightCount == 0)
                    return;
                var num = 1 << layer;
                var indexList = [];
                for (var i = 0; i < this._lightCullingMask.length; i++) {
                    var mask = this._lightCullingMask[i];
                    if (mask & num)
                        indexList.push(i);
                }
                this.intLightCount = indexList.length;
                for (var i = 0; i < indexList.length; i++) {
                    var idx = indexList[i];
                    this.floatLightSpotAngleCos[i] = this._floatLightSpotAngleCos[idx];
                    this.floatLightRange[i] = this._floatLightRange[idx];
                    this.floatLightIntensity[i] = this._floatLightIntensity[idx];
                    //pos
                    this.vec4LightPos[i * 4 + 0] = this._vec4LightPos[idx * 4 + 0];
                    this.vec4LightPos[i * 4 + 1] = this._vec4LightPos[idx * 4 + 1];
                    this.vec4LightPos[i * 4 + 2] = this._vec4LightPos[idx * 4 + 2];
                    this.vec4LightPos[i * 4 + 3] = this._vec4LightPos[idx * 4 + 3];
                    //dir
                    this.vec4LightDir[i * 4 + 0] = this._vec4LightDir[idx * 4 + 0];
                    this.vec4LightDir[i * 4 + 1] = this._vec4LightDir[idx * 4 + 1];
                    this.vec4LightDir[i * 4 + 2] = this._vec4LightDir[idx * 4 + 2];
                    this.vec4LightDir[i * 4 + 3] = this._vec4LightDir[idx * 4 + 3];
                    //color
                    this.vec4LightColor[i * 4 + 0] = this._vec4LightColor[idx * 4 + 0];
                    this.vec4LightColor[i * 4 + 1] = this._vec4LightColor[idx * 4 + 1];
                    this.vec4LightColor[i * 4 + 2] = this._vec4LightColor[idx * 4 + 2];
                    this.vec4LightColor[i * 4 + 3] = this._vec4LightColor[idx * 4 + 3];
                }
            };
            return renderContext;
        }());
        framework.renderContext = renderContext;
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 渲染的层级
         * @version m4m 1.0
         */
        var RenderLayerEnum;
        (function (RenderLayerEnum) {
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 不透明
             * @version m4m 1.0
             */
            RenderLayerEnum[RenderLayerEnum["Common"] = 0] = "Common";
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 半透明
             * @version m4m 1.0
             */
            RenderLayerEnum[RenderLayerEnum["Transparent"] = 1] = "Transparent";
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * Overlay层
             * @version m4m 1.0
             */
            RenderLayerEnum[RenderLayerEnum["Overlay"] = 2] = "Overlay";
        })(RenderLayerEnum = framework.RenderLayerEnum || (framework.RenderLayerEnum = {}));
        // /**
        //  * @public
        //  * @language zh_CN
        //  * @classdesc
        //  * 渲染器接口 继承自组件接口
        //  * @version m4m 1.0
        //  */
        // export interface IRenderer extends INodeComponent
        // {
        //     layer: RenderLayerEnum;
        //     renderLayer: number;  //后期发现 和 gameObject.layer 概念冲突 ，实现时 对接处理
        //     queue: number;
        //     render(context: renderContext, assetmgr: assetMgr, camera: m4m.framework.camera);
        // }
        /**
         * @private
         */
        var renderList = /** @class */ (function () {
            function renderList() {
                this.renderLayers = [];
                var common = new renderLayer(false);
                var transparent = new renderLayer(true);
                var overlay = new renderLayer(true);
                this.renderLayers.push(common);
                this.renderLayers.push(transparent);
                this.renderLayers.push(overlay);
            }
            renderList.prototype.clear = function () {
                var lys = this.renderLayers;
                for (var i = 0, len = lys.length; i < len; i++) {
                    lys[i].list.length = 0;
                    var obj = lys[i].gpuInstanceMap;
                    for (var key in obj) {
                        // obj[key].clear();
                        obj[key].length = 0;
                    }
                    // this.renderLayers[i].gpuInstanceMap = {};
                }
            };
            renderList.prototype.clearBatcher = function () {
                var lys = this.renderLayers;
                for (var i = 0, len = lys.length; i < len; i++) {
                    var obj = lys[i].gpuInstanceBatcherMap;
                    for (var key in obj) {
                        obj[key].dispose();
                        delete obj[key];
                    }
                }
            };
            renderList.prototype.addRenderer = function (renderer, webgl) {
                var idx = renderer.layer;
                // let layer = renderer.layer;
                // var idx = 0;
                // if (layer == RenderLayerEnum.Common)
                // {
                // }
                // else if (layer == RenderLayerEnum.Overlay)
                // {
                //     idx = 2;
                // }
                // else if (layer == RenderLayerEnum.Transparent)
                // {
                //     idx = 1;
                // }
                var gpuInsR = renderer;
                if (!webgl.drawArraysInstanced || !gpuInsR.isGpuInstancing || !gpuInsR.isGpuInstancing()) {
                    this.renderLayers[idx].list.push(renderer);
                }
                else {
                    this.renderLayers[idx].addInstance(gpuInsR);
                }
            };
            renderList.prototype.addStaticInstanceRenderer = function (renderer, webgl, isStatic) {
                if (!isStatic)
                    return;
                var go = renderer.gameObject;
                if (!go || !go.transform.needGpuInstancBatcher || !renderer.isGpuInstancing || !renderer.isGpuInstancing())
                    return;
                var idx = renderer.layer;
                this.renderLayers[idx].addInstanceToBatcher(renderer);
            };
            return renderList;
        }());
        framework.renderList = renderList;
        /**
         * @private
         */
        var renderLayer = /** @class */ (function () {
            function renderLayer(_sort) {
                if (_sort === void 0) { _sort = false; }
                this.needSort = false;
                //先暂时分配 透明与不透明两组
                this.list = [];
                /** gpu instance map*/
                // gpuInstanceMap: {[sID:string] : IRendererGpuIns[]} = {};
                this.gpuInstanceMap = {};
                this.gpuInstanceBatcherMap = {};
                this.needSort = _sort;
            }
            renderLayer.prototype.addInstance = function (r) {
                var mr = r;
                var mf = mr.filter;
                if (!mf || !mf.mesh)
                    return;
                var mat = mr.materials[0];
                if (!mat)
                    return;
                var gpuInstancingGUID = mat.gpuInstancingGUID;
                if (!gpuInstancingGUID)
                    return;
                var id = renderLayer.getRandererGUID(mf.mesh.getGUID(), gpuInstancingGUID);
                if (!this.gpuInstanceMap[id]) {
                    this.gpuInstanceMap[id] = new m4m.math.ReuseArray();
                }
                this.gpuInstanceMap[id].push(r);
            };
            renderLayer.prototype.addInstanceToBatcher = function (r) {
                var mr = r;
                var mf = mr.filter;
                if (!mf)
                    return;
                var mat = mr.materials[0];
                if (!mat)
                    return;
                var gpuInstancingGUID = mat.gpuInstancingGUID;
                if (!gpuInstancingGUID)
                    return;
                // if(!mf){
                //     mf = mr.gameObject.getComponent("meshFilter") as m4m.framework.meshFilter;
                // }
                var mesh = mf.mesh;
                var id = renderLayer.getRandererGUID(mesh.getGUID(), gpuInstancingGUID);
                var bs = this.gpuInstanceBatcherMap[id];
                if (!bs) {
                    bs = this.gpuInstanceBatcherMap[id] = new m4m.framework.meshGpuInsBatcher(mr.gameObject.layer, mesh, mr.materials);
                }
                for (var i = 0, len = bs.bufferDArrs.length; i < len; i++) {
                    var pass = bs.passArr[i];
                    var darr = bs.bufferDArrs[i];
                    m4m.framework.meshRenderer.setInstanceOffsetMatrix(mr.gameObject.transform, mat, pass); //RTS offset 矩阵
                    mat.uploadInstanceAtteribute(pass, darr); //收集 各material instance atteribute
                }
                bs.count++;
            };
            /** gpuInstancing 唯一ID */
            renderLayer.getRandererGUID = function (meshGuid, materialGuid) {
                var meshTemp = this.gpuInsRandererGUIDMap[meshGuid];
                if (!meshTemp) {
                    meshTemp = this.gpuInsRandererGUIDMap[meshGuid] = {};
                }
                var rId = meshTemp[materialGuid];
                if (rId == null) {
                    this.gpuInsRandererGUID++;
                    rId = meshTemp[materialGuid] = this.gpuInsRandererGUID;
                }
                return rId;
            };
            renderLayer.gpuInsRandererGUID = -1;
            renderLayer.gpuInsRandererGUIDMap = {};
            return renderLayer;
        }());
        framework.renderLayer = renderLayer;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 场景是基础的功能，有场景图，相当于Unity的Level
         * @version m4m 1.0
         */
        var scene = /** @class */ (function () {
            /**
             * @private
             * @param app
             */
            function scene(app) {
                /** 自动收集场景中灯光 和 相机 */
                this.autoCollectlightCamera = true;
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 参与渲染的相机
                 * @version m4m 1.0
                 */
                this.renderCameras = []; //需要camera class
                this._mainCamera = null;
                this.renderContext = [];
                this.renderLights = []; //需要光源 class
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * lightmap列表
                 * @version m4m 1.0
                 */
                this.lightmaps = []; //lightmap
                this.RealCameraNumber = 0;
                this.app = app;
                this.webgl = app.webgl;
                this.assetmgr = app.getAssetMgr();
                this.rootNode = new framework.transform();
                this.rootNode.scene = this;
                this.renderList = new framework.renderList();
            }
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 添加ScreenSpaceOverlay
             * @version m4m 1.0
             */
            scene.prototype.addScreenSpaceOverlay = function (overlay) {
                if (!overlay)
                    return;
                if (!this._overlay2ds)
                    this._overlay2ds = [];
                var ol2ds = this._overlay2ds;
                if (ol2ds.indexOf(overlay) != -1)
                    return;
                ol2ds.push(overlay);
                this.sortOverLays(ol2ds);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 删除ScreenSpaceOverlay
             * @version m4m 1.0
             */
            scene.prototype.removeScreenSpaceOverlay = function (overlay) {
                var ol2ds = this._overlay2ds;
                if (!overlay || !ol2ds)
                    return;
                var idx = ol2ds.indexOf(overlay);
                if (idx != -1)
                    ol2ds.splice(idx, 1);
                this.sortOverLays(ol2ds);
            };
            Object.defineProperty(scene.prototype, "mainCamera", {
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 获取当前主相机
                 * @version m4m 1.0
                 */
                get: function () {
                    if (this._mainCamera == null) {
                        this._mainCamera = this.renderCameras[0];
                    }
                    return this._mainCamera;
                },
                /**
                 * @public
                 * @language zh_CN
                 * @classdesc
                 * 设置当前主相机
                 * @param _camera 相机组件实例
                 * @version m4m 1.0
                 */
                set: function (_camera) {
                    for (var i in this.renderCameras) {
                        if (this.renderCameras[i] == _camera) {
                            this._mainCamera = _camera;
                        }
                    }
                },
                enumerable: false,
                configurable: true
            });
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 场景的刷新函数
             * @param delta
             * @version m4m 1.0
             */
            scene.prototype.update = function (delta) {
                //更新矩阵
                //this.rootNode.updateTran(false);
                //this.rootNode.updateAABBChild();//更新完tarn再更新子物体aabb 确保每个transform的aabb正确
                framework.material["lastDrawMatID"] = framework.material["lastDrawMeshID"] = m4m.render.glDrawPass["lastPassID"] = -1; //每帧 清理 material 的记录 ， 避免 显示bug
                //更新跑一遍，刷出渲染列表
                if (this.autoCollectlightCamera) {
                    this.renderCameras.length = 0;
                    this.renderLights.length = 0;
                }
                this.renderList.clear();
                // aniplayer.playerCaches = [];
                this.updateSceneOverLay(delta);
                //递归的更新与填充渲染列表
                this.updateScene(this.rootNode, delta);
                if (this.onLateUpdate)
                    this.onLateUpdate(delta);
                if (framework.physics2D && framework.physics2D.engineRunner) {
                    framework.physics2D.engineRunner.tick(delta);
                }
                if (framework.physics) {
                    framework.physics._step(delta);
                }
                //清理空引用
                if (this._mainCamera && !this._mainCamera.gameObject) {
                    this._mainCamera = null;
                }
                //排序camera 并绘制
                if (this.renderCameras.length > 1) {
                    this.renderCameras.sort(function (a, b) {
                        return a.order - b.order;
                    });
                }
                this.RealCameraNumber = 0;
                var len = this.renderCameras.length;
                for (var i = 0; i < len; i++) {
                    m4m.render.glDrawPass.resetLastState();
                    if (i == len - 1) {
                        this.renderCameras[i].isLastCamera = true;
                    }
                    if (this.app.beRendering) {
                        this._renderCamera(i);
                    }
                    this.renderCameras[i].isLastCamera = false;
                }
                // this.updateSceneOverLay(delta);
                this.rendererSceneOverLay();
                if (this.RealCameraNumber == 0 && this.app && this.app.beRendering) {
                    this.webgl.clearColor(0, 0, 0, 1);
                    this.webgl.clearDepth(1.0);
                    this.webgl.clear(this.webgl.COLOR_BUFFER_BIT | this.webgl.DEPTH_BUFFER_BIT);
                    this.webgl.flush();
                }
                if (framework.DrawCallInfo.BeActived) {
                    framework.DrawCallInfo.inc.showPerFrame();
                    framework.DrawCallInfo.inc.reset();
                }
            };
            //渲染场景 2dUI overlay
            scene.prototype.rendererSceneOverLay = function () {
                var ol2ds = this._overlay2ds;
                if (!ol2ds || ol2ds.length < 1)
                    return;
                var targetcamera = this.mainCamera;
                if (!targetcamera)
                    return;
                var rCams = this.renderCameras;
                var mainCamIdx = rCams.indexOf(targetcamera);
                if (mainCamIdx == -1) {
                    var cname = targetcamera.gameObject.getName();
                    var oktag = false;
                    for (var i = 0, l = rCams.length; i < l; i++) {
                        var cam = rCams[i];
                        if (cam && cam.gameObject.getName() == cname) {
                            targetcamera = this.mainCamera = cam;
                            oktag = true;
                            break;
                        }
                    }
                    if (!oktag) {
                        this._mainCamera = null;
                        targetcamera = this.mainCamera;
                    }
                }
                mainCamIdx = rCams.indexOf(targetcamera);
                if (!targetcamera)
                    return;
                var len = ol2ds.length;
                for (var i = 0, l = len; i < l; ++i) {
                    var overlay = ol2ds[i];
                    if (overlay && this.app && this.app.beRendering) {
                        overlay.render(this.renderContext[mainCamIdx], this.assetmgr, targetcamera);
                    }
                }
            };
            //更新 scene overlayers
            scene.prototype.updateSceneOverLay = function (delta) {
                var ol2ds = this._overlay2ds;
                if (!ol2ds || ol2ds.length < 1)
                    return;
                var targetcamera = this.mainCamera;
                if (!targetcamera)
                    return;
                if (this.renderCameras.indexOf(targetcamera) == -1)
                    return;
                for (var i = 0, l = ol2ds.length; i < l; ++i) {
                    var overlay = ol2ds[i];
                    if (overlay) {
                        overlay.start(targetcamera);
                        overlay.update(delta);
                    }
                }
            };
            //这个函数后面还有别的过程，应该留给camera
            scene.prototype._renderCamera = function (camindex) {
                //增加当前编辑器状态，管控场编相机
                //一个camera 不是一次单纯的绘制，camera 还有多个绘制遍
                var cam = this.renderCameras[camindex];
                var context = this.renderContext[camindex];
                context.fog = this.fog;
                if ((this.app.bePlay && !cam.isEditorCam) || (!this.app.bePlay && cam.isEditorCam)) {
                    context.updateCamera(this.app, cam);
                    context.updateLights(this.renderLights);
                    cam.fillRenderer(this);
                    cam.renderScene(this, context, camindex);
                    this.RealCameraNumber++;
                    // //还有overlay
                    var overLays = cam.getOverLays();
                    for (var i = 0; i < overLays.length; i++) {
                        if (cam.CullingMask & framework.CullingMask.ui) {
                            overLays[i].render(context, this.assetmgr, cam);
                        }
                    }
                }
                if (!this.app.bePlay && this.app.be2dstate) {
                    if (camindex == this.app.curcameraindex) {
                        var overLays = cam.getOverLays();
                        for (var i = 0; i < overLays.length; i++) {
                            if (cam.CullingMask & framework.CullingMask.ui) {
                                overLays[i].render(context, this.assetmgr, cam);
                            }
                        }
                    }
                }
            };
            scene.prototype.sortOverLays = function (lays) {
                if (!lays || lays.length < 1)
                    return;
                lays.sort(function (a, b) {
                    return a.sortOrder - b.sortOrder;
                });
            };
            scene.prototype.updateScene = function (node, delta) {
                if (this.app.bePlay) {
                    this.objupdate(node, delta);
                }
                else {
                    this.objupdateInEditor(node, delta);
                }
            };
            scene.prototype.objupdateInEditor = function (node, delta) {
                node.gameObject.init(); //组件还未初始化的初始化
                if (node.gameObject.renderer != null) {
                    node.gameObject.renderer.update(delta); //update 了啥
                }
                if (node.gameObject.camera) {
                    node.gameObject.camera.update(delta); //update 了啥
                }
                if (this.autoCollectlightCamera)
                    this.collectCameraAndLight(node);
                if (node.children != null) {
                    for (var i = 0; i < node.children.length; i++) {
                        this.objupdateInEditor(node.children[i], delta);
                    }
                }
            };
            scene.prototype.objupdate = function (node, delta) {
                var needInit = node.hasInitComp || node.hasInitCompChild || node.hasOnPlayComp || node.hasOnPlayCompChild;
                var needUpate = node.needUpdate;
                if (needUpate)
                    needUpate = node.hasUpdateComp || node.hasUpdateCompChild;
                if (!needInit && !needUpate)
                    return; //init 和 update 都不需要 直接return
                if (node.hasInitCompChild) {
                    node.hasInitCompChild = false;
                }
                var go = node.gameObject;
                // if (go.needInit){
                if (node.hasInitComp) {
                    go.init(this.app.bePlay); //组件还未初始化的初始化
                }
                if (node.hasUpdateComp || node.hasOnPlayComp || node.hasOnPlayCompChild) {
                    go.update(delta);
                }
                // if(this.autoCollectlightCamera)          //流程放入 camera 和 light 的update中了
                //     this.collectCameraAndLight(node);
                //这里要检测长度 因为在update 或init中 children会改变
                for (var i = 0; i < node.children.length; ++i)
                    this.objupdate(node.children[i], delta);
            };
            /*
            private objupdate(node: transform, delta)//play状态下
            {
                if (!node) return;
                if (node.hasComponent == false && node.hasComponentChild == false)
                    return;
                node.gameObject.init(this.app.bePlay);//组件还未初始化的初始化
                if (node.gameObject.haveComponet)
                {
                    node.gameObject.update(delta);
    
                    this.collectCameraAndLight(node);
                }
                if (node.children)
                {
    
                    for (var i = 0, l = node.children.length; i < l; i++)
                    {
                        this.objupdate(node.children[i], delta);
                    }
                }
            }
            */
            scene.prototype.collectCameraAndLight = function (node) {
                //update 的时候只收集摄像机和灯光信息
                //收集摄像机
                var c = node.gameObject.camera;
                if (c != null && c.gameObject.visibleInScene) {
                    this.renderCameras.push(c);
                }
                var cl = this.renderCameras.length;
                while (this.renderContext.length < cl) {
                    this.renderContext.push(new framework.renderContext(this.webgl));
                }
                //收集灯光
                var l = node.gameObject.light;
                if (l != null && node.gameObject.visible) {
                    this.renderLights.push(l);
                }
            };
            /**
             * 添加灯光到场景中（autoCollectlightCamera : false 时  有效 ）
             * @param l 灯光组件
             */
            scene.prototype.addLight = function (l) {
                if (this.renderLights.indexOf(l) != -1)
                    return;
                this.renderLights.push(l);
            };
            /**
             * 清除场景中添加过的灯光 （autoCollectlightCamera : false 时  有效 ）
            */
            scene.prototype.clearLights = function () {
                this.renderLights.length = 0;
            };
            /**
             * 添加相机到场景中（autoCollectlightCamera : false 时  有效 ）
             * @param l 灯光组件
             */
            scene.prototype.addCamera = function (cam) {
                if (this.renderCameras.indexOf(cam) != -1)
                    return;
                this.renderCameras.push(cam);
                this.renderContext.push(new framework.renderContext(this.webgl));
            };
            /**
             * 清除场景中添加过的相机 （autoCollectlightCamera : false 时 有效 ）
            */
            scene.prototype.clearCameras = function () {
                this.renderCameras.length = 0;
                this.renderContext.length = 0;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 场景根节点下添加物体
             * @param node 要添加的transform
             * @version m4m 1.0
             */
            scene.prototype.addChild = function (node) {
                this.rootNode.addChild(node);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 场景根节点下移出物体
             * @param node 要移出的transform
             * @version m4m 1.0
             */
            scene.prototype.removeChild = function (node) {
                this.rootNode.removeChild(node);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取children列表
             * @version m4m 1.0
             */
            scene.prototype.getChildren = function () {
                return this.rootNode.children;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取children数量
             * @version m4m 1.0
             */
            scene.prototype.getChildCount = function () {
                if (this.rootNode.children == null)
                    return 0;
                return this.rootNode.children.length;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 根据索引获取child
             * @param index 索引
             * @version m4m 1.0
             */
            scene.prototype.getChild = function (index) {
                return this.rootNode.children[index];
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 根据name获取child
             * @param name
             * @version m4m 1.0
             */
            scene.prototype.getChildByName = function (name) {
                var res = this.rootNode.find(name);
                return res;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取场景根节点
             * @version m4m 1.0
             */
            scene.prototype.getRoot = function () {
                return this.rootNode;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取射线路径上的所有物体
             * @param ray 射线实例
             * @param isPickMesh 是否为拾取mesh 否为拾取collider
             * @version m4m 1.0
             */
            scene.prototype.pickAll = function (ray, outInfos, isPickMesh, root, layermask) {
                if (isPickMesh === void 0) { isPickMesh = false; }
                if (root === void 0) { root = this.getRoot(); }
                if (layermask === void 0) { layermask = NaN; }
                if (!outInfos || !ray)
                    return false;
                var isHited = this.doPick(ray, true, isPickMesh, root, outInfos, layermask);
                return isHited;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取射线拾取到的最近物体
             * @param ray 射线实例
             * @param isPickMesh 是否为拾取mesh 否为拾取collider
             * @version m4m 1.0
             */
            scene.prototype.pick = function (ray, outInfo, isPickMesh, root, layermask) {
                if (isPickMesh === void 0) { isPickMesh = false; }
                if (root === void 0) { root = this.getRoot(); }
                if (layermask === void 0) { layermask = NaN; }
                if (!outInfo || !ray)
                    return false;
                var isHited = this.doPick(ray, false, isPickMesh, root, outInfo, layermask);
                return isHited;
                //pickinfo.pickedtran.gameObject.collider.subTran.gameObject.visible = !pickinfo.pickedtran.gameObject.collider.subTran.gameObject.visible;
                //pickinfo.pickedtran.markDirty();
            };
            scene.prototype.doPick = function (ray, pickall, isPickMesh, root, out, layermask) {
                if (layermask === void 0) { layermask = NaN; }
                var ishited = false;
                var pickedList = new Array();
                if (isPickMesh) {
                    ishited = this.pickMesh(ray, root, pickedList, layermask);
                }
                else {
                    ishited = this.pickCollider(ray, root, pickedList, layermask);
                }
                if (pickedList.length == 0)
                    return ishited;
                if (pickall) {
                    out.length = 0;
                    pickedList.forEach(function (element) {
                        out.push(element);
                    });
                }
                else {
                    var index = 0;
                    for (var i = 1; i < pickedList.length; i++) {
                        if (pickedList[i].distance < pickedList[index].distance)
                            index = i;
                    }
                    //return pickedList[index];
                    var temp = pickedList.splice(index, 1);
                    out.cloneFrom(temp[0]);
                    pickedList.forEach(function (element) {
                        m4m.math.pool.delete_pickInfo(element);
                    });
                    pickedList.length = 0;
                }
                return ishited;
            };
            scene.prototype.pickMesh = function (ray, tran, pickedList, layermask) {
                if (layermask === void 0) { layermask = NaN; }
                var ishited = false;
                if (tran.gameObject != null) {
                    if (!tran.gameObject.visible)
                        return ishited;
                    var canDo = true;
                    //if(!isNaN(layermask) && layermask != tran.gameObject.layer) canDo = false;
                    if (!isNaN(layermask) && (layermask & (1 << tran.gameObject.layer)) == 0)
                        canDo = false;
                    if (canDo) {
                        var meshFilter = tran.gameObject.getComponent("meshFilter");
                        if (meshFilter != null) {
                            //3d normal mesh
                            var mesh = meshFilter.getMeshOutput();
                            if (mesh) {
                                var pinfo = m4m.math.pool.new_pickInfo();
                                var bool_1 = mesh.intersects(ray, tran.getWorldMatrix(), pinfo);
                                if (bool_1) {
                                    ishited = true;
                                    pickedList.push(pinfo);
                                    pinfo.pickedtran = tran;
                                }
                            }
                        }
                        else {
                            var skinmesh = tran.gameObject.getComponent("skinnedMeshRenderer");
                            if (skinmesh != null) {
                                //3d skinmesh
                                var pinfo = m4m.math.pool.new_pickInfo();
                                var bool = skinmesh.intersects(ray, pinfo);
                                if (bool) {
                                    ishited = true;
                                    pickedList.push(pinfo);
                                    pinfo.pickedtran = tran;
                                }
                            }
                        }
                    }
                }
                if (tran.children != null) {
                    for (var i = 0; i < tran.children.length; i++) {
                        var bool_2 = this.pickMesh(ray, tran.children[i], pickedList, layermask);
                        if (!ishited)
                            ishited = bool_2;
                    }
                }
                return ishited;
            };
            scene.prototype.pickCollider = function (ray, tran, pickedList, layermask) {
                if (layermask === void 0) { layermask = NaN; }
                var ishited = false;
                if (tran.gameObject != null) {
                    if (!tran.gameObject.visible)
                        return ishited;
                    if (tran.gameObject.collider != null) {
                        var canDo = true;
                        if (!isNaN(layermask) && (layermask & (1 << tran.gameObject.layer)) == 0)
                            canDo = false;
                        //console.error(`${tran.gameObject.layer}  --  ${layermask}`);
                        if (canDo) {
                            //挂了collider
                            var pinfo = m4m.math.pool.new_pickInfo();
                            var bool = ray.intersectCollider(tran, pinfo);
                            if (bool) {
                                ishited = true;
                                pickedList.push(pinfo);
                                pinfo.pickedtran = tran;
                            }
                        }
                    }
                }
                if (tran.children != null) {
                    for (var i = 0; i < tran.children.length; i++) {
                        var bool_3 = this.pickCollider(ray, tran.children[i], pickedList, layermask);
                        if (!ishited)
                            ishited = bool_3;
                    }
                }
                return ishited;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 启用物理到当前场景
             * @param gravity 定义场景物理世界的重力向量
             * @param plugin 定义场景物理世界引擎插件
             * @version m4m 1.0
             */
            scene.prototype.enablePhysics = function (gravity, plugin) {
                if (framework.physics) {
                    return true;
                }
                if (!plugin)
                    plugin = new framework.OimoJSPlugin();
                try {
                    framework.physics = new framework.PhysicsEngine(gravity, plugin);
                    return true;
                }
                catch (e) {
                    // console.error(e.message);
                    throw e;
                    return false;
                }
                //physic=new PhysicsEngine(new math.vector3(0,-9.8,0),new OimoJSPlugin());
            };
            scene.prototype.enable2DPhysics = function (gravity, physicOption) {
                if (physicOption === void 0) { physicOption = null; }
                if (framework.physics2D) {
                    return true;
                }
                try {
                    framework.physics2D = new framework.physicEngine2D(physicOption);
                    framework.physics2D.setGravity(gravity.x, gravity.y);
                    return true;
                }
                catch (e) {
                    // console.error(e.message);
                    throw e;
                    return false;
                }
            };
            /**
             * 刷新 GpuInstancBatcher
             * 被 batcher 条件[isStatic= true , visible = true , needGpuInstancBatcher = true , isGpuInstancing() = true]
             * @param rootNode 指定刷新节点（默认为 场景根节点）
             */
            scene.prototype.refreshGpuInstancBatcher = function (rootNode) {
                //清理历史 缓存
                this.renderList.clearBatcher();
                //遍历所有 渲染对象，有标记的（静态 && gpuInstancingTag ）加到batcher列表
                if (!rootNode)
                    rootNode = this.rootNode;
                this.fillGpuInsBatcher(rootNode, rootNode.gameObject.isStatic);
            };
            scene.prototype.fillGpuInsBatcher = function (node, isStatic) {
                if (!this.webgl.drawArraysInstanced)
                    return;
                //检查渲染对象
                var go = node.gameObject;
                isStatic = isStatic || go.isStatic;
                if (!go || !go.visible || (node.hasRendererComp == false && node.hasRendererCompChild == false))
                    return; //自己没有渲染组件 且 子物体也没有 return
                var renderer = go.renderer;
                if (renderer) {
                    this.renderList.addStaticInstanceRenderer(renderer, this.webgl, isStatic);
                }
                var children = node.children;
                if (children) {
                    for (var i = 0, len = children.length; i < len; i++) {
                        this.fillGpuInsBatcher(children[i], isStatic);
                    }
                }
            };
            return scene;
        }());
        framework.scene = scene;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var uniformSetter = /** @class */ (function () {
            function uniformSetter() {
            }
            uniformSetter.initAutouniform = function () {
                this.autoUniformDic["glstate_matrix_model"] = function (context) {
                    return context.matrixModel;
                };
                this.autoUniformDic["glstate_matrix_world2object"] = function (context) {
                    return context.matrixWorld2Object;
                };
                this.autoUniformDic["glstate_matrix_view"] = function (context) {
                    return context.matrixView;
                };
                this.autoUniformDic["glstate_matrix_project"] = function (context) {
                    return context.matrixProject;
                };
                this.autoUniformDic["glstate_matrix_modelview"] = function (context) {
                    return context.matrixModelView;
                };
                this.autoUniformDic["glstate_matrix_it_modelview"] = function (context) {
                    return context.matrixInverseModelView;
                };
                this.autoUniformDic["glstate_matrix_viewproject"] = function (context) {
                    return context.matrixViewProject;
                };
                this.autoUniformDic["glstate_matrix_mvp"] = function (context) {
                    return context.matrixModelViewProject;
                };
                this.autoUniformDic["glstate_timer"] = function (context) {
                    return context.floatTimer;
                };
                this.autoUniformDic["glstate_lightcount"] = function (context) {
                    return context.intLightCount;
                };
                this.autoUniformDic["glstate_vec4_lightposs"] = function (context) {
                    return context.vec4LightPos;
                };
                this.autoUniformDic["glstate_vec4_lightdirs"] = function (context) {
                    return context.vec4LightDir;
                };
                this.autoUniformDic["glstate_vec4_lightcolors"] = function (context) {
                    return context.vec4LightColor;
                };
                this.autoUniformDic["glstate_float_lightrange"] = function (context) {
                    return context.floatLightRange;
                };
                this.autoUniformDic["glstate_float_lightintensity"] = function (context) {
                    return context.floatLightIntensity;
                };
                this.autoUniformDic["glstate_float_spotangelcoss"] = function (context) {
                    return context.floatLightSpotAngleCos;
                };
                this.autoUniformDic["glstate_eyepos"] = function (context) {
                    return context.eyePos;
                };
                this.autoUniformDic["_LightmapTex"] = function (context) {
                    return context.lightmap;
                };
                this.autoUniformDic["_LightmapTex_01"] = function (context) {
                    return context.lightmap_01;
                };
                this.autoUniformDic["glstate_lightmapOffset"] = function (context) {
                    return context.lightmapOffset;
                };
                this.autoUniformDic["glstate_lightmapUV"] = function (context) {
                    return context.lightmapUV;
                };
                this.autoUniformDic["glstate_lightmapRGBAF16"] = function (context) {
                    return context.lightmapRGBAF16;
                };
                this.autoUniformDic["glstate_fog_start"] = function (context) {
                    return context.fog._Start;
                };
                this.autoUniformDic["glstate_fog_end"] = function (context) {
                    return context.fog._End;
                };
                this.autoUniformDic["glstate_fog_color"] = function (context) {
                    return context.fog._Color;
                };
                this.autoUniformDic["glstate_vec4_bones"] = function (context) {
                    return context.vec4_bones;
                };
                this.autoUniformDic["glstate_matrix_bones"] = function (context) {
                    return context.matrix_bones;
                };
            };
            uniformSetter.autoUniformDic = {};
            return uniformSetter;
        }());
        framework.uniformSetter = uniformSetter;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @private
         */
        var taskstate = /** @class */ (function () {
            function taskstate() {
                this.finish = false;
                this.error = false;
                this.message = null;
                this.cancel = false;
                this.taskCall = null;
                this.taskInterface = null;
            }
            return taskstate;
        }());
        framework.taskstate = taskstate;
        /**
         * @private
         */
        var taskMgr = /** @class */ (function () {
            function taskMgr() {
                this.tasks = [];
                //lasttask: (laststate: taskstate, state: taskstate) => void;
                this.laststate = null;
            }
            taskMgr.prototype.addTaskCall = function (task) {
                var st = new taskstate();
                st.taskCall = task;
                this.tasks.push(st);
            };
            taskMgr.prototype.addTask = function (task) {
                var st = new taskstate();
                st.taskInterface = task;
                this.tasks.push(st);
            };
            taskMgr.prototype.move = function (delta) {
                if (this.laststate != null && this.laststate.cancel) {
                    return;
                }
                if (this.laststate != null && this.laststate.finish == false) {
                    return;
                }
                var task = this.tasks.shift();
                if (task == null) {
                    return;
                }
                var state = new taskstate();
                var laststate = this.laststate;
                this.laststate = state;
                if (task.taskInterface == null) {
                    task.taskCall(laststate, state);
                }
                else {
                    task.taskInterface.move(delta, laststate, state);
                }
            };
            taskMgr.prototype.cancel = function () {
                if (this.laststate != null) {
                    this.laststate.cancel = true;
                }
            };
            return taskMgr;
        }());
        framework.taskMgr = taskMgr;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var threading;
    (function (threading) {
        var gdPromise = /** @class */ (function () {
            // private thenCall: (val: T) => void;
            function gdPromise(executor) {
                var _this = this;
                this.execQueue = new Array();
                setTimeout(function () {
                    executor(_this.resolve.bind(_this), _this.reject.bind(_this));
                }, 0);
            }
            gdPromise.prototype.resolve = function (value) {
                try {
                    // if (this.thenCall)
                    //     this.thenCall(value);
                    while (this.execQueue.length > 0)
                        this.execQueue.shift()(value);
                }
                catch (e) {
                    this.reject(e);
                }
            };
            gdPromise.prototype.reject = function (reason) {
                console.error(reason);
                if (this.catchMethod)
                    return this.catchMethod(reason);
            };
            gdPromise.prototype.then = function (thenCall) {
                // this.thenCall = thenCall;
                this.execQueue.push(thenCall);
                return this;
            };
            gdPromise.prototype.catch = function (callbcack) {
                this.catchMethod = callbcack;
                return this;
            };
            return gdPromise;
        }());
        threading.gdPromise = gdPromise;
    })(threading = m4m.threading || (m4m.threading = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var threading;
    (function (threading) {
        var thread = /** @class */ (function () {
            function thread() {
                var _this = this;
                this.callID = 0;
                this.callMap = {}; //new Map<number, { resolve: any }>();
                if (!thread.workerInstance) {
                    this.worker = new Worker("lib/th.js");
                    this.worker.onmessage = function (e) {
                        //e.data.id
                        _this.OnMessage(e);
                    };
                    this.worker.onerror = function (e) {
                        console.error(e);
                    };
                }
                else {
                    this.worker = thread.workerInstance;
                }
            }
            Object.defineProperty(thread, "Instance", {
                get: function () {
                    if (!thread.instance)
                        thread.instance = new thread();
                    return thread.instance;
                },
                enumerable: false,
                configurable: true
            });
            thread.prototype.OnMessage = function (e) {
                if (e.data && this.callMap[e.data.id]) {
                    this.callMap[e.data.id].callback(e.data.result);
                    delete this.callMap[e.data.id];
                }
            };
            thread.prototype.Call = function (name, data, callback) {
                this.worker.postMessage({
                    handle: name,
                    data: data,
                    id: ++this.callID
                });
                this.callMap[this.callID] = { callback: callback };
            };
            return thread;
        }());
        threading.thread = thread;
    })(threading = m4m.threading || (m4m.threading = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 表示轴对称包围盒
         * @version m4m 1.0
         */
        var aabb = /** @class */ (function () {
            /**
            * @public
            * @language zh_CN
            * 构建轴对称包围盒
            * @param _minimum 最小点
            * @param _maximum 最大点
            * @version m4m 1.0
            * @platform Web,Native
            */
            function aabb(_minimum, _maximum) {
                this.opmin = new m4m.math.vector3();
                this.opmax = new m4m.math.vector3();
                this._center = new m4m.math.vector3();
                this.srcmin = m4m.math.pool.clone_vector3(_minimum);
                this.srcmax = m4m.math.pool.clone_vector3(_maximum);
                this.minimum = m4m.math.pool.clone_vector3(_minimum);
                this.maximum = m4m.math.pool.clone_vector3(_maximum);
            }
            /**
            * @public
            * @language zh_CN
            * 刷新轴对称包围盒
            * @param worldmatrix 物体的世界矩阵
            * @version m4m 1.0
            * @platform Web,Native
            */
            aabb.prototype.update = function (worldmatrix) {
                // m4m.math.matrixGetTranslation(worldmatrix, this.opmin);
                // m4m.math.matrixGetTranslation(worldmatrix, this.opmax);
                // if (worldmatrix.rawData[0] > 0)
                // {
                //     this.opmin.x += worldmatrix.rawData[0] * this.srcmin.x;
                //     this.opmax.x += worldmatrix.rawData[0] * this.srcmax.x;
                // }
                // else
                // {
                //     this.opmin.x += worldmatrix.rawData[0] * this.srcmax.x;
                //     this.opmax.x += worldmatrix.rawData[0] * this.srcmin.x;
                // }
                // if (worldmatrix.rawData[1] > 0)
                // {
                //     this.opmin.y += worldmatrix.rawData[1] * this.srcmin.y;
                //     this.opmax.y += worldmatrix.rawData[1] * this.srcmax.y;
                // }
                // else
                // {
                //     this.opmin.y += worldmatrix.rawData[1] * this.srcmax.y;
                //     this.opmax.y += worldmatrix.rawData[1] * this.srcmin.y;
                // }
                // if (worldmatrix.rawData[2] > 0)
                // {
                //     this.opmin.z += worldmatrix.rawData[2] * this.srcmin.z;
                //     this.opmax.z += worldmatrix.rawData[2] * this.srcmax.z;
                // }
                // else
                // {
                //     this.opmin.z += worldmatrix.rawData[2] * this.srcmax.z;
                //     this.opmax.z += worldmatrix.rawData[2] * this.srcmin.z;
                // }
                // if (worldmatrix.rawData[4] > 0)
                // {
                //     this.opmin.x += worldmatrix.rawData[4] * this.srcmin.x;
                //     this.opmax.x += worldmatrix.rawData[4] * this.srcmax.x;
                // }
                // else
                // {
                //     this.opmin.x += worldmatrix.rawData[4] * this.srcmax.x;
                //     this.opmax.x += worldmatrix.rawData[4] * this.srcmin.x;
                // }
                // if (worldmatrix.rawData[5] > 0)
                // {
                //     this.opmin.y += worldmatrix.rawData[5] * this.srcmin.y;
                //     this.opmax.y += worldmatrix.rawData[5] * this.srcmax.y;
                // }
                // else
                // {
                //     this.opmin.y += worldmatrix.rawData[5] * this.srcmax.y;
                //     this.opmax.y += worldmatrix.rawData[5] * this.srcmin.y;
                // }
                // if (worldmatrix.rawData[6] > 0)
                // {
                //     this.opmin.z += worldmatrix.rawData[6] * this.srcmin.z;
                //     this.opmax.z += worldmatrix.rawData[6] * this.srcmax.z;
                // }
                // else
                // {
                //     this.opmin.z += worldmatrix.rawData[6] * this.srcmax.z;
                //     this.opmax.z += worldmatrix.rawData[6] * this.srcmin.z;
                // }
                // if (worldmatrix.rawData[8] > 0)
                // {
                //     this.opmin.x += worldmatrix.rawData[8] * this.srcmin.x;
                //     this.opmax.x += worldmatrix.rawData[8] * this.srcmax.x;
                // }
                // else
                // {
                //     this.opmin.x += worldmatrix.rawData[8] * this.srcmax.x;
                //     this.opmax.x += worldmatrix.rawData[8] * this.srcmin.x;
                // }
                // if (worldmatrix.rawData[9] > 0)
                // {
                //     this.opmin.y += worldmatrix.rawData[9] * this.srcmin.y;
                //     this.opmax.y += worldmatrix.rawData[9] * this.srcmax.y;
                // }
                // else
                // {
                //     this.opmin.y += worldmatrix.rawData[9] * this.srcmax.y;
                //     this.opmax.y += worldmatrix.rawData[9] * this.srcmin.y;
                // }
                // if (worldmatrix.rawData[10] > 0)
                // {
                //     this.opmin.z += worldmatrix.rawData[10] * this.srcmin.z;
                //     this.opmax.z += worldmatrix.rawData[10] * this.srcmax.z;
                // }
                // else
                // {
                //     this.opmin.z += worldmatrix.rawData[10] * this.srcmax.z;
                //     this.opmax.z += worldmatrix.rawData[10] * this.srcmin.z;
                // }
                m4m.math.matrixTransformVector3(this.srcmax, worldmatrix, this.opmax);
                m4m.math.matrixTransformVector3(this.srcmin, worldmatrix, this.opmin);
                // recalculat max and min
                var temp = m4m.math.pool.new_vector3();
                m4m.math.vec3Max(this.opmax, this.opmin, temp);
                m4m.math.vec3Min(this.opmax, this.opmin, this.opmin);
                m4m.math.vec3Clone(temp, this.opmax);
                m4m.math.pool.delete_vector3(temp);
                // this.minimum = m4m.math.pool.clone_vector3(this.opmin);
                // this.maximum = m4m.math.pool.clone_vector3(this.opmax);
                m4m.math.vec3Clone(this.opmin, this.minimum);
                m4m.math.vec3Clone(this.opmax, this.maximum);
            };
            /**
            * @public
            * @language zh_CN
            * 包含一个点
            * @param vec 世界坐标
            * @version m4m 1.0
            * @platform Web,Native
            */
            aabb.prototype.addVector3 = function (vec) {
                m4m.math.vec3Max(this.maximum, vec, this.maximum);
                m4m.math.vec3Max(this.minimum, vec, this.minimum);
            };
            /**
            * @public
            * @language zh_CN
            * 检查是否包含点
            * @param vec 世界坐标
            * @version m4m 1.0
            * @platform Web,Native
            */
            aabb.prototype.containsVector3 = function (vec) {
                return (vec.x > this.minimum.x) && (vec.x < this.maximum.x) &&
                    (vec.y > this.minimum.y) && (vec.x < this.maximum.y) &&
                    (vec.z > this.minimum.z) && (vec.z < this.maximum.z);
            };
            /**
            * @public
            * @language zh_CN
            * 检查是否与aabb相交
            * @param aabb 轴对称包围盒
            * @version m4m 1.0
            * @platform Web,Native
            */
            aabb.prototype.intersectAABB = function (aabb) {
                if (this.minimum.x > aabb.maximum.x)
                    return false;
                if (this.maximum.x < aabb.minimum.x)
                    return false;
                if (this.minimum.x > aabb.maximum.x)
                    return false;
                if (this.maximum.x < aabb.minimum.x)
                    return false;
                if (this.minimum.x > aabb.maximum.x)
                    return false;
                if (this.maximum.x < aabb.minimum.x)
                    return false;
                return true;
            };
            /**
            * @public
            * @language zh_CN
            * 包含一个aabb
            * @param aabb 轴对称包围盒
            * @version m4m 1.0
            * @platform Web,Native
            */
            aabb.prototype.addAABB = function (aabb) {
                if (aabb != null) {
                    m4m.math.vec3Max(this.maximum, aabb.maximum, this.maximum);
                    m4m.math.vec3Min(this.minimum, aabb.minimum, this.minimum);
                }
            };
            Object.defineProperty(aabb.prototype, "center", {
                /**
                * @public
                * @language zh_CN
                * 计算包围盒的中心位置
                * @version m4m 1.0
                * @platform Web,Native
                */
                get: function () {
                    m4m.math.vec3Add(this.maximum, this.minimum, this._center);
                    m4m.math.vec3ScaleByNum(this._center, 0.5, this._center);
                    return this._center;
                },
                enumerable: false,
                configurable: true
            });
            /**
            * @public
            * @language zh_CN
            * 清空
            * @version m4m 1.0
            * @platform Web,Native
            */
            aabb.prototype.clear = function () {
                m4m.math.vec3SetByFloat(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, this.minimum);
                m4m.math.vec3SetByFloat(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, this.maximum);
            };
            /**
            * @public
            * @language zh_CN
            * 克隆
            * @version m4m 1.0
            * @platform Web,Native
            */
            aabb.prototype.clone = function () {
                var _min = m4m.math.pool.clone_vector3(this.minimum);
                var _max = m4m.math.pool.clone_vector3(this.maximum);
                var aabb = new m4m.framework.aabb(_min, _max);
                return aabb;
            };
            aabb.prototype.cloneTo = function (to) {
                m4m.math.vec3Clone(this.minimum, to.minimum);
                m4m.math.vec3Clone(this.minimum, to.srcmin);
                m4m.math.vec3Clone(this.maximum, to.maximum);
                m4m.math.vec3Clone(this.maximum, to.srcmax);
            };
            /**
            * @public
            * @language zh_CN
            * 获取包围盒顶点数据
            * @param vecs 引用数组
            * @version m4m 1.0
            * @platform Web,Native
            */
            aabb.prototype.getVec3 = function (vecs) {
                vecs[0] = m4m.math.pool.clone_vector3(this.minimum);
                vecs[1] = m4m.math.pool.clone_vector3(this.minimum);
                vecs[1].z = this.maximum.z;
                vecs[2] = m4m.math.pool.clone_vector3(this.minimum);
                vecs[2].x = this.maximum.x;
                vecs[3] = m4m.math.pool.clone_vector3(this.maximum);
                vecs[3].y = this.minimum.y;
                vecs[4] = m4m.math.pool.clone_vector3(this.minimum);
                vecs[4].y = this.maximum.y;
                vecs[5] = m4m.math.pool.clone_vector3(this.maximum);
                vecs[5].x = this.minimum.x;
                vecs[6] = m4m.math.pool.clone_vector3(this.maximum);
                vecs[6].z = this.minimum.z;
                vecs[7] = m4m.math.pool.clone_vector3(this.maximum);
            };
            return aabb;
        }());
        framework.aabb = aabb;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 碰撞检测Tool
         * @version m4m 1.0
         */
        var collision = /** @class */ (function () {
            function collision() {
            }
            //obb-mesh  obb-obb  mesh-mesh
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * obb 碰 obb
            * @version m4m 1.0
            */
            collision.obbVsObb = function (a, b) {
                if (!a || !b)
                    return false;
                var box0 = a;
                var box1 = b;
                var box0_dirs = box0.directions;
                var box1_dirs = box1.directions;
                if (!this.obbOverLap(box0_dirs[0], box0, box1))
                    return false;
                if (!this.obbOverLap(box0_dirs[1], box0, box1))
                    return false;
                if (!this.obbOverLap(box0_dirs[2], box0, box1))
                    return false;
                if (!this.obbOverLap(box1_dirs[0], box0, box1))
                    return false;
                if (!this.obbOverLap(box1_dirs[1], box0, box1))
                    return false;
                if (!this.obbOverLap(box1_dirs[2], box0, box1))
                    return false;
                var tv3 = collision.helpv3;
                m4m.math.vec3Cross(box0_dirs[0], box1_dirs[0], tv3);
                if (!this.obbOverLap(tv3, box0, box1))
                    return false;
                m4m.math.vec3Cross(box0_dirs[0], box1_dirs[1], tv3);
                if (!this.obbOverLap(tv3, box0, box1))
                    return false;
                m4m.math.vec3Cross(box0_dirs[0], box1_dirs[2], tv3);
                if (!this.obbOverLap(tv3, box0, box1))
                    return false;
                m4m.math.vec3Cross(box0_dirs[1], box1_dirs[0], tv3);
                if (!this.obbOverLap(tv3, box0, box1))
                    return false;
                m4m.math.vec3Cross(box0_dirs[1], box1_dirs[1], tv3);
                if (!this.obbOverLap(tv3, box0, box1))
                    return false;
                m4m.math.vec3Cross(box0_dirs[1], box1_dirs[2], tv3);
                if (!this.obbOverLap(tv3, box0, box1))
                    return false;
                m4m.math.vec3Cross(box0_dirs[2], box1_dirs[0], tv3);
                if (!this.obbOverLap(tv3, box0, box1))
                    return false;
                m4m.math.vec3Cross(box0_dirs[2], box1_dirs[1], tv3);
                if (!this.obbOverLap(tv3, box0, box1))
                    return false;
                m4m.math.vec3Cross(box0_dirs[2], box1_dirs[2], tv3);
                if (!this.obbOverLap(tv3, box0, box1))
                    return false;
                return true;
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * sphere 碰 sphere
            * @version m4m 1.0
            */
            collision.sphereVsSphere = function (a, b) {
                if (!a || !b)
                    return false;
                var dis = m4m.math.vec3Distance(a.center, b.center);
                return dis <= a.radius + b.radius;
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * obb 碰 sphere
            * @version m4m 1.0
            */
            collision.obbVsSphere = function (a, b) {
                if (!a || !b)
                    return false;
                var a_dirs = a.directions;
                if (!this.obb_SphereOverLap(a_dirs[0], a, b))
                    return false;
                if (!this.obb_SphereOverLap(a_dirs[1], a, b))
                    return false;
                if (!this.obb_SphereOverLap(a_dirs[2], a, b))
                    return false;
                var axis = collision.helpv3;
                m4m.math.vec3Subtract(a.worldCenter, b.center, axis); //obb 上 到圆心最近点 的轴
                m4m.math.vec3Normalize(axis, axis);
                if (!this.obb_SphereOverLap(axis, a, b))
                    return false;
                var tv3_1 = collision.helpv3_1;
                m4m.math.vec3Cross(a_dirs[0], axis, tv3_1);
                if (!this.obb_SphereOverLap(tv3_1, a, b))
                    return false;
                m4m.math.vec3Cross(a_dirs[1], axis, tv3_1);
                if (!this.obb_SphereOverLap(tv3_1, a, b))
                    return false;
                m4m.math.vec3Cross(a_dirs[2], axis, tv3_1);
                if (!this.obb_SphereOverLap(tv3_1, a, b))
                    return false;
                return true;
            };
            collision.obb_SphereOverLap = function (axis, box0, sphere) {
                var tv2 = this.helpv2;
                var tv2_1 = this.helpv2_1;
                box0.computeExtentsByAxis(axis, tv2);
                sphere.computeExtentsByAxis(axis, tv2_1);
                return this.extentsOverlap(tv2, tv2_1);
            };
            collision.obbOverLap = function (axis, box0, box1) {
                var tv2 = this.helpv2;
                var tv2_1 = this.helpv2_1;
                box0.computeExtentsByAxis(axis, tv2);
                box1.computeExtentsByAxis(axis, tv2_1);
                return this.extentsOverlap(tv2, tv2_1);
            };
            collision.extentsOverlap = function (a, b) {
                return !(a.x > b.y || b.x > a.y);
            };
            collision.helpv3 = new m4m.math.vector3();
            collision.helpv3_1 = new m4m.math.vector3();
            //MeshVsMesh
            //obbVsMesh
            //SphereVsMesh
            //tool fun
            collision.helpv2 = new m4m.math.vector2();
            collision.helpv2_1 = new m4m.math.vector2();
            return collision;
        }());
        framework.collision = collision;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 表示定向包围盒
         * @version m4m 1.0
         */
        var obb = /** @class */ (function () {
            function obb() {
                /** xyz 轴 方向  */
                this._directions = [];
                /** 世界坐标顶半长 */
                this._halfSizeWorld = new m4m.math.vector3();
                /** 世界坐标顶点数据 */
                this._vectorsWorld = new Array();
                /** 世界坐标中心点 */
                this._worldCenter = new m4m.math.vector3();
                /** 世界坐标矩阵 */
                this._worldMatrix = new m4m.math.matrix();
                /**
                * @public
                * @language zh_CN
                * @classdesc
                * 包围盒世界空间下各个点坐标
                * @version m4m 1.0
                */
                this.vectors = new Array();
                this.dirtyMap = {};
            }
            Object.defineProperty(obb.prototype, "vectorsWorld", {
                /**
                * @public
                * @language zh_CN
                * @classdesc
                * 包围盒世界空间下各个点坐标
                * @version m4m 1.0
                */
                get: function () {
                    var needInit = this._vectorsWorld.length < 1;
                    if (needInit) {
                        for (var i = 0; i < 8; i++) {
                            this._vectorsWorld.push(new m4m.math.vector3());
                        }
                    }
                    if (this.dirtyMap[obb.tag_wVectors] || needInit) {
                        var wMtx = this.getWorldMatrix();
                        for (var i = 0; i < 8; i++) {
                            m4m.math.matrixTransformVector3(this.vectors[i], wMtx, this._vectorsWorld[i]);
                        }
                        this.dirtyMap[obb.tag_wVectors] = false;
                    }
                    return this._vectorsWorld;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(obb.prototype, "worldCenter", {
                /**
               * @public
               * @language zh_CN
               * @classdesc
               * 在世界空间的中心点
               * @version m4m 1.0
               */
                get: function () {
                    if (this.dirtyMap[obb.tag_wCenter]) {
                        m4m.math.matrixTransformVector3(this.center, this._worldMatrix, this._worldCenter);
                        this.dirtyMap[obb.tag_wCenter] = false;
                    }
                    return this._worldCenter;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(obb.prototype, "halfSizeWorld", {
                /**
                * @public
                * @language zh_CN
                * @classdesc
                * 包围盒在世界坐标中各轴向半长
                * @version m4m 1.0
                */
                get: function () {
                    if (this.dirtyMap[obb.tag_wHalfSize]) {
                        var wVects = this.vectorsWorld;
                        var wMin = obb.helpv3;
                        var wMax = obb.helpv3_1;
                        m4m.math.vec3SetAll(wMin, Number.MAX_VALUE);
                        m4m.math.vec3SetAll(wMax, -Number.MAX_VALUE);
                        for (var i = 0; i < 8; i++) {
                            var p = wVects[i];
                            wMin.x = p.x < wMin.x ? p.x : wMin.x;
                            wMin.y = p.y < wMin.y ? p.y : wMin.y;
                            wMin.z = p.z < wMin.z ? p.z : wMin.z;
                            wMax.x = p.x > wMax.x ? p.x : wMax.x;
                            wMax.y = p.y > wMax.y ? p.y : wMax.y;
                            wMax.z = p.z > wMax.z ? p.z : wMax.z;
                        }
                        m4m.math.vec3Subtract(wMax, wMin, this._halfSizeWorld);
                        m4m.math.vec3ScaleByNum(this._halfSizeWorld, 0.5, this._halfSizeWorld);
                        this.dirtyMap[obb.tag_wHalfSize] = false;
                    }
                    return this._halfSizeWorld;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(obb.prototype, "directions", {
                /**
                * @public
                * @language zh_CN
                * @classdesc
                * x,y,z 轴方向
                * @version m4m 1.0
                */
                get: function () {
                    if (this.dirtyMap[obb.tag_directions]) {
                        m4m.math.matrixGetVector3ByOffset(this._worldMatrix, 0, this._directions[0]);
                        m4m.math.matrixGetVector3ByOffset(this._worldMatrix, 4, this._directions[1]);
                        m4m.math.matrixGetVector3ByOffset(this._worldMatrix, 8, this._directions[2]);
                        this.dirtyMap[obb.tag_directions] = false;
                    }
                    return this._directions;
                },
                enumerable: false,
                configurable: true
            });
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 获取obb世界矩阵
            * @version m4m 1.0
             */
            obb.prototype.getWorldMatrix = function () {
                return this._worldMatrix;
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 由最大最小点构建定向包围盒
            * @param minimum 最小点坐标
            * @param maximum 最大点坐标
            * @version m4m 1.0
            */
            obb.prototype.buildByMaxMin = function (minimum, maximum) {
                this.vectors[0] = m4m.math.pool.clone_vector3(minimum);
                this.vectors[1] = m4m.math.pool.clone_vector3(minimum);
                this.vectors[1].z = maximum.z;
                this.vectors[2] = m4m.math.pool.clone_vector3(minimum);
                this.vectors[2].x = maximum.x;
                this.vectors[3] = m4m.math.pool.clone_vector3(maximum);
                this.vectors[3].y = minimum.y;
                this.vectors[4] = m4m.math.pool.clone_vector3(minimum);
                this.vectors[4].y = maximum.y;
                this.vectors[5] = m4m.math.pool.clone_vector3(maximum);
                this.vectors[5].x = minimum.x;
                this.vectors[6] = m4m.math.pool.clone_vector3(maximum);
                this.vectors[6].z = minimum.z;
                this.vectors[7] = m4m.math.pool.clone_vector3(maximum);
                this.center = new m4m.math.vector3();
                m4m.math.vec3Add(maximum, minimum, this.center);
                m4m.math.vec3ScaleByNum(this.center, 0.5, this.center);
                this.halfsize = new m4m.math.vector3();
                m4m.math.vec3Subtract(maximum, minimum, this.halfsize);
                m4m.math.vec3ScaleByNum(this.halfsize, 0.5, this.halfsize);
                this._directions = [new m4m.math.vector3(), new m4m.math.vector3(), new m4m.math.vector3()];
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 由中心点和各轴向长度构建定向包围盒
            * @param center 中心点坐标
            * @param size 各轴向长度
            * @version m4m 1.0
            */
            obb.prototype.buildByCenterSize = function (center, size) {
                this.center = m4m.math.pool.clone_vector3(center);
                this.halfsize = m4m.math.pool.clone_vector3(size);
                m4m.math.vec3ScaleByNum(this.halfsize, 0.5, this.halfsize);
                var hsx = this.halfsize.x;
                var hsy = this.halfsize.y;
                var hsz = this.halfsize.z;
                var cenx = this.center.x;
                var ceny = this.center.y;
                var cenz = this.center.z;
                this.vectors[0] = new m4m.math.vector3(cenx - hsx, ceny - hsy, cenz - hsz);
                this.vectors[1] = new m4m.math.vector3(cenx - hsx, ceny - hsy, cenz + hsz);
                this.vectors[2] = new m4m.math.vector3(cenx + hsx, ceny - hsy, cenz - hsz);
                this.vectors[3] = new m4m.math.vector3(cenx + hsx, ceny - hsy, cenz + hsz);
                this.vectors[4] = new m4m.math.vector3(cenx - hsx, ceny + hsy, cenz - hsz);
                this.vectors[5] = new m4m.math.vector3(cenx - hsx, ceny + hsy, cenz + hsz);
                this.vectors[6] = new m4m.math.vector3(cenx + hsx, ceny + hsy, cenz - hsz);
                this.vectors[7] = new m4m.math.vector3(cenx + hsx, ceny + hsy, cenz + hsz);
                this._directions = [new m4m.math.vector3(), new m4m.math.vector3(), new m4m.math.vector3()];
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 刷新定向包围盒
            * @param worldmatrix 物体的世界矩阵
            * @version m4m 1.0
            */
            obb.prototype.update = function (worldmatrix) {
                var _this = this;
                if (!worldmatrix)
                    return;
                var isDirty = !m4m.math.matrixEqual(this._worldMatrix, worldmatrix);
                if (!isDirty) {
                    return;
                }
                else {
                    m4m.math.matrixClone(worldmatrix, this._worldMatrix);
                    obb.tags.forEach(function (tag) {
                        _this.dirtyMap[tag] = true;
                    });
                }
            };
            /**
             * @public
             * @language zh_CN
             * @param bound 碰撞体
             * @classdesc
             * 碰撞体检测碰撞
             * @version m4m 1.0
             */
            obb.prototype.intersects = function (bound) {
                if (!bound)
                    return false;
                if (bound instanceof obb) {
                    return framework.collision.obbVsObb(bound, this);
                }
                else if (bound instanceof framework.spherestruct) {
                    return framework.collision.obbVsSphere(this, bound);
                }
            };
            /**
             * @public
             * @language zh_CN
             * @param axis 指定轴
             * @param out 长度范围
             * @classdesc
             * 计算到指定轴上投影的长度
             * @version m4m 1.0
             */
            obb.prototype.computeExtentsByAxis = function (axis, out) {
                var p = m4m.math.vec3Dot(this.worldCenter, axis);
                var dirs = this.directions;
                var size = this.halfSizeWorld;
                var r0 = Math.abs(m4m.math.vec3Dot(dirs[0], axis)) * size.x;
                var r1 = Math.abs(m4m.math.vec3Dot(dirs[1], axis)) * size.y;
                var r2 = Math.abs(m4m.math.vec3Dot(dirs[2], axis)) * size.z;
                var r = r0 + r1 + r2;
                out.x = p - r;
                out.y = p + r;
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 克隆一个obb
            * @version m4m 1.0
            */
            obb.prototype.clone = function () {
                var _obb = new obb();
                _obb.center = m4m.math.pool.clone_vector3(this.center);
                _obb.halfsize = this.halfsize;
                for (var key in this._directions) {
                    _obb._directions[key] = m4m.math.pool.clone_vector3(this._directions[key]);
                }
                _obb._worldMatrix = m4m.math.pool.clone_matrix(this._worldMatrix);
                _obb._halfSizeWorld = m4m.math.pool.clone_vector3(this._halfSizeWorld);
                _obb._worldCenter = m4m.math.pool.clone_vector3(this._worldCenter);
                _obb.vectors = [];
                _obb._vectorsWorld = [];
                for (var i = 0; i < 8; i++) {
                    _obb.vectors[i] = this.vectors[i];
                    _obb._vectorsWorld[i] = this._vectorsWorld[i];
                }
                _obb.dirtyMap = {};
                for (var key in this.dirtyMap) {
                    _obb.dirtyMap[key] = this.dirtyMap[key];
                }
                return _obb;
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 释放
            * @version m4m 1.0
            */
            obb.prototype.dispose = function () {
                this.vectors.length = 0;
                this._directions.length = 0;
                this.dirtyMap = null;
                this._halfSizeWorld = null;
                this._vectorsWorld.length = 0;
                this._worldCenter = null;
                this._worldMatrix = null;
            };
            obb.helpv3 = new m4m.math.vector3();
            obb.helpv3_1 = new m4m.math.vector3();
            obb.tag_wCenter = "tag_wCenter";
            obb.tag_wVectors = "tag_wVectors";
            obb.tag_wHalfSize = "tag_wHalfSize";
            obb.tag_directions = "tag_directions";
            obb.tags = [obb.tag_wCenter, obb.tag_wVectors, obb.tag_wHalfSize, obb.tag_directions];
            return obb;
        }());
        framework.obb = obb;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var obb2d = /** @class */ (function () {
            function obb2d() {
            }
            Object.defineProperty(obb2d.prototype, "size", {
                /**
                * @public
                * @language zh_CN
                * @classdesc
                * 包围盒大小
                * @version m4m 1.0
                */
                get: function () { return this._size; },
                set: function (size) {
                    if (!size || !this._size)
                        return;
                    m4m.math.vec2Clone(size, this._size);
                    this.halfWidth = this._size.x / 2;
                    this.halfHeight = this._size.y / 2;
                },
                enumerable: false,
                configurable: true
            });
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 由最大最小点构建定向包围盒
            * @param center 中心点坐标
            * @param width 包围盒宽度
            * @param height 包围盒高度
            * @version m4m 1.0
            */
            obb2d.prototype.buildByCenterSize = function (center, width, height) {
                this.center = m4m.math.pool.clone_vector2(center);
                this.offset = m4m.math.pool.new_vector2();
                this.scale = m4m.math.pool.new_vector2();
                this.rotate = new m4m.math.angelref();
                this._size = new m4m.math.vector2(width, height);
                this.halfWidth = width / 2;
                this.halfHeight = height / 2;
                this.directions = [new m4m.math.vector2(), new m4m.math.vector2()];
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 刷新定向包围盒
            * @param canvasWorldMtx Canvas世界矩阵
            * @version m4m 1.0
            */
            obb2d.prototype.update = function (canvasWorldMtx) {
                //getTranslation
                m4m.math.matrix3x2Decompose(canvasWorldMtx, this.scale, this.rotate, this.center);
                var tranOffset = m4m.math.pool.new_vector2();
                var scaleRotateMtx = m4m.math.pool.new_matrix3x2();
                m4m.math.matrix3x2Clone(canvasWorldMtx, scaleRotateMtx);
                scaleRotateMtx.rawData[4] = scaleRotateMtx.rawData[5] = 0; //消除位移
                m4m.math.matrix3x2TransformVector2(scaleRotateMtx, this.offset, tranOffset);
                m4m.math.vec2Add(this.center, tranOffset, this.center);
                //dirs
                this.directions[0].x = canvasWorldMtx.rawData[0];
                this.directions[0].y = canvasWorldMtx.rawData[1];
                this.directions[1].x = canvasWorldMtx.rawData[2];
                this.directions[1].y = canvasWorldMtx.rawData[3];
                m4m.math.pool.delete_vector2(tranOffset);
                m4m.math.pool.delete_matrix3x2(scaleRotateMtx);
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * obb2d的碰撞检测
            * @param _obb 待检测obb2d
            * @version m4m 1.0
            */
            obb2d.prototype.intersects = function (_obb) {
                if (_obb == null)
                    return false;
                var box0 = this;
                var box1 = _obb;
                if (!this.axisOverlap(box0.directions[0], box0, box1))
                    return false;
                if (!this.axisOverlap(box0.directions[1], box0, box1))
                    return false;
                if (!this.axisOverlap(box1.directions[0], box0, box1))
                    return false;
                if (!this.axisOverlap(box1.directions[1], box0, box1))
                    return false;
                return true;
            };
            obb2d.prototype.computeBoxExtents = function (axis, box) {
                var p = m4m.math.vec2Dot(box.center, axis);
                var r0 = Math.abs(m4m.math.vec2Dot(box.directions[0], axis)) * box.halfWidth;
                var r1 = Math.abs(m4m.math.vec2Dot(box.directions[1], axis)) * box.halfHeight;
                var r = r0 + r1;
                var result = m4m.math.pool.new_vector2();
                result.x = p - r;
                result.y = p + r;
                return result;
            };
            obb2d.prototype.axisOverlap = function (axis, box0, box1) {
                var result0 = this.computeBoxExtents(axis, box0);
                var result1 = this.computeBoxExtents(axis, box1);
                return this.extentsOverlap(result0.x, result0.y, result1.x, result1.y);
            };
            obb2d.prototype.extentsOverlap = function (min0, max0, min1, max1) {
                return !(min0 > max1 || min1 > max0);
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 克隆一个obb
            * @version m4m 1.0
            */
            obb2d.prototype.clone = function () {
                var _obb = new obb2d();
                _obb.center = m4m.math.pool.clone_vector2(this.center);
                _obb._size = m4m.math.pool.clone_vector2(this._size);
                _obb.halfWidth = this.halfWidth;
                _obb.halfHeight = this.halfHeight;
                _obb.scale = m4m.math.pool.clone_vector2(this.scale);
                _obb.rotate = new m4m.math.angelref();
                _obb.rotate.v = this.rotate.v;
                for (var key in this.directions) {
                    _obb.directions[key] = m4m.math.pool.clone_vector2(this.directions[key]);
                }
                return _obb;
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 释放
            * @version m4m 1.0
            */
            obb2d.prototype.dispose = function () {
                if (this.center)
                    m4m.math.pool.delete_vector2(this.center);
                if (this._size)
                    m4m.math.pool.delete_vector2(this._size);
                if (this.scale)
                    m4m.math.pool.delete_vector2(this.scale);
                if (this.directions) {
                    this.directions.forEach(function (dir) {
                        if (dir)
                            m4m.math.pool.delete_vector2(dir);
                    });
                    this.directions.length = 0;
                }
            };
            __decorate([
                m4m.reflect.Field("vector2"),
                __metadata("design:type", m4m.math.vector2)
            ], obb2d.prototype, "offset", void 0);
            __decorate([
                m4m.reflect.Field("vector2"),
                __metadata("design:type", m4m.math.vector2),
                __metadata("design:paramtypes", [m4m.math.vector2])
            ], obb2d.prototype, "size", null);
            return obb2d;
        }());
        framework.obb2d = obb2d;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
        * @private
        * @language zh_CN
        * @classdesc
        * 拾取到的信息
        * @version m4m 1.0
        */
        var pickinfo = /** @class */ (function () {
            function pickinfo(_bu, _bv, _distance) {
                if (_bu === void 0) { _bu = 0; }
                if (_bv === void 0) { _bv = 0; }
                if (_distance === void 0) { _distance = 0; }
                this.normal = new m4m.math.vector3();
                this.distance = 0;
                this.hitposition = new m4m.math.vector3();
                this.bu = 0;
                this.bv = 0;
                this.faceId = -1;
                this.subMeshId = 0;
                this.distance = _distance;
                this.bu = _bu;
                this.bv = _bv;
            }
            pickinfo.prototype.init = function () {
                this.pickedtran = null;
                this.hitposition.x = this.hitposition.y = this.hitposition.z = this.distance = this.bu = this.bv = this.subMeshId = 0;
                this.faceId = -1;
            };
            pickinfo.prototype.cloneFrom = function (from) {
                m4m.math.vec3Clone(from.normal, this.normal);
                this.pickedtran = from.pickedtran;
                m4m.math.vec3Clone(from.hitposition, this.hitposition);
                this.distance = from.distance;
                this.bu = from.bu;
                this.bv = from.bv;
                this.subMeshId = from.subMeshId;
                this.faceId = from.faceId;
            };
            return pickinfo;
        }());
        framework.pickinfo = pickinfo;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var nodePool = /** @class */ (function () {
            function nodePool() {
            }
            nodePool.new_node = function (bounds, level) {
                if (level === void 0) { level = 0; }
                var n = this.nodelist.pop();
                if (n) {
                    n.bounds = bounds;
                    n.level = level;
                }
                else
                    n = new qtNode(bounds, level);
                return n;
            };
            nodePool.delete_node = function (n) {
                if (!n)
                    return;
                n.level = 0;
                n.nodes.length = n.objects.length = 0;
                m4m.math.pool.delete_rect(n.bounds);
                this.nodelist.push(n);
            };
            nodePool.nodelist = [];
            return nodePool;
        }());
        /**
         * 四叉树节点
         */
        var qtNode = /** @class */ (function () {
            function qtNode(bounds, level) {
                if (level === void 0) { level = 0; }
                this.objects = []; //物体对象容器
                this.nodes = []; //四个象限对应的子节点
                this.level = isNaN(level) || level < 0 ? 0 : level;
                this.bounds = bounds;
            }
            /**
             * 分裂,拆分到子节点
             */
            qtNode.prototype.split = function () {
                var level = this.level;
                var bounds = this.bounds;
                var sWidth = bounds.w / 2;
                var sHeight = bounds.h / 2;
                var x = bounds.x;
                var y = bounds.y;
                var cx = x + sWidth;
                var cy = y + sHeight;
                var r_0 = m4m.math.pool.new_rect(cx, y, sWidth, sHeight);
                var r_1 = m4m.math.pool.new_rect(x, y, sWidth, sHeight);
                var r_2 = m4m.math.pool.new_rect(x, cy, sWidth, sHeight);
                var r_3 = m4m.math.pool.new_rect(cx, cy, sWidth, sHeight);
                this.nodes.push(nodePool.new_node(r_0, level + 1), nodePool.new_node(r_1, level + 1), nodePool.new_node(r_2, level + 1), nodePool.new_node(r_3, level + 1));
            };
            /**
             * 清空所有子节点
             */
            qtNode.prototype.clear = function () {
                var nodes = this.nodes;
                this.objects.splice(0, this.objects.length);
                while (nodes.length) {
                    var subnode = nodes.shift();
                    subnode.clear();
                    nodePool.delete_node(subnode);
                }
            };
            /**
             * 获取象限号
             * @param rect 矩形区域
             * @param checkIsInner 检查是否在内部，没有溢出象限界限
             */
            qtNode.prototype.getIndex = function (rect, checkIsInner) {
                if (checkIsInner === void 0) { checkIsInner = false; }
                var bounds = this.bounds;
                var cx = bounds.x + (bounds.w / 2);
                var cy = bounds.y + (bounds.h / 2);
                var onTop = (bounds.y + rect.h) <= cy;
                var onBottom = rect.y > cy;
                var onLeft = (bounds.x + rect.w) <= cx;
                var onRight = rect.x > cx;
                // 检测矩形是否溢出象限界限
                if (checkIsInner &&
                    (Math.abs(rect.x - bounds.x) + (rect.w / 2) > (bounds.w / 2) ||
                        Math.abs(rect.y - bounds.y) + (rect.h / 2) > (bounds.h / 2))) {
                    return -1;
                }
                if (onTop) {
                    if (onRight) {
                        return 0;
                    }
                    else if (onLeft) {
                        return 1;
                    }
                }
                else if (onBottom) {
                    if (onLeft) {
                        return 2;
                    }
                    else if (onRight) {
                        return 3;
                    }
                }
                return -1;
            };
            /**
            * @public
            * @language zh_CN
            * 插入节点
            * @param rect 矩形区域
            * @version m4m 1.0
            */
            qtNode.prototype.insert = function (rect, maxObjNum, maxLevel) {
                var objs = this.objects;
                var index;
                if (this.nodes.length) {
                    index = this.getIndex(rect, true);
                    if (index != -1) {
                        this.nodes[index].insert(rect, maxObjNum, maxLevel);
                        return;
                    }
                }
                objs.push(rect);
                if (!this.nodes.length &&
                    this.objects.length > maxObjNum &&
                    this.level < maxLevel) {
                    this.split();
                    for (var i = objs.length - 1; i >= 0; i--) {
                        index = this.getIndex(objs[i], true);
                        if (index !== -1) {
                            this.nodes[index].insert(objs.splice(i, 1)[0], maxObjNum, maxLevel);
                        }
                    }
                }
            };
            qtNode.prototype.concatToArr = function (targetArr, addArr) {
                if (!targetArr || !addArr)
                    return;
                addArr.forEach(function (sub) {
                    if (sub)
                        targetArr.push(sub);
                });
            };
            qtNode.prototype.retrieve = function (rect, outRects) {
                var arr;
                var index;
                if (this.level === 0)
                    outRects.length = 0;
                // concatArr(result, this.objects);
                this.concatToArr(outRects, this.objects);
                if (this.nodes.length) {
                    index = this.getIndex(rect);
                    if (index !== -1) {
                        this.nodes[index].retrieve(rect, outRects);
                    }
                    else {
                        // arr = rect.carve(this.bounds.cX, this.bounds.cY);
                        var cx = this.bounds.x + (this.bounds.w / 2);
                        var cy = this.bounds.y + (this.bounds.h / 2);
                        arr = this.rectCarve(rect, cx, cy);
                        for (var i = arr.length - 1; i >= 0; i--) {
                            index = this.getIndex(arr[i]);
                            if (index != -1) {
                                this.nodes[index].retrieve(rect, outRects);
                            }
                        }
                        arr.forEach(function (element) {
                            if (element)
                                m4m.math.pool.delete_rect(element);
                        });
                    }
                }
            };
            /**
             * 分割矩形
             * @param src
             * @param cx
             * @param cy
             */
            qtNode.prototype.rectCarve = function (src, cx, cy) {
                var result = [];
                var temps = [];
                var dX = cx - src.x;
                var dY = cy - src.y;
                var carveX = dX > 0 && dX < src.w;
                var carveY = dY > 0 && dY < src.h;
                // 切割XY方向
                if (carveX && carveY) {
                    temps = this.rectCarve(src, cx, src.y);
                    while (temps.length) {
                        var temp = temps.pop();
                        this.concatToArr(result, this.rectCarve(temp, src.x, cy));
                    }
                    // 只切割X方向
                }
                else if (carveX) {
                    result.push(m4m.math.pool.new_rect(src.x, src.y, dX, src.h), m4m.math.pool.new_rect(cx, src.y, src.w - dX, src.h));
                    // 只切割Y方向
                }
                else if (carveY) {
                    result.push(m4m.math.pool.new_rect(src.x, src.y, src.w, dY), m4m.math.pool.new_rect(src.x, cy, src.w, src.h - dY));
                }
                return result;
            };
            return qtNode;
        }());
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 四叉树
         * @version m4m 1.0
         */
        var quadTree = /** @class */ (function () {
            /**
             * @public
             * @language zh_CN
             * 四叉树
             * @param bounds 全局的矩形范围
             * @param maxObjNum 每个节点(象限) 能包含的最大物体数量
             * @param maxLevel 树的最大深度
             * @version m4m 1.0
             */
            function quadTree(bounds, maxObjNum, maxLevel) {
                if (maxObjNum === void 0) { maxObjNum = 5; }
                if (maxLevel === void 0) { maxLevel = 5; }
                this.cacheArr = [];
                this.rootNode = new qtNode(bounds, 0);
                this.MAX_OBJECTS = maxObjNum;
                this.MAX_LEVELS = maxLevel;
            }
            /**
            * @public
            * @language zh_CN
            * 插入节点
            * @param rect 矩形区域
            * @version m4m 1.0
            */
            quadTree.prototype.insert = function (rect) {
                this.rootNode.insert(rect, this.MAX_OBJECTS, this.MAX_LEVELS);
            };
            /**
             * @public
             * @language zh_CN
             * 检索结果
             * @param bounds 检测矩形
             * @param outRects 返回结果矩形数组
             * @version m4m 1.0
             */
            quadTree.prototype.retrieve = function (bounds, outRects) {
                if (!bounds || !outRects)
                    return;
                outRects.length = 0;
                this.rootNode.retrieve(bounds, outRects);
            };
            /**
            * @public
            * @language zh_CN
            * 清理所有节点
            * @version m4m 1.0
            */
            quadTree.prototype.clear = function () {
                if (!this.rootNode)
                    return;
                this.rootNode.clear();
            };
            return quadTree;
        }());
        framework.quadTree = quadTree;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 射线
         * @version m4m 1.0
         */
        var ray = /** @class */ (function () {
            /**
            * @private
            * @language zh_CN
            * @classdesc
            * 构建射线
            * @param _origin 射线起点
            * @param _dir 射线方向
            * @version m4m 1.0
            * @platform Web,Native
            */
            function ray(_origin, _dir) {
                this.origin = new m4m.math.vector3();
                this.direction = new m4m.math.vector3();
                this.set(_origin, _dir);
            }
            /**
            * @private
            * @language zh_CN
            * @classdesc
            * 设置射线的属性
            * @param _origin 射线起点
            * @param _dir 射线方向
            * @version m4m 1.0
            * @platform Web,Native
            */
            ray.prototype.set = function (_origin, _dir) {
                m4m.math.vec3Clone(_origin, this.origin);
                m4m.math.vec3Clone(_dir, this.direction);
            };
            /**
            * @private
            * @language zh_CN
            * @classdesc
            * 与aabb碰撞相交检测
            * @param _aabb 待检测aabb
            * @version m4m 1.0
            * @platform Web,Native
            */
            ray.prototype.intersectAABB = function (_aabb) {
                return this.intersectBoxMinMax(_aabb.minimum, _aabb.maximum);
            };
            /**
            * @private
            * @language zh_CN
            * @classdesc
            * 与transform表示的plane碰撞相交检测，主要用于2d检测
            * @param tran transform
            * @version m4m 1.0
            * @platform Web,Native
            */
            ray.prototype.intersectPlaneTransform = function (tran, outInfo) {
                var ishided = false;
                var panelpoint = tran.getWorldTranslate();
                var forward = m4m.math.pool.new_vector3();
                tran.getForwardInWorld(forward);
                var hitposition = m4m.math.pool.new_vector3();
                ishided = this.intersectPlane(panelpoint, forward, hitposition);
                if (ishided) {
                    m4m.math.vec3Clone(hitposition, outInfo.hitposition);
                    outInfo.distance = m4m.math.vec3Distance(outInfo.hitposition, this.origin);
                    outInfo.pickedtran = tran;
                }
                m4m.math.pool.delete_vector3(forward);
                m4m.math.pool.delete_vector3(hitposition);
                return ishided;
            };
            ray.prototype.intersectPlane = function (planePoint, planeNormal, outHitPoint) {
                var vp1 = planeNormal.x;
                var vp2 = planeNormal.y;
                var vp3 = planeNormal.z;
                var n1 = planePoint.x;
                var n2 = planePoint.y;
                var n3 = planePoint.z;
                var v1 = this.direction.x;
                var v2 = this.direction.y;
                var v3 = this.direction.z;
                var m1 = this.origin.x;
                var m2 = this.origin.y;
                var m3 = this.origin.z;
                var vpt = v1 * vp1 + v2 * vp2 + v3 * vp3;
                if (vpt === 0) {
                    return false;
                }
                else {
                    var t = ((n1 - m1) * vp1 + (n2 - m2) * vp2 + (n3 - m3) * vp3) / vpt;
                    outHitPoint.x = m1 + v1 * t;
                    outHitPoint.y = m2 + v2 * t;
                    outHitPoint.z = m3 + v3 * t;
                    //return new m4m.math.vector3(m1 + v1 * t, m2 + v2 * t, m3 + v3 * t);
                    return true;
                }
            };
            /**
            * @private
            * @language zh_CN
            * @classdesc
            * 与碰撞盒相交检测
            * @param tran 待检测带碰撞盒的transform
            * @version m4m 1.0
            * @platform Web,Native
            */
            ray.prototype.intersectCollider = function (tran, outInfo) {
                var ishided = false;
                var _collider = tran.gameObject.collider;
                var lastDistance = Number.MAX_VALUE;
                if (_collider instanceof framework.boxcollider) {
                    var obb_1 = _collider.getBound();
                    if (!obb_1)
                        return ishided;
                    if (!ray.tempVecs) {
                        ray.tempVecs = [];
                        for (var i = 0; i < 8; i++) {
                            ray.tempVecs.push(new m4m.math.vector3());
                        }
                    }
                    var wVects = obb_1.vectorsWorld;
                    for (var i = 0; i < 8; i++) {
                        m4m.math.vec3Clone(wVects[i], ray.tempVecs[i]);
                    }
                    // obb.caclWorldVecs(ray.tempVecs, _collider.gameObject.transform.getWorldMatrix());   
                    if (!ray.tempMData)
                        ray.tempMData = new m4m.render.meshData();
                    m4m.render.meshData.genBoxByArray(ray.tempVecs, ray.tempMData);
                    var data = ray.tempMData;
                    var trisindexLen = data.getTriIndexCount();
                    for (var index = 0; index < trisindexLen; index += 3) {
                        // var p0 = data.pos[data.trisindex[index]];
                        // var p1 = data.pos[data.trisindex[index + 1]];
                        // var p2 = data.pos[data.trisindex[index + 2]];
                        var triIdx0 = data.getTriIndex(index);
                        var triIdx1 = data.getTriIndex(index + 1);
                        var triIdx2 = data.getTriIndex(index + 2);
                        var p0 = ray.help_v3;
                        var p1 = ray.help_v3_1;
                        var p2 = ray.help_v3_2;
                        data.getPosition(triIdx0, p0);
                        data.getPosition(triIdx1, p1);
                        data.getPosition(triIdx2, p2);
                        var tempinfo = m4m.math.pool.new_pickInfo();
                        var bool = this.intersectsTriangle(p0, p1, p2, tempinfo);
                        if (bool) {
                            if (tempinfo.distance < 0)
                                continue;
                            if (lastDistance > tempinfo.distance) {
                                ishided = true;
                                outInfo.cloneFrom(tempinfo);
                                outInfo.pickedtran = tran;
                                lastDistance = outInfo.distance;
                                var tdir = m4m.math.pool.new_vector3();
                                m4m.math.vec3ScaleByNum(this.direction, outInfo.distance, tdir);
                                m4m.math.vec3Add(this.origin, tdir, outInfo.hitposition);
                                m4m.math.pool.delete_vector3(tdir);
                            }
                        }
                        m4m.math.pool.delete_pickInfo(tempinfo);
                    }
                }
                else if (_collider instanceof framework.meshcollider) {
                    var mesh_3 = _collider.getBound();
                    if (mesh_3 != null) {
                        ishided = mesh_3.intersects(this, tran.getWorldMatrix(), outInfo);
                    }
                }
                else if (_collider instanceof framework.canvasRenderer) {
                    ishided = this.intersectPlaneTransform(tran, outInfo);
                }
                return ishided;
            };
            /**
            * @private
            * @language zh_CN
            * @classdesc
            * 与最大最小点表示的box相交检测
            * @param minimum
            * @param maximum
            * @version m4m 1.0
            * @platform Web,Native
            */
            ray.prototype.intersectBoxMinMax = function (minimum, maximum) {
                var d = 0.0;
                var maxValue = Number.MAX_VALUE;
                var inv;
                var min;
                var max;
                var temp;
                if (Math.abs(this.direction.x) < 0.0000001) {
                    if (this.origin.x < minimum.x || this.origin.x > maximum.x) {
                        return false;
                    }
                }
                else {
                    inv = 1.0 / this.direction.x;
                    min = (minimum.x - this.origin.x) * inv;
                    max = (maximum.x - this.origin.x) * inv;
                    if (max === -Infinity) {
                        max = Infinity;
                    }
                    if (min > max) {
                        temp = min;
                        min = max;
                        max = temp;
                    }
                    d = Math.max(min, d);
                    maxValue = Math.min(max, maxValue);
                    if (d > maxValue) {
                        return false;
                    }
                }
                if (Math.abs(this.direction.y) < 0.0000001) {
                    if (this.origin.y < minimum.y || this.origin.y > maximum.y) {
                        return false;
                    }
                }
                else {
                    inv = 1.0 / this.direction.y;
                    min = (minimum.y - this.origin.y) * inv;
                    max = (maximum.y - this.origin.y) * inv;
                    if (max === -Infinity) {
                        max = Infinity;
                    }
                    if (min > max) {
                        temp = min;
                        min = max;
                        max = temp;
                    }
                    d = Math.max(min, d);
                    maxValue = Math.min(max, maxValue);
                    if (d > maxValue) {
                        return false;
                    }
                }
                if (Math.abs(this.direction.z) < 0.0000001) {
                    if (this.origin.z < minimum.z || this.origin.z > maximum.z) {
                        return false;
                    }
                }
                else {
                    inv = 1.0 / this.direction.z;
                    min = (minimum.z - this.origin.z) * inv;
                    max = (maximum.z - this.origin.z) * inv;
                    if (max === -Infinity) {
                        max = Infinity;
                    }
                    if (min > max) {
                        temp = min;
                        min = max;
                        max = temp;
                    }
                    d = Math.max(min, d);
                    maxValue = Math.min(max, maxValue);
                    if (d > maxValue) {
                        return false;
                    }
                }
                return true;
            };
            /**
            * @private
            * @language zh_CN
            * @classdesc
            * 与球相交检测
            * @param center 球圆心坐标
            * @param radius 球半径
            * @version m4m 1.0
            * @platform Web,Native
            */
            ray.prototype.intersectsSphere = function (center, radius) {
                var center_ori = m4m.math.pool.new_vector3();
                m4m.math.vec3Subtract(center, this.origin, center_ori);
                var raydist = m4m.math.vec3Dot(this.direction, center_ori);
                if (orilen2 < rad2)
                    return true; //射线起点在球里
                if (raydist < 0)
                    return false; //到圆心的向量在方向向量上的投影为负  夹角不在-90 90
                var orilen2 = m4m.math.vec3SqrLength(center_ori);
                m4m.math.pool.delete_vector3(center_ori);
                var rad2 = radius * radius;
                var d = rad2 - (orilen2 - raydist * raydist);
                if (d < 0)
                    return false;
                return true;
            };
            /**
            * @private
            * @language zh_CN
            * @classdesc
            * 与三角形相交检测
            * @param vertex0
            * @param vertex1
            * @param vertex2
            * @param outInfo
            * @version m4m 1.0
            * @platform Web,Native
            */
            ray.prototype.intersectsTriangle = function (vertex0, vertex1, vertex2, outInfo) {
                var _edge1 = m4m.math.pool.new_vector3();
                var _edge2 = m4m.math.pool.new_vector3();
                var _pvec = m4m.math.pool.new_vector3();
                var _tvec = m4m.math.pool.new_vector3();
                var _qvec = m4m.math.pool.new_vector3();
                m4m.math.vec3Subtract(vertex1, vertex0, _edge1);
                m4m.math.vec3Subtract(vertex2, vertex0, _edge2);
                m4m.math.vec3Cross(this.direction, _edge2, _pvec);
                var det = m4m.math.vec3Dot(_edge1, _pvec);
                if (det === 0) {
                    return false;
                }
                var invdet = 1 / det;
                m4m.math.vec3Subtract(this.origin, vertex0, _tvec);
                var bu = m4m.math.vec3Dot(_tvec, _pvec) * invdet;
                if (bu < 0 || bu > 1.0) {
                    return false;
                }
                m4m.math.vec3Cross(_tvec, _edge1, _qvec);
                var bv = m4m.math.vec3Dot(this.direction, _qvec) * invdet;
                if (bv < 0 || bu + bv > 1.0) {
                    return false;
                }
                var distance = m4m.math.vec3Dot(_edge2, _qvec) * invdet;
                outInfo.init();
                outInfo.bu = bu;
                outInfo.bv = bv;
                outInfo.distance = distance;
                //return new pickinfo(bu, bv, distance);
                m4m.math.vec3Cross(_edge1, _edge2, outInfo.normal);
                m4m.math.vec3Normalize(outInfo.normal, outInfo.normal);
                m4m.math.pool.delete_vector3(_edge1);
                m4m.math.pool.delete_vector3(_edge2);
                m4m.math.pool.delete_vector3(_pvec);
                m4m.math.pool.delete_vector3(_tvec);
                m4m.math.pool.delete_vector3(_qvec);
                return true;
            };
            ray.help_v3 = new m4m.math.vector3();
            ray.help_v3_1 = new m4m.math.vector3();
            ray.help_v3_2 = new m4m.math.vector3();
            return ray;
        }());
        framework.ray = ray;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * tween 工具
         */
        var tweenUtil = /** @class */ (function () {
            function tweenUtil() {
            }
            //transplant by TextFx——Ease Function
            /**
             * 获取缓动计算后的进度值
             * @param ease_type 缓动类型
             * @param linear_progress   当前进度值(范围: 0 - 1)
             */
            tweenUtil.GetEaseProgress = function (ease_type, linear_progress) {
                switch (ease_type) {
                    case tweenMethod.Linear:
                        return linear_progress;
                    case tweenMethod.ExpoEaseOut:
                        return tweenUtil.ExpoEaseOut(linear_progress, 0, 1, 1);
                    case tweenMethod.ExpoEaseIn:
                        return tweenUtil.ExpoEaseIn(linear_progress, 0, 1, 1);
                    case tweenMethod.ExpoEaseOutIn:
                        return tweenUtil.ExpoEaseOutIn(linear_progress, 0, 1, 1);
                    case tweenMethod.ExpoEaseInOut:
                        return tweenUtil.ExpoEaseInOut(linear_progress, 0, 1, 1);
                    case tweenMethod.CircEaseOut:
                        return tweenUtil.CircEaseOut(linear_progress, 0, 1, 1);
                    case tweenMethod.CircEaseIn:
                        return tweenUtil.CircEaseIn(linear_progress, 0, 1, 1);
                    case tweenMethod.CircEaseOutIn:
                        return tweenUtil.CircEaseOutIn(linear_progress, 0, 1, 1);
                    case tweenMethod.CircEaseInOut:
                        return tweenUtil.CircEaseInOut(linear_progress, 0, 1, 1);
                    case tweenMethod.QuadEaseOut:
                        return tweenUtil.QuadEaseOut(linear_progress, 0, 1, 1);
                    case tweenMethod.QuadEaseIn:
                        return tweenUtil.QuadEaseIn(linear_progress, 0, 1, 1);
                    case tweenMethod.QuadEaseOutIn:
                        return tweenUtil.QuadEaseOutIn(linear_progress, 0, 1, 1);
                    case tweenMethod.QuadEaseInOut:
                        return tweenUtil.QuadEaseInOut(linear_progress, 0, 1, 1);
                    case tweenMethod.SineEaseOut:
                        return tweenUtil.SineEaseOut(linear_progress, 0, 1, 1);
                    case tweenMethod.SineEaseIn:
                        return tweenUtil.SineEaseIn(linear_progress, 0, 1, 1);
                    case tweenMethod.SineEaseOutIn:
                        return tweenUtil.SineEaseOutIn(linear_progress, 0, 1, 1);
                    case tweenMethod.SineEaseInOut:
                        return tweenUtil.SineEaseInOut(linear_progress, 0, 1, 1);
                    case tweenMethod.CubicEaseOut:
                        return tweenUtil.CubicEaseOut(linear_progress, 0, 1, 1);
                    case tweenMethod.CubicEaseIn:
                        return tweenUtil.CubicEaseIn(linear_progress, 0, 1, 1);
                    case tweenMethod.CubicEaseOutIn:
                        return tweenUtil.CubicEaseOutIn(linear_progress, 0, 1, 1);
                    case tweenMethod.CubicEaseInOut:
                        return tweenUtil.CubicEaseInOut(linear_progress, 0, 1, 1);
                    case tweenMethod.QuartEaseOut:
                        return tweenUtil.QuartEaseOut(linear_progress, 0, 1, 1);
                    case tweenMethod.QuartEaseIn:
                        return tweenUtil.QuartEaseIn(linear_progress, 0, 1, 1);
                    case tweenMethod.QuartEaseOutIn:
                        return tweenUtil.QuartEaseOutIn(linear_progress, 0, 1, 1);
                    case tweenMethod.QuartEaseInOut:
                        return tweenUtil.QuartEaseInOut(linear_progress, 0, 1, 1);
                    case tweenMethod.QuintEaseOut:
                        return tweenUtil.QuintEaseOut(linear_progress, 0, 1, 1);
                    case tweenMethod.QuintEaseIn:
                        return tweenUtil.QuintEaseIn(linear_progress, 0, 1, 1);
                    case tweenMethod.QuintEaseOutIn:
                        return tweenUtil.QuintEaseOutIn(linear_progress, 0, 1, 1);
                    case tweenMethod.QuintEaseInOut:
                        return tweenUtil.QuintEaseInOut(linear_progress, 0, 1, 1);
                    case tweenMethod.ElasticEaseOut:
                        return tweenUtil.ElasticEaseOut(linear_progress, 0, 1, 1);
                    case tweenMethod.ElasticEaseIn:
                        return tweenUtil.ElasticEaseIn(linear_progress, 0, 1, 1);
                    case tweenMethod.ElasticEaseOutIn:
                        return tweenUtil.ElasticEaseOutIn(linear_progress, 0, 1, 1);
                    case tweenMethod.ElasticEaseInOut:
                        return tweenUtil.ElasticEaseInOut(linear_progress, 0, 1, 1);
                    case tweenMethod.BounceEaseOut:
                        return tweenUtil.BounceEaseOut(linear_progress, 0, 1, 1);
                    case tweenMethod.BounceEaseIn:
                        return tweenUtil.BounceEaseIn(linear_progress, 0, 1, 1);
                    case tweenMethod.BounceEaseOutIn:
                        return tweenUtil.BounceEaseOutIn(linear_progress, 0, 1, 1);
                    case tweenMethod.BounceEaseInOut:
                        return tweenUtil.BounceEaseInOut(linear_progress, 0, 1, 1);
                    case tweenMethod.BackEaseOut:
                        return tweenUtil.BackEaseOut(linear_progress, 0, 1, 1);
                    case tweenMethod.BackEaseIn:
                        return tweenUtil.BackEaseIn(linear_progress, 0, 1, 1);
                    case tweenMethod.BackEaseOutIn:
                        return tweenUtil.BackEaseOutIn(linear_progress, 0, 1, 1);
                    case tweenMethod.BackEaseInOut:
                        return tweenUtil.BackEaseInOut(linear_progress, 0, 1, 1);
                    default:
                        return linear_progress;
                }
            };
            /**
             * Easing equation function for a simple linear tweening, with no easing.
             * @param t Current time in seconds.
             * @param b Starting value.
             * @param c Final value.
             * @param d Duration of
             */
            tweenUtil.Linear = function (t, b, c, d) {
                return c * t / d + b;
            };
            /**
            Easing equation function for an exponential (2^t) easing out:
            decelerating from zero velocity.
             */
            tweenUtil.ExpoEaseOut = function (t, b, c, d) {
                return (t == d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
            };
            /**
            Easing equation function for an exponential (2^t) easing in:
            accelerating from zero velocity.
             */
            tweenUtil.ExpoEaseIn = function (t, b, c, d) {
                return (t == 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;
            };
            /**
             Easing equation function for an exponential (2^t) easing in/out:
             acceleration until halfway, then deceleration.
            */
            tweenUtil.ExpoEaseInOut = function (t, b, c, d) {
                if (t == 0)
                    return b;
                if (t == d)
                    return b + c;
                if ((t /= d / 2) < 1)
                    return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
                return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
            };
            /**
             Easing equation function for an exponential (2^t) easing out/in:
             deceleration until halfway, then acceleration.
            */
            tweenUtil.ExpoEaseOutIn = function (t, b, c, d) {
                if (t < d / 2)
                    return tweenUtil.ExpoEaseOut(t * 2, b, c / 2, d);
                return tweenUtil.ExpoEaseIn((t * 2) - d, b + c / 2, c / 2, d);
            };
            /**
             Easing equation function for a circular (sqrt(1-t^2)) easing out:
             decelerating from zero velocity.
            */
            tweenUtil.CircEaseOut = function (t, b, c, d) {
                return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
            };
            /**
             Easing equation function for a circular (sqrt(1-t^2)) easing in:
             accelerating from zero velocity.
            */
            tweenUtil.CircEaseIn = function (t, b, c, d) {
                return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
            };
            /**
             Easing equation function for a circular (sqrt(1-t^2)) easing in/out:
             acceleration until halfway, then deceleration.
            */
            tweenUtil.CircEaseInOut = function (t, b, c, d) {
                if ((t /= d / 2) < 1)
                    return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
                return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
            };
            /**
             Easing equation function for a circular (sqrt(1-t^2)) easing in/out:
             acceleration until halfway, then deceleration.
            */
            tweenUtil.CircEaseOutIn = function (t, b, c, d) {
                if (t < d / 2)
                    return tweenUtil.CircEaseOut(t * 2, b, c / 2, d);
                return tweenUtil.CircEaseIn((t * 2) - d, b + c / 2, c / 2, d);
            };
            /**
             Easing equation function for a quadratic (t^2) easing out:
             decelerating from zero velocity.
            */
            tweenUtil.QuadEaseOut = function (t, b, c, d) {
                return -c * (t /= d) * (t - 2) + b;
            };
            /**
             Easing equation function for a quadratic (t^2) easing in:
             accelerating from zero velocity.
            */
            tweenUtil.QuadEaseIn = function (t, b, c, d) {
                return c * (t /= d) * t + b;
            };
            /**
             Easing equation function for a quadratic (t^2) easing in/out:
             acceleration until halfway, then deceleration.
            */
            tweenUtil.QuadEaseInOut = function (t, b, c, d) {
                if ((t /= d / 2) < 1)
                    return c / 2 * t * t + b;
                return -c / 2 * ((--t) * (t - 2) - 1) + b;
            };
            /**
             Easing equation function for a quadratic (t^2) easing out/in:
             deceleration until halfway, then acceleration.
            */
            tweenUtil.QuadEaseOutIn = function (t, b, c, d) {
                if (t < d / 2)
                    return tweenUtil.QuadEaseOut(t * 2, b, c / 2, d);
                return tweenUtil.QuadEaseIn((t * 2) - d, b + c / 2, c / 2, d);
            };
            /**
             Easing equation function for a sinusoidal (sin(t)) easing out:
             decelerating from zero velocity.
            */
            tweenUtil.SineEaseOut = function (t, b, c, d) {
                return c * Math.sin(t / d * (Math.PI / 2)) + b;
            };
            /**
             Easing equation function for a sinusoidal (sin(t)) easing in:
             accelerating from zero velocity.
            */
            tweenUtil.SineEaseIn = function (t, b, c, d) {
                return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
            };
            /**
             Easing equation function for a sinusoidal (sin(t)) easing in/out:
             acceleration until halfway, then deceleration.
            */
            tweenUtil.SineEaseInOut = function (t, b, c, d) {
                if ((t /= d / 2) < 1)
                    return c / 2 * (Math.sin(Math.PI * t / 2)) + b;
                return -c / 2 * (Math.cos(Math.PI * --t / 2) - 2) + b;
            };
            /**
             Easing equation function for a sinusoidal (sin(t)) easing in/out:
             deceleration until halfway, then acceleration.
            */
            tweenUtil.SineEaseOutIn = function (t, b, c, d) {
                if (t < d / 2)
                    return tweenUtil.SineEaseOut(t * 2, b, c / 2, d);
                return tweenUtil.SineEaseIn((t * 2) - d, b + c / 2, c / 2, d);
            };
            /**
             Easing equation function for a cubic (t^3) easing out:
             decelerating from zero velocity.
            */
            tweenUtil.CubicEaseOut = function (t, b, c, d) {
                return c * ((t = t / d - 1) * t * t + 1) + b;
            };
            /**
             Easing equation function for a cubic (t^3) easing in:
             accelerating from zero velocity.
            */
            tweenUtil.CubicEaseIn = function (t, b, c, d) {
                return c * (t /= d) * t * t + b;
            };
            /**
             Easing equation function for a cubic (t^3) easing in/out:
             acceleration until halfway, then deceleration.
            */
            tweenUtil.CubicEaseInOut = function (t, b, c, d) {
                if ((t /= d / 2) < 1)
                    return c / 2 * t * t * t + b;
                return c / 2 * ((t -= 2) * t * t + 2) + b;
            };
            /**
             Easing equation function for a cubic (t^3) easing out/in:
             deceleration until halfway, then acceleration.
            */
            tweenUtil.CubicEaseOutIn = function (t, b, c, d) {
                if (t < d / 2)
                    return tweenUtil.CubicEaseOut(t * 2, b, c / 2, d);
                return tweenUtil.CubicEaseIn((t * 2) - d, b + c / 2, c / 2, d);
            };
            /**
             Easing equation function for a quartic (t^4) easing out:
             decelerating from zero velocity.
            */
            tweenUtil.QuartEaseOut = function (t, b, c, d) {
                return -c * ((t = t / d - 1) * t * t * t - 1) + b;
            };
            /**
             Easing equation function for a quartic (t^4) easing in:
             accelerating from zero velocity.
            */
            tweenUtil.QuartEaseIn = function (t, b, c, d) {
                return c * (t /= d) * t * t * t + b;
            };
            /**
             Easing equation function for a quartic (t^4) easing in/out:
             acceleration until halfway, then deceleration.
            */
            tweenUtil.QuartEaseInOut = function (t, b, c, d) {
                if ((t /= d / 2) < 1)
                    return c / 2 * t * t * t * t + b;
                return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
            };
            /**
             Easing equation function for a quartic (t^4) easing out/in:
             deceleration until halfway, then acceleration.
            */
            tweenUtil.QuartEaseOutIn = function (t, b, c, d) {
                if (t < d / 2)
                    return tweenUtil.QuartEaseOut(t * 2, b, c / 2, d);
                return tweenUtil.QuartEaseIn((t * 2) - d, b + c / 2, c / 2, d);
            };
            /**
             Easing equation function for a quintic (t^5) easing out:
             decelerating from zero velocity.
            */
            tweenUtil.QuintEaseOut = function (t, b, c, d) {
                return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
            };
            /**
             Easing equation function for a quintic (t^5) easing in:
             accelerating from zero velocity.
            */
            tweenUtil.QuintEaseIn = function (t, b, c, d) {
                return c * (t /= d) * t * t * t * t + b;
            };
            /**
             Easing equation function for a quintic (t^5) easing in/out:
             acceleration until halfway, then deceleration.
            */
            tweenUtil.QuintEaseInOut = function (t, b, c, d) {
                if ((t /= d / 2) < 1)
                    return c / 2 * t * t * t * t * t + b;
                return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
            };
            /**
             Easing equation function for a quintic (t^5) easing in/out:
             acceleration until halfway, then deceleration.
            */
            tweenUtil.QuintEaseOutIn = function (t, b, c, d) {
                if (t < d / 2)
                    return tweenUtil.QuintEaseOut(t * 2, b, c / 2, d);
                return tweenUtil.QuintEaseIn((t * 2) - d, b + c / 2, c / 2, d);
            };
            /**
             Easing equation function for an elastic (exponentially decaying sine wave) easing out:
             decelerating from zero velocity.
            */
            tweenUtil.ElasticEaseOut = function (t, b, c, d) {
                if ((t /= d) == 1)
                    return b + c;
                var p = d * 0.3;
                var s = p / 4;
                return (c * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b);
            };
            /**
             Easing equation function for an elastic (exponentially decaying sine wave) easing in:
             accelerating from zero velocity.
            */
            tweenUtil.ElasticEaseIn = function (t, b, c, d) {
                if ((t /= d) == 1)
                    return b + c;
                var p = d * 0.3;
                var s = p / 4;
                return -(c * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
            };
            /**
             Easing equation function for an elastic (exponentially decaying sine wave) easing in/out:
             acceleration until halfway, then deceleration.
            */
            tweenUtil.ElasticEaseInOut = function (t, b, c, d) {
                if ((t /= d / 2) == 2)
                    return b + c;
                var p = d * (0.3 * 1.5);
                var s = p / 4;
                if (t < 1)
                    return -0.5 * (c * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
                return c * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * 0.5 + c + b;
            };
            /**
             Easing equation function for an elastic (exponentially decaying sine wave) easing out/in:
             deceleration until halfway, then acceleration.
            */
            tweenUtil.ElasticEaseOutIn = function (t, b, c, d) {
                if (t < d / 2)
                    return tweenUtil.ElasticEaseOut(t * 2, b, c / 2, d);
                return tweenUtil.ElasticEaseIn((t * 2) - d, b + c / 2, c / 2, d);
            };
            /**
             Easing equation function for a bounce (exponentially decaying parabolic bounce) easing out:
             decelerating from zero velocity.
            */
            tweenUtil.BounceEaseOut = function (t, b, c, d) {
                if ((t /= d) < (1 / 2.75))
                    return c * (7.5625 * t * t) + b;
                else if (t < (2 / 2.75))
                    return c * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75) + b;
                else if (t < (2.5 / 2.75))
                    return c * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375) + b;
                else
                    return c * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + b;
            };
            /**
             Easing equation function for a bounce (exponentially decaying parabolic bounce) easing in:
             accelerating from zero velocity.
            */
            tweenUtil.BounceEaseIn = function (t, b, c, d) {
                return c - tweenUtil.BounceEaseOut(d - t, 0, c, d) + b;
            };
            /**
             Easing equation function for a bounce (exponentially decaying parabolic bounce) easing in/out:
             acceleration until halfway, then deceleration.
            */
            tweenUtil.BounceEaseInOut = function (t, b, c, d) {
                if (t < d / 2)
                    return tweenUtil.BounceEaseIn(t * 2, 0, c, d) * 0.5 + b;
                else
                    return tweenUtil.BounceEaseOut(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
            };
            /**
             Easing equation function for a bounce (exponentially decaying parabolic bounce) easing out/in:
             deceleration until halfway, then acceleration.
            */
            tweenUtil.BounceEaseOutIn = function (t, b, c, d) {
                if (t < d / 2)
                    return tweenUtil.BounceEaseOut(t * 2, b, c / 2, d);
                return tweenUtil.BounceEaseIn((t * 2) - d, b + c / 2, c / 2, d);
            };
            /**
             Easing equation function for a back (overshooting cubic easing: (s+1)*t^3 - s*t^2) easing out:
             decelerating from zero velocity.
            */
            tweenUtil.BackEaseOut = function (t, b, c, d) {
                return c * ((t = t / d - 1) * t * ((1.70158 + 1) * t + 1.70158) + 1) + b;
            };
            /**
             Easing equation function for a back (overshooting cubic easing: (s+1)*t^3 - s*t^2) easing in:
             accelerating from zero velocity.
            */
            tweenUtil.BackEaseIn = function (t, b, c, d) {
                return c * (t /= d) * t * ((1.70158 + 1) * t - 1.70158) + b;
            };
            /**
             Easing equation function for a back (overshooting cubic easing: (s+1)*t^3 - s*t^2) easing in/out:
             acceleration until halfway, then deceleration.
            */
            tweenUtil.BackEaseInOut = function (t, b, c, d) {
                var s = 1.70158;
                if ((t /= d / 2) < 1)
                    return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
                return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
            };
            /**
             Easing equation function for a back (overshooting cubic easing: (s+1)*t^3 - s*t^2) easing out/in:
             deceleration until halfway, then acceleration.
            */
            tweenUtil.BackEaseOutIn = function (t, b, c, d) {
                if (t < d / 2)
                    return tweenUtil.BackEaseOut(t * 2, b, c / 2, d);
                return tweenUtil.BackEaseIn((t * 2) - d, b + c / 2, c / 2, d);
            };
            return tweenUtil;
        }());
        framework.tweenUtil = tweenUtil;
        /**
         * tween 方法
         */
        var tweenMethod;
        (function (tweenMethod) {
            /** 正常线性*/
            tweenMethod[tweenMethod["Linear"] = 0] = "Linear";
            /** 指数曲线*/
            tweenMethod[tweenMethod["ExpoEaseOut"] = 1] = "ExpoEaseOut";
            tweenMethod[tweenMethod["ExpoEaseIn"] = 2] = "ExpoEaseIn";
            tweenMethod[tweenMethod["ExpoEaseInOut"] = 3] = "ExpoEaseInOut";
            tweenMethod[tweenMethod["ExpoEaseOutIn"] = 4] = "ExpoEaseOutIn";
            /** 圆形曲线*/
            tweenMethod[tweenMethod["CircEaseOut"] = 5] = "CircEaseOut";
            tweenMethod[tweenMethod["CircEaseIn"] = 6] = "CircEaseIn";
            tweenMethod[tweenMethod["CircEaseInOut"] = 7] = "CircEaseInOut";
            tweenMethod[tweenMethod["CircEaseOutIn"] = 8] = "CircEaseOutIn";
            /** 二次方曲线*/
            tweenMethod[tweenMethod["QuadEaseOut"] = 9] = "QuadEaseOut";
            tweenMethod[tweenMethod["QuadEaseIn"] = 10] = "QuadEaseIn";
            tweenMethod[tweenMethod["QuadEaseInOut"] = 11] = "QuadEaseInOut";
            tweenMethod[tweenMethod["QuadEaseOutIn"] = 12] = "QuadEaseOutIn";
            /** 正弦曲线*/
            tweenMethod[tweenMethod["SineEaseOut"] = 13] = "SineEaseOut";
            tweenMethod[tweenMethod["SineEaseIn"] = 14] = "SineEaseIn";
            tweenMethod[tweenMethod["SineEaseInOut"] = 15] = "SineEaseInOut";
            tweenMethod[tweenMethod["SineEaseOutIn"] = 16] = "SineEaseOutIn";
            /** 三次方曲线*/
            tweenMethod[tweenMethod["CubicEaseOut"] = 17] = "CubicEaseOut";
            tweenMethod[tweenMethod["CubicEaseIn"] = 18] = "CubicEaseIn";
            tweenMethod[tweenMethod["CubicEaseInOut"] = 19] = "CubicEaseInOut";
            tweenMethod[tweenMethod["CubicEaseOutIn"] = 20] = "CubicEaseOutIn";
            /** 四次方曲线*/
            tweenMethod[tweenMethod["QuartEaseOut"] = 21] = "QuartEaseOut";
            tweenMethod[tweenMethod["QuartEaseIn"] = 22] = "QuartEaseIn";
            tweenMethod[tweenMethod["QuartEaseInOut"] = 23] = "QuartEaseInOut";
            tweenMethod[tweenMethod["QuartEaseOutIn"] = 24] = "QuartEaseOutIn";
            /** 五次方曲线*/
            tweenMethod[tweenMethod["QuintEaseOut"] = 25] = "QuintEaseOut";
            tweenMethod[tweenMethod["QuintEaseIn"] = 26] = "QuintEaseIn";
            tweenMethod[tweenMethod["QuintEaseInOut"] = 27] = "QuintEaseInOut";
            tweenMethod[tweenMethod["QuintEaseOutIn"] = 28] = "QuintEaseOutIn";
            /** 橡皮筋弹性曲线*/
            tweenMethod[tweenMethod["ElasticEaseOut"] = 29] = "ElasticEaseOut";
            tweenMethod[tweenMethod["ElasticEaseIn"] = 30] = "ElasticEaseIn";
            tweenMethod[tweenMethod["ElasticEaseInOut"] = 31] = "ElasticEaseInOut";
            tweenMethod[tweenMethod["ElasticEaseOutIn"] = 32] = "ElasticEaseOutIn";
            /** 乒乓球弹性曲线*/
            tweenMethod[tweenMethod["BounceEaseOut"] = 33] = "BounceEaseOut";
            tweenMethod[tweenMethod["BounceEaseIn"] = 34] = "BounceEaseIn";
            tweenMethod[tweenMethod["BounceEaseInOut"] = 35] = "BounceEaseInOut";
            tweenMethod[tweenMethod["BounceEaseOutIn"] = 36] = "BounceEaseOutIn";
            /** 回退曲线*/
            tweenMethod[tweenMethod["BackEaseOut"] = 37] = "BackEaseOut";
            tweenMethod[tweenMethod["BackEaseIn"] = 38] = "BackEaseIn";
            tweenMethod[tweenMethod["BackEaseInOut"] = 39] = "BackEaseInOut";
            tweenMethod[tweenMethod["BackEaseOutIn"] = 40] = "BackEaseOutIn";
        })(tweenMethod = framework.tweenMethod || (framework.tweenMethod = {}));
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * 数组工具
         */
        var ArrayUtil = /** @class */ (function () {
            function ArrayUtil() {
            }
            /**
             * 使用b元素替换数组中第一个a元素。
             *
             * @param arr 被操作数组
             * @param a 被替换的元素
             * @param b 用于替换的元素
             * @param isAdd 当数组中没有找到a元素时，是否需要把b元素添加到数组尾部。默认值为true。
             */
            ArrayUtil.replace = function (arr, a, b, isAdd) {
                if (isAdd === void 0) { isAdd = true; }
                var isreplace = false;
                for (var i = 0; i < arr.length; i++) {
                    if (arr[i] == a) {
                        arr[i] = b;
                        isreplace = true;
                        break;
                    }
                }
                if (!isreplace && isAdd)
                    arr.push(b);
                return arr;
            };
            /**
             * 连接一个或多个数组到自身
             *
             * @param self 被操作数组
             * @param items 要添加到数组末尾的其他项。
             * @returns 返回自身
             */
            ArrayUtil.concatToSelf = function (self) {
                var items = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    items[_i - 1] = arguments[_i];
                }
                var arr = [];
                items.forEach(function (v) { return arr = arr.concat(v); });
                arr.forEach(function (v) { return self.push(v); });
                return self;
            };
            /**
             * 使数组变得唯一，不存在两个相等的元素
             *
             * @param arr 被操作数组
             * @param compare 比较函数
             */
            ArrayUtil.unique = function (arr, compare) {
                var keys = Object.keys(arr);
                var ids = keys.map(function (v) { return Number(v); }).filter(function (v) { return !isNaN(v); });
                var deleteMap = {};
                //
                for (var i = 0, n = ids.length; i < n; i++) {
                    var ki = ids[i];
                    if (deleteMap[ki])
                        continue;
                    for (var j = i + 1; j < n; j++) {
                        var kj = ids[j];
                        if (compare(arr[ki], arr[kj]))
                            deleteMap[kj] = true;
                    }
                }
                //
                for (var i = ids.length - 1; i >= 0; i--) {
                    var id = ids[i];
                    if (deleteMap[id])
                        arr.splice(id, 1);
                }
                return arr;
            };
            return ArrayUtil;
        }());
        framework.ArrayUtil = ArrayUtil;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var CLASS_KEY = "__class__";
        /**
         * 类工具
         *
         * @author feng3d
         */
        var ClassUtils = /** @class */ (function () {
            function ClassUtils() {
            }
            /**
             * 返回对象的完全限定类名。
             * @param value 需要完全限定类名称的对象，可以将任何 JavaScript 值传递给此方法，包括所有可用的 JavaScript 类型、对象实例、原始类型
             * （如number)和类对象
             * @returns 包含完全限定类名称的字符串。
             */
            ClassUtils.getQualifiedClassName = function (value) {
                if (value == null)
                    return "null";
                var prototype = value.prototype ? value.prototype : Object.getPrototypeOf(value);
                if (prototype.hasOwnProperty(CLASS_KEY))
                    return prototype[CLASS_KEY];
                var className = prototype.constructor.name;
                if (_global[className] == prototype.constructor)
                    return className;
                //在可能的命名空间内查找
                for (var i = 0; i < _classNameSpaces.length; i++) {
                    var tryClassName = _classNameSpaces[i] + "." + className;
                    if (this.getDefinitionByName(tryClassName) == prototype.constructor) {
                        className = tryClassName;
                        registerClass(prototype.constructor, className);
                        return className;
                    }
                }
                // console.warn(`未在给出的命名空间 ${_classNameSpaces} 内找到 ${value} 的定义`);
                return className;
            };
            /**
             * 返回 name 参数指定的类的类对象引用。
             * @param name 类的名称。
             */
            ClassUtils.getDefinitionByName = function (name, readCache) {
                if (readCache === void 0) { readCache = true; }
                if (name == "null")
                    return null;
                if (!name)
                    return null;
                if (_global[name])
                    return _global[name];
                if (readCache && _definitionCache[name])
                    return _definitionCache[name];
                var paths = name.split(".");
                var length = paths.length;
                var definition = _global;
                for (var i = 0; i < length; i++) {
                    var path = paths[i];
                    definition = definition[path];
                    if (!definition) {
                        return null;
                    }
                }
                _definitionCache[name] = definition;
                return definition;
            };
            /**
             * 获取默认实例
             *
             * @param name 类名称
             */
            ClassUtils.getDefaultInstanceByName = function (name) {
                var defaultInst = this.defaultInstMap[name];
                if (defaultInst)
                    return defaultInst;
                //
                var cls = this.getDefinitionByName(name);
                if (!cls)
                    return undefined;
                defaultInst = this.defaultInstMap[name] = new cls();
                // 冻结对象，防止被修改
                Object.freeze(defaultInst);
                return defaultInst;
            };
            /**
             * 获取实例
             *
             * @param name 类名称
             */
            ClassUtils.getInstanceByName = function (name) {
                var cls = this.getDefinitionByName(name);
                if (!cls)
                    return undefined;
                return new cls();
            };
            /**
             * 新增反射对象所在的命名空间，使得getQualifiedClassName能够得到正确的结果
             */
            ClassUtils.addClassNameSpace = function (namespace) {
                if (_classNameSpaces.indexOf(namespace) == -1) {
                    _classNameSpaces.push(namespace);
                }
            };
            ClassUtils.defaultInstMap = {};
            return ClassUtils;
        }());
        framework.ClassUtils = ClassUtils;
        ;
        var _definitionCache = {};
        var _global;
        var global;
        if (typeof window != "undefined") {
            _global = window;
        }
        else if (typeof global != "undefined") {
            _global = global;
        }
        var _classNameSpaces = ["m4m.framework"];
        /**
         * 为一个类定义注册完全限定类名
         * @param classDefinition 类定义
         * @param className 完全限定类名
         */
        function registerClass(classDefinition, className) {
            var prototype = classDefinition.prototype;
            Object.defineProperty(prototype, CLASS_KEY, { value: className, writable: true });
        }
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * layer mask
         * @version m4m 1.0
         */
        var CullingMask;
        (function (CullingMask) {
            //--------- 系统定义区段 ----------
            CullingMask[CullingMask["nothing"] = 0] = "nothing";
            CullingMask[CullingMask["default"] = 1] = "default";
            CullingMask[CullingMask["transparentFx"] = 2] = "transparentFx";
            CullingMask[CullingMask["IgnoreRaycast"] = 4] = "IgnoreRaycast";
            CullingMask[CullingMask["editor"] = 8] = "editor";
            CullingMask[CullingMask["water"] = 16] = "water";
            CullingMask[CullingMask["ui"] = 32] = "ui";
            CullingMask[CullingMask["preview"] = 64] = "preview";
            CullingMask[CullingMask["builtin_0"] = 1] = "builtin_0";
            CullingMask[CullingMask["builtin_1"] = 2] = "builtin_1";
            CullingMask[CullingMask["builtin_2"] = 4] = "builtin_2";
            CullingMask[CullingMask["builtin_3"] = 8] = "builtin_3";
            CullingMask[CullingMask["builtin_4"] = 16] = "builtin_4";
            CullingMask[CullingMask["builtin_5"] = 32] = "builtin_5";
            CullingMask[CullingMask["builtin_6"] = 64] = "builtin_6";
            CullingMask[CullingMask["builtin_7"] = 128] = "builtin_7";
            //--------- 用户自定义区段 ----------
            CullingMask[CullingMask["modelbeforeui"] = 256] = "modelbeforeui";
            CullingMask[CullingMask["user_8"] = 256] = "user_8";
            CullingMask[CullingMask["user_9"] = 512] = "user_9";
            CullingMask[CullingMask["user_10"] = 1024] = "user_10";
            CullingMask[CullingMask["user_11"] = 2048] = "user_11";
            CullingMask[CullingMask["user_12"] = 4096] = "user_12";
            CullingMask[CullingMask["user_13"] = 8192] = "user_13";
            CullingMask[CullingMask["user_14"] = 16384] = "user_14";
            CullingMask[CullingMask["user_15"] = 32768] = "user_15";
            CullingMask[CullingMask["user_16"] = 65536] = "user_16";
            CullingMask[CullingMask["user_17"] = 131072] = "user_17";
            CullingMask[CullingMask["user_18"] = 262144] = "user_18";
            CullingMask[CullingMask["user_19"] = 524288] = "user_19";
            CullingMask[CullingMask["user_20"] = 1048576] = "user_20";
            CullingMask[CullingMask["user_21"] = 2097152] = "user_21";
            CullingMask[CullingMask["user_22"] = 4194304] = "user_22";
            CullingMask[CullingMask["user_23"] = 8388608] = "user_23";
            CullingMask[CullingMask["user_24"] = 16777216] = "user_24";
            CullingMask[CullingMask["user_25"] = 33554432] = "user_25";
            CullingMask[CullingMask["user_26"] = 67108864] = "user_26";
            CullingMask[CullingMask["user_27"] = 134217728] = "user_27";
            CullingMask[CullingMask["user_28"] = 268435456] = "user_28";
            CullingMask[CullingMask["user_29"] = 536870912] = "user_29";
            CullingMask[CullingMask["user_30"] = 1073741824] = "user_30";
            CullingMask[CullingMask["user_31"] = 2147483648] = "user_31";
            CullingMask[CullingMask["everything"] = 4294967295] = "everything";
        })(CullingMask = framework.CullingMask || (framework.CullingMask = {}));
        /**
         * @private
         * @language zh_CN
         * @classdesc
         * 剔除mask工具类
         * @version m4m 1.0
         */
        var cullingmaskutil = /** @class */ (function () {
            function cullingmaskutil() {
            }
            cullingmaskutil.maskTolayer = function (mask) {
                return Math.log(mask) / Math.log(2);
            };
            cullingmaskutil.layerToMask = function (layer) {
                return 1 << layer;
            };
            return cullingmaskutil;
        }());
        framework.cullingmaskutil = cullingmaskutil;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @private
         * @language zh_CN
         * @classdesc
         * 给编辑器用的工具类，用eval方式获取enum对象
         * @version m4m 1.0
         */
        var EnumUtil = /** @class */ (function () {
            function EnumUtil() {
            }
            EnumUtil.getEnumObjByType = function (enumType) {
                var index = enumType.indexOf("m4m.framework.");
                if (index == 0)
                    enumType = enumType.substr(15);
                return eval("{result:" + enumType + "}");
            };
            return EnumUtil;
        }());
        framework.EnumUtil = EnumUtil;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * GL扩展
         *
         * @author feng3d
         */
        var GLExtension = /** @class */ (function () {
            function GLExtension(gl) {
                gl.extensions = this;
                this.initExtensions(gl);
                this.cacheGLQuery(gl);
                // //webgl拓展兼容,加宏标记
                // if (this.EXT_shader_texture_lod != null)
                // {
                //     sceneMgr.app.globalMacros.push('TEXTURE_LOD');
                // }
            }
            GLExtension.prototype.initExtensions = function (gl) {
                this.EXT_color_buffer_half_float = gl.getExtension("EXT_color_buffer_half_float");
                this.EXT_texture_filter_anisotropic = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
                // this.OES_texture_float_linear = gl.getExtension("OES_texture_float_linear");
                this.OES_texture_half_float_linear = gl.getExtension("OES_texture_half_float_linear");
                this.EXT_color_buffer_float = gl.getExtension("EXT_color_buffer_float");
                this.WEBGL_compressed_texture_etc = gl.getExtension("WEBGL_compressed_texture_etc");
                this.WEBGL_compressed_texture_etc1 = gl.getExtension("WEBGL_compressed_texture_etc1");
                this.WEBGL_compressed_texture_pvrtc = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
                this.WEBGL_compressed_texture_s3tc = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
                this.WEBGL_compressed_texture_s3tc_srgb = gl.getExtension('WEBGL_compressed_texture_s3tc_srgb');
                this.WEBGL_compressed_texture_astc = gl.getExtension('WEBGL_compressed_texture_astc');
                this.WEBGL_debug_renderer_info = gl.getExtension("WEBGL_debug_renderer_info");
                this.WEBGL_debug_shaders = gl.getExtension("WEBGL_debug_shaders");
                this.WEBGL_lose_context = gl.getExtension("WEBGL_lose_context") || gl.getExtension("WEBKIT_WEBGL_lose_context") || gl.getExtension("MOZ_WEBGL_lose_context");
            };
            /**
             * 缓存GL查询
             * @param gl GL实例
             */
            GLExtension.prototype.cacheGLQuery = function (gl) {
                var oldGetExtension = gl.getExtension;
                gl.getExtension = function (name) {
                    gl.extensions[name] = gl.extensions[name] || oldGetExtension.apply(gl, arguments);
                    return gl.extensions[name];
                };
            };
            return GLExtension;
        }());
        framework.GLExtension = GLExtension;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * Number类型的工具类
         * @version m4m 1.0
         */
        var NumberUtil = /** @class */ (function () {
            function NumberUtil() {
            }
            /**
             * @public
             * @language zh_CN
             * 获取键值A对应的codevalue
             * @version m4m 1.0
             */
            NumberUtil.KEY_A = 65;
            /**
             * @public
             * @language zh_CN
             * 获取键值D对应的codevalue
             * @version m4m 1.0
             */
            NumberUtil.KEY_D = 68;
            /**
             * @public
             * @language zh_CN
             * 获取键值E对应的codevalue
             * @version m4m 1.0
             */
            NumberUtil.KEY_E = 69;
            /**
             * @public
             * @language zh_CN
             * 获取键值Q对应的codevalue
             * @version m4m 1.0
             */
            NumberUtil.KEY_Q = 81;
            /**
             * @public
             * @language zh_CN
             * 获取键值R对应的codevalue
             * @version m4m 1.0
             */
            NumberUtil.KEY_R = 82;
            /**
             * @public
             * @language zh_CN
             * 获取键值S对应的codevalue
             * @version m4m 1.0
             */
            NumberUtil.KEY_S = 83;
            /**
             * @public
             * @language zh_CN
             * 获取键值W对应的codevalue
             * @version m4m 1.0
             */
            NumberUtil.KEY_W = 87;
            /**
             * @public
             * @language zh_CN
             * 获取键值a对应的codevalue
             * @version m4m 1.0
             */
            NumberUtil.KEY_a = 97;
            /**
             * @public
             * @language zh_CN
             * 获取键值d对应的codevalue
             * @version m4m 1.0
             */
            NumberUtil.KEY_d = 100;
            /**
             * @public
             * @language zh_CN
             * 获取键值e对应的codevalue
             * @version m4m 1.0
             */
            NumberUtil.KEY_e = 101;
            /**
             * @public
             * @language zh_CN
             * 获取键值q对应的codevalue
             * @version m4m 1.0
             */
            NumberUtil.KEY_q = 113;
            /**
             * @public
             * @language zh_CN
             * 获取键值r对应的codevalue
             * @version m4m 1.0
             */
            NumberUtil.KEY_r = 114;
            /**
             * @public
             * @language zh_CN
             * 获取键值s对应的codevalue
             * @version m4m 1.0
             */
            NumberUtil.KEY_s = 115;
            /**
             * @public
             * @language zh_CN
             * 获取键值w对应的codevalue
             * @version m4m 1.0
             */
            NumberUtil.KEY_w = 119;
            return NumberUtil;
        }());
        framework.NumberUtil = NumberUtil;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * Object 工具
         */
        var ObjectUtil = /** @class */ (function () {
            function ObjectUtil() {
            }
            /**
             * 判断是否为基础类型 undefined,null,boolean,string,number
             */
            ObjectUtil.isBaseType = function (object) {
                //基础类型
                if (object == undefined
                    || object == null
                    || typeof object == "boolean"
                    || typeof object == "string"
                    || typeof object == "number")
                    return true;
            };
            /**
             * 判断是否为Object对象，构造函数是否为Object， 检测 object.constructor == Object
             *
             * @param obj 用于判断的对象
             */
            ObjectUtil.isObject = function (obj) {
                return obj != null && (obj.constructor == Object || (obj.constructor.name == "Object")); // 兼容其他 HTMLIFrameElement 传入的Object
            };
            return ObjectUtil;
        }());
        framework.ObjectUtil = ObjectUtil;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @private
         * @language zh_CN
         * @classdesc
         * 正则表达式的工具类，提供一些引擎用到的正则表达式
         * @version m4m 1.0
         */
        var RegexpUtil = /** @class */ (function () {
            function RegexpUtil() {
            }
            //shader properties
            RegexpUtil.textureRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\)[ ]*=[ ]*'(.+)'[ ]*\{[ ]*([a-zA-Z]*)[ ]*([a-zA-Z]*)[ ]*\}/;
            RegexpUtil.vectorRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\)[ ]*=[ ]*\([ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*\)/;
            RegexpUtil.floatRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\)[ ]*=[ ]*([0-9.-]+)/;
            RegexpUtil.rangeRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\([ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*\)[ ]*\)[ ]*=[ ]*([0-9.-]+)/;
            //material
            RegexpUtil.vector4Regexp = /\([ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*\)/;
            //特效解析，[1,2],2,1
            RegexpUtil.vector3FloatOrRangeRegexp = /([0-9.-]+|\[[0-9.-]+,[0-9.-]+\]),([0-9.-]+|\[[0-9.-]+,[0-9.-]+\]),([0-9.-]+|\[[0-9.-]+,[0-9.-]+\])/;
            return RegexpUtil;
        }());
        framework.RegexpUtil = RegexpUtil;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * 序列化属性函数
         *
         * 序列化对象时建议使用 serialization.serialize
         *
         * @param target 序列化后的对象，存放序列化后属性值的对象。
         * @param source 被序列化的对象，提供序列化前属性值的对象。
         * @param property 序列化属性名称
         * @param handlers 序列化属性函数列表
         */
        function propertyHandler(target, source, property, handlers, serialization) {
            for (var i = 0; i < handlers.length; i++) {
                if (handlers[i](target, source, property, handlers, serialization)) {
                    return true;
                }
            }
            return true;
        }
        /**
         * 序列化属性函数
         *
         * 序列化对象时建议使用 serialization.serialize
         *
         * @param target 序列化后的对象，存放序列化后属性值的对象。
         * @param source 被序列化的对象，提供序列化前属性值的对象。
         * @param property 序列化属性名称
         * @param handlers 序列化属性函数列表
         */
        function differentPropertyHandler(target, source, property, different, handlers, serialization) {
            for (var i = 0; i < handlers.length; i++) {
                if (handlers[i](target, source, property, different, handlers, serialization)) {
                    return true;
                }
            }
            return true;
        }
        var __root__ = "__root__";
        /**
         * 序列化
         *
         * @author feng3d
         */
        var Serialization = /** @class */ (function () {
            function Serialization() {
                /**
                 * 序列化函数列表
                 */
                this.serializeHandlers = [];
                /**
                 * 反序列化函数列表
                 */
                this.deserializeHandlers = [];
                /**
                 * 比较差异函数列表
                 */
                this.differentHandlers = [];
                /**
                 * 设置函数列表
                 */
                this.setValueHandlers = [];
            }
            /**
             * 序列化对象
             *
             * 过程中使用 different与默认值作比较减少结果中的数据。
             *
             * @param target 被序列化的对象
             *
             * @returns 序列化后简单数据对象（由Object与Array组合可 JSON.stringify 的简单结构）
             */
            Serialization.prototype.serialize = function (target) {
                var handlers = this.serializeHandlers.sort(function (a, b) { return b.priority - a.priority; }).map(function (v) { return v.handler; });
                var result = {};
                propertyHandler(result, { __root__: target }, __root__, handlers, this);
                var v = result[__root__];
                return v;
            };
            /**
             * 反序列化对象为基础对象数据（由Object与Array组合）
             *
             * @param object 换为Json的对象
             * @returns 反序列化后的数据
             */
            Serialization.prototype.deserialize = function (object) {
                var handlers = this.deserializeHandlers.sort(function (a, b) { return b.priority - a.priority; }).map(function (v) { return v.handler; });
                var result = {};
                propertyHandler(result, { __root__: object }, __root__, handlers, this);
                var v = result[__root__];
                return v;
            };
            /**
             * 比较两个对象的不同，提取出不同的数据(可能会经过反序列化处理)
             *
             * @param target 用于检测不同的数据
             * @param source   模板（默认）数据
             * @param different 比较得出的不同（简单结构）数据
             *
             * @returns 比较得出的不同数据（由Object与Array组合可 JSON.stringify 的简单结构）
             */
            Serialization.prototype.different = function (target, source) {
                var handlers = this.differentHandlers.sort(function (a, b) { return b.priority - a.priority; }).map(function (v) { return v.handler; });
                var different = { __root__: {} };
                differentPropertyHandler({ __root__: target }, { __root__: source }, __root__, different, handlers, this);
                return different[__root__];
            };
            /**
             * 从数据对象中提取数据给目标对象赋值（可能会经过序列化处理）
             *
             * @param target 目标对象
             * @param source 数据对象 可由Object与Array以及自定义类型组合
             */
            Serialization.prototype.setValue = function (target, source) {
                var handlers = this.setValueHandlers.sort(function (a, b) { return b.priority - a.priority; }).map(function (v) { return v.handler; });
                propertyHandler({ __root__: target }, { __root__: source }, __root__, handlers, this);
                return target;
            };
            /**
             * 克隆
             * @param target 被克隆对象
             */
            Serialization.prototype.clone = function (target) {
                return this.deserialize(this.serialize(target));
            };
            return Serialization;
        }());
        framework.Serialization = Serialization;
        framework.CLASS_KEY = "__class__";
        var SERIALIZE_KEY = "_serialize__";
        /**
         * 获取序列化属性列表
         */
        function getSerializableMembers(object, serializableMembers) {
            serializableMembers = serializableMembers || [];
            if (object["__proto__"]) {
                getSerializableMembers(object["__proto__"], serializableMembers);
            }
            var serializePropertys = object[SERIALIZE_KEY];
            if (serializePropertys)
                framework.ArrayUtil.concatToSelf(serializableMembers, serializePropertys);
            framework.ArrayUtil.unique(serializableMembers);
            return serializableMembers;
        }
        framework.serialization = new Serialization();
        framework.serialization.serializeHandlers.push(
        //基础类型
        {
            priority: 0,
            handler: function (target, source, property) {
                var spv = source[property];
                if (framework.ObjectUtil.isBaseType(spv)) {
                    target[property] = spv;
                    return true;
                }
                return false;
            }
        }, 
        //处理方法
        {
            priority: 0,
            handler: function (target, source, property) {
                var spv = source[property];
                if (spv && typeof spv == "function") {
                    var object = {};
                    object[framework.CLASS_KEY] = "function";
                    object.data = spv.toString();
                    target[property] = object;
                    return true;
                }
                return false;
            }
        }, 
        // 排除不支持序列化对象 serializable == false 时不进行序列化
        {
            priority: 0,
            handler: function (target, source, property) {
                var spv = source[property];
                if (spv && spv["serializable"] == false) {
                    return true;
                }
                return false;
            }
        }, 
        // 自定义序列化函数
        {
            priority: 0,
            handler: function (target, source, property) {
                var spv = source[property];
                if (spv && spv["serialize"]) {
                    var object = {};
                    object[framework.CLASS_KEY] = framework.ClassUtils.getQualifiedClassName(spv);
                    spv["serialize"](object);
                    target[property] = object;
                    return true;
                }
                return false;
            }
        }, 
        //处理数组
        {
            priority: 0,
            handler: function (target, source, property, handlers, serialization) {
                var spv = source[property];
                if (Array.isArray(spv)) {
                    var arr_5 = target[property] || [];
                    var keys = Object.keys(spv);
                    keys.forEach(function (v) {
                        propertyHandler(arr_5, spv, v, handlers, serialization);
                    });
                    target[property] = arr_5;
                    return true;
                }
                return false;
            }
        }, 
        //处理普通Object
        {
            priority: 0,
            handler: function (target, source, property, handlers, serialization) {
                var spv = source[property];
                if (framework.ObjectUtil.isObject(spv)) {
                    var object_1 = {};
                    var keys = Object.keys(spv);
                    keys.forEach(function (key) {
                        propertyHandler(object_1, spv, key, handlers, serialization);
                    });
                    target[property] = object_1;
                    return true;
                }
                return false;
            }
        }, 
        // 使用默认序列化
        {
            priority: -10000,
            handler: function (target, source, property, handlers, serialization) {
                var tpv = target[property];
                var spv = source[property];
                if (tpv == null || tpv.constructor != spv.constructor) {
                    var className = framework.ClassUtils.getQualifiedClassName(spv);
                    // 获取或创建对象默认实例，把默认实例保存在构造函数上省去使用map保存。
                    var inst = spv.constructor.inst;
                    if (!inst)
                        inst = spv.constructor.inst = new spv.constructor();
                    // .constructor 上的属性会被继承
                    if (!(inst instanceof spv.constructor))
                        inst = spv.constructor.inst = new spv.constructor();
                    var diff = serialization.different(spv, inst);
                    diff[framework.CLASS_KEY] = className;
                    target[property] = diff;
                }
                else {
                    debugger;
                    var diff = serialization.different(spv, tpv);
                    if (diff)
                        target[property] = diff;
                }
                return true;
            }
        });
        framework.serialization.deserializeHandlers.push(
        //基础类型
        {
            priority: 0,
            handler: function (target, source, property) {
                var spv = source[property];
                if (framework.ObjectUtil.isBaseType(spv)) {
                    target[property] = spv;
                    return true;
                }
                return false;
            }
        }, 
        //处理方法
        {
            priority: 0,
            handler: function (target, source, property) {
                var spv = source[property];
                if (spv && spv[framework.CLASS_KEY] == "function") {
                    target[property] = eval("(".concat(spv.data, ")"));
                    return true;
                }
                return false;
            }
        }, 
        // 处理非原生Object对象
        {
            priority: 0,
            handler: function (target, source, property) {
                var spv = source[property];
                if (!framework.ObjectUtil.isObject(spv) && !Array.isArray(spv)) {
                    target[property] = spv;
                    return true;
                }
                return false;
            }
        }, 
        //处理数组
        {
            priority: 0,
            handler: function (target, source, property, handlers, serialization) {
                var spv = source[property];
                if (Array.isArray(spv)) {
                    var arr = target[property] || [];
                    var keys = Object.keys(spv);
                    keys.forEach(function (key) {
                        propertyHandler(arr, spv, key, handlers, serialization);
                    });
                    target[property] = arr;
                    return true;
                }
                return false;
            }
        }, 
        // 处理 没有类名称标记的 普通Object
        {
            priority: 0,
            handler: function (target, source, property, handlers, serialization) {
                var tpv = target[property];
                var spv = source[property];
                if (framework.ObjectUtil.isObject(spv) && spv[framework.CLASS_KEY] == null) {
                    var obj = {};
                    if (tpv)
                        obj = tpv;
                    //
                    var keys = Object.keys(spv);
                    keys.forEach(function (key) {
                        propertyHandler(obj, spv, key, handlers, serialization);
                    });
                    target[property] = obj;
                    return true;
                }
                return false;
            }
        }, 
        // 处理自定义反序列化对象
        {
            priority: 0,
            handler: function (target, source, property) {
                var tpv = target[property];
                var spv = source[property];
                var inst = framework.ClassUtils.getInstanceByName(spv[framework.CLASS_KEY]);
                //处理自定义反序列化对象
                if (inst && inst["deserialize"]) {
                    if (tpv && tpv.constructor == inst.constructor) {
                        inst = tpv;
                    }
                    inst["deserialize"](spv);
                    target[property] = inst;
                    return true;
                }
                return false;
            }
        }, 
        // 处理自定义对象的反序列化 
        {
            priority: -10000,
            handler: function (target, source, property, handlers, serialization) {
                var tpv = target[property];
                var spv = source[property];
                var inst = framework.ClassUtils.getInstanceByName(spv[framework.CLASS_KEY]);
                if (inst) {
                    if (tpv && tpv.constructor == inst.constructor) {
                        inst = tpv;
                    }
                    //默认反序列
                    var keys = Object.keys(spv);
                    keys.forEach(function (key) {
                        if (key != framework.CLASS_KEY)
                            propertyHandler(inst, spv, key, handlers, serialization);
                    });
                    target[property] = inst;
                    return true;
                }
                console.warn("\u672A\u5904\u7406");
                return false;
            }
        });
        framework.serialization.differentHandlers = [
            // 相等对象
            {
                priority: 0,
                handler: function (target, source, property) {
                    if (target[property] == source[property]) {
                        return true;
                    }
                    return false;
                }
            },
            // 目标数据为null时
            {
                priority: 0,
                handler: function (target, source, property, different, handlers, serialization) {
                    if (null == source[property]) {
                        different[property] = serialization.serialize(target[property]);
                        return true;
                    }
                    return false;
                }
            },
            // 基础类型
            {
                priority: 0,
                handler: function (target, source, property, different, handlers, serialization) {
                    var tpv = target[property];
                    if (framework.ObjectUtil.isBaseType(tpv)) {
                        different[property] = tpv;
                        return true;
                    }
                    return false;
                }
            },
            // 数组
            {
                priority: 0,
                handler: function (target, source, property, different, handlers, serialization) {
                    var tpv = target[property];
                    var spv = source[property];
                    if (Array.isArray(tpv)) {
                        var keys = Object.keys(tpv);
                        var diff = [];
                        keys.forEach(function (key) {
                            differentPropertyHandler(tpv, spv, key, diff, handlers, serialization);
                        });
                        if (Object.keys(diff).length > 0)
                            different[property] = diff;
                        return true;
                    }
                    return false;
                }
            },
            // 不同对象类型
            {
                priority: 0,
                handler: function (target, source, property, different, handlers, serialization) {
                    var tpv = target[property];
                    var spv = source[property];
                    if (spv.constructor != tpv.constructor) {
                        different[property] = serialization.serialize(tpv);
                        return true;
                    }
                    return false;
                }
            },
            // 默认处理
            {
                priority: -10000,
                handler: function (target, source, property, different, handlers, serialization) {
                    var tpv = target[property];
                    var spv = source[property];
                    var keys = getSerializableMembers(tpv);
                    if (tpv.constructor == Object)
                        keys = Object.keys(tpv);
                    var diff = {};
                    keys.forEach(function (v) {
                        differentPropertyHandler(tpv, spv, v, diff, handlers, serialization);
                    });
                    if (Object.keys(diff).length > 0)
                        different[property] = diff;
                    return true;
                }
            },
        ];
        /**
         * 设置函数列表
         */
        framework.serialization.setValueHandlers = [
            // 值相等时直接返回
            {
                priority: 0,
                handler: function (target, source, property, handlers) {
                    if (target[property] == source[property]) {
                        return true;
                    }
                    return false;
                }
            },
            // 当原值等于null时直接反序列化赋值
            {
                priority: 0,
                handler: function (target, source, property, handlers, serialization) {
                    var tpv = target[property];
                    var spv = source[property];
                    if (tpv == null) {
                        target[property] = serialization.deserialize(spv);
                        return true;
                    }
                    return false;
                }
            },
            // 处理简单类型
            {
                priority: 0,
                handler: function (target, source, property, handlers) {
                    var tpv = target[property];
                    var spv = source[property];
                    if (framework.ObjectUtil.isBaseType(spv)) {
                        target[property] = spv;
                        return true;
                    }
                    return false;
                }
            },
            // 处理数组
            {
                priority: 0,
                handler: function (target, source, property, handlers, serialization) {
                    var tpv = target[property];
                    var spv = source[property];
                    if (Array.isArray(spv)) {
                        var keys = Object.keys(spv);
                        keys.forEach(function (key) {
                            propertyHandler(tpv, spv, key, handlers, serialization);
                        });
                        target[property] = tpv;
                        return true;
                    }
                    return false;
                }
            },
            // 处理非 Object 类型数据
            {
                priority: 0,
                handler: function (target, source, property, handlers, serialization) {
                    var tpv = target[property];
                    var spv = source[property];
                    if (!framework.ObjectUtil.isObject(spv)) {
                        target[property] = serialization.deserialize(spv);
                        return true;
                    }
                    return false;
                }
            },
            // 处理 Object 基础类型数据
            {
                priority: 0,
                handler: function (target, source, property, handlers, serialization) {
                    var tpv = target[property];
                    var spv = source[property];
                    if (framework.ObjectUtil.isObject(spv) && spv[framework.CLASS_KEY] == undefined) {
                        var keys = Object.keys(spv);
                        keys.forEach(function (key) {
                            propertyHandler(tpv, spv, key, handlers, serialization);
                        });
                        target[property] = tpv;
                        return true;
                    }
                    return false;
                }
            },
            // 处理自定义类型
            {
                priority: -10000,
                handler: function (target, source, property, handlers, serialization) {
                    var tpv = target[property];
                    var spv = source[property];
                    var targetClassName = framework.ClassUtils.getQualifiedClassName(target[property]);
                    // 相同对象类型
                    if (targetClassName == spv[framework.CLASS_KEY]) {
                        var keys = Object.keys(spv);
                        keys.forEach(function (key) {
                            propertyHandler(tpv, spv, key, handlers, serialization);
                        });
                        target[property] = tpv;
                    }
                    else {
                        // 不同对象类型
                        target[property] = serialization.deserialize(spv);
                    }
                    return true;
                }
            },
        ];
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 正则表达式的工具类，提供一些引擎用到的正则表达式
         * @version m4m 1.0
         */
        var StringUtil = /** @class */ (function () {
            function StringUtil() {
            }
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 将一个字符串中的所有指定字符替换为指定字符
             * @param srcStr 要处理的字符串
             * @param fromStr 原字符串中的指定字符串
             * @param toStr 将被替换为的字符串
             * @version m4m 1.0
             */
            StringUtil.replaceAll = function (srcStr, fromStr, toStr) {
                return srcStr.replace(new RegExp(fromStr, 'gm'), toStr);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 剔除掉字符串中所有的空格
             * @param str 要处理的字符串
             * @version m4m 1.0
             */
            StringUtil.trimAll = function (str) {
                str += ""; //可能传进来number，number没有replace方法
                var result = str.replace(/(^\s+)|(\s+$)/g, "");
                result = result.replace(/\s/g, "");
                return result;
            };
            /**
             * @private
             * @language zh_CN
             * @classdesc
             * 将一个字符串中的第一个字符转为小写
             * @param str 要处理的字符串
             * @version m4m 1.0
             */
            StringUtil.firstCharToLowerCase = function (str) {
                var firstChar = str.substr(0, 1).toLowerCase();
                var other = str.substr(1);
                return firstChar + other;
            };
            StringUtil.isNullOrEmptyObject = function (obj) {
                if (!obj)
                    return true;
                for (var n in obj) {
                    return false;
                }
                return true;
            };
            /**
             * 获取文件的 后缀
             * @param filePath 文件字符串
             * @returns
             */
            StringUtil.GetSuffix = function (filePath) {
                var _r = this.suffixPattern.exec(filePath);
                if (_r == null)
                    return "";
                return _r[0];
            };
            /**
             * 解码成 文本字符串
             * @param array 数组
             * @returns 文本字符串
             */
            StringUtil.decodeText = function (array) {
                if (typeof TextDecoder !== 'undefined') {
                    return new TextDecoder().decode(array);
                }
                // Avoid the String.fromCharCode.apply(null, array) shortcut, which
                // throws a "maximum call stack size exceeded" error for large arrays.
                var s = '';
                for (var i = 0, il = array.length; i < il; i++) {
                    // Implicitly assumes little-endian.
                    s += String.fromCharCode(array[i]);
                }
                try {
                    // merges multi-byte utf-8 characters.
                    return decodeURIComponent(escape(s));
                }
                catch (e) { // see #16358
                    return s;
                }
            };
            /** 启用标记 */
            StringUtil.ENABLED = "enabled";
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 内建TAG “Untagged”
             * @version m4m 1.0
             */
            StringUtil.builtinTag_Untagged = "Untagged";
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 内建TAG “Player”
             * @version m4m 1.0
             */
            StringUtil.builtinTag_Player = "Player";
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 内建TAG “EditorOnly”
             * @version m4m 1.0
             */
            StringUtil.builtinTag_EditorOnly = "EditorOnly";
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 内建TAG “MainCamera”
             * @version m4m 1.0
             */
            StringUtil.builtinTag_MainCamera = "MainCamera";
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取camera组件的名字
             * @version m4m 1.0
             */
            StringUtil.COMPONENT_CAMERA = "camera";
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取boxcollider组件的名字
             * @version m4m 1.0
             */
            StringUtil.COMPONENT_BOXCOLLIDER = "boxcollider";
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取light组件的名字
             * @version m4m 1.0
             */
            StringUtil.COMPONENT_LIGHT = "light";
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取meshFilter组件的名字
             * @version m4m 1.0
             */
            StringUtil.COMPONENT_MESHFILTER = "meshFilter";
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取meshRenderer组件的名字
             * @version m4m 1.0
             */
            StringUtil.COMPONENT_MESHRENDER = "meshRenderer";
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取effectSystem组件的名字
             * @version m4m 1.0
             */
            StringUtil.COMPONENT_EFFECTSYSTEM = "effectSystem";
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取label组件的名字
             * @version m4m 1.0
             */
            StringUtil.COMPONENT_LABEL = "label";
            StringUtil.COMPONENT_uirect = "uirect";
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取image2D组件的名字
             * @version m4m 1.0
             */
            StringUtil.COMPONENT_IMAGE = "image2D";
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取rawImage2D组件的名字
             * @version m4m 1.0
             */
            StringUtil.COMPONENT_RAWIMAGE = "rawImage2D";
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取button组件的名字
             * @version m4m 1.0
             */
            StringUtil.COMPONENT_BUTTON = "button";
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取skinnedMeshRenderer组件的名字
             * @version m4m 1.0
             */
            StringUtil.COMPONENT_SKINMESHRENDER = "skinnedMeshRenderer";
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取AudioPlayer组件的名字
             * @version m4m 1.0
             */
            StringUtil.COMPONENT_AUDIOPLAYER = "AudioPlayer";
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取cameraController组件的名字
             * @version m4m 1.0
             */
            StringUtil.COMPONENT_CAMERACONTROLLER = "cameraController";
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 获取canvasRenderer组件的名字
             * @version m4m 1.0
             */
            StringUtil.COMPONENT_CANVASRENDER = "canvasRenderer";
            /**
             * @private
             */
            StringUtil.UIStyle_RangeFloat = "rangeFloat";
            /**
             * @private
             */
            StringUtil.UIStyle_Enum = "enum";
            /**
             * @private
             */
            StringUtil.RESOURCES_MESH_CUBE = "cube";
            /** 匹配文件后缀 */
            StringUtil.suffixPattern = /(\.([a-z|0-9]*)){1,2}$/;
            return StringUtil;
        }());
        framework.StringUtil = StringUtil;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var textureutil = /** @class */ (function () {
            function textureutil() {
            }
            textureutil.loadUtil = function (path) {
                //插入textureutil的js代码
                var sc1 = document.createElement("script");
                var sc2 = document.createElement("script");
                sc1.src = path + "lib/webgl-util.js";
                sc2.src = path + "";
                document.body.appendChild(sc1);
                document.body.appendChild(sc2);
            };
            return textureutil;
        }());
        framework.textureutil = textureutil;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 原生3d模型类型
         * @version m4m 1.0
         */
        var PrimitiveType;
        (function (PrimitiveType) {
            PrimitiveType[PrimitiveType["Sphere"] = 0] = "Sphere";
            PrimitiveType[PrimitiveType["Capsule"] = 1] = "Capsule";
            PrimitiveType[PrimitiveType["Cylinder"] = 2] = "Cylinder";
            PrimitiveType[PrimitiveType["Cube"] = 3] = "Cube";
            PrimitiveType[PrimitiveType["Plane"] = 4] = "Plane";
            PrimitiveType[PrimitiveType["Quad"] = 5] = "Quad";
            PrimitiveType[PrimitiveType["Pyramid"] = 6] = "Pyramid";
        })(PrimitiveType = framework.PrimitiveType || (framework.PrimitiveType = {}));
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 原生2d类型
         * @version m4m 1.0
         */
        var Primitive2DType;
        (function (Primitive2DType) {
            /** 原始图片渲染器 */
            Primitive2DType[Primitive2DType["RawImage2D"] = 0] = "RawImage2D";
            /** 多功能图片渲染器（sprite） */
            Primitive2DType[Primitive2DType["Image2D"] = 1] = "Image2D";
            /** 文本渲染器 */
            Primitive2DType[Primitive2DType["Label"] = 2] = "Label";
            /** 按钮 */
            Primitive2DType[Primitive2DType["Button"] = 3] = "Button";
            /** 输入框 */
            Primitive2DType[Primitive2DType["InputField"] = 4] = "InputField";
            /** 进度条 */
            Primitive2DType[Primitive2DType["Progressbar"] = 5] = "Progressbar";
            /** Panel */
            Primitive2DType[Primitive2DType["Panel"] = 6] = "Panel";
            /** ScrollView */
            Primitive2DType[Primitive2DType["ScrollRect"] = 7] = "ScrollRect";
        })(Primitive2DType = framework.Primitive2DType || (framework.Primitive2DType = {}));
        /**
         * 判断 函数对象代码实现内容是否是空的
         * @param fun
         */
        function functionIsEmpty(fun) {
            if (!fun)
                true;
            var funStr = fun.toString().replace(/\s/g, "");
            var idx = funStr.indexOf("{");
            var idx_1 = funStr.indexOf("}");
            if (idx == -1 || idx_1 == -1)
                return true;
            return (idx_1 - idx) <= 1;
        }
        framework.functionIsEmpty = functionIsEmpty;
        /**
         * 获取实例对象的类名字符串
         * @param obj 对象实例
         */
        function getClassName(obj) {
            if (!obj)
                return "";
            var constructor = Object.getPrototypeOf(obj).constructor;
            if (!constructor)
                return "";
            return constructor.name;
        }
        framework.getClassName = getClassName;
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * Transform工具类
         * @version m4m 1.0
         */
        var TransformUtil = /** @class */ (function () {
            function TransformUtil() {
            }
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 创建默认的3d对象
             * @param type 原生3d对象类型
             * @param app application的实例
             * @version m4m 1.0
             */
            TransformUtil.CreatePrimitive = function (type, app) {
                if (app === void 0) { app = null; }
                if (!app) {
                    app = framework.sceneMgr.app;
                }
                var objName = PrimitiveType[type];
                var trans = new framework.transform();
                trans.name = objName;
                var mesh = trans.gameObject.addComponent("meshFilter");
                var smesh = app.getAssetMgr().getDefaultMesh(objName.toLowerCase());
                mesh.mesh = smesh;
                var renderer = trans.gameObject.addComponent("meshRenderer");
                renderer.materials = [];
                renderer.materials.push(new framework.material());
                renderer.materials[0].setShader(app.getAssetMgr().getShader("shader/def"));
                return trans;
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 创建默认的2d控件
             * @param type 2d控件类型
             * @param app application的实例
             * @version m4m 1.0
             */
            TransformUtil.Create2DPrimitive = function (type, app) {
                if (app === void 0) { app = null; }
                if (!app) {
                    app = framework.sceneMgr.app;
                }
                // let enumObj = EnumUtil.getEnumObjByType("m4m.framework.Primitive2DType");
                var objName = Primitive2DType[type];
                var componentName = framework.StringUtil.firstCharToLowerCase(objName);
                var t2d = this.make2DNode(objName);
                var i2dComp = t2d.addComponent(componentName);
                switch (type) {
                    case Primitive2DType.RawImage2D:
                        TransformUtil.create2D_rawImage(i2dComp, app);
                        break;
                    case Primitive2DType.Image2D:
                        TransformUtil.create2D_image2D(i2dComp, app);
                        break;
                    case Primitive2DType.Label:
                        TransformUtil.create2D_label(i2dComp, app);
                        break;
                    case Primitive2DType.Button:
                        TransformUtil.create2D_button(i2dComp, app);
                        break;
                    case Primitive2DType.InputField:
                        TransformUtil.create2D_InputField(i2dComp, app);
                        break;
                    case Primitive2DType.Progressbar:
                        TransformUtil.create2D_progressbar(i2dComp, app);
                        break;
                    case Primitive2DType.ScrollRect:
                        TransformUtil.create2D_scrollRect(i2dComp, app);
                        break;
                }
                return t2d;
            };
            TransformUtil.make2DNode = function (name, parent, lOpt, w, h, px, py) {
                if (parent === void 0) { parent = null; }
                if (lOpt === void 0) { lOpt = 0; }
                if (w === void 0) { w = 100; }
                if (h === void 0) { h = 100; }
                if (px === void 0) { px = 0; }
                if (py === void 0) { py = 0; }
                var node = new framework.transform2D();
                node.name = name;
                node.width = w;
                node.height = h;
                node.layoutState = lOpt;
                node.pivot.x = px;
                node.pivot.y = py;
                if (parent)
                    parent.addChild(node);
                return node;
            };
            TransformUtil.create2D_rawImage = function (img, app) {
                img.transform.width = 100;
                img.transform.height = 100;
                img.image = app.getAssetMgr().getDefaultTexture("white");
            };
            TransformUtil.create2D_image2D = function (img, app) {
                img.transform.width = 100;
                img.transform.height = 100;
                img.sprite = app.getAssetMgr().getDefaultSprite("white_sprite");
            };
            TransformUtil.create2D_progressbar = function (progress, app) {
                progress.transform.width = 160;
                progress.transform.height = 20;
                var bgimg = progress.transform.addComponent("image2D");
                bgimg.sprite = app.getAssetMgr().getDefaultSprite("white_sprite");
                bgimg.color = new m4m.math.color(0.6, 0.6, 0.6, 1);
                progress.barBg = bgimg;
                var layout = m4m.framework.layoutOption;
                var Opt = layout.TOP | layout.BOTTOM | layout.LEFT;
                var cut = this.make2DNode("FillCut", progress.transform, Opt);
                // cut.isMask = true;
                progress.cutPanel = cut;
                var fill = this.make2DNode("Fill", cut, Opt);
                var fillimg = fill.addComponent("image2D");
                fillimg.sprite = app.getAssetMgr().getDefaultSprite("white_sprite");
                progress.barOverImg = fillimg;
                // progress.transform.markDirty();
            };
            TransformUtil.create2D_scrollRect = function (scrollrect, app) {
                scrollrect.transform.width = 200;
                scrollrect.transform.height = 200;
                var img = scrollrect.transform.addComponent("image2D");
                img.sprite = app.getAssetMgr().getDefaultSprite("white_sprite");
                img.color = new m4m.math.color(0.3, 0.3, 0.3, 1);
                var cont = this.make2DNode("Content", scrollrect.transform);
                cont.width = scrollrect.transform.width + 100;
                cont.height = scrollrect.transform.height + 100;
                scrollrect.content = cont;
                scrollrect.horizontal = true;
                scrollrect.vertical = true;
                scrollrect.transform.isMask = true;
                scrollrect.transform.markDirty();
            };
            TransformUtil.create2D_label = function (label, app) {
                label.transform.width = 150;
                label.transform.height = 50;
                label.text = "label";
                label.fontsize = 24;
                label.color = new m4m.math.color(1, 0, 0, 1);
                // let _font = app.getAssetMgr().getAssetByName("STXINGKA.font.json");
                // if (_font == null)
                // {
                //     app.getAssetMgr().load("res/STXINGKA.TTF.png", m4m.framework.AssetTypeEnum.Auto, (s) =>
                //     {
                //         if (s.isfinish)
                //         {
                //             app.getAssetMgr().load("res/resources/STXINGKA.font.json", m4m.framework.AssetTypeEnum.Auto, (s1) =>
                //             {
                //                 label.font = app.getAssetMgr().getAssetByName("STXINGKA.font.json") as m4m.framework.font;
                //                 label.transform.markDirty();
                //             });
                //         }
                //     });
                // }
                // else
                // {
                //     label.font = _font as m4m.framework.font;;
                //     label.transform.markDirty();
                // }
            };
            TransformUtil.create2D_button = function (btn, app) {
                btn.transform.width = 150;
                btn.transform.height = 50;
                var img = btn.transform.addComponent("image2D");
                img.sprite = app.getAssetMgr().getDefaultSprite("white_sprite");
                img.imageType = m4m.framework.ImageType.Sliced;
                btn.targetImage = img;
                btn.transition = m4m.framework.TransitionType.ColorTint; //颜色变换
                // var lab = new m4m.framework.transform2D();
                var lab = this.make2DNode("label", btn.transform, 0, 150, 50);
                lab.localTranslate.y = -10;
                var label = lab.addComponent("label");
                label.text = "button";
                label.fontsize = 25;
                label.color = new m4m.math.color(1, 0, 0, 1);
                // let _font = app.getAssetMgr().getAssetByName("STXINGKA.font.json");
                // if (_font == null)
                // {
                //     app.getAssetMgr().load("res/STXINGKA.TTF.png", m4m.framework.AssetTypeEnum.Auto, (s) =>
                //     {
                //         if (s.isfinish)
                //         {
                //             app.getAssetMgr().load("res/resources/STXINGKA.font.json", m4m.framework.AssetTypeEnum.Auto, (s1) =>
                //             {
                //                 label.font = app.getAssetMgr().getAssetByName("STXINGKA.font.json") as m4m.framework.font;
                //                 btn.transform.markDirty();
                //             });
                //         }
                //     });
                // }
                // else
                // {
                //     label.font = _font as m4m.framework.font;;
                //     btn.transform.markDirty();
                // }
            };
            TransformUtil.create2D_InputField = function (ipt, app) {
                var assetMgr = app.getAssetMgr();
                var opt = framework.layoutOption;
                var tOpt = opt.TOP | opt.RIGHT | opt.BOTTOM | opt.LEFT;
                //设置节点
                var node = ipt.transform;
                node.width = 160;
                node.height = 30;
                node.isMask = true;
                //添加 背景图
                var bg_t = this.make2DNode("frameImage", node, tOpt);
                var bg_img = bg_t.addComponent("image2D");
                bg_img.sprite = assetMgr.getDefaultSprite("white_sprite");
                var fSize = 24;
                //添加 Text lable
                var text_t = this.make2DNode("Text", node, tOpt);
                var text_l = text_t.addComponent("label");
                text_l.verticalType = m4m.framework.VerticalType.Top;
                text_l.horizontalType = m4m.framework.HorizontalType.Left;
                text_l.fontsize = fSize;
                m4m.math.colorSet(text_l.color, 0, 0, 0, 1);
                m4m.math.colorSet(text_l.color2, 0, 0, 0, 0.5);
                //添加 占位文本 label
                var placeholder_t = this.make2DNode("Placeholder", node, tOpt);
                var placeholder_l = placeholder_t.addComponent("label");
                placeholder_l.verticalType = m4m.framework.VerticalType.Top;
                placeholder_l.horizontalType = m4m.framework.HorizontalType.Left;
                placeholder_l.fontsize = fSize;
                m4m.math.colorSet(placeholder_l.color, 0.6, 0.6, 0.6, 1);
                m4m.math.colorSet(placeholder_l.color2, 0.6, 0.6, 0.6, 0.5);
                //组合
                ipt.TextLabel = text_l;
                ipt.PlaceholderLabel = placeholder_l;
                ipt.frameImage = bg_img;
                node.markDirty();
            };
            return TransformUtil;
        }());
        framework.TransformUtil = TransformUtil;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        framework.lazy = {
            getvalue: function (lazyItem) {
                if (typeof lazyItem == "function")
                    return lazyItem();
                return lazyItem;
            }
        };
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var WebGLDebugUtils = /** @class */ (function () {
            function WebGLDebugUtils() {
                /**
                 * Map of numbers to names.
                 * @type {Object}
                 */
                this.glEnums = null;
            }
            /**
         * Wrapped logging function.
         * @param {string} msg Message to log.
         */
            WebGLDebugUtils.prototype.log = function (msg) {
                if (window.console && window.console.log) {
                    window.console.log(msg);
                }
            };
            /**
             * Initializes this module. Safe to call more than once.
             * @param {!WebGL2RenderingContext} ctx A WebGL context. If
             *    you have more than one context it doesn't matter which one
             *    you pass in, it is only used to pull out constants.
             */
            WebGLDebugUtils.prototype.init = function (ctx) {
                if (this.glEnums == null) {
                    this.glEnums = {};
                    for (var propertyName in ctx) {
                        if (typeof ctx[propertyName] == 'number') {
                            this.glEnums[ctx[propertyName]] = propertyName;
                        }
                    }
                }
            };
            /**
             * Checks the utils have been initialized.
             */
            WebGLDebugUtils.prototype.checkInit = function () {
                if (this.glEnums == null) {
                    throw 'WebGLDebugUtils.init(ctx) not called';
                }
            };
            /**
             * Returns true or false if value matches any WebGL enum
             * @param {*} value Value to check if it might be an enum.
             * @return {boolean} True if value matches one of the WebGL defined enums
             */
            WebGLDebugUtils.prototype.mightBeEnum = function (value) {
                this.checkInit();
                return (this.glEnums[value] !== undefined);
            };
            /**
             * Gets an string version of an WebGL enum.
             *
             * Example:
             *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());
             *
             * @param {number} value Value to return an enum for
             * @return {string} The string version of the enum.
             */
            WebGLDebugUtils.prototype.glEnumToString = function (value) {
                this.checkInit();
                var name = this.glEnums[value];
                return (name !== undefined) ? name :
                    ("*UNKNOWN WebGL ENUM (0x" + value.toString(16) + ")");
            };
            /**
             * Returns the string version of a WebGL argument.
             * Attempts to convert enum arguments to strings.
             * @param {string} functionName the name of the WebGL function.
             * @param {number} argumentIndx the index of the argument.
             * @param {*} value The value of the argument.
             * @return {string} The value as a string.
             */
            WebGLDebugUtils.prototype.glFunctionArgToString = function (functionName, argumentIndex, value) {
                var funcInfo = WebGLDebugUtils.glValidEnumContexts[functionName];
                if (funcInfo !== undefined) {
                    if (funcInfo[argumentIndex]) {
                        return this.glEnumToString(value);
                    }
                }
                return value.toString();
            };
            /**
             * Given a WebGL context returns a wrapped context that calls
             * gl.getError after every command and calls a function if the
             * result is not gl.NO_ERROR.
             *
             * @param {!WebGL2RenderingContext} ctx The webgl context to
             *        wrap.
             * @param {!function(err, funcName, args): void} opt_onErrorFunc
             *        The function to call when gl.getError returns an
             *        error. If not specified the default function calls
             *        console.log with a message.
             */
            WebGLDebugUtils.prototype.makeDebugContext = function (ctx, opt_onErrorFunc) {
                var _this = this;
                if (opt_onErrorFunc === void 0) { opt_onErrorFunc = null; }
                this.init(ctx);
                opt_onErrorFunc = opt_onErrorFunc ||
                    (function (err, functionName, args) {
                        // apparently we can't do args.join(",");
                        var argStr = "";
                        for (var ii = 0; ii < args.length; ++ii) {
                            argStr += ((ii == 0) ? '' : ', ') +
                                _this.glFunctionArgToString(functionName, ii, args[ii]);
                        }
                        // self.log("WebGL error "+ self.glEnumToString(err) + " in "+ functionName +
                        //     "(" + argStr + ")");
                        console.error("WebGL error " + _this.glEnumToString(err) + " in " + functionName +
                            "(" + argStr + ")");
                    });
                // function(err, functionName, args) {
                //       // apparently we can't do args.join(",");
                //       var argStr = "";
                //       for (var ii = 0; ii < args.length; ++ii) {
                //         argStr += ((ii == 0) ? '' : ', ') +
                //         self.glFunctionArgToString(functionName, ii, args[ii]);
                //       }
                //       // self.log("WebGL error "+ self.glEnumToString(err) + " in "+ functionName +
                //       //     "(" + argStr + ")");
                //       console.error("WebGL error "+ self.glEnumToString(err) + " in "+ functionName +
                //           "(" + argStr + ")");
                //     };
                // Holds booleans for each GL error so after we get the error ourselves
                // we can still return it to the client app.
                var glErrorShadow = {};
                // Makes a function that calls a WebGL function and then calls getError.
                function makeErrorWrapper(ctx, functionName) {
                    return function () {
                        var result = ctx[functionName].apply(ctx, arguments);
                        var err = ctx.getError();
                        if (err != 0) {
                            glErrorShadow[err] = true;
                            opt_onErrorFunc(err, functionName, arguments);
                        }
                        return result;
                    };
                }
                // Make a an object that has a copy of every property of the WebGL context
                // but wraps all functions.
                var wrapper = {};
                for (var propertyName in ctx) {
                    if (typeof ctx[propertyName] == 'function') {
                        wrapper[propertyName] = makeErrorWrapper(ctx, propertyName);
                    }
                    else {
                        wrapper[propertyName] = ctx[propertyName];
                    }
                }
                // Override the getError function with one that returns our saved results.
                wrapper["getError"] = function () {
                    for (var err in glErrorShadow) {
                        if (glErrorShadow[err]) {
                            glErrorShadow[err] = false;
                            return err;
                        }
                    }
                    return ctx.NO_ERROR;
                };
                console.error(" i am ---makeDebugContext-");
                return wrapper;
            };
            WebGLDebugUtils.prototype.resetToInitialState = function (ctx) {
                var numAttribs = ctx.getParameter(ctx.MAX_VERTEX_ATTRIBS);
                var tmp = ctx.createBuffer();
                ctx.bindBuffer(ctx.ARRAY_BUFFER, tmp);
                for (var ii = 0; ii < numAttribs; ++ii) {
                    ctx.disableVertexAttribArray(ii);
                    ctx.vertexAttribPointer(ii, 4, ctx.FLOAT, false, 0, 0);
                    ctx.vertexAttrib1f(ii, 0);
                }
                ctx.deleteBuffer(tmp);
                var numTextureUnits = ctx.getParameter(ctx.MAX_TEXTURE_IMAGE_UNITS);
                for (var ii = 0; ii < numTextureUnits; ++ii) {
                    ctx.activeTexture(ctx.TEXTURE0 + ii);
                    ctx.bindTexture(ctx.TEXTURE_CUBE_MAP, null);
                    ctx.bindTexture(ctx.TEXTURE_2D, null);
                }
                ctx.activeTexture(ctx.TEXTURE0);
                ctx.useProgram(null);
                ctx.bindBuffer(ctx.ARRAY_BUFFER, null);
                ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, null);
                ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
                ctx.bindRenderbuffer(ctx.RENDERBUFFER, null);
                ctx.disable(ctx.BLEND);
                ctx.disable(ctx.CULL_FACE);
                ctx.disable(ctx.DEPTH_TEST);
                ctx.disable(ctx.DITHER);
                ctx.disable(ctx.SCISSOR_TEST);
                ctx.blendColor(0, 0, 0, 0);
                ctx.blendEquation(ctx.FUNC_ADD);
                ctx.blendFunc(ctx.ONE, ctx.ZERO);
                ctx.clearColor(0, 0, 0, 0);
                ctx.clearDepth(1);
                ctx.clearStencil(-1);
                ctx.colorMask(true, true, true, true);
                ctx.cullFace(ctx.BACK);
                ctx.depthFunc(ctx.LESS);
                ctx.depthMask(true);
                ctx.depthRange(0, 1);
                ctx.frontFace(ctx.CCW);
                ctx.hint(ctx.GENERATE_MIPMAP_HINT, ctx.DONT_CARE);
                ctx.lineWidth(1);
                ctx.pixelStorei(ctx.PACK_ALIGNMENT, 4);
                ctx.pixelStorei(ctx.UNPACK_ALIGNMENT, 4);
                ctx.pixelStorei(ctx.UNPACK_FLIP_Y_WEBGL, false);
                ctx.pixelStorei(ctx.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
                // TODO: Delete this IF.
                if (ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL) {
                    ctx.pixelStorei(ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL, ctx.BROWSER_DEFAULT_WEBGL);
                }
                ctx.polygonOffset(0, 0);
                ctx.sampleCoverage(1, false);
                ctx.scissor(0, 0, ctx.canvas.width, ctx.canvas.height);
                ctx.stencilFunc(ctx.ALWAYS, 0, 0xFFFFFFFF);
                ctx.stencilMask(0xFFFFFFFF);
                ctx.stencilOp(ctx.KEEP, ctx.KEEP, ctx.KEEP);
                ctx.viewport(0, 0, ctx.canvas.clientWidth, ctx.canvas.clientHeight);
                ctx.clear(ctx.COLOR_BUFFER_BIT | ctx.DEPTH_BUFFER_BIT | ctx.STENCIL_BUFFER_BIT);
                // TODO: This should NOT be needed but Firefox fails with 'hint'
                while (ctx.getError())
                    ;
            };
            WebGLDebugUtils.prototype.makeLostContextSimulatingContext = function (ctx) {
                var wrapper_ = {};
                var contextId_ = 1;
                var contextLost_ = false;
                var resourceId_ = 0;
                var resourceDb_ = [];
                var onLost_ = undefined;
                var onRestored_ = undefined;
                var nextOnRestored_ = undefined;
                // Holds booleans for each GL error so can simulate errors.
                var glErrorShadow_ = {};
                function isWebGLObject(obj) {
                    //return false;
                    return (obj instanceof WebGLBuffer ||
                        obj instanceof WebGLFramebuffer ||
                        obj instanceof WebGLProgram ||
                        obj instanceof WebGLRenderbuffer ||
                        obj instanceof WebGLShader ||
                        obj instanceof WebGLTexture);
                }
                function checkResources(args) {
                    for (var ii = 0; ii < args.length; ++ii) {
                        var arg = args[ii];
                        if (isWebGLObject(arg)) {
                            return arg.__webglDebugContextLostId__ == contextId_;
                        }
                    }
                    return true;
                }
                function clearErrors() {
                    var k = Object.keys(glErrorShadow_);
                    for (var ii = 0; ii < k.length; ++ii) {
                        delete glErrorShadow_[k[ii]];
                    }
                }
                // Makes a function that simulates WebGL when out of context.
                function makeLostContextWrapper(ctx, functionName) {
                    var f = ctx[functionName];
                    return function () {
                        // Only call the functions if the context is not lost.
                        if (!contextLost_) {
                            if (!checkResources(arguments)) {
                                glErrorShadow_[ctx.INVALID_OPERATION] = true;
                                return;
                            }
                            var result = f.apply(ctx, arguments);
                            return result;
                        }
                    };
                }
                for (var propertyName in ctx) {
                    if (typeof ctx[propertyName] == 'function') {
                        wrapper_[propertyName] = makeLostContextWrapper(ctx, propertyName);
                    }
                    else {
                        wrapper_[propertyName] = ctx[propertyName];
                    }
                }
                function makeWebGLContextEvent(statusMessage) {
                    return { statusMessage: statusMessage };
                }
                function freeResources() {
                    for (var ii = 0; ii < resourceDb_.length; ++ii) {
                        var resource = resourceDb_[ii];
                        if (resource instanceof WebGLBuffer) {
                            ctx.deleteBuffer(resource);
                        }
                        //  else if (resource instanceof WebctxFramebuffer) {
                        //   ctx.deleteFramebuffer(resource);
                        // } else if (resource instanceof WebctxProgram) {
                        //   ctx.deleteProgram(resource);
                        // } else if (resource instanceof WebctxRenderbuffer) {
                        //   ctx.deleteRenderbuffer(resource);
                        // } else if (resource instanceof WebctxShader) {
                        //   ctx.deleteShader(resource);
                        // } else if (resource instanceof WebctxTexture) {
                        //   ctx.deleteTexture(resource);
                        // }
                    }
                }
                wrapper_["loseContext"] = function () {
                    if (!contextLost_) {
                        contextLost_ = true;
                        ++contextId_;
                        while (ctx.getError())
                            ;
                        clearErrors();
                        glErrorShadow_[ctx.CONTEXT_LOST_WEBGL] = true;
                        setTimeout(function () {
                            if (onLost_) {
                                onLost_(makeWebGLContextEvent("context lost"));
                            }
                        }, 0);
                    }
                };
                wrapper_["restoreContext"] = function () {
                    if (contextLost_) {
                        if (onRestored_) {
                            setTimeout(function () {
                                freeResources();
                                this.resetToInitialState(ctx);
                                contextLost_ = false;
                                if (onRestored_) {
                                    var callback = onRestored_;
                                    onRestored_ = nextOnRestored_;
                                    nextOnRestored_ = undefined;
                                    callback(makeWebGLContextEvent("context restored"));
                                }
                            }, 0);
                        }
                        else {
                            throw "You can not restore the context without a listener";
                        }
                    }
                };
                // Wrap a few functions specially.
                wrapper_["getError"] = function () {
                    if (!contextLost_) {
                        var err;
                        while (err = ctx.getError()) {
                            glErrorShadow_[err] = true;
                        }
                    }
                    for (var key in glErrorShadow_) {
                        if (glErrorShadow_[key]) {
                            delete glErrorShadow_[key];
                            return key;
                        }
                    }
                    return ctx.NO_ERROR;
                };
                var creationFunctions = [
                    "createBuffer",
                    "createFramebuffer",
                    "createProgram",
                    "createRenderbuffer",
                    "createShader",
                    "createTexture"
                ];
                for (var ii = 0; ii < creationFunctions.length; ++ii) {
                    var functionName = creationFunctions[ii];
                    wrapper_[functionName] = function (f) {
                        return function () {
                            if (contextLost_) {
                                return null;
                            }
                            var obj = f.apply(ctx, arguments);
                            obj.__webglDebugContextLostId__ = contextId_;
                            resourceDb_.push(obj);
                            return obj;
                        };
                    }(ctx[functionName]);
                }
                var functionsThatShouldReturnNull = [
                    "getActiveAttrib",
                    "getActiveUniform",
                    "getBufferParameter",
                    "getContextAttributes",
                    "getAttachedShaders",
                    "getFramebufferAttachmentParameter",
                    "getParameter",
                    "getProgramParameter",
                    "getProgramInfoLog",
                    "getRenderbufferParameter",
                    "getShaderParameter",
                    "getShaderInfoLog",
                    "getShaderSource",
                    "getTexParameter",
                    "getUniform",
                    "getUniformLocation",
                    "getVertexAttrib"
                ];
                for (var ii = 0; ii < functionsThatShouldReturnNull.length; ++ii) {
                    var functionName = functionsThatShouldReturnNull[ii];
                    wrapper_[functionName] = function (f) {
                        return function () {
                            if (contextLost_) {
                                return null;
                            }
                            return f.apply(ctx, arguments);
                        };
                    }(wrapper_[functionName]);
                }
                var isFunctions = [
                    "isBuffer",
                    "isEnabled",
                    "isFramebuffer",
                    "isProgram",
                    "isRenderbuffer",
                    "isShader",
                    "isTexture"
                ];
                for (var ii = 0; ii < isFunctions.length; ++ii) {
                    var functionName = isFunctions[ii];
                    wrapper_[functionName] = function (f) {
                        return function () {
                            if (contextLost_) {
                                return false;
                            }
                            return f.apply(ctx, arguments);
                        };
                    }(wrapper_[functionName]);
                }
                wrapper_["checkFramebufferStatus"] = function (f) {
                    return function () {
                        if (contextLost_) {
                            return ctx.FRAMEBUFFER_UNSUPPORTED;
                        }
                        return f.apply(ctx, arguments);
                    };
                }(wrapper_["checkFramebufferStatus"]);
                wrapper_["getAttribLocation"] = function (f) {
                    return function () {
                        if (contextLost_) {
                            return -1;
                        }
                        return f.apply(ctx, arguments);
                    };
                }(wrapper_["getAttribLocation"]);
                wrapper_["getVertexAttribOffset"] = function (f) {
                    return function () {
                        if (contextLost_) {
                            return 0;
                        }
                        return f.apply(ctx, arguments);
                    };
                }(wrapper_["getVertexAttribOffset"]);
                wrapper_["isContextLost"] = function () {
                    return contextLost_;
                };
                function wrapEvent(listener) {
                    if (typeof (listener) == "function") {
                        return listener;
                    }
                    else {
                        return function (info) {
                            listener.handleEvent(info);
                        };
                    }
                }
                wrapper_["registerOnContextLostListener"] = function (listener) {
                    onLost_ = wrapEvent(listener);
                };
                wrapper_["registerOnContextRestoredListener"] = function (listener) {
                    if (contextLost_) {
                        nextOnRestored_ = wrapEvent(listener);
                    }
                    else {
                        onRestored_ = wrapEvent(listener);
                    }
                };
                return wrapper_;
            };
            /**
             * Which arguements are enums.
             * @type {!Object.<number, string>}
             */
            WebGLDebugUtils.glValidEnumContexts = {
                // Generic setters and getters
                'enable': { 0: true },
                'disable': { 0: true },
                'getParameter': { 0: true },
                // Rendering
                'drawArrays': { 0: true },
                'drawElements': { 0: true, 2: true },
                // Shaders
                'createShader': { 0: true },
                'getShaderParameter': { 1: true },
                'getProgramParameter': { 1: true },
                // Vertex attributes
                'getVertexAttrib': { 1: true },
                'vertexAttribPointer': { 2: true },
                // Textures
                'bindTexture': { 0: true },
                'activeTexture': { 0: true },
                'getTexParameter': { 0: true, 1: true },
                'texParameterf': { 0: true, 1: true },
                'texParameteri': { 0: true, 1: true, 2: true },
                'texImage2D': { 0: true, 2: true, 6: true, 7: true },
                'texSubImage2D': { 0: true, 6: true, 7: true },
                'copyTexImage2D': { 0: true, 2: true },
                'copyTexSubImage2D': { 0: true },
                'generateMipmap': { 0: true },
                // Buffer objects
                'bindBuffer': { 0: true },
                'bufferData': { 0: true, 2: true },
                'bufferSubData': { 0: true },
                'getBufferParameter': { 0: true, 1: true },
                // Renderbuffers and framebuffers
                'pixelStorei': { 0: true, 1: true },
                'readPixels': { 4: true, 5: true },
                'bindRenderbuffer': { 0: true },
                'bindFramebuffer': { 0: true },
                'checkFramebufferStatus': { 0: true },
                'framebufferRenderbuffer': { 0: true, 1: true, 2: true },
                'framebufferTexture2D': { 0: true, 1: true, 2: true },
                'getFramebufferAttachmentParameter': { 0: true, 1: true, 2: true },
                'getRenderbufferParameter': { 0: true, 1: true },
                'renderbufferStorage': { 0: true, 1: true },
                // Frame buffer operations (clear, blend, depth test, stencil)
                'clear': { 0: true },
                'depthFunc': { 0: true },
                'blendFunc': { 0: true, 1: true },
                'blendFuncSeparate': { 0: true, 1: true, 2: true, 3: true },
                'blendEquation': { 0: true },
                'blendEquationSeparate': { 0: true, 1: true },
                'stencilFunc': { 0: true },
                'stencilFuncSeparate': { 0: true, 1: true },
                'stencilMaskSeparate': { 0: true },
                'stencilOp': { 0: true, 1: true, 2: true },
                'stencilOpSeparate': { 0: true, 1: true, 2: true, 3: true },
                // Culling
                'cullFace': { 0: true },
                'frontFace': { 0: true },
            };
            return WebGLDebugUtils;
        }());
        framework.WebGLDebugUtils = WebGLDebugUtils;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        var WebGLUtils = /** @class */ (function () {
            function WebGLUtils() {
                /**
               * Mesasge for getting a webgl browser
               * @type {string}
               */
                this.GET_A_WEBGL_BROWSER = '' +
                    'This page requires a browser that supports WebGL.<br/>' +
                    '<a href="http://get.webgl.org">Click here to upgrade your browser.</a>';
                /**
                * Mesasge for need better hardware
                * @type {string}
                */
                this.OTHER_PROBLEM = '' +
                    "It doesn't appear your computer can support WebGL.<br/>" +
                    '<a href="http://get.webgl.org">Click here for more information.</a>';
                //为了兼容性的冗余处理
                /**
                 * Provides requestAnimationFrame in a cross browser
                 * way.
                 */
                if (!window.requestAnimationFrame) {
                    var tempwin = window;
                    window.requestAnimationFrame =
                        tempwin.requestAnimationFrame ||
                            tempwin.webkitRequestAnimationFrame ||
                            tempwin.mozRequestAnimationFrame ||
                            tempwin.oRequestAnimationFrame ||
                            tempwin.msRequestAnimationFrame ||
                            function (/* function FrameRequestCallback */ callback, /* DOMElement Element */ element) {
                                window.setTimeout(callback, 1000 / 60);
                            };
                }
                /** * ERRATA: 'cancelRequestAnimationFrame' renamed to 'cancelAnimationFrame' to reflect an update to the W3C Animation-Timing Spec.
                 *
                 * Cancels an animation frame request.
                 * Checks for cross-browser support, falls back to clearTimeout.
                 * @param {number}  Animation frame request. */
                if (!window.cancelAnimationFrame) {
                    var tempwin = window;
                    window.cancelAnimationFrame = (tempwin.cancelRequestAnimationFrame ||
                        tempwin.webkitCancelAnimationFrame || tempwin.webkitCancelRequestAnimationFrame ||
                        tempwin.mozCancelAnimationFrame || tempwin.mozCancelRequestAnimationFrame ||
                        tempwin.msCancelAnimationFrame || tempwin.msCancelRequestAnimationFrame ||
                        tempwin.oCancelAnimationFrame || tempwin.oCancelRequestAnimationFrame ||
                        window.clearTimeout);
                }
            }
            /**
         * Creates the HTLM for a failure message
         * @param {string} canvasContainerId id of container of th
         *        canvas.
         * @return {string} The html.
         */
            WebGLUtils.prototype.makeFailHTML = function (msg) {
                return '' +
                    '<div style="margin: auto; width:500px;z-index:10000;margin-top:20em;text-align:center;">' + msg + '</div>';
                // return '' +
                //   '<table style="background-color: #8CE; width: 100%; height: 100%;"><tr>' +
                //   '<td align="center">' +
                //   '<div style="display: table-cell; vertical-align: middle;">' +
                //   '<div style="">' + msg + '</div>' +
                //   '</div>' +
                //   '</td></tr></table>';
            };
            ;
            /**
             * Creates a webgl context. If creation fails it will
             * change the contents of the container of the <canvas>
             * tag to an error message with the correct links for WebGL.
             * @param {Element} canvas. The canvas element to create a
             *     context from.
             * @param {WebGLContextCreationAttirbutes} opt_attribs Any
             *     creation attributes you want to pass in.
             * @param {function:(msg)} opt_onError An function to call
             *     if there is an error during creation.
             * @return {WebGL2RenderingContext} The created context.
             */
            WebGLUtils.prototype.setupWebGL = function (canvas, opt_attribs, opt_onError) {
                var _this = this;
                if (opt_attribs === void 0) { opt_attribs = null; }
                if (opt_onError === void 0) { opt_onError = null; }
                var handleCreationError = function (msg) {
                    var container = document.getElementsByTagName("body")[0];
                    //var container = canvas.parentNode;
                    if (container) {
                        var str = WebGL2RenderingContext ?
                            _this.OTHER_PROBLEM :
                            _this.GET_A_WEBGL_BROWSER;
                        if (msg) {
                            str += "<br/><br/>Status: " + msg;
                        }
                        container.innerHTML = _this.makeFailHTML(str);
                    }
                };
                opt_onError = opt_onError || handleCreationError;
                if (canvas.addEventListener) {
                    canvas.addEventListener("webglcontextcreationerror", function (event) {
                        opt_onError(event.statusMessage);
                    }, false);
                }
                var context = this.create3DContext(canvas, opt_attribs);
                if (!context) {
                    if (!WebGL2RenderingContext) {
                        opt_onError("");
                    }
                    else {
                        opt_onError("");
                    }
                }
                return context;
            };
            /**
             * Creates a webgl context.
             * @param {!Canvas} canvas The canvas tag to get context
             *     from. If one is not passed in one will be created.
             * @return {!WebGLContext} The created context.
             */
            WebGLUtils.prototype.create3DContext = function (canvas, opt_attribs) {
                // var names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];  //webgl
                var names = ["webgl2", "experimental-webgl2", "moz-webgl2"]; //webgl2
                var context = null;
                for (var ii = 0; ii < names.length; ++ii) {
                    try {
                        context = canvas.getContext(names[ii], opt_attribs);
                    }
                    catch (e) { }
                    if (context) {
                        break;
                    }
                }
                return context;
            };
            return WebGLUtils;
        }());
        framework.WebGLUtils = WebGLUtils;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * 动画曲线
         *
         * 基于时间轴的连续三阶Bézier曲线
         *
         * @author feng3d
         */
        var AnimationCurve1 = /** @class */ (function () {
            function AnimationCurve1() {
                /**
                 * 最大tan值，超出该值后将会变成分段
                 */
                this.maxtan = 1000;
                /**
                 * The behaviour of the animation before the first keyframe.
                 *
                 * 在第一个关键帧之前的动画行为。
                 */
                this.preWrapMode = framework.AnimationCurveWrapMode.Clamp;
                /**
                 * The behaviour of the animation after the last keyframe.
                 *
                 * 动画在最后一个关键帧之后的行为。
                 */
                this.postWrapMode = framework.AnimationCurveWrapMode.Clamp;
                /**
                 * All keys defined in the animation curve.
                 *
                 * 动画曲线上所有关键字定义。
                 *
                 * 注： 该值已对时间排序，否则赋值前请使用 sort((a, b) => a.time - b.time) 进行排序
                 */
                this.keys = [{ time: 0, value: 1, inTangent: 0, outTangent: 0 }];
            }
            Object.defineProperty(AnimationCurve1.prototype, "numKeys", {
                /**
                 * 关键点数量
                 */
                get: function () {
                    return this.keys.length;
                },
                enumerable: false,
                configurable: true
            });
            /**
             * 添加关键点
             *
             * 添加关键点后将会执行按t进行排序
             *
             * @param key 关键点
             */
            AnimationCurve1.prototype.addKey = function (key) {
                this.keys.push(key);
                this.sort();
            };
            /**
             * 关键点排序
             *
             * 当移动关键点或者新增关键点时需要再次排序
             */
            AnimationCurve1.prototype.sort = function () {
                this.keys.sort(function (a, b) { return a.time - b.time; });
            };
            /**
             * 删除关键点
             * @param key 关键点
             */
            AnimationCurve1.prototype.deleteKey = function (key) {
                var index = this.keys.indexOf(key);
                if (index != -1)
                    this.keys.splice(index, 1);
            };
            /**
             * 获取关键点
             * @param index 索引
             */
            AnimationCurve1.prototype.getKey = function (index) {
                return this.keys[index];
            };
            /**
             * 获取关键点索引
             * @param key 关键点
             */
            AnimationCurve1.prototype.indexOfKeys = function (key) {
                return this.keys.indexOf(key);
            };
            /**
             * 获取曲线上点信息
             * @param t 时间轴的位置 [0,1]
             */
            AnimationCurve1.prototype.getPoint = function (t) {
                var wrapMode = framework.AnimationCurveWrapMode.Clamp;
                if (t < 0)
                    wrapMode = this.preWrapMode;
                else if (t > 1)
                    wrapMode = this.postWrapMode;
                switch (wrapMode) {
                    case framework.AnimationCurveWrapMode.Clamp:
                        t = m4m.math.floatClamp(t, 0, 1);
                        break;
                    case framework.AnimationCurveWrapMode.Loop:
                        t = m4m.math.floatClamp(t - Math.floor(t), 0, 1);
                        break;
                    case framework.AnimationCurveWrapMode.PingPong:
                        t = m4m.math.floatClamp(t - Math.floor(t), 0, 1);
                        if (Math.floor(t) % 2 == 1)
                            t = 1 - t;
                        break;
                }
                var keys = this.keys;
                var maxtan = this.maxtan;
                var value = 0, tangent = 0, isfind = false;
                ;
                for (var i = 0, n = keys.length; i < n; i++) {
                    // 使用 bezierCurve 进行采样曲线点
                    var key = keys[i];
                    var prekey = keys[i - 1];
                    if (i > 0 && prekey.time <= t && t <= key.time) {
                        var xstart = prekey.time;
                        var ystart = prekey.value;
                        var tanstart = prekey.outTangent;
                        var xend = key.time;
                        var yend = key.value;
                        var tanend = key.inTangent;
                        if (maxtan > Math.abs(tanstart) && maxtan > Math.abs(tanend)) {
                            var ct = (t - prekey.time) / (key.time - prekey.time);
                            var sys = [ystart, ystart + tanstart * (xend - xstart) / 3, yend - tanend * (xend - xstart) / 3, yend];
                            var fy = framework.BezierCurve.getValue(ct, sys);
                            isfind = true;
                            value = fy;
                            tangent = framework.BezierCurve.getDerivative(ct, sys) / (xend - xstart);
                            break;
                        }
                        else {
                            isfind = true;
                            value = prekey.value;
                            tangent = 0;
                            break;
                        }
                    }
                    if (i == 0 && t <= key.time) {
                        isfind = true;
                        value = key.value;
                        tangent = 0;
                        break;
                    }
                    if (i == n - 1 && t >= key.time) {
                        isfind = true;
                        value = key.value;
                        tangent = 0;
                        break;
                    }
                }
                if (keys.length == 0)
                    return { time: t, value: 0, inTangent: 0, outTangent: 0 };
                return { time: t, value: value, inTangent: tangent, outTangent: tangent };
            };
            /**
             * 获取值
             * @param t 时间轴的位置 [0,1]
             */
            AnimationCurve1.prototype.getValue = function (t) {
                var point = this.getPoint(t);
                if (!point)
                    return 0;
                return point.value;
            };
            /**
             * 查找关键点
             * @param t 时间轴的位置 [0,1]
             * @param y 值
             * @param precision 查找精度
             */
            AnimationCurve1.prototype.findKey = function (t, y, precision) {
                var keys = this.keys;
                for (var i = 0; i < keys.length; i++) {
                    if (Math.abs(keys[i].time - t) < precision && Math.abs(keys[i].value - y) < precision) {
                        return keys[i];
                    }
                }
                return null;
            };
            /**
             * 添加曲线上的关键点
             *
             * 如果该点在曲线上，则添加关键点
             *
             * @param time 时间轴的位置 [0,1]
             * @param value 值
             * @param precision 查找进度
             */
            AnimationCurve1.prototype.addKeyAtCurve = function (time, value, precision) {
                var point = this.getPoint(time);
                if (Math.abs(value - point.value) < precision) {
                    this.keys.push(point);
                    this.keys.sort(function (a, b) { return a.time - b.time; });
                    return point;
                }
                return null;
            };
            /**
             * 获取曲线样本数据
             *
             * 这些点可用于连线来拟合曲线。
             *
             * @param num 采样次数 ，采样点分别为[0,1/num,2/num,....,(num-1)/num,1]
             */
            AnimationCurve1.prototype.getSamples = function (num) {
                if (num === void 0) { num = 100; }
                var results = [];
                for (var i = 0; i <= num; i++) {
                    var p = this.getPoint(i / num);
                    results.push(p);
                }
                return results;
            };
            return AnimationCurve1;
        }());
        framework.AnimationCurve1 = AnimationCurve1;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * 动画曲线Wrap模式，处理超出范围情况
         *
         * @author feng3d
         */
        var AnimationCurveWrapMode;
        (function (AnimationCurveWrapMode) {
            /**
             * 夹紧; 0>-<1
             */
            AnimationCurveWrapMode[AnimationCurveWrapMode["Clamp"] = 1] = "Clamp";
            /**
             * 循环; 0->1,0->1
             */
            AnimationCurveWrapMode[AnimationCurveWrapMode["Loop"] = 2] = "Loop";
            /**
             * 来回循环; 0->1,1->0
             */
            AnimationCurveWrapMode[AnimationCurveWrapMode["PingPong"] = 4] = "PingPong";
        })(AnimationCurveWrapMode = framework.AnimationCurveWrapMode || (framework.AnimationCurveWrapMode = {}));
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * Bézier曲线
         * @see https://en.wikipedia.org/wiki/B%C3%A9zier_curve
         *
         * @author feng3d
         */
        var BezierCurve = /** @class */ (function () {
            function BezierCurve() {
            }
            /**
             * 线性Bézier曲线
             * 给定不同的点P0和P1，线性Bézier曲线就是这两个点之间的直线。曲线由下式给出
             * ```
             * B(t) = p0 + t * (p1 - p0) = (1 - t) * p0 + t * p1 , 0 <= t && t <= 1
             * ```
             * 相当于线性插值
             *
             * @param t 插值度
             * @param p0 点0
             * @param p1 点1
             */
            BezierCurve.linear = function (t, p0, p1) {
                return p0 + t * (p1 - p0);
                // return (1 - t) * p0 + t * p1;
            };
            /**
             * 线性Bézier曲线关于t的导数
             * @param t 插值度
             * @param p0 点0
             * @param p1 点1
             */
            BezierCurve.linearDerivative = function (t, p0, p1) {
                return p1 - p0;
            };
            /**
             * 线性Bézier曲线关于t的二阶导数
             * @param t 插值度
             * @param p0 点0
             * @param p1 点1
             */
            BezierCurve.linearSecondDerivative = function (t, p0, p1) {
                return 0;
            };
            /**
             * 二次Bézier曲线
             *
             * 二次Bézier曲线是由函数B（t）跟踪的路径，给定点P0，P1和P2，
             * ```
             * B(t) = (1 - t) * ((1 - t) * p0 + t * p1) + t * ((1 - t) * p1 + t * p2) , 0 <= t && t <= 1
             * ```
             * 这可以解释为分别从P0到P1和从P1到P2的线性Bézier曲线上相应点的线性插值。重新排列前面的等式得出：
             * ```
             * B(t) = (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2 , 0 <= t && t <= 1
             * ```
             * Bézier曲线关于t的导数是
             * ```
             * B'(t) = 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1)
             * ```
             * 从中可以得出结论：在P0和P2处曲线的切线在P 1处相交。随着t从0增加到1，曲线沿P1的方向从P0偏离，然后从P1的方向弯曲到P2。
             *
             * Bézier曲线关于t的二阶导数是
             * ```
             * B''(t) = 2 * (p2 - 2 * p1 + p0)
             * ```
             *
             * @param t 插值度
             * @param p0 点0
             * @param p1 点1
             * @param p2 点2
             */
            BezierCurve.quadratic = function (t, p0, p1, p2) {
                // return this.linear(t, this.linear(t, p0, p1), this.linear(t, p1, p2));
                // return (1 - t) * ((1 - t) * p0 + t * p1) + t * ((1 - t) * p1 + t * p2);
                return (1 - t) * (1 - t) * p0 + 2 * (1 - t) * t * p1 + t * t * p2;
            };
            /**
             * 二次Bézier曲线关于t的导数
             * @param t 插值度
             * @param p0 点0
             * @param p1 点1
             * @param p2 点2
             */
            BezierCurve.quadraticDerivative = function (t, p0, p1, p2) {
                // return 2 * this.linear(t, this.linearDerivative(t, p0, p1), this.linearDerivative(t, p1, p2));
                return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);
            };
            /**
             * 二次Bézier曲线关于t的二阶导数
             * @param t 插值度
             * @param p0 点0
             * @param p1 点1
             * @param p2 点2
             */
            BezierCurve.quadraticSecondDerivative = function (t, p0, p1, p2) {
                // return 1 * 2 * this.linearDerivative(t, p1 - p0, p2 - p1)
                // return 1 * 2 * ((p2 - p1) - (p1 - p0));
                return 2 * (p2 - 2 * p1 + p0);
            };
            /**
             * 立方Bézier曲线
             *
             * 平面中或高维空间中（其实一维也是成立的，这里就是使用一维计算）的四个点P0，P1，P2和P3定义了三次Bézier曲线。
             * 曲线开始于P0朝向P1并且从P2的方向到达P3。通常不会通过P1或P2; 这些点只是为了提供方向信息。
             * P1和P2之间的距离在转向P2之前确定曲线向P1移动的“多远”和“多快” 。
             *
             * 对于由点Pi，Pj和Pk定义的二次Bézier曲线，可以将Bpipjpk(t)写成三次Bézier曲线，它可以定义为两条二次Bézier曲线的仿射组合：
             * ```
             * B(t) = (1 - t) * Bp0p1p2(t) + t * Bp1p2p3(t) , 0 <= t && t <= 1
             * ```
             * 曲线的显式形式是：
             * ```
             * B(t) = (1 - t) * (1 - t) * (1 - t) * p0 + 3 * (1 - t) * (1 - t) * t * p1 + 3 * (1 - t) * t * t * p2 + t * t * t * p3 , 0 <= t && t <= 1
             * ```
             * 对于P1和P2的一些选择，曲线可以相交，或者包含尖点。
             *
             * 三次Bézier曲线相对于t的导数是
             * ```
             * B'(t) = 3 * (1 - t) * (1 - t) * (p1 - p0) + 6 * (1 - t) * t * (p2 - p1) + 3 * t * t * (p3 - p2);
             * ```
             * 三次Bézier曲线关于t的二阶导数是
             * ```
             * 6 * (1 - t) * (p2 - 2 * p1 + p0) + 6 * t * (p3 - 2 * p2 + p1);
             * ```
             *
             * @param t 插值度
             * @param p0 点0
             * @param p1 点1
             * @param p2 点2
             * @param p3 点3
             */
            BezierCurve.cubic = function (t, p0, p1, p2, p3) {
                // return this.linear(t, this.quadratic(t, p0, p1, p2), this.quadratic(t, p1, p2, p3));
                return (1 - t) * (1 - t) * (1 - t) * p0 + 3 * (1 - t) * (1 - t) * t * p1 + 3 * (1 - t) * t * t * p2 + t * t * t * p3;
            };
            /**
             * 三次Bézier曲线关于t的导数
             * @param t 插值度
             * @param p0 点0
             * @param p1 点1
             * @param p2 点2
             * @param p3 点3
             */
            BezierCurve.cubicDerivative = function (t, p0, p1, p2, p3) {
                // return 3 * this.linear(t, this.quadraticDerivative(t, p0, p1, p2), this.quadraticDerivative(t, p1, p2, p3));
                return 3 * (1 - t) * (1 - t) * (p1 - p0) + 6 * (1 - t) * t * (p2 - p1) + 3 * t * t * (p3 - p2);
            };
            /**
             * 三次Bézier曲线关于t的二阶导数
             * @param t 插值度
             * @param p0 点0
             * @param p1 点1
             * @param p2 点2
             */
            BezierCurve.cubicSecondDerivative = function (t, p0, p1, p2, p3) {
                // return 3 * this.linear(t, this.quadraticSecondDerivative(t, p0, p1, p2), this.quadraticSecondDerivative(t, p1, p2, p3));
                return 6 * (1 - t) * (p2 - 2 * p1 + p0) + 6 * t * (p3 - 2 * p2 + p1);
            };
            /**
             * n次Bézier曲线
             *
             * 一般定义
             *
             * Bézier曲线可以定义为任意度n。
             *
             * @param t 插值度
             * @param ps 点列表 ps.length == n+1
             * @param processs 收集中间过程数据，可用作Bézier曲线动画数据
             */
            BezierCurve.bn = function (t, ps, processs) {
                if (processs === void 0) { processs = null; }
                ps = ps.concat();
                if (processs)
                    processs.push(ps.concat());
                // n次Bézier递推
                for (var i = ps.length - 1; i > 0; i--) {
                    for (var j = 0; j < i; j++) {
                        ps[j] = (1 - t) * ps[j] + t * ps[j + 1];
                    }
                    if (processs) {
                        ps.length = ps.length - 1;
                        processs.push(ps.concat());
                    }
                }
                return ps[0];
            };
            /**
             * n次Bézier曲线关于t的导数
             *
             * 一般定义
             *
             * Bézier曲线可以定义为任意度n。
             *
             * @param t 插值度
             * @param ps 点列表 ps.length == n+1
             */
            BezierCurve.bnDerivative = function (t, ps) {
                if (ps.length < 2)
                    return 0;
                ps = ps.concat();
                // 进行
                for (var i = 0, n = ps.length - 1; i < n; i++) {
                    ps[i] = ps[i + 1] - ps[i];
                }
                //
                ps.length = ps.length - 1;
                var v = ps.length * this.bn(t, ps);
                return v;
            };
            /**
             * n次Bézier曲线关于t的二阶导数
             *
             * 一般定义
             *
             * Bézier曲线可以定义为任意度n。
             *
             * @param t 插值度
             * @param ps 点列表 ps.length == n+1
             */
            BezierCurve.bnSecondDerivative = function (t, ps) {
                if (ps.length < 3)
                    return 0;
                ps = ps.concat();
                // 进行
                for (var i = 0, n = ps.length - 1; i < n; i++) {
                    ps[i] = ps[i + 1] - ps[i];
                }
                //
                ps.length = ps.length - 1;
                var v = ps.length * this.bnDerivative(t, ps);
                return v;
            };
            /**
             * n次Bézier曲线关于t的dn阶导数
             *
             * Bézier曲线可以定义为任意度n。
             *
             * @param t 插值度
             * @param dn 求导次数
             * @param ps 点列表     ps.length == n+1
             */
            BezierCurve.bnND = function (t, dn, ps) {
                if (ps.length < dn + 1)
                    return 0;
                var factorial = 1;
                ps = ps.concat();
                for (var j = 0; j < dn; j++) {
                    // 进行
                    for (var i = 0, n = ps.length - 1; i < n; i++) {
                        ps[i] = ps[i + 1] - ps[i];
                    }
                    //
                    ps.length = ps.length - 1;
                    factorial *= ps.length;
                }
                var v = factorial * this.bn(t, ps);
                return v;
            };
            /**
             * 获取曲线在指定插值度上的值
             * @param t 插值度
             * @param ps 点列表
             */
            BezierCurve.getValue = function (t, ps) {
                if (ps.length == 2) {
                    return this.linear(t, ps[0], ps[1]);
                }
                if (ps.length == 3) {
                    return this.quadratic(t, ps[0], ps[1], ps[2]);
                }
                if (ps.length == 4) {
                    return this.cubic(t, ps[0], ps[1], ps[2], ps[3]);
                }
                return this.bn(t, ps);
                // var t1 = 1 - t;
                // return t1 * t1 * t1 * ps[0] + 3 * t1 * t1 * t * ps[1] + 3 * t1 * t * t * ps[2] + t * t * t * ps[3];
            };
            /**
             * 获取曲线在指定插值度上的导数(斜率)
             * @param t 插值度
             * @param ps 点列表
             */
            BezierCurve.getDerivative = function (t, ps) {
                if (ps.length == 2) {
                    return this.linearDerivative(t, ps[0], ps[1]);
                }
                if (ps.length == 3) {
                    return this.quadraticDerivative(t, ps[0], ps[1], ps[2]);
                }
                if (ps.length == 4) {
                    return this.cubicDerivative(t, ps[0], ps[1], ps[2], ps[3]);
                }
                return this.bnDerivative(t, ps);
                // return 3 * (1 - t) * (1 - t) * (ps[1] - ps[0]) + 6 * (1 - t) * t * (ps[2] - ps[1]) + 3 * t * t * (ps[3] - ps[2]);
            };
            /**
             * 获取曲线在指定插值度上的二阶导数
             * @param t 插值度
             * @param ps 点列表
             */
            BezierCurve.getSecondDerivative = function (t, ps) {
                if (ps.length == 2) {
                    return this.linearSecondDerivative(t, ps[0], ps[1]);
                }
                if (ps.length == 3) {
                    return this.quadraticSecondDerivative(t, ps[0], ps[1], ps[2]);
                }
                if (ps.length == 4) {
                    return this.cubicSecondDerivative(t, ps[0], ps[1], ps[2], ps[3]);
                }
                return this.bnSecondDerivative(t, ps);
                // return 3 * (1 - t) * (1 - t) * (ps[1] - ps[0]) + 6 * (1 - t) * t * (ps[2] - ps[1]) + 3 * t * t * (ps[3] - ps[2]);
            };
            /**
             * 查找区间内极值列表
             *
             * @param ps 点列表
             * @param numSamples 采样次数，用于分段查找极值
             * @param precision  查找精度
             *
             * @returns 极值列表 {} {ts: 极值插值度列表,vs: 极值值列表}
             */
            BezierCurve.getExtremums = function (ps, numSamples, precision) {
                var _this = this;
                if (numSamples === void 0) { numSamples = 10; }
                if (precision === void 0) { precision = 0.0000001; }
                var samples = [];
                for (var i = 0; i <= numSamples; i++) {
                    samples.push(this.getDerivative(i / numSamples, ps));
                }
                // 查找存在解的分段
                //
                var resultTs = [];
                var resultVs = [];
                for (var i = 0, n = numSamples; i < n; i++) {
                    if (samples[i] * samples[i + 1] < 0) {
                        var guessT = framework.EquationSolving.line(function (x) { return _this.getDerivative(x, ps); }, i / numSamples, (i + 1) / numSamples, precision);
                        resultTs.push(guessT);
                        resultVs.push(this.getValue(guessT, ps));
                    }
                }
                return { ts: resultTs, vs: resultVs };
            };
            /**
             * 获取单调区间列表
             * @returns {} {ts: 区间结点插值度列表,vs: 区间结点值列表}
             */
            BezierCurve.getMonotoneIntervals = function (ps, numSamples, precision) {
                if (numSamples === void 0) { numSamples = 10; }
                if (precision === void 0) { precision = 0.0000001; }
                // 区间内的单调区间
                var monotoneIntervalTs = [0, 1];
                var monotoneIntervalVs = [ps[0], ps[ps.length - 1]];
                // 预先计算好极值
                var extremums = this.getExtremums(ps, numSamples, precision);
                for (var i = 0; i < extremums.ts.length; i++) {
                    // 增加单调区间
                    monotoneIntervalTs.splice(i + 1, 0, extremums.ts[i]);
                    monotoneIntervalVs.splice(i + 1, 0, extremums.vs[i]);
                }
                return { ts: monotoneIntervalTs, vs: monotoneIntervalVs };
            };
            /**
             * 获取目标值所在的插值度T
             *
             * @param targetV 目标值
             * @param ps 点列表
             * @param numSamples 分段数量，用于分段查找，用于解决寻找多个解、是否无解等问题；过少的分段可能会造成找不到存在的解决，过多的分段将会造成性能很差。
             * @param precision  查找精度
             *
             * @returns 返回解数组
             */
            BezierCurve.getTFromValue = function (targetV, ps, numSamples, precision) {
                var _this = this;
                if (numSamples === void 0) { numSamples = 10; }
                if (precision === void 0) { precision = 0.0000001; }
                // 获取单调区间
                var monotoneIntervals = this.getMonotoneIntervals(ps, numSamples, precision);
                var monotoneIntervalTs = monotoneIntervals.ts;
                var monotoneIntervalVs = monotoneIntervals.vs;
                // 存在解的单调区间
                var results = [];
                // 遍历单调区间
                for (var i = 0, n = monotoneIntervalVs.length - 1; i < n; i++) {
                    if ((monotoneIntervalVs[i] - targetV) * (monotoneIntervalVs[i + 1] - targetV) <= 0) {
                        var fx = function (x) { return _this.getValue(x, ps) - targetV; };
                        // 连线法
                        var result = framework.EquationSolving.line(fx, monotoneIntervalTs[i], monotoneIntervalTs[i + 1], precision);
                        results.push(result);
                    }
                }
                return results;
            };
            /**
             * 分割曲线
             *
             * 在曲线插值度t位置分割为两条连接起来与原曲线完全重合的曲线
             *
             * @param t 分割位置（插值度）
             * @param ps 被分割曲线点列表
             * @returns 返回两条曲线组成的数组
             */
            BezierCurve.split = function (t, ps) {
                // 获取曲线的动画过程
                var processs = [];
                BezierCurve.bn(t, ps, processs);
                // 第一条曲线
                var fps = [];
                // 第二条曲线
                var sps = [];
                // 使用当前t值进行分割曲线
                for (var i = processs.length - 1; i >= 0; i--) {
                    if (i == processs.length - 1) {
                        // 添加关键点
                        fps.push(processs[i][0]);
                        fps.push(processs[i][0]);
                    }
                    else {
                        // 添加左右控制点
                        fps.unshift(processs[i][0]);
                        sps.push(processs[i].pop());
                    }
                }
                return [fps, sps];
            };
            /**
             * 合并曲线
             *
             * 合并两条连接的曲线为一条曲线并且可以还原为分割前的曲线
             *
             * @param fps 第一条曲线点列表
             * @param sps 第二条曲线点列表
             * @param mergeType 合并方式。mergeType = 0时进行还原合并，还原拆分之前的曲线；mergeType = 1时进行拟合合并，合并后的曲线会经过两条曲线的连接点；
             */
            BezierCurve.merge = function (fps, sps, mergeType) {
                if (mergeType === void 0) { mergeType = 0; }
                fps = fps.concat();
                sps = sps.concat();
                var processs = [];
                var t;
                // 上条曲线
                var pps;
                // 当前曲线
                var ps;
                for (var i = 0, n = fps.length; i < n; i++) {
                    ps = processs[i] = [];
                    if (i == 0) {
                        processs[i][0] = fps.pop();
                        sps.shift();
                    }
                    else if (i == 1) {
                        // 计算t值
                        processs[i][0] = fps.pop();
                        processs[i][1] = sps.shift();
                        t = (processs[i - 1][0] - processs[i][0]) / (processs[i][1] - processs[i][0]);
                    }
                    else {
                        pps = processs[i - 1];
                        // 前面增加点
                        var nfp = fps.pop();
                        // 后面增加点
                        var nsp = sps.shift();
                        // 从前往后计算
                        var ps0 = [];
                        ps0[0] = nfp;
                        for (var j = 0, n_1 = pps.length; j < n_1; j++) {
                            ps0[j + 1] = ps0[j] + (pps[j] - ps0[j]) / t;
                        }
                        // 从后往前计算
                        var ps1 = [];
                        ps1[pps.length] = nsp;
                        for (var j = pps.length - 1; j >= 0; j--) {
                            ps1[j] = ps1[j + 1] - (ps1[j + 1] - pps[j]) / (1 - t);
                        }
                        // 拟合合并,合并前后两个方向的计算
                        if (mergeType == 1) {
                            for (var j = 0, n_2 = ps0.length - 1; j <= n_2; j++) {
                                ps[j] = (ps0[j] * (n_2 - j) + ps1[j] * j) / n_2;
                            }
                        }
                        else if (mergeType == 0) {
                            // 还原合并，前半段使用从前往后计算，后半段使用从后往前计算
                            for (var j = 0, n_3 = ps0.length - 1; j <= n_3; j++) {
                                if (j < n_3 / 2) {
                                    ps[j] = ps0[j];
                                }
                                else if (j > n_3 / 2) {
                                    ps[j] = ps1[j];
                                }
                                else {
                                    ps[j] = (ps0[j] + ps1[j]) / 2;
                                }
                            }
                        }
                        else {
                            console.error("\u5408\u5E76\u7C7B\u578B mergeType ".concat(mergeType, " \u9519\u8BEF!"));
                        }
                    }
                }
                return processs.pop();
            };
            /**
             * 获取曲线样本数据
             *
             * 这些点可用于连线来拟合曲线。
             *
             * @param ps 点列表
             * @param num 采样次数 ，采样点分别为[0,1/num,2/num,....,(num-1)/num,1]
             */
            BezierCurve.getSamples = function (ps, num) {
                if (num === void 0) { num = 100; }
                var results = [];
                for (var i = 0; i <= num; i++) {
                    var t = i / num;
                    var p = this.getValue(t, ps);
                    results.push({ t: t, v: p });
                }
                return results;
            };
            return BezierCurve;
        }());
        framework.BezierCurve = BezierCurve;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * 最大最小曲线
         *
         * @author feng3d
         */
        var MinMaxCurve = /** @class */ (function () {
            function MinMaxCurve() {
                /**
                 * 模式
                 */
                this.mode = framework.MinMaxCurveMode.Constant;
                /**
                 * Set the constant value.
                 *
                 * 设置常数值。
                 */
                this.constant = 0;
                /**
                 * Set a constant for the lower bound.
                 *
                 * 为下界设置一个常数。
                 */
                this.constantMin = 0;
                /**
                 * Set a constant for the upper bound.
                 *
                 * 为上界设置一个常数。
                 */
                this.constantMax = 0;
                /**
                 * Set the curve.
                 *
                 * 设置曲线。
                 */
                this.curve = new framework.AnimationCurve1();
                /**
                 * Set a curve for the lower bound.
                 *
                 * 为下界设置一条曲线。
                 */
                this.curveMin = new framework.AnimationCurve1();
                /**
                 * Set a curve for the upper bound.
                 *
                 * 为上界设置一条曲线。
                 */
                this.curveMax = new framework.AnimationCurve1();
                /**
                 * Set a multiplier to be applied to the curves.
                 *
                 * 设置一个乘数应用于曲线。
                 */
                this.curveMultiplier = 1;
                /**
                 * 是否在编辑器中只显示Y轴 0-1 区域，例如 lifetime 为非负，需要设置为true
                 */
                this.between0And1 = false;
            }
            /**
             * 获取值
             * @param time 时间
             */
            MinMaxCurve.prototype.getValue = function (time, randomBetween) {
                if (randomBetween === void 0) { randomBetween = Math.random(); }
                switch (this.mode) {
                    case framework.MinMaxCurveMode.Constant:
                        return this.constant;
                    case framework.MinMaxCurveMode.Curve:
                        return this.curve.getValue(time) * this.curveMultiplier;
                    case framework.MinMaxCurveMode.TwoConstants:
                        return m4m.math.numberLerp(this.constantMin, this.constantMax, randomBetween);
                    case framework.MinMaxCurveMode.TwoCurves:
                        return m4m.math.numberLerp(this.curveMin.getValue(time), this.curveMax.getValue(time), randomBetween) * this.curveMultiplier;
                }
                return this.constant;
            };
            return MinMaxCurve;
        }());
        framework.MinMaxCurve = MinMaxCurve;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * 曲线模式
         *
         * @author feng3d
         */
        var MinMaxCurveMode;
        (function (MinMaxCurveMode) {
            /**
             * Use a single constant for the MinMaxCurve.
             *
             * 使用单个常数。
             */
            MinMaxCurveMode[MinMaxCurveMode["Constant"] = 0] = "Constant";
            /**
             * Use a single curve for the MinMaxCurve.
             *
             * 使用一条曲线
             */
            MinMaxCurveMode[MinMaxCurveMode["Curve"] = 1] = "Curve";
            /**
             * Use a random value between 2 constants for the MinMaxCurve.
             *
             * 在两个常量之间使用一个随机值
             */
            MinMaxCurveMode[MinMaxCurveMode["TwoConstants"] = 3] = "TwoConstants";
            /**
             * Use a random value between 2 curves for the MinMaxCurve.
             *
             * 在两条曲线之间使用一个随机值。
             */
            MinMaxCurveMode[MinMaxCurveMode["TwoCurves"] = 2] = "TwoCurves";
        })(MinMaxCurveMode = framework.MinMaxCurveMode || (framework.MinMaxCurveMode = {}));
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         *
         * @author feng3d
         */
        var MinMaxCurveVector3 = /** @class */ (function () {
            function MinMaxCurveVector3() {
                /**
                 * x 曲线
                 */
                this.xCurve = new framework.MinMaxCurve();
                /**
                 * y 曲线
                 */
                this.yCurve = new framework.MinMaxCurve();
                /**
                 * z 曲线
                 */
                this.zCurve = new framework.MinMaxCurve();
            }
            /**
             * 获取值
             * @param time 时间
             */
            MinMaxCurveVector3.prototype.getValue = function (time, randomBetween) {
                if (randomBetween === void 0) { randomBetween = Math.random(); }
                return new m4m.math.vector3(this.xCurve.getValue(time, randomBetween), this.yCurve.getValue(time, randomBetween), this.zCurve.getValue(time, randomBetween));
            };
            return MinMaxCurveVector3;
        }());
        framework.MinMaxCurveVector3 = MinMaxCurveVector3;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * 颜色渐变
         *
         * @author feng3d
         */
        var Gradient = /** @class */ (function () {
            function Gradient() {
                /**
                 * 渐变模式
                 */
                this.mode = framework.GradientMode.Blend;
                /**
                 * 在渐变中定义的所有alpha键。
                 *
                 * 注： 该值已对时间排序，否则赋值前请使用 sort((a, b) => a.time - b.time) 进行排序
                 */
                this.alphaKeys = [{ alpha: 1, time: 0 }, { alpha: 1, time: 1 }];
                /**
                 * 在渐变中定义的所有color键。
                 *
                 * 注： 该值已对时间排序，否则赋值前请使用 sort((a, b) => a.time - b.time) 进行排序
                 */
                this.colorKeys = [{ color: new m4m.math.color(1, 1, 1), time: 0 }, { color: new m4m.math.color(1, 1, 1), time: 1 }];
            }
            /**
             * 获取值
             * @param time 时间
             */
            Gradient.prototype.getValue = function (time) {
                var alpha = this.getAlpha(time);
                var color = this.getColor(time);
                return new m4m.math.color(color.r, color.g, color.b, alpha);
            };
            /**
             * 获取透明度
             * @param time 时间
             */
            Gradient.prototype.getAlpha = function (time) {
                var alphaKeys = this.alphaKeys;
                if (alphaKeys.length == 1)
                    return alphaKeys[0].alpha;
                if (time <= alphaKeys[0].time)
                    return alphaKeys[0].alpha;
                if (time >= alphaKeys[alphaKeys.length - 1].time)
                    return alphaKeys[alphaKeys.length - 1].alpha;
                for (var i = 0, n = alphaKeys.length - 1; i < n; i++) {
                    var t = alphaKeys[i].time, v = alphaKeys[i].alpha, nt = alphaKeys[i + 1].time, nv = alphaKeys[i + 1].alpha;
                    if (time == t)
                        return v;
                    if (time == nt)
                        return nv;
                    if (t < time && time < nt) {
                        if (this.mode == framework.GradientMode.Fixed)
                            return nv;
                        return m4m.math.mapLinear(time, t, nt, v, nv);
                    }
                }
                return 1;
            };
            /**
             * 获取透明度
             * @param time 时间
             */
            Gradient.prototype.getColor = function (time) {
                var colorKeys = this.colorKeys;
                if (colorKeys.length == 1)
                    return colorKeys[0].color;
                if (time <= colorKeys[0].time)
                    return colorKeys[0].color;
                if (time >= colorKeys[colorKeys.length - 1].time)
                    return colorKeys[colorKeys.length - 1].color;
                for (var i = 0, n = colorKeys.length - 1; i < n; i++) {
                    var t = colorKeys[i].time, v = colorKeys[i].color, nt = colorKeys[i + 1].time, nv = colorKeys[i + 1].color;
                    if (time == t)
                        return v;
                    if (time == nt)
                        return nv;
                    if (t < time && time < nt) {
                        if (this.mode == framework.GradientMode.Fixed)
                            return nv;
                        var color = new m4m.math.color();
                        m4m.math.colorLerp(v, nv, (time - t) / (nt - t), color);
                        return color;
                    }
                }
                return new m4m.math.color();
            };
            return Gradient;
        }());
        framework.Gradient = Gradient;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * 渐变模式
         *
         * @author feng3d
         */
        var GradientMode;
        (function (GradientMode) {
            /**
             * 混合
             */
            GradientMode[GradientMode["Blend"] = 0] = "Blend";
            /**
             * 阶梯
             */
            GradientMode[GradientMode["Fixed"] = 1] = "Fixed";
        })(GradientMode = framework.GradientMode || (framework.GradientMode = {}));
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * 最大最小颜色渐变
         *
         * @author feng3d
         */
        var MinMaxGradient = /** @class */ (function () {
            function MinMaxGradient() {
                /**
                 * Set the mode that the min-max gradient will use to evaluate colors.
                 *
                 * 设置最小-最大梯度将用于评估颜色的模式。
                 */
                this.mode = framework.MinMaxGradientMode.Color;
                /**
                 * Set a constant color.
                 *
                 * 常量颜色值
                 */
                this.color = new m4m.math.color();
                /**
                 * Set a constant color for the lower bound.
                 *
                 * 为下界设置一个常量颜色。
                 */
                this.colorMin = new m4m.math.color();
                /**
                 * Set a constant color for the upper bound.
                 *
                 * 为上界设置一个常量颜色。
                 */
                this.colorMax = new m4m.math.color();
                /**
                 * Set the gradient.
                 *
                 * 设置渐变。
                 */
                this.gradient = new framework.Gradient();
                /**
                 * Set a gradient for the lower bound.
                 *
                 * 为下界设置一个渐变。
                 */
                this.gradientMin = new framework.Gradient();
                /**
                 * Set a gradient for the upper bound.
                 *
                 * 为上界设置一个渐变。
                 */
                this.gradientMax = new framework.Gradient();
            }
            /**
             * 获取值
             * @param time 时间
             */
            MinMaxGradient.prototype.getValue = function (time, randomBetween, out) {
                if (randomBetween === void 0) { randomBetween = Math.random(); }
                if (out === void 0) { out = new m4m.math.color(); }
                switch (this.mode) {
                    case framework.MinMaxGradientMode.Color:
                        m4m.math.colorClone(this.color, out);
                        break;
                    case framework.MinMaxGradientMode.Gradient:
                        m4m.math.colorClone(this.gradient.getValue(time), out);
                        break;
                    case framework.MinMaxGradientMode.TwoColors:
                        m4m.math.colorLerp(this.colorMin, this.colorMax, randomBetween, out);
                        break;
                    case framework.MinMaxGradientMode.TwoGradients:
                        var min = this.gradientMin.getValue(time);
                        var max = this.gradientMax.getValue(time);
                        m4m.math.colorLerp(min, max, randomBetween, out);
                        break;
                    case framework.MinMaxGradientMode.RandomColor:
                        var v = this.gradient.getValue(randomBetween);
                        m4m.math.colorClone(v, out);
                        break;
                }
                return out;
            };
            return MinMaxGradient;
        }());
        framework.MinMaxGradient = MinMaxGradient;
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var framework;
    (function (framework) {
        /**
         * 最大最小颜色渐变模式
         *
         * @author feng3d
         */
        var MinMaxGradientMode;
        (function (MinMaxGradientMode) {
            /**
             * Use a single color for the MinMaxGradient.
             *
             * 使用单一颜色的。
             */
            MinMaxGradientMode[MinMaxGradientMode["Color"] = 0] = "Color";
            /**
             * Use a single color gradient for the MinMaxGradient.
             *
             * 使用单一颜色渐变。
             */
            MinMaxGradientMode[MinMaxGradientMode["Gradient"] = 1] = "Gradient";
            /**
             * Use a random value between 2 colors for the MinMaxGradient.
             *
             * 在两种颜色之间使用一个随机值。
             */
            MinMaxGradientMode[MinMaxGradientMode["TwoColors"] = 2] = "TwoColors";
            /**
             * Use a random value between 2 color gradients for the MinMaxGradient.
             *
             * 在两个颜色梯度之间使用一个随机值。
             */
            MinMaxGradientMode[MinMaxGradientMode["TwoGradients"] = 3] = "TwoGradients";
            /**
             * Define a list of colors in the MinMaxGradient, to be chosen from at random.
             *
             * 在一个颜色列表中随机选择。
             */
            MinMaxGradientMode[MinMaxGradientMode["RandomColor"] = 4] = "RandomColor";
        })(MinMaxGradientMode = framework.MinMaxGradientMode || (framework.MinMaxGradientMode = {}));
    })(framework = m4m.framework || (m4m.framework = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var io;
    (function (io) {
        // class loadRetryMgr
        // {
        //     public static urlCaseDic: { [url: string]: number };
        // }
        var urlCaseDic = {};
        var retryTime = 500;
        var retryCount = 9999;
        /**
         *
         * @param url 加载路径
         * @param fun 加载结果回调函数
         * @param onprocess 加载进度
         * @param loadedFun 正常加载完成后回调
         */
        function xhrLoad(url, fun, onprocess, responseType, loadedFun) {
            if (onprocess === void 0) { onprocess = null; }
            var req = new XMLHttpRequest();
            var isLoaded = false;
            req.open("GET", url);
            req.responseType = responseType;
            req.onreadystatechange = function () {
                if (req.readyState == 4) {
                    if (req.status == 200) {
                        if (urlCaseDic[url])
                            delete urlCaseDic[url];
                        isLoaded = true;
                        loadedFun(req);
                    }
                    else {
                        switch (req.status) {
                            case 404:
                                if (fun)
                                    fun(null, new Error("got a 404:" + url));
                                console.error("got a 404:" + url);
                                urlCaseDic[url] = retryCount; //无法找到资源 不需要重试
                                break;
                        }
                    }
                }
            };
            req.onprogress = function (ev) {
                if (onprocess)
                    onprocess(ev.loaded, ev.total);
            };
            req.onerror = function (ev) {
                if (fun)
                    fun(null, new Error("URL : ".concat(url, " \n onerr on req: ")));
                //因 onloadend 无论成功失败都会回调   这里的重试注掉 
                // loadFail(req, url, fun, onprocess, responseType, loadedFun);
            };
            req.onloadend = function () {
                //console.error(" is onload");
                if (!isLoaded) {
                    loadFail(req, url, fun, onprocess, responseType, loadedFun);
                }
            };
            // try
            // {
            req.send();
            // } catch (err)
            // {
            //     fun(null, err);
            // }
        }
        io.xhrLoad = xhrLoad;
        function loadFail(xhr, url, fun, onprocess, responseType, loadedFun) {
            console.error("\u4E0B\u8F7D\u5931\u8D25: ".concat(url, "  status:").concat(xhr.status, ", ").concat(retryTime, "/ms \u540E\u91CD\u8BD5"));
            urlCaseDic[url] = urlCaseDic[url] || 0;
            if (urlCaseDic[url] >= retryCount) {
                urlCaseDic[url] = 0;
                if (fun)
                    fun(null, new Error("load this url fail  ：" + url), true); //throw error after retry some times
                console.error("------ load this url fail URL:".concat(url, "  "));
            }
            else {
                setTimeout(function () {
                    urlCaseDic[url]++;
                    m4m.io.xhrLoad(url, fun, onprocess, responseType, loadedFun);
                }, retryTime);
            }
        }
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 加载text资源
         * @param url 加载路径
         * @param fun 加载结果回调函数
         * @param onprocess 加载进度
         * @version m4m 1.0
         */
        function loadText(url, fun, onprocess) {
            if (onprocess === void 0) { onprocess = null; }
            // if (framework.assetMgr.useBinJs)
            // {
            //     url = framework.assetMgr.correctTxtFileName(url);
            // }
            m4m.io.xhrLoad(url, fun, onprocess, "text", function (req) {
                fun(req.responseText, null);
            });
        }
        io.loadText = loadText;
        var cachedMap = {};
        var checkClsTime = 0;
        function GetJSON(url, text) {
            if (text === void 0) { text = undefined; }
            return new Promise(function (r) {
                var cached = cachedMap[url];
                cached.ready = true;
                cached.useTime = Date.now();
                if (cached.json) {
                    r(cached.json);
                }
                else {
                    JSONParse(text || cached.text).then(function (json) {
                        //cachedMap[url] = json;
                        // cached.json = json;                
                        r(json);
                    });
                }
            });
            // return JSONParse(text);
        }
        function JSONParse(text) {
            return new Promise(function (resolve, resaon) {
                var json;
                try {
                    json = JSON.parse(text);
                }
                catch (e) {
                    resaon(e);
                }
                resolve(json);
            });
        }
        io.JSONParse = JSONParse;
        function loadJSON(url, fun, onprocess) {
            if (onprocess === void 0) { onprocess = null; }
            return new Promise(function (r) {
                // if (framework.assetMgr.useBinJs)
                //     url = framework.assetMgr.correctTxtFileName(url);
                var now = Date.now();
                if (now - checkClsTime > 15000) //15秒检查缓存
                 {
                    // console.log("检查json缓存");
                    checkClsTime = now;
                    for (var k in cachedMap) {
                        var cached_1 = cachedMap[k];
                        if (cached_1.ready && now - cachedMap[k].useTime >= 60000) //1分钟 未使用自动清除
                         {
                            // console.log(`json 超时 ${k} ${(now - cached.useTime) / 1000}/秒`);
                            delete cachedMap[k];
                        }
                    }
                }
                var cached = cachedMap[url];
                if (!cached) {
                    cached = cachedMap[url] = {
                        queue: [],
                        // ready: false,
                        init: true,
                        useTime: now
                    };
                }
                if (!cached.ready)
                    cached.queue.push(fun);
                if (cached.ready) {
                    fun(cached.json, null);
                    GetJSON(url).then(function (json) {
                        r(json);
                    });
                    return;
                }
                if (cached.init) {
                    cached.init = false;
                    m4m.io.xhrLoad(url, fun, onprocess, "text", function (req) {
                        GetJSON(url, req.response).then(function (json) {
                            var cached = cachedMap[url];
                            cached.text = req.responseText;
                            var slowOut = function () {
                                if (cached.queue.length > 0)
                                    cached.queue.shift()(json, null);
                                if (cached.queue.length > 0)
                                    setTimeout(slowOut, 10);
                            };
                            // while (cached.queue.length > 0)
                            if (cached.queue.length == 1)
                                cached.queue.shift()(json, null);
                            else
                                slowOut();
                            //缓存成josn
                            cached.json = json;
                            cached.text = "";
                        });
                    });
                }
            });
        }
        io.loadJSON = loadJSON;
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 加载arraybuffer资源
         * @param url 加载路径
         * @param fun 加载结果回调函数
         * @param onprocess 加载进度
         * @version m4m 1.0
         */
        function loadArrayBuffer(url, fun, onprocess) {
            if (onprocess === void 0) { onprocess = null; }
            // if (framework.assetMgr.useBinJs)
            // {
            //     url = framework.assetMgr.correctFileName(url);
            // }
            //req.responseType = "arraybuffer";//ie 一定要在open之后修改responseType
            m4m.io.xhrLoad(url, fun, onprocess, "arraybuffer", function (req) {
                fun(req.response, null);
            });
        }
        io.loadArrayBuffer = loadArrayBuffer;
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 加载二进制资源
         * @param url 加载路径
         * @param fun 加载结果回调函数
         * @param onprocess 加载进度
         * @version m4m 1.0
         */
        function loadBlob(url, fun, onprocess) {
            if (onprocess === void 0) { onprocess = null; }
            m4m.io.xhrLoad(url, fun, onprocess, "blob", function (req) {
                fun(req.response, null);
            });
        }
        io.loadBlob = loadBlob;
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * 加载图片资源
         * @param url 加载路径
         * @param fun 加载结果回调函数
         * @param progress 加载进度
         * @version m4m 1.0
         */
        function loadImg(url, fun, onprocess) {
            if (onprocess === void 0) { onprocess = null; }
            // let guid = framework.resID.next();
            m4m.framework.assetMgr.Instance["_loadImg"](url, function (img, err) {
                fun(img, err);
            });
            // m4m.io.xhrLoad(url, fun, onprocess, "blob", (req) =>
            // {
            //     var blob = req.response;
            //     var img = document.createElement("img");
            //     //img.crossOrigin = "anonymous";
            //     img.onload = function (e)
            //     {
            //         window.URL.revokeObjectURL(img.src);
            //         fun(img, null);
            //     };
            //     img.onerror = function (e)
            //     {
            //         fun(null, new Error("error when blob to img:" + url));
            //     }
            //     try
            //     {
            //         img.src = window.URL.createObjectURL(blob);
            //     } catch (e)
            //     {
            //         fun(null, e);
            //     }
            // });
        }
        io.loadImg = loadImg;
    })(io = m4m.io || (m4m.io = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    //定义 快捷使用池 数据结构对象 
    /** 从池中取一个 vector2 */
    function poolv2(clone) { return !clone ? m4m.math.pool.new_vector2() : m4m.math.pool.clone_vector2(clone); }
    m4m.poolv2 = poolv2;
    /** 删除释放一个 vector2 */
    function poolv2_del(data) { m4m.math.pool.delete_vector2(data); }
    m4m.poolv2_del = poolv2_del;
    ;
    /** 从池中取一个 vector3 */
    function poolv3(clone) { return !clone ? m4m.math.pool.new_vector3() : m4m.math.pool.clone_vector3(clone); }
    m4m.poolv3 = poolv3;
    /** 删除释放一个 vector3 */
    function poolv3_del(data) { m4m.math.pool.delete_vector3(data); }
    m4m.poolv3_del = poolv3_del;
    ;
    /** 从池中取一个 vector4 */
    function poolv4(clone) { return !clone ? m4m.math.pool.new_vector4() : m4m.math.pool.clone_vector4(clone); }
    m4m.poolv4 = poolv4;
    /** 删除释放一个 vector4 */
    function poolv4_del(data) { m4m.math.pool.delete_vector4(data); }
    m4m.poolv4_del = poolv4_del;
    ;
    /** 从池中取一个 quaternion */
    function poolquat(clone) { return !clone ? m4m.math.pool.new_quaternion() : m4m.math.pool.clone_quaternion(clone); }
    m4m.poolquat = poolquat;
    /** 删除释放一个 quaternion */
    function poolquat_del(data) { m4m.math.pool.delete_quaternion(data); }
    m4m.poolquat_del = poolquat_del;
    ;
    /** 从池中取一个 matrix */
    function poolmtx(clone) { return !clone ? m4m.math.pool.new_matrix() : m4m.math.pool.clone_matrix(clone); }
    m4m.poolmtx = poolmtx;
    /** 删除释放一个 matrix */
    function poolmtx_del(data) { m4m.math.pool.delete_matrix(data); }
    m4m.poolmtx_del = poolmtx_del;
    ;
    /** 从池中取一个 matrix3x2 */
    function poolmtx3x2(clone) { return !clone ? m4m.math.pool.new_matrix3x2() : m4m.math.pool.clone_matrix3x2(clone); }
    m4m.poolmtx3x2 = poolmtx3x2;
    /** 删除释放一个 matrix3x2 */
    function poolmtx3x2_del(data) { m4m.math.pool.delete_matrix3x2(data); }
    m4m.poolmtx3x2_del = poolmtx3x2_del;
    ;
    /** 从池中取一个 rect */
    function poolrect(clone) { return !clone ? m4m.math.pool.new_rect() : m4m.math.pool.clone_rect(clone); }
    m4m.poolrect = poolrect;
    /** 删除释放一个 rect */
    function poolrect_del(data) { m4m.math.pool.delete_rect(data); }
    m4m.poolrect_del = poolrect_del;
    ;
    /** 从池中取一个 color */
    function poolcolor(clone) { return !clone ? m4m.math.pool.new_color() : m4m.math.pool.clone_color(clone); }
    m4m.poolcolor = poolcolor;
    /** 删除释放一个 color */
    function poolcolor_del(data) { m4m.math.pool.delete_color(data); }
    m4m.poolcolor_del = poolcolor_del;
    ;
})(m4m || (m4m = {}));
(function (m4m) {
    var math;
    (function (math) {
        /**
        * @public
        * @language zh_CN
        * @classdesc
        * 对常用结构类型数据进行池化处理，
        * 在大量使用结构类型数据的逻辑中尽量使用该结构
        * @version m4m 1.0
        */
        var pool = /** @class */ (function () {
            function pool() {
            }
            pool.genHelpData = function (type, id) {
                var result;
                if (!type || id == null)
                    return result;
                if (this.helpDataMap[type] && this.helpDataMap[type][id]) {
                    result = this.helpDataMap[type][id];
                }
                else {
                    if (!this.helpDataMap[type])
                        this.helpDataMap[type] = {};
                    var obj = void 0;
                    switch (type) {
                        case "v2":
                            obj = this.new_vector2();
                            break;
                        case "v3":
                            obj = this.new_vector3();
                            break;
                        case "v4":
                            obj = this.new_vector4();
                            break;
                        case "quat":
                            obj = this.new_quaternion();
                            break;
                        case "mtx":
                            obj = this.new_matrix();
                            break;
                        case "mtx3x2":
                            obj = this.new_matrix3x2();
                            break;
                        case "pinfo":
                            obj = this.new_pickInfo();
                            break;
                        case "color":
                            obj = this.new_color();
                            break;
                        case "rect":
                            obj = this.new_rect();
                            break;
                        default:
                            obj = {};
                            break;
                    }
                    this.helpDataMap[type][id] = obj;
                    result = obj;
                }
                return result;
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 释放所有池
            * @version m4m 1.0
            */
            pool.collect_all = function () {
                pool.collect_vector4();
                pool.collect_vector3();
                pool.collect_vector2();
                pool.collect_matrix();
                pool.collect_quaternion();
                pool.collect_color();
                pool.collect_pickInfo();
            };
            Object.defineProperty(pool, "vector4_one", {
                /**
                * @public
                * @language zh_CN
                * @classdesc
                * 获取1填充的v4
                * @version m4m 1.0
                */
                get: function () {
                    if (pool._vector4_one == null) {
                        pool._vector4_one = new math.vector4(1, 1, 1, 1);
                    }
                    return pool._vector4_one;
                },
                enumerable: false,
                configurable: true
            });
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 获取一个v4
            * @version m4m 1.0
            */
            pool.new_vector4 = function (x, y, z, w) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (z === void 0) { z = 0; }
                if (w === void 0) { w = 0; }
                if (pool.unused_vector4.length > 0) {
                    var v4 = pool.unused_vector4.pop();
                    v4.x = x;
                    v4.y = y;
                    v4.z = z;
                    v4.w = w;
                    return v4;
                }
                else
                    return new math.vector4(x, y, z, w);
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 有返回值的v4克隆
            * @version m4m 1.0
            */
            pool.clone_vector4 = function (src) {
                if (pool.unused_vector4.length > 0) {
                    var v = pool.unused_vector4.pop();
                    v.x = src.x;
                    v.y = src.y;
                    v.z = src.z;
                    v.w = src.w;
                    // v.rawData.set(src.rawData);
                    return v;
                }
                else
                    return new math.vector4(src.x, src.y, src.z);
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 回收一个v4
            * @version m4m 1.0
            */
            pool.delete_vector4 = function (v) {
                if (v == null)
                    return;
                if (v instanceof math.vector4) {
                    v.x = v.y = v.z = 0;
                    v.w = 1;
                    pool.unused_vector4.push(v);
                }
                else
                    console.error("kindding me?确定你要回收的是vector4吗？");
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 清除v4池
            * @version m4m 1.0
            */
            pool.collect_vector4 = function () {
                pool.unused_vector4.length = 0; //清除未使用的vector 池子
            };
            Object.defineProperty(pool, "color_one", {
                /**
                * @public
                * @language zh_CN
                * @classdesc
                * 获取1填充的color
                * @version m4m 1.0
                */
                get: function () {
                    if (pool._color_one == null) {
                        pool._color_one = new math.color(1, 1, 1, 1);
                    }
                    return pool._color_one;
                },
                enumerable: false,
                configurable: true
            });
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 获取一个color
            * @version m4m 1.0
            */
            pool.new_color = function (r, g, b, a) {
                if (r === void 0) { r = 0; }
                if (g === void 0) { g = 0; }
                if (b === void 0) { b = 0; }
                if (a === void 0) { a = 0; }
                if (pool.unused_color.length > 0) {
                    var c = pool.unused_color.pop();
                    c.r = r;
                    c.g = g;
                    c.b = b;
                    c.a = a;
                    return c;
                }
                else
                    return new math.color(r, g, b, a);
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * clone一个color
            * @version m4m 1.0
            */
            pool.clone_color = function (col) {
                if (pool.unused_color.length > 0) {
                    var c = pool.unused_color.pop();
                    c.r = col.r;
                    c.g = col.g;
                    c.b = col.b;
                    c.a = col.r;
                    //    c.rawData.set(col.rawData);
                    return c;
                }
                else
                    return new math.color(col.r, col.g, col.b, col.a);
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 回收color
            * @version m4m 1.0
            */
            pool.delete_color = function (v) {
                if (v == null)
                    return;
                if (v instanceof math.color) {
                    v.r = v.g = v.b = 0;
                    v.a = 1;
                    pool.unused_color.push(v);
                }
                else
                    console.error("kindding me?确定你要回收的是color吗？");
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 清除color池
            * @version m4m 1.0
            */
            pool.collect_color = function () {
                pool.unused_color.length = 0; //清除未使用的vector 池子
            };
            Object.defineProperty(pool, "vector3_up", {
                /**
                * @public
                * @language zh_CN
                * @classdesc
                * 获取v3朝y轴正向
                * @version m4m 1.0
                */
                get: function () {
                    if (pool._vector3_up == null) {
                        pool._vector3_up = new math.vector3(0, 1, 0);
                    }
                    pool._vector3_up.y = 1;
                    pool._vector3_up.x = pool._vector3_up.z = 0;
                    return pool._vector3_up;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(pool, "vector3_right", {
                /**
                * @public
                * @language zh_CN
                * @classdesc
                * 获取v3朝x轴正向
                * @version m4m 1.0
                */
                get: function () {
                    if (pool._vector3_right == null) {
                        pool._vector3_right = new math.vector3(1, 0, 0);
                    }
                    pool._vector3_right.x = 1;
                    pool._vector3_right.y = pool._vector3_right.z = 0;
                    return pool._vector3_right;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(pool, "vector3_forward", {
                /**
                * @public
                * @language zh_CN
                * @classdesc
                * 获取v3朝z轴正向
                * @version m4m 1.0
                */
                get: function () {
                    if (pool._vector3_forward == null) {
                        pool._vector3_forward = new math.vector3(0, 0, 1);
                    }
                    pool._vector3_forward.x = pool._vector3_forward.y = 0;
                    pool._vector3_forward.z = 1;
                    return pool._vector3_forward;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(pool, "vector3_zero", {
                /**
                * @public
                * @language zh_CN
                * @classdesc
                * 获取0填充的v3
                * @version m4m 1.0
                */
                get: function () {
                    if (pool._vector3_zero == null) {
                        pool._vector3_zero = new math.vector3(0, 0, 0);
                    }
                    pool._vector3_zero.x = pool._vector3_zero.y = pool._vector3_zero.z = 0;
                    return pool._vector3_zero;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(pool, "vector3_one", {
                /**
                * @public
                * @language zh_CN
                * @classdesc
                * 获取1填充的v3
                * @version m4m 1.0
                */
                get: function () {
                    if (pool._vector3_one == null) {
                        pool._vector3_one = new math.vector3(1, 1, 1);
                    }
                    pool._vector3_one.x = pool._vector3_one.y = pool._vector3_one.z = 1;
                    return pool._vector3_one;
                },
                enumerable: false,
                configurable: true
            });
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 获取一个v3
            * @version m4m 1.0
            */
            pool.new_vector3 = function (x, y, z) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (z === void 0) { z = 0; }
                if (pool.unused_vector3.length > 0) {
                    var v3 = pool.unused_vector3.pop();
                    v3.x = x;
                    v3.y = y;
                    v3.z = z;
                    return v3;
                }
                else
                    return new math.vector3(x, y, z);
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 带返回值的v3克隆
            * @version m4m 1.0
            */
            pool.clone_vector3 = function (src) {
                if (pool.unused_vector3.length > 0) {
                    var v = pool.unused_vector3.pop();
                    v.x = src.x;
                    v.y = src.y;
                    v.z = src.z;
                    // v.rawData.set(src.rawData);
                    return v;
                }
                else
                    return new math.vector3(src.x, src.y, src.z);
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 回收一个v3
            * @version m4m 1.0
            */
            pool.delete_vector3 = function (v) {
                if (v == null)
                    return;
                if (v instanceof math.vector3) {
                    v.x = v.y = v.z = 0;
                    pool.unused_vector3.push(v);
                }
                else
                    console.error("kindding me?确定你要回收的是vector3吗？");
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 回收一个v3数组
            * @version m4m 1.0
            */
            pool.delete_vector3Array = function (vs) {
                for (var i = 0; i < vs.length; i++) {
                    if (vs[i] != undefined) {
                        this.delete_vector3(vs[i]);
                    }
                }
                vs.length = 0;
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 清除v3池
            * @version m4m 1.0
            */
            pool.collect_vector3 = function () {
                pool.unused_vector3.length = 0; //清除未使用的vector 池子
            };
            Object.defineProperty(pool, "vector2_zero", {
                /**
                * @public
                * @language zh_CN
                * @classdesc
                * 获取v2 zero
                * @version m4m 1.0
                */
                get: function () {
                    if (pool._vector2_zero == null) {
                        pool._vector2_zero = new math.vector2(0, 0);
                    }
                    pool._vector2_zero.x = pool._vector2_zero.y = 1;
                    return pool._vector2_zero;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(pool, "vector2_up", {
                /**
                * @public
                * @language zh_CN
                * @classdesc
                * 获取v2朝y轴正向
                * @version m4m 1.0
                */
                get: function () {
                    if (pool._vector2_up == null) {
                        pool._vector2_up = new math.vector2(0, 1);
                    }
                    pool._vector2_up.x = 0;
                    pool._vector2_up.y = 1;
                    return pool._vector2_up;
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(pool, "vector2_right", {
                /**
                * @public
                * @language zh_CN
                * @classdesc
                * 获取v2朝x轴正向
                * @version m4m 1.0
                */
                get: function () {
                    if (pool._vector2_right == null) {
                        pool._vector2_right = new math.vector2(1, 0);
                    }
                    pool._vector2_right.x = 1;
                    pool._vector2_right.y = 0;
                    return pool._vector2_right;
                },
                enumerable: false,
                configurable: true
            });
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 获取一个v2
            * @version m4m 1.0
            */
            pool.new_vector2 = function (x, y) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (pool.unused_vector2.length > 0) {
                    var v2 = pool.unused_vector2.pop();
                    v2.x = x;
                    v2.y = y;
                    return v2;
                }
                else
                    return new math.vector2(x, y);
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 带返回值的v2克隆
            * @version m4m 1.0
            */
            pool.clone_vector2 = function (src) {
                if (pool.unused_vector2.length > 0) {
                    var v = pool.unused_vector2.pop();
                    v.x = src.x;
                    v.y = src.y;
                    // if (src.rawData.length > v.rawData.length)
                    // {
                    //     src.rawData[0] = v.rawData[0];
                    //     src.rawData[1] = v.rawData[1];
                    // } else
                    //     v.rawData.set(src.rawData);
                    return v;
                }
                else
                    return new math.vector2(src.x, src.y);
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 回收一个v2
            * @version m4m 1.0
            */
            pool.delete_vector2 = function (v) {
                if (v == null)
                    return;
                if (v instanceof math.vector2) {
                    v.x = v.y = 0;
                    pool.unused_vector2.push(v);
                }
                else
                    console.error("kindding me?确定你要回收的是vector2吗？");
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 回收一个v2数组
            * @version m4m 1.0
            */
            pool.delete_vector2Array = function (vs) {
                for (var i = 0; i < vs.length; i++) {
                    if (vs[i] != undefined) {
                        this.delete_vector2(vs[i]);
                    }
                }
                vs.length = 0;
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 清除v2池
            * @version m4m 1.0
            */
            pool.collect_vector2 = function () {
                pool.unused_vector2.length = 0; //清除未使用的vector 池子
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 获取一个3x2matrix
            * @version m4m 1.0
            */
            pool.new_matrix3x2 = function () {
                if (pool.unused_matrix3x2.length > 0)
                    return pool.unused_matrix3x2.pop();
                else
                    return new math.matrix3x2();
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 带返回值的3x2matrix克隆
            * @version m4m 1.0
            */
            pool.clone_matrix3x2 = function (src) {
                var v = pool.new_matrix3x2();
                for (var i = 0; i < 6; i++)
                    v.rawData[i] = src.rawData[i];
                // v.rawData.set(src.rawData);
                return v;
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 回收一个3x2matrix
            * @version m4m 1.0
            */
            pool.delete_matrix3x2 = function (v) {
                if (v == null)
                    return;
                if (v instanceof math.matrix3x2) {
                    v.rawData[0] = 1;
                    v.rawData[1] = 0;
                    v.rawData[2] = 0;
                    v.rawData[3] = 1;
                    v.rawData[4] = 0;
                    v.rawData[5] = 0;
                    pool.unused_matrix3x2.push(v);
                }
                else {
                    console.error("kindding me?确定你要回收的是matrix3x2吗？");
                }
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 清除3x2matrix池
            * @version m4m 1.0
            */
            pool.collect_matrix3x2 = function () {
                pool.unused_matrix3x2.length = 0; //清除未使用的池子
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 获取一个matrix
            * @version m4m 1.0
            */
            pool.new_matrix = function () {
                if (pool.unused_matrix.length > 0)
                    return pool.unused_matrix.pop();
                else
                    return new math.matrix();
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 带返回值的matrix克隆
            * @version m4m 1.0
            */
            pool.clone_matrix = function (src) {
                var v = pool.new_matrix();
                for (var i = 0; i < 16; i++)
                    v.rawData[i] = src.rawData[i];
                // v.rawData.set(src.rawData);
                return v;
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 回收一个matrix
            * @version m4m 1.0
            */
            pool.delete_matrix = function (v) {
                if (v == null)
                    return;
                if (v instanceof math.matrix) {
                    v.rawData[0] = 1;
                    v.rawData[1] = 0;
                    v.rawData[2] = 0;
                    v.rawData[3] = 0;
                    v.rawData[4] = 0;
                    v.rawData[5] = 1;
                    v.rawData[6] = 0;
                    v.rawData[7] = 0;
                    v.rawData[8] = 0;
                    v.rawData[9] = 0;
                    v.rawData[10] = 1;
                    v.rawData[11] = 0;
                    v.rawData[12] = 0;
                    v.rawData[13] = 0;
                    v.rawData[14] = 0;
                    v.rawData[15] = 1;
                    pool.unused_matrix.push(v);
                }
                else
                    console.error("kindding me?确定你要回收的是matrix吗？");
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 清除matrix池
            * @version m4m 1.0
            */
            pool.collect_matrix = function () {
                pool.unused_matrix.length = 0; //清除未使用的池子
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 获取一个quat
            * @version m4m 1.0
            */
            pool.new_quaternion = function (x, y, z, w) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (z === void 0) { z = 0; }
                if (w === void 0) { w = 1; }
                if (pool.unused_quaternion.length > 0) {
                    var q = pool.unused_quaternion.pop();
                    q.x = x;
                    q.y = y;
                    q.z = z;
                    q.w = w;
                    return q;
                }
                else
                    return new math.quaternion(x, y, z, w);
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 带返回值的quat克隆
            * @version m4m 1.0
            */
            pool.clone_quaternion = function (src) {
                if (pool.unused_quaternion.length > 0) {
                    var v = pool.unused_quaternion.pop();
                    v.x = src.x;
                    v.y = src.y;
                    v.z = src.z;
                    v.w = src.w;
                    // v.rawData.set(src.rawData);
                    return v;
                }
                else
                    return new math.quaternion(src.x, src.y, src.z, src.w);
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 回收一个quat
            * @version m4m 1.0
            */
            pool.delete_quaternion = function (v) {
                if (v == null)
                    return;
                if (v instanceof math.quaternion) {
                    v.x = v.y = v.z = 0;
                    v.w = 1;
                    pool.unused_quaternion.push(v);
                }
                else
                    console.error("kindding me?确定你要回收的是quaternion吗？");
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 清除quat池
            * @version m4m 1.0
            */
            pool.collect_quaternion = function () {
                pool.unused_quaternion.length = 0; //清除未使用的池子
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 获取一个pickInfo
            * @version m4m 1.0
            */
            pool.new_pickInfo = function (bu, bv, distance) {
                if (bu === void 0) { bu = 0; }
                if (bv === void 0) { bv = 0; }
                if (distance === void 0) { distance = 0; }
                if (pool.unused_pickInfo.length > 0) {
                    var pk = pool.unused_pickInfo.pop();
                    pk.bu = bu;
                    pk.bv = bv;
                    pk.distance = distance;
                    return pk;
                }
                else
                    return new m4m.framework.pickinfo(bu, bv, distance);
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 回收一个pickInfo
            * @version m4m 1.0
            */
            pool.delete_pickInfo = function (v) {
                if (v == null)
                    return;
                if (v instanceof m4m.framework.pickinfo) {
                    v.init();
                    pool.unused_pickInfo.push(v);
                }
                else
                    console.error("kindding me?确定你要回收的是pickInfo吗？");
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 清除pickInfo池
             * @version m4m 1.0
             */
            pool.collect_pickInfo = function () {
                pool.unused_pickInfo.length = 0;
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 获取一个rect
            * @version m4m 1.0
            */
            pool.new_rect = function (x, y, w, h) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                if (w === void 0) { w = 0; }
                if (h === void 0) { h = 0; }
                if (pool.unused_rect.length > 0) {
                    var r = pool.unused_rect.pop();
                    r.x = x;
                    r.y = y;
                    r.w = w;
                    r.h = h;
                    return r;
                }
                else
                    return new math.rect(x, y, w, h);
            };
            /**
            * @public
            * @language zh_CN
            * @classdesc
            * 带返回值的rect克隆
            * @version m4m 1.0
            */
            pool.clone_rect = function (src) {
                if (pool.unused_rect.length > 0) {
                    var v = pool.unused_rect.pop();
                    v.x = src.x;
                    v.y = src.y;
                    v.w = src.w;
                    v.h = src.h;
                    return v;
                }
                else
                    return new math.rect(src.x, src.y, src.w, src.h);
            };
            /**
             * @public
             * @language zh_CN
             * @classdesc
             * 回收一个rect
             * @version m4m 1.0
             */
            pool.delete_rect = function (v) {
                if (v == null)
                    return;
                if (v instanceof math.rect) {
                    v.x = v.y = v.w = v.h = 0;
                    pool.unused_rect.push(v);
                }
                else
                    console.error("kindding me?确定你要回收的是rect吗？");
            };
            /**
              * @public
              * @language zh_CN
              * @classdesc
              * 清除rect池
              * @version m4m 1.0
              */
            pool.collect_rect = function () {
                pool.unused_rect.length = 0;
            };
            pool.helpDataMap = {};
            pool.unused_vector4 = [];
            pool.unused_color = [];
            pool.unused_vector3 = [];
            pool.unused_vector2 = [];
            //for matrix3x2
            pool.unused_matrix3x2 = [];
            //for matrix
            pool.unused_matrix = [];
            pool.identityMat = new math.matrix();
            //for quaternion
            pool.unused_quaternion = [];
            pool.unused_pickInfo = [];
            //for rect
            pool.unused_rect = [];
            return pool;
        }());
        math.pool = pool;
    })(math = m4m.math || (m4m.math = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var render;
    (function (render) {
        /**
         * @private
         */
        var caps = /** @class */ (function () {
            function caps() {
            }
            return caps;
        }());
        render.caps = caps;
        /**
         * @private
         */
        var webglkit = /** @class */ (function () {
            function webglkit() {
            }
            webglkit.SetMaxVertexAttribArray = function (webgl, count) {
                for (var i = count; i < webglkit._maxVertexAttribArray; i++) {
                    webgl.disableVertexAttribArray(i);
                }
                webglkit._maxVertexAttribArray = count;
            };
            webglkit.GetTextureNumber = function (index) {
                return webglkit._texNumber[index];
            };
            webglkit.initConst = function (webgl) {
                if (webglkit._texNumber == null) {
                    webglkit._texNumber = [];
                    webglkit._texNumber.push(webgl.TEXTURE0);
                    webglkit._texNumber.push(webgl.TEXTURE1);
                    webglkit._texNumber.push(webgl.TEXTURE2);
                    webglkit._texNumber.push(webgl.TEXTURE3);
                    webglkit._texNumber.push(webgl.TEXTURE4);
                    webglkit._texNumber.push(webgl.TEXTURE5);
                    webglkit._texNumber.push(webgl.TEXTURE6);
                    webglkit._texNumber.push(webgl.TEXTURE7);
                    webglkit._texNumber.push(webgl.TEXTURE8);
                    webglkit._texNumber.push(webgl.TEXTURE9);
                    webglkit._texNumber.push(webgl.TEXTURE10);
                    webglkit._texNumber.push(webgl.TEXTURE11);
                    webglkit._texNumber.push(webgl.TEXTURE12);
                    webglkit._texNumber.push(webgl.TEXTURE13);
                    webglkit._texNumber.push(webgl.TEXTURE14);
                    webglkit._texNumber.push(webgl.TEXTURE15);
                    webglkit.LEQUAL = webgl.LEQUAL;
                    webglkit.NEVER = webgl.NEVER;
                    webglkit.EQUAL = webgl.EQUAL;
                    webglkit.GEQUAL = webgl.GEQUAL;
                    webglkit.NOTEQUAL = webgl.NOTEQUAL;
                    webglkit.LESS = webgl.LESS;
                    webglkit.GREATER = webgl.GREATER;
                    webglkit.ALWAYS = webgl.ALWAYS;
                    webglkit.FUNC_ADD = webgl.FUNC_ADD;
                    webglkit.FUNC_SUBTRACT = webgl.FUNC_SUBTRACT;
                    webglkit.FUNC_REVERSE_SUBTRACT = webgl.FUNC_REVERSE_SUBTRACT;
                    webglkit.ONE = webgl.ONE;
                    webglkit.ZERO = webgl.ZERO;
                    webglkit.SRC_ALPHA = webgl.SRC_ALPHA;
                    webglkit.SRC_COLOR = webgl.SRC_COLOR;
                    webglkit.ONE_MINUS_SRC_ALPHA = webgl.ONE_MINUS_SRC_ALPHA;
                    webglkit.ONE_MINUS_SRC_COLOR = webgl.ONE_MINUS_SRC_COLOR;
                    webglkit.ONE_MINUS_DST_ALPHA = webgl.ONE_MINUS_DST_ALPHA;
                    webglkit.ONE_MINUS_DST_COLOR = webgl.ONE_MINUS_DST_COLOR;
                    // Extensions
                    //这个扩展会影响bump
                    if (webgl.getExtension) {
                        webglkit.caps.standardDerivatives = (webgl.getExtension('OES_standard_derivatives') !== null);
                        webglkit.caps.pvrtcExtension = webgl.getExtension('WEBGL_compressed_texture_pvrtc');
                        webglkit.caps.atcExtension = webgl.getExtension('WEBGL_compressed_texture_atc');
                        webglkit.caps.textureFloat = (webgl.getExtension('OES_texture_float') !== null);
                    }
                    //各种扩展
                    // webglkit.caps.s3tc = webgl.getExtension('WEBGL_compressed_texture_s3tc');
                    // webglkit.caps.textureFloat = (webgl.getExtension('OES_texture_float') !== null);
                    // webglkit.caps.textureAnisotropicFilterExtension = webgl.getExtension('EXT_texture_filter_anisotropic') || webgl.getExtension('WEBKIT_EXT_texture_filter_anisotropic') || webgl.getExtension('MOZ_EXT_texture_filter_anisotropic');
                    // webglkit.caps.maxAnisotropy = webglkit.caps.textureAnisotropicFilterExtension ? webgl.getParameter(webglkit.caps.textureAnisotropicFilterExtension.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
                    // webglkit.caps.instancedArrays = webgl.getExtension('ANGLE_instanced_arrays');
                    // webglkit.caps.uintIndices = webgl.getExtension('OES_element_index_uint') !== null;
                    // webglkit.caps.fragmentDepthSupported = webgl.getExtension('EXT_frag_depth') !== null;
                    // webglkit.caps.highPrecisionShaderSupported = true;
                    // webglkit.caps.drawBuffersExtension =webgl.getExtension('WEBGL_draw_buffers');
                    // webglkit.caps.textureFloatLinearFiltering = webgl.getExtension('OES_texture_float_linear');
                    // webglkit.caps.textureLOD = webgl.getExtension('EXT_shader_texture_lod');
                }
            };
            webglkit._maxVertexAttribArray = 0;
            webglkit._texNumber = null;
            webglkit.caps = new caps();
            return webglkit;
        }());
        render.webglkit = webglkit;
    })(render = m4m.render || (m4m.render = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var render;
    (function (render) {
        /**
         * @private
         */
        var ShowFaceStateEnum;
        (function (ShowFaceStateEnum) {
            ShowFaceStateEnum[ShowFaceStateEnum["ALL"] = 0] = "ALL";
            ShowFaceStateEnum[ShowFaceStateEnum["CCW"] = 1] = "CCW";
            ShowFaceStateEnum[ShowFaceStateEnum["CW"] = 2] = "CW";
        })(ShowFaceStateEnum = render.ShowFaceStateEnum || (render.ShowFaceStateEnum = {}));
        /**
         * @private
         */
        var DrawModeEnum;
        (function (DrawModeEnum) {
            DrawModeEnum[DrawModeEnum["VboTri"] = 0] = "VboTri";
            DrawModeEnum[DrawModeEnum["VboLine"] = 1] = "VboLine";
            DrawModeEnum[DrawModeEnum["EboTri"] = 2] = "EboTri";
            DrawModeEnum[DrawModeEnum["EboLine"] = 3] = "EboLine";
        })(DrawModeEnum = render.DrawModeEnum || (render.DrawModeEnum = {}));
        /**
         * @private
         */
        var BlendModeEnum;
        (function (BlendModeEnum) {
            BlendModeEnum[BlendModeEnum["Close"] = 0] = "Close";
            BlendModeEnum[BlendModeEnum["Blend"] = 1] = "Blend";
            BlendModeEnum[BlendModeEnum["Blend_PreMultiply"] = 2] = "Blend_PreMultiply";
            BlendModeEnum[BlendModeEnum["Add"] = 3] = "Add";
            BlendModeEnum[BlendModeEnum["Add_PreMultiply"] = 4] = "Add_PreMultiply";
        })(BlendModeEnum = render.BlendModeEnum || (render.BlendModeEnum = {}));
        /**
         * @private
         */
        var glDrawPass = /** @class */ (function () {
            function glDrawPass() {
                this.id = new m4m.framework.resID();
                this.state_showface = ShowFaceStateEnum.CCW;
                this.state_zwrite = false;
                this.state_ztest = false;
                this.state_ztest_method = render.webglkit.LEQUAL;
                this.state_blend = false;
                this.state_blendEquation = 0;
                this.state_blendSrcRGB = 0;
                this.state_blendDestRGB = 0;
                this.state_blendSrcAlpha = 0;
                this.state_blendDestALpha = 0;
                // applyUniformSaved(webgl: WebGL2RenderingContext)
                // {
                //     var texindex = 0;//自动统计使用的贴图
                //     //set uniform
                //     for (var key in this.uniforms)
                //     {
                //         var u = this.uniforms[key];
                //         if (u.type == UniformTypeEnum.Texture)
                //         {
                //             if (this.uniformallchange || u.change)
                //             {
                //                 var tex = u.value != null ? (u.value as ITexture).texture : null;
                //                 webgl.activeTexture(webglkit.GetTextureNumber(webgl, texindex));
                //                 webgl.bindTexture(webgl.TEXTURE_2D, tex);
                //                 webgl.uniform1i(u.location, texindex);
                //             }
                //             texindex++;
                //         }
                //         else if (this.uniformallchange || u.change)
                //         {
                //             if (u.type == UniformTypeEnum.Float)
                //             {
                //                 webgl.uniform1f(u.location, u.value);
                //             }
                //             else if (u.type == UniformTypeEnum.Floatv)
                //             {
                //                 webgl.uniform1fv(u.location, u.value as Float32Array);
                //             }
                //             else if (u.type == UniformTypeEnum.Float4 || u.type == UniformTypeEnum.Float4v)
                //             {
                //                 try
                //                 {
                //                     webgl.uniform4fv(u.location, u.value as Float32Array);
                //                 } catch (e)
                //                 {
                //                     console.error(key + "  " + u.value);
                //                     for (let k in this.uniforms)
                //                     {
                //                         console.error(k);
                //                     }
                //                 }
                //             }
                //             else if (u.type == UniformTypeEnum.Float4x4 || u.type == UniformTypeEnum.Float4x4v)
                //             {
                //                 webgl.uniformMatrix4fv(u.location, false, u.value as Float32Array);
                //             }
                //         }
                //         u.change = false;
                //     }
                //     this.uniformallchange = false;
                // }
                // applyUniform_Float(webgl: WebGL2RenderingContext, key: string, value: number)
                // {
                //     var u = this.uniforms[key];
                //     webgl.uniform1f(u.location, value);
                // }
                // applyUniform_Floatv(webgl: WebGL2RenderingContext, key: string, value: Float32Array)
                // {
                //     var u = this.uniforms[key];
                //     webgl.uniform1fv(u.location, value);
                // }
                // applyUniform_Float4(webgl: WebGL2RenderingContext, key: string, value: math.vector4)
                // {
                //     var u = this.uniforms[key];
                //     webgl.uniform4f(u.location, value.x, value.y, value.z, value.w);
                // }
                // applyUniform_Float4v(webgl: WebGL2RenderingContext, key: string, values: Float32Array)
                // {
                //     var u = this.uniforms[key];
                //     webgl.uniform4fv(u.location, values);
                // }
                // applyUniform_Float4x4(webgl: WebGL2RenderingContext, key: string, value: math.matrix)
                // {
                //     var u = this.uniforms[key];
                //     webgl.uniformMatrix4fv(u.location, false, value.rawData);
                // }
                // applyUniform_Float4x4v(webgl: WebGL2RenderingContext, key: string, values: Float32Array)
                // {
                //     var u = this.uniforms[key];
                //     webgl.uniformMatrix4fv(u.location, false, values);
                // }
                // applyUniform_FloatTexture(webgl: WebGL2RenderingContext, texindex: number, key: string, value: ITexture)
                // {
                //     var u = this.uniforms[key];
                //     var tex = value != null ? (value as ITexture).texture : null;
                //     webgl.activeTexture(webglkit.GetTextureNumber(webgl, texindex));
                //     webgl.bindTexture(webgl.TEXTURE_2D, tex);
                //     webgl.uniform1i(u.location, texindex);
                // }
                // draw(webgl: WebGL2RenderingContext, mesh: glMesh, drawmode: DrawModeEnum = DrawModeEnum.EboTri,
                //     drawindexindex: number = 0, drawbegin: number = 0, drawcount: number = -1)
                // {
                //     this.use(webgl);
                //     //bind attribute &vbo
                //     mesh.bind(webgl, this.program, drawindexindex);
                //     if (drawmode == DrawModeEnum.VboTri)
                //     {
                //         mesh.drawArrayTris(webgl, drawbegin, drawcount);
                //     }
                //     else if (drawmode == DrawModeEnum.VboLine)
                //     {
                //         mesh.drawArrayLines(webgl, drawbegin, drawcount);
                //     }
                //     else if (drawmode == DrawModeEnum.EboTri)
                //     {
                //         mesh.drawElementTris(webgl, drawbegin, drawcount);
                //     }
                //     else if (drawmode == DrawModeEnum.EboLine)
                //     {
                //         mesh.drawElementLines(webgl, drawbegin, drawcount);
                //     }
                // }
                // private getCurDrawState(): string
                // {
                //     let res: string = "";
                //     res = this.formate(this.state_showface.toString(), res);
                //     res = this.formate(this.state_zwrite.toString(), res);
                //     res = this.formate(this.state_ztest.toString(), res);
                //     if (this.state_ztest)
                //     {
                //         res = this.formate(this.state_ztest_method.toString(), res);
                //     } else
                //     {
                //         res = this.formate("ztestnone", res);
                //     }
                //     res = this.formate(this.state_blend.toString(), res);
                //     if (this.state_blend)
                //     {
                //         res = this.formate(this.state_blendEquation.toString(), res);
                //     } else
                //     {
                //         res = this.formate("blendnone", res);
                //     }
                //     // console.log(res);
                //     return res;
                // }
                // private getCurBlendVal(): string
                // {
                //     let res: string = "";
                //     res = this.formate(this.state_blendSrcRGB.toString(), res);
                //     res = this.formate(this.state_blendDestRGB.toString(), res);
                //     res = this.formate(this.state_blendSrcAlpha.toString(), res);
                //     res = this.formate(this.state_blendDestALpha.toString(), res);
                //     return res;
                // }
                // private formate(str: string, out: string)
                // {
                //     return out += str + "_";
                // }
            }
            //static mapUniformDic:{[type:number]:(webgl: WebGL2RenderingContext, key: WebGLUniformLocation, value: any)=>void};
            //uniformallchange: boolean = false;
            glDrawPass.prototype.setProgram = function (program, uniformDefault) {
                if (uniformDefault === void 0) { uniformDefault = false; }
                this.program = program;
                this.mapuniforms = program.mapUniform;
            };
            glDrawPass.prototype.setAlphaBlend = function (mode) {
                this.state_blendMode = mode;
                if (mode == BlendModeEnum.Add) {
                    this.state_blend = true;
                    this.state_blendEquation = render.webglkit.FUNC_ADD;
                    this.state_blendSrcRGB = render.webglkit.SRC_ALPHA;
                    this.state_blendDestRGB = render.webglkit.ONE;
                    this.state_blendSrcAlpha = render.webglkit.SRC_ALPHA;
                    this.state_blendDestALpha = render.webglkit.ONE;
                }
                else if (mode == BlendModeEnum.Add_PreMultiply) {
                    this.state_blend = true;
                    this.state_blendEquation = render.webglkit.FUNC_ADD;
                    this.state_blendSrcRGB = render.webglkit.ONE;
                    this.state_blendDestRGB = render.webglkit.ONE;
                    this.state_blendSrcAlpha = render.webglkit.SRC_ALPHA;
                    this.state_blendDestALpha = render.webglkit.ONE;
                }
                else if (mode == BlendModeEnum.Blend) {
                    this.state_blend = true;
                    this.state_blendEquation = render.webglkit.FUNC_ADD;
                    this.state_blendSrcRGB = render.webglkit.SRC_ALPHA;
                    this.state_blendDestRGB = render.webglkit.ONE_MINUS_SRC_ALPHA;
                    this.state_blendSrcAlpha = render.webglkit.SRC_ALPHA;
                    this.state_blendDestALpha = render.webglkit.ONE;
                }
                else if (mode == BlendModeEnum.Blend_PreMultiply) {
                    this.state_blend = true;
                    this.state_blendEquation = render.webglkit.FUNC_ADD;
                    this.state_blendSrcRGB = render.webglkit.ONE;
                    this.state_blendDestRGB = render.webglkit.ONE_MINUS_SRC_ALPHA;
                    this.state_blendSrcAlpha = render.webglkit.SRC_ALPHA;
                    this.state_blendDestALpha = render.webglkit.ONE;
                }
                else if (mode == BlendModeEnum.Close) {
                    this.state_blend = false;
                }
            };
            //uniform type 验证放到mat setunifom中，这边省去类型验证。
            // //设置uniform save起来
            // uniformFloat(name: string, number: number)
            // {
            //     // var v = this.uniforms[name];
            //     // if (v == null) throw new Error("do not have this uniform");
            //     // if (v.type != UniformTypeEnum.Float) throw new Error("wrong uniform type:" + v.type);
            //     this.uniforms[name].value = number;
            //     //this.uniforms[name].change = true;
            // }
            // uniformFloatv(name: string, numbers: Float32Array)
            // {
            //     // var v = this.uniforms[name];
            //     // if (v == null) throw new Error("do not have this uniform");
            //     // if (v.type != UniformTypeEnum.Floatv) throw new Error("wrong uniform type:" + v.type);
            //     this.uniforms[name].value = numbers;
            //     //this.uniforms[name].change = true;
            // }
            // uniformVec4(name: string, vec: math.vector4)
            // {
            //     // var v = this.uniforms[name];
            //     // if (v == null) throw new Error("do not have this uniform");
            //     // if (v.type != UniformTypeEnum.Float4) throw new Error("wrong uniform type:" + v.type);
            //     var varray = this.uniforms[name].value;
            //     if (varray == null)
            //     {
            //         this.uniforms[name].value = [vec.x, vec.y, vec.z, vec.w];
            //         //varray = this.uniforms[name].value;
            //     }else
            //     {
            //         varray[0] = vec.x;
            //         varray[1] = vec.y;
            //         varray[2] = vec.z;
            //         varray[3] = vec.w;
            //     }
            //     //this.uniforms[name].change = true;
            // }
            // uniformVec4v(name: string, vecdata: Float32Array)
            // {
            //     // var v = this.uniforms[name];
            //     // if (v == null) throw new Error("do not have this uniform");
            //     // if (v.type != UniformTypeEnum.Float4v) throw new Error("wrong uniform type:" + v.type);
            //     this.uniforms[name].value = vecdata;
            //     //this.uniforms[name].change = true;
            // }
            // uniformMatrix(name: string, mat: math.matrix)
            // {
            //     // var v = this.uniforms[name];
            //     // if (v == null) throw new Error("do not have this uniform");
            //     // if (v.type != UniformTypeEnum.Float4x4) throw new Error("wrong uniform type:" + v.type);
            //     this.uniforms[name].value = mat.rawData;
            //     // this.uniforms[name].change = true;
            // }
            // uniformMatrixV(name: string, matdata: Float32Array)
            // {
            //     // var v = this.uniforms[name];
            //     // if (v == null) throw new Error("do not have this uniform");
            //     // if (v.type != UniformTypeEnum.Float4x4v) throw new Error("wrong uniform type:" + v.type);
            //     this.uniforms[name].value = matdata;
            //     // this.uniforms[name].change = true;
            // }
            // uniformTexture(name: string, tex: render.ITexture)
            // {
            //     // var v = this.uniforms[name];
            //     // if (v == null) throw new Error("do not have this uniform");
            //     // if (v.type != UniformTypeEnum.Texture) throw new Error("wrong uniform type:" + v.type);
            //     this.uniforms[name].value = tex;
            //     // this.uniforms[name].change = true;
            // }
            //static textureID: number[] = null;
            //使用材质
            /**
             * 因为ui那边会改变state，所以每次开始渲染场景先将laststatereset。
             */
            glDrawPass.resetLastState = function () {
                this.lastShowFace = -1;
                this.lastZWrite = null;
                this.lastZTest = null;
                this.lastZTestMethod = -1;
                this.lastBlend = null;
                this.lastBlendMode = null;
            };
            glDrawPass.prototype.use = function (webgl) {
                var ID = this.id.getID();
                var lastSame = glDrawPass.lastPassID == ID;
                glDrawPass.lastPassID = ID;
                if (lastSame)
                    return;
                // if (this.state_showface == ShowFaceStateEnum.ALL)
                // {
                //     webgl.disable(webgl.CULL_FACE);
                // }
                // else
                // {
                //     if (this.state_showface == ShowFaceStateEnum.CCW)
                //     {
                //         webgl.frontFace(webgl.CCW);
                //     }
                //     else
                //     {
                //         webgl.frontFace(webgl.CW);
                //     }
                //     webgl.cullFace(webgl.BACK);
                //     webgl.enable(webgl.CULL_FACE);
                // }
                // if (this.state_zwrite)
                // {
                //     webgl.depthMask(true);
                // }
                // else
                // {
                //     webgl.depthMask(false);
                // }
                // if (this.state_ztest)
                // {
                //     webgl.enable(webgl.DEPTH_TEST);
                //     webgl.depthFunc(this.state_ztest_method);
                // }
                // else
                // {
                //     webgl.disable(webgl.DEPTH_TEST);
                // }
                // if (this.state_blend)
                // {
                //     webgl.enable(webgl.BLEND);
                //     webgl.blendEquation(this.state_blendEquation);
                //     //this.webgl.blendFunc(this.webgl.ONE, this.webgl.ONE_MINUS_SRC_ALPHA);
                //     webgl.blendFuncSeparate(this.state_blendSrcRGB, this.state_blendDestRGB,
                //         this.state_blendSrcAlpha, this.state_blendDestALpha);
                // }
                // else
                // {
                //     webgl.disable(webgl.BLEND);
                // }
                if (this.state_showface != glDrawPass.lastShowFace) {
                    glDrawPass.lastShowFace = this.state_showface;
                    if (this.state_showface == ShowFaceStateEnum.ALL) {
                        webgl.disable(webgl.CULL_FACE);
                    }
                    else {
                        if (this.state_showface == ShowFaceStateEnum.CCW) {
                            webgl.frontFace(webgl.CCW);
                        }
                        else {
                            webgl.frontFace(webgl.CW);
                        }
                        webgl.cullFace(webgl.BACK);
                        webgl.enable(webgl.CULL_FACE);
                    }
                }
                if (this.state_zwrite != glDrawPass.lastZWrite) {
                    glDrawPass.lastZWrite = this.state_zwrite;
                    if (this.state_zwrite) {
                        webgl.depthMask(true);
                    }
                    else {
                        webgl.depthMask(false);
                    }
                }
                if (this.state_ztest != glDrawPass.lastZTest) {
                    glDrawPass.lastZTest = this.state_ztest;
                    if (this.state_ztest) {
                        webgl.enable(webgl.DEPTH_TEST);
                    }
                    else {
                        webgl.disable(webgl.DEPTH_TEST);
                    }
                }
                if (this.state_ztest && glDrawPass.lastZTestMethod != this.state_ztest_method) {
                    glDrawPass.lastZTestMethod = this.state_ztest_method;
                    webgl.depthFunc(this.state_ztest_method);
                }
                if (this.state_blend != glDrawPass.lastBlend) {
                    glDrawPass.lastBlend = this.state_blend;
                    if (this.state_blend) {
                        webgl.enable(webgl.BLEND);
                    }
                    else {
                        webgl.disable(webgl.BLEND);
                    }
                }
                if (this.state_blend && glDrawPass.lastBlendMode != this.state_blendMode) {
                    glDrawPass.lastBlendMode = this.state_blendMode;
                    webgl.blendEquation(this.state_blendEquation);
                    //this.webgl.blendFunc(this.webgl.ONE, this.webgl.ONE_MINUS_SRC_ALPHA);
                    webgl.blendFuncSeparate(this.state_blendSrcRGB, this.state_blendDestRGB, this.state_blendSrcAlpha, this.state_blendDestALpha);
                }
                //use program
                this.program.use(webgl);
                // if (applyUniForm)
                // {
                //     this.applyUniformSaved(webgl);
                // }
            };
            glDrawPass.lastShowFace = -1;
            glDrawPass.lastZWrite = null;
            glDrawPass.lastZTest = null;
            glDrawPass.lastZTestMethod = -1;
            glDrawPass.lastBlend = null;
            glDrawPass.lastBlendMode = null;
            glDrawPass.useStateMap = {};
            glDrawPass.lastPassID = -1;
            return glDrawPass;
        }());
        render.glDrawPass = glDrawPass;
    })(render = m4m.render || (m4m.render = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var render;
    (function (render) {
        /**
         * 顶点格式类型
         */
        var VertexFormatMask;
        (function (VertexFormatMask) {
            VertexFormatMask[VertexFormatMask["Position"] = 1] = "Position";
            VertexFormatMask[VertexFormatMask["Normal"] = 2] = "Normal";
            VertexFormatMask[VertexFormatMask["Tangent"] = 4] = "Tangent";
            VertexFormatMask[VertexFormatMask["Color"] = 8] = "Color";
            VertexFormatMask[VertexFormatMask["UV0"] = 16] = "UV0";
            VertexFormatMask[VertexFormatMask["UV1"] = 32] = "UV1";
            VertexFormatMask[VertexFormatMask["BlendIndex4"] = 64] = "BlendIndex4";
            VertexFormatMask[VertexFormatMask["BlendWeight4"] = 128] = "BlendWeight4";
            VertexFormatMask[VertexFormatMask["ColorEX"] = 256] = "ColorEX";
        })(VertexFormatMask = render.VertexFormatMask || (render.VertexFormatMask = {}));
        /**
         * 顶点作色器中的地址 (最大 0 - 15)
         */
        var VertexLocation;
        (function (VertexLocation) {
            /** 顶点位置坐标地址 */
            VertexLocation[VertexLocation["Position_L"] = 0] = "Position_L";
            /** 顶点法线坐标地址 */
            VertexLocation[VertexLocation["Normal_L"] = 1] = "Normal_L";
            /** 顶点切线坐标地址 */
            VertexLocation[VertexLocation["Tangent_L"] = 2] = "Tangent_L";
            /** 顶点颜色地址 */
            VertexLocation[VertexLocation["Color_L"] = 3] = "Color_L";
            /** 顶点第一个纹理坐标地址 */
            VertexLocation[VertexLocation["UV0_L"] = 4] = "UV0_L";
            /** 顶点第二个纹理坐标地址 */
            VertexLocation[VertexLocation["UV1_L"] = 5] = "UV1_L";
            /** 顶点蒙皮索引 */
            VertexLocation[VertexLocation["BlendIndex4_L"] = 6] = "BlendIndex4_L";
            /** 顶点蒙皮权重 */
            VertexLocation[VertexLocation["BlendWeight4_L"] = 7] = "BlendWeight4_L";
            /** 顶点第二个颜色地址 */
            VertexLocation[VertexLocation["ColorEX_L"] = 8] = "ColorEX_L";
            //mesh 拓展预览位置 ....
            /** GPUInstance 内建开始地址 */
            VertexLocation[VertexLocation["GPUInstanceStart"] = 12] = "GPUInstanceStart";
            /** GPUInstance 偏移(toWorld)矩阵  */
            VertexLocation[VertexLocation["InstanceOffsetMatrix_L"] = 12] = "InstanceOffsetMatrix_L";
        })(VertexLocation = render.VertexLocation || (render.VertexLocation = {}));
        /**
         * @private
         */
        var number4 = /** @class */ (function () {
            function number4() {
            }
            number4.set = function (data, _v0, _v1, _v2, _v3) {
                data.v0 = _v0;
                data.v1 = _v1;
                data.v2 = _v2;
                data.v3 = _v3;
            };
            return number4;
        }());
        render.number4 = number4;
        /**
         * @private
         */
        var MeshTypeEnum;
        (function (MeshTypeEnum) {
            MeshTypeEnum[MeshTypeEnum["Static"] = 0] = "Static";
            MeshTypeEnum[MeshTypeEnum["Dynamic"] = 1] = "Dynamic";
            MeshTypeEnum[MeshTypeEnum["Stream"] = 2] = "Stream";
        })(MeshTypeEnum = render.MeshTypeEnum || (render.MeshTypeEnum = {}));
        /**
         * @private
         */
        var drawInfo = /** @class */ (function () {
            function drawInfo() {
                this.triCount = 0;
                this.vboCount = 0;
                this.renderCount = 0;
            }
            Object.defineProperty(drawInfo, "ins", {
                get: function () {
                    if (drawInfo._ins == null)
                        drawInfo._ins = new drawInfo();
                    return drawInfo._ins;
                },
                enumerable: false,
                configurable: true
            });
            return drawInfo;
        }());
        render.drawInfo = drawInfo;
        /**
         * @private
         */
        var glMesh = /** @class */ (function () {
            function glMesh(webgl) {
                this.eboDataType = WebGL2RenderingContext.UNSIGNED_SHORT;
                this.eboElementSize = 2;
                this.indexCount = 0;
                this.vertexFormat = VertexFormatMask.Position;
                this.webgl = webgl != null ? webgl : m4m.framework.sceneMgr.app.webgl;
            }
            /**
             * 获取 顶点着色器中 Attribute (in) 的地址
             * @param vf 顶点格式标记
             * @returns Attribute (in) 的地址
             */
            glMesh.getAttributeLocation = function (vf) {
                var map = this.AttributeLocationMap;
                if (!map) {
                    map = {};
                    map[VertexFormatMask.Position] = VertexLocation.Position_L;
                    map[VertexFormatMask.Normal] = VertexLocation.Normal_L;
                    map[VertexFormatMask.Tangent] = VertexLocation.Tangent_L;
                    map[VertexFormatMask.Color] = VertexLocation.Color_L;
                    map[VertexFormatMask.UV0] = VertexLocation.UV0_L;
                    map[VertexFormatMask.UV1] = VertexLocation.UV1_L;
                    map[VertexFormatMask.BlendIndex4] = VertexLocation.BlendIndex4_L;
                    map[VertexFormatMask.BlendWeight4] = VertexLocation.BlendWeight4_L;
                    map[VertexFormatMask.ColorEX] = VertexLocation.ColorEX_L;
                }
                return map[vf];
            };
            glMesh.prototype.initBuffer = function (webgl, vf, vertexCount, mode) {
                if (mode === void 0) { mode = MeshTypeEnum.Static; }
                if (this.vbo != null)
                    throw new Error("you can only initbuffer once.");
                if (mode == MeshTypeEnum.Static)
                    this.mode = webgl.STATIC_DRAW;
                else if (mode == MeshTypeEnum.Dynamic)
                    this.mode = webgl.DYNAMIC_DRAW;
                else if (mode == MeshTypeEnum.Stream)
                    this.mode = webgl.STREAM_DRAW;
                this.vertexFormat = vf;
                this.vertexCount = vertexCount;
                if (vertexCount > 0) {
                    this.vertexByteSize = render.meshData.calcByteSize(vf);
                    this.vbo = webgl.createBuffer();
                    webgl.bindBuffer(webgl.ARRAY_BUFFER, this.vbo);
                    webgl.bufferData(webgl.ARRAY_BUFFER, vertexCount * this.vertexByteSize, this.mode);
                }
                // this.indexCounts = []
                // this.ebos = [];
            };
            glMesh.prototype.addIndex = function (webgl, indexcount) {
                // let index = this.ebos.length;
                var index = 0;
                var _ebo = webgl.createBuffer();
                webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, _ebo);
                webgl.bufferData(webgl.ELEMENT_ARRAY_BUFFER, indexcount * 2, this.mode);
                // this.ebos.push(_ebo);
                this.ebo = _ebo;
                // this.indexCounts.push(indexcount);
                this.indexCount = indexcount;
                return index;
            };
            glMesh.prototype.resetVboSize = function (webgl, vertexCount) {
                this.vertexCount = vertexCount;
                webgl.bindBuffer(webgl.ARRAY_BUFFER, this.vbo);
                webgl.bufferData(webgl.ARRAY_BUFFER, vertexCount * this.vertexByteSize, this.mode);
            };
            glMesh.prototype.resetEboSize = function (webgl, eboindex, indexcount) {
                if (!this.ebo)
                    return;
                // this.indexCounts[eboindex] = indexcount;
                this.indexCount = indexcount;
                // webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, this.ebos[eboindex]);
                webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, this.ebo);
                webgl.bufferData(webgl.ELEMENT_ARRAY_BUFFER, indexcount * 2, this.mode);
            };
            glMesh.prototype.dispose = function () {
                // if (this.ebos) {
                //     for (var i = 0; i < this.ebos.length; i++)
                //         webgl.deleteBuffer(this.ebos[i]);
                //     this.ebos.length = 0;
                // }
                this.webgl.deleteBuffer(this.vbo);
                this.webgl.deleteBuffer(this.ebo);
                this.webgl.deleteVertexArray(this.vao);
                this.ebo = null;
                this.vbo = null;
                this.vao = null;
            };
            glMesh.prototype.caclByteLength = function () {
                var total = 0;
                total += this.vertexByteSize * this.vertexCount;
                // for (let k in this.indexCounts) {
                //     total += this.indexCounts[k] * 2;
                // }
                total += this.indexCount * 2;
                return total;
            };
            // bindVboBuffer(webgl: WebGL2RenderingContext) {
            //     webgl.bindBuffer(webgl.ARRAY_BUFFER, this.vbo);
            // }
            // bind(webgl: WebGL2RenderingContext, shadercode: glProgram, bindEbo: number = 0) {
            //     // this.bindIndex = bindEbo;
            //     // if (bindEbo >= 0) {
            //     //     webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, this.ebos[bindEbo]);
            //     // }
            //     if (this.ebo) {
            //         webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, this.ebo);
            //     }
            //     var total = this.vertexByteSize;
            //     //绑定vbo和shader顶点格式，这部分应该要区分材质改变与参数改变，可以少切换一些状态
            //     var seek = 0;
            //     // var channel = 0;
            //     {//pos
            //         if (shadercode.posPos >= 0) {
            //             webgl.enableVertexAttribArray(shadercode.posPos);
            //             webgl.vertexAttribPointer(shadercode.posPos, 3, webgl.FLOAT, false, total, seek);
            //             // channel++;
            //         }
            //         seek += 12;
            //     }
            //     if (this.vertexFormat & VertexFormatMask.Normal) {
            //         if (shadercode.posNormal >= 0) {
            //             webgl.enableVertexAttribArray(shadercode.posNormal);
            //             webgl.vertexAttribPointer(shadercode.posNormal, 3, webgl.FLOAT, true, total, seek);
            //             // channel++;
            //         }
            //         seek += 12;
            //     }
            //     else if (shadercode.posNormal >= 0)//需要处理mesh里没有这个通道，但是shader里有的情况
            //     {
            //         webgl.disableVertexAttribArray(shadercode.posNormal);
            //         // channel++;
            //     }
            //     if (this.vertexFormat & VertexFormatMask.Tangent) {
            //         if (shadercode.posTangent >= 0) {
            //             webgl.enableVertexAttribArray(shadercode.posTangent);
            //             webgl.vertexAttribPointer(shadercode.posTangent, 3, webgl.FLOAT, true, total, seek);
            //             // channel++;
            //         }
            //         seek += 12;
            //     }
            //     else if (shadercode.posTangent >= 0)//需要处理mesh里没有这个通道，但是shader里有的情况
            //     {
            //         webgl.disableVertexAttribArray(shadercode.posTangent);
            //         // channel++;
            //     }
            //     if (this.vertexFormat & VertexFormatMask.Color) {
            //         if (shadercode.posColor >= 0) {
            //             webgl.enableVertexAttribArray(shadercode.posColor);
            //             webgl.vertexAttribPointer(shadercode.posColor, 4, webgl.FLOAT, false, total, seek);
            //             // channel++;
            //         }
            //         seek += 16;
            //     }
            //     else if (shadercode.posColor >= 0) {
            //         webgl.disableVertexAttribArray(shadercode.posColor);
            //         // channel++;
            //     }
            //     if (this.vertexFormat & VertexFormatMask.UV0) {
            //         if (shadercode.posUV0 >= 0) {
            //             webgl.enableVertexAttribArray(shadercode.posUV0);
            //             webgl.vertexAttribPointer(shadercode.posUV0, 2, webgl.FLOAT, false, total, seek);
            //             // channel++;
            //         }
            //         seek += 8;
            //     }
            //     else if (shadercode.posUV0 >= 0) {
            //         webgl.disableVertexAttribArray(shadercode.posUV0);
            //         // channel++;
            //     }
            //     if (this.vertexFormat & VertexFormatMask.UV1) {
            //         if (shadercode.posUV2 >= 0) {
            //             webgl.enableVertexAttribArray(shadercode.posUV2);
            //             webgl.vertexAttribPointer(shadercode.posUV2, 2, webgl.FLOAT, false, total, seek);
            //             // channel++;
            //         }
            //         seek += 8;
            //     }
            //     else if (shadercode.posUV2 >= 0) {
            //         webgl.disableVertexAttribArray(shadercode.posUV2);
            //         // channel++;
            //     }
            //     if (this.vertexFormat & VertexFormatMask.BlendIndex4) {
            //         if (shadercode.posBlendIndex4 >= 0) {
            //             webgl.enableVertexAttribArray(shadercode.posBlendIndex4);
            //             webgl.vertexAttribPointer(shadercode.posBlendIndex4, 4, webgl.FLOAT, false, total, seek);
            //             // channel++;
            //         }
            //         seek += 16;
            //     }
            //     else if (shadercode.posBlendIndex4 >= 0) {
            //         webgl.disableVertexAttribArray(shadercode.posBlendIndex4);
            //         // channel++;
            //     }
            //     if (this.vertexFormat & VertexFormatMask.BlendWeight4) {
            //         if (shadercode.posBlendWeight4 >= 0) {
            //             webgl.enableVertexAttribArray(shadercode.posBlendWeight4);
            //             webgl.vertexAttribPointer(shadercode.posBlendWeight4, 4, webgl.FLOAT, false, total, seek);
            //             // channel++;
            //         }
            //         seek += 16;
            //     }
            //     else if (shadercode.posBlendWeight4 >= 0) {
            //         webgl.disableVertexAttribArray(shadercode.posBlendWeight4);
            //         // channel++;
            //     }
            //     if (this.vertexFormat & VertexFormatMask.ColorEX) {
            //         if (shadercode.posColorEx >= 0) {
            //             webgl.enableVertexAttribArray(shadercode.posColorEx);
            //             webgl.vertexAttribPointer(shadercode.posColorEx, 4, webgl.FLOAT, false, total, seek);
            //             // channel++;
            //         }
            //         seek += 16;
            //     }
            //     else if (shadercode.posColorEx >= 0) {
            //         webgl.disableVertexAttribArray(shadercode.posColorEx);
            //         // channel++;
            //     }
            //     // webglkit.SetMaxVertexAttribArray(webgl, channel);
            // }
            glMesh.prototype.uploadVertexSubData = function (webgl, varray, offset) {
                if (offset === void 0) { offset = 0; }
                webgl.bindBuffer(webgl.ARRAY_BUFFER, this.vbo);
                webgl.bufferSubData(webgl.ARRAY_BUFFER, offset, varray);
            };
            glMesh.prototype.uploadVertexData = function (webgl, varray) {
                webgl.bindBuffer(webgl.ARRAY_BUFFER, this.vbo);
                webgl.bufferData(webgl.ARRAY_BUFFER, varray, this.mode);
            };
            glMesh.prototype.uploadIndexSubData = function (webgl, eboindex, data, offset) {
                if (offset === void 0) { offset = 0; }
                if (!this.ebo)
                    return;
                // webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, this.ebos[eboindex]);
                webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, this.ebo);
                webgl.bufferSubData(webgl.ELEMENT_ARRAY_BUFFER, offset, data);
            };
            glMesh.prototype.uploadIndexData = function (webgl, eboindex, data, dataType) {
                if (dataType === void 0) { dataType = WebGL2RenderingContext.UNSIGNED_SHORT; }
                if (!this.ebo)
                    return;
                // this.eboDataType = dataType;
                var _dType = WebGL2RenderingContext.UNSIGNED_SHORT;
                this.eboElementSize = 2;
                //webgl2 支持 32模式了, 通过类型判断是否为uint32
                if (data && data instanceof Uint32Array) {
                    _dType = WebGL2RenderingContext.UNSIGNED_INT;
                    this.eboElementSize = 4;
                }
                this.eboDataType = _dType;
                // this.eboDataType = dataType;
                // webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, this.ebos[eboindex]);
                webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, this.ebo);
                webgl.bufferData(webgl.ELEMENT_ARRAY_BUFFER, data, this.mode);
            };
            /** 顶点数组绘制三角面 */
            glMesh.prototype.drawArrayTris = function (webgl, start, count, instanceCount) {
                if (start === void 0) { start = 0; }
                if (count === void 0) { count = -1; }
                if (instanceCount === void 0) { instanceCount = 1; }
                if (count < 0)
                    count = ((this.vertexCount / 3) | 0) * 3;
                drawInfo.ins.triCount += count / 3;
                drawInfo.ins.renderCount++;
                //model
                if (instanceCount > 1 && webgl.drawArraysInstanced != null) {
                    webgl.drawArraysInstanced(webgl.TRIANGLES, start, count, instanceCount);
                }
                else {
                    webgl.drawArrays(webgl.TRIANGLES, start, count);
                }
            };
            /** 顶点数组绘制线段 */
            glMesh.prototype.drawArrayLines = function (webgl, start, count, instanceCount) {
                if (start === void 0) { start = 0; }
                if (count === void 0) { count = -1; }
                if (instanceCount === void 0) { instanceCount = 1; }
                if (count < 0)
                    count = ((this.vertexCount / 2) | 0) * 2;
                drawInfo.ins.renderCount++;
                //model
                if (instanceCount > 1 && webgl.drawArraysInstanced != null) {
                    webgl.drawArraysInstanced(webgl.LINES, start, count, instanceCount);
                }
                else {
                    webgl.drawArrays(webgl.LINES, start, count);
                }
            };
            /** EBO 绘制三角面 */
            glMesh.prototype.drawElementTris = function (webgl, start, count, instanceCount) {
                if (start === void 0) { start = 0; }
                if (count === void 0) { count = -1; }
                if (instanceCount === void 0) { instanceCount = 1; }
                // if (count < 0) count = ((this.indexCounts[this.bindIndex] / 3) | 0) * 3;
                if (count < 0)
                    count = ((this.indexCount / 3) | 0) * 3;
                drawInfo.ins.triCount += count / 3;
                drawInfo.ins.renderCount++;
                //下面的*2 是 写死 16bit的地址
                if (instanceCount > 1 && webgl.drawElementsInstanced != null) {
                    webgl.drawElementsInstanced(webgl.TRIANGLES, count, this.eboDataType, start * this.eboElementSize, instanceCount);
                }
                else {
                    webgl.drawElements(webgl.TRIANGLES, count, this.eboDataType, start * this.eboElementSize);
                }
            };
            /** EBO 绘制线段 */
            glMesh.prototype.drawElementLines = function (webgl, start, count, instanceCount) {
                if (start === void 0) { start = 0; }
                if (count === void 0) { count = -1; }
                if (instanceCount === void 0) { instanceCount = 1; }
                // if (count < 0) count = ((this.indexCounts[this.bindIndex] / 2) | 0) * 2;
                if (count < 0)
                    count = ((this.indexCount / 2) | 0) * 2;
                drawInfo.ins.renderCount++;
                if (instanceCount > 1 && webgl.drawElementsInstanced != null) {
                    webgl.drawElementsInstanced(webgl.LINES, count, this.eboDataType, start * this.eboElementSize, instanceCount);
                }
                else {
                    webgl.drawElements(webgl.LINES, count, this.eboDataType, start * this.eboElementSize);
                }
            };
            /** 初始化VAO */
            glMesh.prototype.initVAO = function () {
                var webgl = this.webgl;
                if (this.vao)
                    webgl.deleteVertexArray(this.vao); //给一个新的vao
                this.vao = webgl.createVertexArray();
                var vf = this.vertexFormat;
                //bind
                this.onVAO();
                //in
                webgl.bindBuffer(webgl.ARRAY_BUFFER, this.vbo);
                var total = this.vertexByteSize;
                var seek = 0;
                var posLocation = glMesh.getAttributeLocation(vf & VertexFormatMask.Position);
                if (posLocation != null) {
                    webgl.enableVertexAttribArray(posLocation);
                    webgl.vertexAttribPointer(posLocation, 3, webgl.FLOAT, false, total, seek);
                    seek += 12;
                }
                var normalLocation = glMesh.getAttributeLocation(vf & VertexFormatMask.Normal);
                if (normalLocation != null) {
                    webgl.enableVertexAttribArray(normalLocation);
                    webgl.vertexAttribPointer(normalLocation, 3, webgl.FLOAT, true, total, seek);
                    seek += 12;
                }
                var tangentLocation = glMesh.getAttributeLocation(vf & VertexFormatMask.Tangent);
                if (tangentLocation != null) {
                    webgl.enableVertexAttribArray(tangentLocation);
                    webgl.vertexAttribPointer(tangentLocation, 3, webgl.FLOAT, true, total, seek);
                    seek += 12;
                }
                var colorLocation = glMesh.getAttributeLocation(vf & VertexFormatMask.Color);
                if (colorLocation != null) {
                    webgl.enableVertexAttribArray(colorLocation);
                    webgl.vertexAttribPointer(colorLocation, 4, webgl.FLOAT, false, total, seek);
                    seek += 16;
                }
                var uv0Location = glMesh.getAttributeLocation(vf & VertexFormatMask.UV0);
                if (uv0Location != null) {
                    webgl.enableVertexAttribArray(uv0Location);
                    webgl.vertexAttribPointer(uv0Location, 2, webgl.FLOAT, false, total, seek);
                    seek += 8;
                }
                var uv1Location = glMesh.getAttributeLocation(vf & VertexFormatMask.UV1);
                if (uv1Location != null) {
                    webgl.enableVertexAttribArray(uv1Location);
                    webgl.vertexAttribPointer(uv1Location, 2, webgl.FLOAT, false, total, seek);
                    seek += 8;
                }
                var blendIndex4Location = glMesh.getAttributeLocation(vf & VertexFormatMask.BlendIndex4);
                if (blendIndex4Location != null) {
                    webgl.enableVertexAttribArray(blendIndex4Location);
                    webgl.vertexAttribPointer(blendIndex4Location, 4, webgl.FLOAT, false, total, seek);
                    seek += 16;
                }
                var blendWeight4Location = glMesh.getAttributeLocation(vf & VertexFormatMask.BlendWeight4);
                if (blendWeight4Location != null) {
                    webgl.enableVertexAttribArray(blendWeight4Location);
                    webgl.vertexAttribPointer(blendWeight4Location, 4, webgl.FLOAT, false, total, seek);
                    seek += 16;
                }
                var colorEXLocation = glMesh.getAttributeLocation(vf & VertexFormatMask.ColorEX);
                if (colorEXLocation != null) {
                    webgl.enableVertexAttribArray(colorEXLocation);
                    webgl.vertexAttribPointer(colorEXLocation, 4, webgl.FLOAT, false, total, seek);
                    seek += 16;
                }
                //ebo
                if (this.ebo) {
                    webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, this.ebo);
                }
                this.offVAO();
            };
            /** 打开 VAO */
            glMesh.prototype.onVAO = function () {
                if (!this.vao)
                    return;
                this.webgl.bindVertexArray(this.vao);
            };
            /** 关闭 VAO */
            glMesh.prototype.offVAO = function () {
                this.webgl.bindVertexArray(null);
            };
            return glMesh;
        }());
        render.glMesh = glMesh;
    })(render = m4m.render || (m4m.render = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var render;
    (function (render) {
        /**
         * @private
         */
        var meshData = /** @class */ (function () {
            function meshData() {
                /** 三角形索引使用 uint32 模式，默认 false */
                this.triIndexUint32Mode = true;
                this._segmentSize = 0;
            }
            Object.defineProperty(meshData.prototype, "isBufferDataMode", {
                /** 数据是缓冲区模式 */
                get: function () { return this.vertexBufferData != null; },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(meshData.prototype, "vertexBufferData", {
                /** 顶点数据buffer */
                get: function () { return this._vertexBufferData; },
                set: function (val) {
                    this._vertexBufferData = val;
                    this._segmentSize = this.getSegmentSize();
                },
                enumerable: false,
                configurable: true
            });
            ;
            ;
            Object.defineProperty(meshData.prototype, "tmpVArr", {
                // private tmpVArr: Float32Array;
                // private tmpInxArr: Uint16Array;
                /**
                 * 请使用 vertexBufferData ,为了兼容工具链暂时保留
                 * @deprecated 遗弃的接口
                 */
                get: function () { return this.vertexBufferData; },
                set: function (val) { this.vertexBufferData = val; },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(meshData.prototype, "tmpInxArr", {
                /**
                 * 请使用 triIndexBufferData ,为了兼容工具链暂时保留
                 * @deprecated 遗弃的接口
                 */
                get: function () { return this.triIndexBufferData; },
                set: function (val) { this.triIndexBufferData = val; },
                enumerable: false,
                configurable: true
            });
            meshData.addQuadPos = function (data, quad) {
                var istart = data.pos.length;
                meshData.addQuadVec3(data.pos, quad);
                data.trisindex.push(istart + 0);
                data.trisindex.push(istart + 1);
                data.trisindex.push(istart + 2);
                data.trisindex.push(istart + 2);
                data.trisindex.push(istart + 1);
                data.trisindex.push(istart + 3);
            };
            meshData.addQuadPos_Quad = function (data, quad) {
                var istart = data.pos.length;
                meshData.addQuadVec3(data.pos, quad);
                data.trisindex.push(istart + 0);
                data.trisindex.push(istart + 1);
                data.trisindex.push(istart + 3);
                data.trisindex.push(istart + 2);
            };
            meshData.addQuadVec3ByValue = function (array, value) {
                for (var i = 0; i < 4; i++) {
                    var v = m4m.math.pool.clone_vector3(value);
                    array.push(v);
                }
            };
            meshData.addQuadVec3 = function (array, quad) {
                array.push(quad[0]);
                array.push(quad[1]);
                array.push(quad[2]);
                array.push(quad[3]);
            };
            meshData.addQuadVec2 = function (array, quad) {
                array.push(quad[0]);
                array.push(quad[1]);
                array.push(quad[2]);
                array.push(quad[3]);
            };
            meshData.genQuad = function (size) {
                var half = size * 0.5;
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                meshData.addQuadVec3ByValue(data.normal, new m4m.math.vector3(0, 0, 1));
                meshData.addQuadPos(data, [
                    new m4m.math.vector3(-half, half, 0),
                    new m4m.math.vector3(-half, -half, 0),
                    new m4m.math.vector3(half, half, 0),
                    new m4m.math.vector3(half, -half, 0)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new m4m.math.vector2(0, 1),
                    new m4m.math.vector2(0, 0),
                    new m4m.math.vector2(1, 1),
                    new m4m.math.vector2(1, 0)
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new m4m.math.vector3(1, 0, 0));
                return data;
            };
            meshData.genQuad_forparticle = function (size) {
                var half = size * 0.5;
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                meshData.addQuadVec3ByValue(data.normal, new m4m.math.vector3(0, 0, 1));
                meshData.addQuadPos(data, [
                    new m4m.math.vector3(0, half, 0),
                    new m4m.math.vector3(0, -half, 0),
                    new m4m.math.vector3(2 * half, half, 0),
                    new m4m.math.vector3(2 * half, -half, 0)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new m4m.math.vector2(0, 0),
                    new m4m.math.vector2(0, 1),
                    new m4m.math.vector2(1, 0),
                    new m4m.math.vector2(1, 1)
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new m4m.math.vector3(1, 0, 0));
                return data;
            };
            meshData.genPlaneCCW = function (size) {
                var half = size * 0.5;
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                meshData.addQuadVec3ByValue(data.normal, new m4m.math.vector3(0, 1, 0));
                meshData.addQuadPos(data, [
                    new m4m.math.vector3(-half, 0, half),
                    new m4m.math.vector3(-half, 0, -half),
                    new m4m.math.vector3(half, 0, half),
                    new m4m.math.vector3(half, 0, -half)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new m4m.math.vector2(0, 0),
                    new m4m.math.vector2(0, 1),
                    new m4m.math.vector2(1, 0),
                    new m4m.math.vector2(1, 1)
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new m4m.math.vector3(1, 0, 0));
                return data;
            };
            meshData.genCylinderCCW = function (height, radius, segment) {
                if (segment === void 0) { segment = 20; }
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.uv = [];
                var normal = new m4m.math.vector3(0, 1, 0);
                for (var s = 0; s < 4; s++) {
                    var y = (s < 2 ? 0.5 : -0.5) * height;
                    if (s == 0)
                        normal = new m4m.math.vector3(0, 1, 0);
                    else if (s == 3)
                        normal = new m4m.math.vector3(0, -1, 0);
                    for (var i = 0; i < segment; i++) {
                        var r = i / segment * Math.PI * 2;
                        var x = Math.sin(r);
                        var z = Math.cos(r);
                        if (s == 1 || s == 2)
                            normal = new m4m.math.vector3(x, 0, z);
                        data.pos.push(new m4m.math.vector3(x * radius, y, z * radius));
                        var vn = m4m.math.pool.clone_vector3(normal);
                        data.normal.push(vn);
                        if (s == 0 || s == 3) {
                            data.uv.push(new m4m.math.vector2(x / 2 + 0.5, z / 2 + 0.5));
                        }
                        else {
                            data.uv.push(new m4m.math.vector2(i / segment, y < 0 ? 0 : 1));
                        }
                    }
                }
                var itop = data.pos.length;
                data.pos.push(new m4m.math.vector3(0, 0.5 * height, 0));
                data.normal.push(new m4m.math.vector3(0, 1, 0));
                data.uv.push(new m4m.math.vector2(0.5, 0.5));
                var ibottom = data.pos.length;
                data.pos.push(new m4m.math.vector3(0, -0.5 * height, 0));
                data.normal.push(new m4m.math.vector3(0, -1, 0));
                data.uv.push(new m4m.math.vector2(0.5, 0.5));
                for (var i = 0; i < segment; i++) {
                    //top
                    data.trisindex.push(itop);
                    data.trisindex.push(i == segment - 1 ? segment * 0 + 0 : segment * 0 + i + 1);
                    data.trisindex.push(segment * 0 + i + 0);
                    //bottom
                    data.trisindex.push(ibottom);
                    data.trisindex.push(segment * 3 + i + 0);
                    data.trisindex.push(i == segment - 1 ? segment * 3 + 0 : segment * 3 + i + 1);
                    //side
                    var t = segment * 1 + i;
                    var t2 = i == segment - 1 ? segment * 1 + 0 : segment * 1 + i + 1;
                    var b = segment * 2 + i;
                    var b2 = i == segment - 1 ? segment * 2 + 0 : segment * 2 + i + 1;
                    data.trisindex.push(t);
                    data.trisindex.push(t2);
                    data.trisindex.push(b);
                    data.trisindex.push(t2);
                    data.trisindex.push(b2);
                    data.trisindex.push(b);
                }
                return data;
            };
            meshData.genPyramid = function (height, halfsize) {
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.uv = [];
                var vec1 = new m4m.math.vector3();
                var vec2 = new m4m.math.vector3();
                var vec3 = new m4m.math.vector3();
                var vec4 = new m4m.math.vector3();
                var vec5 = new m4m.math.vector3(0, -1, 0);
                var uvxx = new m4m.math.vector2(0.5, 0.5);
                var uv00 = new m4m.math.vector2(0, 0);
                var uv01 = new m4m.math.vector2(0, 1);
                var uv10 = new m4m.math.vector2(1, 0);
                var uv11 = new m4m.math.vector2(1, 1);
                var ipos = 0;
                data.pos.push(new m4m.math.vector3(-halfsize, -height * 0.5, -halfsize));
                data.pos.push(new m4m.math.vector3(0, height * 0.5, 0));
                data.pos.push(new m4m.math.vector3(halfsize, -height * 0.5, -halfsize));
                m4m.math.vec3Cross(new m4m.math.vector3(halfsize, height, halfsize), new m4m.math.vector3(halfsize, -height, -halfsize), vec1);
                data.normal.push(vec1);
                data.normal.push(vec1);
                data.normal.push(vec1);
                data.uv.push(uv00);
                data.uv.push(uvxx);
                data.uv.push(uv01);
                data.trisindex.push(ipos);
                data.trisindex.push(ipos + 2);
                data.trisindex.push(ipos + 1);
                ipos += 3;
                data.pos.push(new m4m.math.vector3(halfsize, -height * 0.5, -halfsize));
                data.pos.push(new m4m.math.vector3(0, height * 0.5, 0));
                data.pos.push(new m4m.math.vector3(halfsize, -height * 0.5, halfsize));
                m4m.math.vec3Cross(new m4m.math.vector3(-halfsize, height, halfsize), new m4m.math.vector3(halfsize, -height, halfsize), vec2);
                data.normal.push(vec2);
                data.normal.push(vec2);
                data.normal.push(vec2);
                data.uv.push(uv01);
                data.uv.push(uvxx);
                data.uv.push(uv11);
                data.trisindex.push(ipos);
                data.trisindex.push(ipos + 2);
                data.trisindex.push(ipos + 1);
                ipos += 3;
                data.pos.push(new m4m.math.vector3(halfsize, -height * 0.5, halfsize));
                data.pos.push(new m4m.math.vector3(0, height * 0.5, 0));
                data.pos.push(new m4m.math.vector3(-halfsize, -height * 0.5, halfsize));
                m4m.math.vec3Cross(new m4m.math.vector3(-halfsize, height, -halfsize), new m4m.math.vector3(-halfsize, -height, halfsize), vec3);
                data.normal.push(vec3);
                data.normal.push(vec3);
                data.normal.push(vec3);
                data.uv.push(uv11);
                data.uv.push(uvxx);
                data.uv.push(uv10);
                data.trisindex.push(ipos);
                data.trisindex.push(ipos + 2);
                data.trisindex.push(ipos + 1);
                ipos += 3;
                data.pos.push(new m4m.math.vector3(-halfsize, -height * 0.5, halfsize));
                data.pos.push(new m4m.math.vector3(0, height * 0.5, 0));
                data.pos.push(new m4m.math.vector3(-halfsize, -height * 0.5, -halfsize));
                m4m.math.vec3Cross(new m4m.math.vector3(halfsize, height, -halfsize), new m4m.math.vector3(-halfsize, -height, -halfsize), vec4);
                data.normal.push(vec4);
                data.normal.push(vec4);
                data.normal.push(vec4);
                data.uv.push(uv10);
                data.uv.push(uvxx);
                data.uv.push(uv00);
                data.trisindex.push(ipos);
                data.trisindex.push(ipos + 2);
                data.trisindex.push(ipos + 1);
                ipos += 3;
                data.pos.push(new m4m.math.vector3(-halfsize, -height * 0.5, -halfsize));
                data.pos.push(new m4m.math.vector3(halfsize, -height * 0.5, -halfsize));
                data.pos.push(new m4m.math.vector3(halfsize, -height * 0.5, halfsize));
                data.pos.push(new m4m.math.vector3(-halfsize, -height * 0.5, halfsize));
                data.normal.push(vec5);
                data.normal.push(vec5);
                data.normal.push(vec5);
                data.normal.push(vec5);
                data.uv.push(uv00);
                data.uv.push(uv10);
                data.uv.push(uv11);
                data.uv.push(uv01);
                data.trisindex.push(ipos);
                data.trisindex.push(ipos + 2);
                data.trisindex.push(ipos + 1);
                data.trisindex.push(ipos + 3);
                data.trisindex.push(ipos + 2);
                data.trisindex.push(ipos);
                ipos += 4;
                return data;
            };
            meshData.genSphereCCW = function (radius, widthSegments, heightSegments) {
                if (radius === void 0) { radius = 1; }
                if (widthSegments === void 0) { widthSegments = 24; }
                if (heightSegments === void 0) { heightSegments = 12; }
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                widthSegments = Math.max(3, Math.floor(widthSegments));
                heightSegments = Math.max(2, Math.floor(heightSegments));
                var ix, iy;
                var index = 0;
                var grid = [];
                var vertex = new m4m.math.vector3();
                var normal = new m4m.math.vector3();
                // generate vertices, normals and uvs
                for (iy = 0; iy <= heightSegments; iy++) {
                    var verticesRow = [];
                    var v = iy / heightSegments;
                    for (ix = 0; ix <= widthSegments; ix++) {
                        var u = ix / widthSegments;
                        // vertex
                        vertex.x = -radius * Math.cos(u * Math.PI * 2) * Math.sin(v * Math.PI);
                        vertex.y = radius * Math.cos(v * Math.PI);
                        vertex.z = radius * Math.sin(u * Math.PI * 2) * Math.sin(v * Math.PI);
                        data.pos.push(m4m.math.pool.clone_vector3(vertex));
                        // normal
                        normal = m4m.math.pool.clone_vector3(vertex);
                        var num = Math.sqrt(normal.x * normal.x + normal.y * normal.y + normal.z * normal.z);
                        if (num > Number.MIN_VALUE) {
                            normal.x = normal.x / num;
                            normal.y = normal.y / num;
                            normal.z = normal.z / num;
                        }
                        else {
                            normal.x = 0;
                            normal.y = 0;
                            normal.z = 0;
                        }
                        data.normal.push(normal);
                        // uv
                        var uv = new m4m.math.vector2(1 - u, v);
                        data.uv.push(uv);
                        verticesRow.push(index++);
                    }
                    grid.push(verticesRow);
                }
                // indices
                for (iy = 0; iy < heightSegments; iy++) {
                    for (ix = 0; ix < widthSegments; ix++) {
                        var a = grid[iy][ix + 1];
                        var b = grid[iy][ix];
                        var c = grid[iy + 1][ix];
                        var d = grid[iy + 1][ix + 1];
                        if (iy !== 0)
                            data.trisindex.push(a, d, b);
                        if (iy !== heightSegments - 1)
                            data.trisindex.push(b, d, c);
                    }
                }
                return data;
            };
            meshData.genBoxCCW = function (size) {
                var half = size * 0.5;
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                //bottom
                meshData.addQuadVec3ByValue(data.normal, new m4m.math.vector3(0, -1, 0));
                meshData.addQuadPos(data, [
                    new m4m.math.vector3(-half, -half, -half),
                    new m4m.math.vector3(-half, -half, half),
                    new m4m.math.vector3(half, -half, -half),
                    new m4m.math.vector3(half, -half, half)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new m4m.math.vector2(0, 0),
                    new m4m.math.vector2(0, 1),
                    new m4m.math.vector2(1, 0),
                    new m4m.math.vector2(1, 1),
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new m4m.math.vector3(-1, 0, 0));
                //top
                meshData.addQuadVec3ByValue(data.normal, new m4m.math.vector3(0, 1, 0));
                meshData.addQuadPos(data, [
                    new m4m.math.vector3(-half, half, half),
                    new m4m.math.vector3(-half, half, -half),
                    new m4m.math.vector3(half, half, half),
                    new m4m.math.vector3(half, half, -half)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new m4m.math.vector2(0, 0),
                    new m4m.math.vector2(0, 1),
                    new m4m.math.vector2(1, 0),
                    new m4m.math.vector2(1, 1),
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new m4m.math.vector3(1, 0, 0));
                //back
                meshData.addQuadVec3ByValue(data.normal, new m4m.math.vector3(0, 0, 1));
                meshData.addQuadPos(data, [
                    new m4m.math.vector3(-half, -half, half),
                    new m4m.math.vector3(-half, half, half),
                    new m4m.math.vector3(half, -half, half),
                    new m4m.math.vector3(half, half, half)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new m4m.math.vector2(1, 1),
                    new m4m.math.vector2(1, 0),
                    new m4m.math.vector2(0, 1),
                    new m4m.math.vector2(0, 0),
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new m4m.math.vector3(-1, 0, 0));
                //front
                meshData.addQuadVec3ByValue(data.normal, new m4m.math.vector3(0, 0, -1));
                meshData.addQuadPos(data, [
                    new m4m.math.vector3(-half, half, -half),
                    new m4m.math.vector3(-half, -half, -half),
                    new m4m.math.vector3(half, half, -half),
                    new m4m.math.vector3(half, -half, -half)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new m4m.math.vector2(0, 0),
                    new m4m.math.vector2(0, 1),
                    new m4m.math.vector2(1, 0),
                    new m4m.math.vector2(1, 1),
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new m4m.math.vector3(1, 0, 0));
                //right
                meshData.addQuadVec3ByValue(data.normal, new m4m.math.vector3(1, 0, 0));
                meshData.addQuadPos(data, [
                    new m4m.math.vector3(half, -half, -half),
                    new m4m.math.vector3(half, -half, half),
                    new m4m.math.vector3(half, half, -half),
                    new m4m.math.vector3(half, half, half)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new m4m.math.vector2(0, 1),
                    new m4m.math.vector2(1, 1),
                    new m4m.math.vector2(0, 0),
                    new m4m.math.vector2(1, 0),
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new m4m.math.vector3(0, 0, 1));
                //left
                meshData.addQuadVec3ByValue(data.normal, new m4m.math.vector3(-1, 0, 0));
                meshData.addQuadPos(data, [
                    new m4m.math.vector3(-half, -half, half),
                    new m4m.math.vector3(-half, -half, -half),
                    new m4m.math.vector3(-half, half, half),
                    new m4m.math.vector3(-half, half, -half)
                ]);
                meshData.addQuadVec2(data.uv, [
                    new m4m.math.vector2(0, 1),
                    new m4m.math.vector2(1, 1),
                    new m4m.math.vector2(0, 0),
                    new m4m.math.vector2(1, 0),
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new m4m.math.vector3(0, 0, -1));
                return data;
            };
            meshData.genBoxByArray = function (array, outData) {
                if (!outData)
                    return;
                // var data = new meshData();
                outData.pos = [];
                outData.trisindex = [];
                outData.normal = [];
                outData.tangent = [];
                outData.uv = [];
                //bottom
                meshData.addQuadVec3ByValue(outData.normal, new m4m.math.vector3(0, -1, 0));
                meshData.addQuadPos(outData, [
                    array[0],
                    array[1],
                    array[2],
                    array[3]
                ]);
                meshData.addQuadVec3ByValue(outData.tangent, new m4m.math.vector3(-1, 0, 0));
                //top
                meshData.addQuadVec3ByValue(outData.normal, new m4m.math.vector3(0, 1, 0));
                meshData.addQuadPos(outData, [
                    array[4],
                    array[5],
                    array[6],
                    array[7]
                ]);
                meshData.addQuadVec3ByValue(outData.tangent, new m4m.math.vector3(1, 0, 0));
                //back
                meshData.addQuadVec3ByValue(outData.normal, new m4m.math.vector3(0, 0, 1));
                meshData.addQuadPos(outData, [
                    array[1],
                    array[3],
                    array[5],
                    array[7]
                ]);
                meshData.addQuadVec3ByValue(outData.tangent, new m4m.math.vector3(1, 0, 0));
                //front
                meshData.addQuadVec3ByValue(outData.normal, new m4m.math.vector3(0, 0, -1));
                meshData.addQuadPos(outData, [
                    array[0],
                    array[2],
                    array[4],
                    array[6]
                ]);
                meshData.addQuadVec3ByValue(outData.tangent, new m4m.math.vector3(-1, 0, 0));
                //right
                meshData.addQuadVec3ByValue(outData.normal, new m4m.math.vector3(1, 0, 0));
                meshData.addQuadPos(outData, [
                    array[6],
                    array[2],
                    array[7],
                    array[3]
                ]);
                meshData.addQuadVec3ByValue(outData.tangent, new m4m.math.vector3(0, 0, -1));
                //left
                meshData.addQuadVec3ByValue(outData.normal, new m4m.math.vector3(-1, 0, 0));
                meshData.addQuadPos(outData, [
                    array[0],
                    array[4],
                    array[1],
                    array[5]
                ]);
                meshData.addQuadVec3ByValue(outData.tangent, new m4m.math.vector3(0, 0, 1));
                // return data;
            };
            meshData.genBoxByArray_Quad = function (array) {
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.tangent = [];
                data.uv = [];
                //bottom
                meshData.addQuadVec3ByValue(data.normal, new m4m.math.vector3(0, -1, 0));
                meshData.addQuadPos_Quad(data, [
                    array[0],
                    array[1],
                    array[2],
                    array[3]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new m4m.math.vector3(-1, 0, 0));
                //top
                meshData.addQuadVec3ByValue(data.normal, new m4m.math.vector3(0, 1, 0));
                meshData.addQuadPos_Quad(data, [
                    array[4],
                    array[5],
                    array[6],
                    array[7]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new m4m.math.vector3(1, 0, 0));
                //back
                meshData.addQuadVec3ByValue(data.normal, new m4m.math.vector3(0, 0, 1));
                meshData.addQuadPos_Quad(data, [
                    array[1],
                    array[3],
                    array[5],
                    array[7]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new m4m.math.vector3(1, 0, 0));
                //front
                meshData.addQuadVec3ByValue(data.normal, new m4m.math.vector3(0, 0, -1));
                meshData.addQuadPos_Quad(data, [
                    array[0],
                    array[2],
                    array[4],
                    array[6]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new m4m.math.vector3(-1, 0, 0));
                //right
                meshData.addQuadVec3ByValue(data.normal, new m4m.math.vector3(1, 0, 0));
                meshData.addQuadPos_Quad(data, [
                    array[6],
                    array[2],
                    array[7],
                    array[3]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new m4m.math.vector3(0, 0, -1));
                //left
                meshData.addQuadVec3ByValue(data.normal, new m4m.math.vector3(-1, 0, 0));
                meshData.addQuadPos_Quad(data, [
                    array[0],
                    array[4],
                    array[1],
                    array[5]
                ]);
                meshData.addQuadVec3ByValue(data.tangent, new m4m.math.vector3(0, 0, 1));
                return data;
            };
            meshData.genCircleLineCCW = function (radius, segment, wide) {
                if (segment === void 0) { segment = 64; }
                if (wide === void 0) { wide = 0.05; }
                var data = new meshData();
                data.pos = [];
                data.trisindex = [];
                data.normal = [];
                data.uv = [];
                for (var i = 0; i < segment; i++) {
                    var r1 = Math.PI * 2 * i / segment;
                    var x1 = Math.sin(r1) * radius;
                    var z1 = Math.cos(r1) * radius;
                    var r2 = Math.PI * 2 * (i + 1) / segment;
                    var x2 = Math.sin(r2) * radius;
                    var z2 = Math.cos(r2) * radius;
                    meshData.addQuadPos(data, [
                        new m4m.math.vector3(x2, wide, z2),
                        new m4m.math.vector3(x1, wide, z1),
                        new m4m.math.vector3(x2, -wide, z2),
                        new m4m.math.vector3(x1, -wide, z1)
                    ]);
                }
                return data;
            };
            meshData.prototype.caclByteLength = function () {
                var len = 0;
                if (this.pos != undefined)
                    len += 12;
                if (this.color != undefined)
                    len += 16;
                if (this.normal != undefined)
                    len += 12;
                if (this.tangent != undefined)
                    len += 12;
                if (this.uv != undefined)
                    len += 8;
                if (this.uv2 != undefined)
                    len += 8;
                if (this.blendIndex != undefined)
                    len += 16;
                if (this.blendWeight != undefined)
                    len += 16;
                if (this.colorex != undefined)
                    len += 16;
                if (this.trisindex != undefined)
                    len += 12;
                len *= this.pos.length;
                return len;
            };
            meshData.calcByteSize = function (vf) {
                var total = 0; //nothing
                if (vf & render.VertexFormatMask.Position)
                    total += 12;
                if (vf & render.VertexFormatMask.Normal)
                    total += 12;
                if (vf & render.VertexFormatMask.Tangent)
                    total += 12;
                if (vf & render.VertexFormatMask.Color)
                    total += 16;
                if (vf & render.VertexFormatMask.UV0)
                    total += 8;
                if (vf & render.VertexFormatMask.UV1)
                    total += 8;
                if (vf & render.VertexFormatMask.BlendIndex4)
                    total += 16;
                if (vf & render.VertexFormatMask.BlendWeight4)
                    total += 16;
                if (vf & render.VertexFormatMask.ColorEX)
                    total += 16;
                return total;
            };
            /** 获取顶点段落长度 */
            meshData.prototype.getSegmentSize = function () {
                var vf = this.originVF;
                return 3 +
                    (vf & render.VertexFormatMask.Normal ? 3 : 0) +
                    (vf & render.VertexFormatMask.Tangent ? 3 : 0) +
                    (vf & render.VertexFormatMask.UV0 ? 2 : 0) +
                    (vf & render.VertexFormatMask.UV1 ? 2 : 0) +
                    (vf & render.VertexFormatMask.Color ? 4 : 0) +
                    (vf & render.VertexFormatMask.ColorEX ? 4 : 0) +
                    (vf & render.VertexFormatMask.BlendIndex4 ? 4 : 0) +
                    (vf & render.VertexFormatMask.BlendWeight4 ? 4 : 0);
            };
            /** 获取顶点数量 */
            meshData.prototype.getVertexCount = function () {
                if (!this.isBufferDataMode) {
                    return this.pos.length;
                }
                else {
                    if (!this.vertexBufferData)
                        return 0;
                    var segmentSize = this._segmentSize;
                    return Math.floor(this.vertexBufferData.length / segmentSize);
                }
            };
            /** 获取三角形索引数量 */
            meshData.prototype.getTriIndexCount = function () {
                if (!this.isBufferDataMode) {
                    if (!this.trisindex)
                        return 0;
                    return this.trisindex.length;
                }
                else {
                    if (!this.triIndexBufferData)
                        return 0;
                    return this.triIndexBufferData.length;
                }
            };
            /**
             * 获取顶点位置
             * @param vertexIndex 顶点索引
             * @param out 输出vector3
             */
            meshData.prototype.getPosition = function (vertexIndex, out) {
                if (vertexIndex < 0 || !out)
                    return;
                if (!this.isBufferDataMode) {
                    var pos = this.pos[vertexIndex];
                    out.x = pos.x;
                    out.y = pos.y;
                    out.z = pos.z;
                }
                else {
                    var startIdx = vertexIndex * this._segmentSize;
                    out.x = this._vertexBufferData[startIdx];
                    out.y = this._vertexBufferData[startIdx + 1];
                    out.z = this._vertexBufferData[startIdx + 2];
                }
            };
            /**
             * 获取三角形索引
             * @param Index 数组索引
             * @returns 三角形顶点索引
             */
            meshData.prototype.getTriIndex = function (Index) {
                if (!this.isBufferDataMode) {
                    if (!this.trisindex)
                        return 0;
                    return this.trisindex[Index];
                }
                else {
                    if (!this.triIndexBufferData)
                        return 0;
                    return this.triIndexBufferData[Index];
                }
            };
            /**
             * 遍历顶点数据
             * @param callbackfn 遍历每个顶点数据时调用的函数
             */
            meshData.prototype.foreachVertexData = function (callbackfn) {
                //
                if (callbackfn == null)
                    return;
                var isBufferM = this.isBufferDataMode;
                if (isBufferM && !this.vertexBufferData)
                    return;
                //
                var vdata = {};
                var vf = this.originVF;
                if (!isBufferM) {
                    var len = this.pos.length;
                    for (var i = 0; i < len; i++) {
                        //pos
                        vdata.pos = this.pos[i];
                        vdata.normal = vf & render.VertexFormatMask.Normal && this.normal ? this.normal[i] : null;
                        vdata.tangent = vf & render.VertexFormatMask.Tangent && this.tangent ? this.tangent[i] : null;
                        vdata.uv = vf & render.VertexFormatMask.UV0 && this.uv ? this.uv[i] : null;
                        vdata.uv2 = vf & render.VertexFormatMask.UV1 && this.uv2 ? this.uv2[i] : null;
                        vdata.color = vf & render.VertexFormatMask.Color && this.color ? this.color[i] : null;
                        vdata.colorex = vf & render.VertexFormatMask.ColorEX && this.colorex ? this.colorex[i] : null;
                        vdata.blendIndex = vf & render.VertexFormatMask.BlendIndex4 && this.blendIndex ? this.blendIndex[i] : null;
                        vdata.blendWeight = vf & render.VertexFormatMask.BlendWeight4 && this.blendWeight ? this.blendWeight[i] : null;
                        //callback
                        callbackfn(vdata, i);
                    }
                }
                else {
                    var _pos = new m4m.math.vector3();
                    var _normal = new m4m.math.vector3();
                    var _tangent = new m4m.math.vector3();
                    var _uv = new m4m.math.vector2();
                    var _uv2 = new m4m.math.vector2();
                    var _color = new m4m.math.color();
                    var _colorex = new m4m.math.color();
                    var _blendIndex = new render.number4();
                    var _blendWeight = new render.number4();
                    var vBuffer = this.vertexBufferData;
                    var segmentSize = this._segmentSize;
                    var len = Math.floor(vBuffer.length / segmentSize);
                    vdata.pos = _pos;
                    for (var i = 0; i < len; i++) {
                        var idx = i * segmentSize;
                        vdata.normal = (vf & render.VertexFormatMask.Normal) ? _normal : null;
                        vdata.tangent = (vf & render.VertexFormatMask.Tangent) ? _tangent : null;
                        vdata.color = (vf & render.VertexFormatMask.Color) ? _color : null;
                        vdata.uv = (vf & render.VertexFormatMask.UV0) ? _uv : null;
                        vdata.uv2 = (vf & render.VertexFormatMask.UV1) ? _uv2 : null;
                        vdata.blendIndex = (vf & render.VertexFormatMask.BlendIndex4) ? _blendIndex : null;
                        vdata.blendWeight = (vf & render.VertexFormatMask.BlendWeight4) ? _blendWeight : null;
                        vdata.colorex = (vf & render.VertexFormatMask.ColorEX) ? _colorex : null;
                        //
                        m4m.math.vec3Set(vdata.pos, vBuffer[idx++], vBuffer[idx++], vBuffer[idx++]);
                        if (vdata.normal)
                            m4m.math.vec3Set(vdata.normal, vBuffer[idx++], vBuffer[idx++], vBuffer[idx++]);
                        if (vdata.tangent)
                            m4m.math.vec3Set(vdata.tangent, vBuffer[idx++], vBuffer[idx++], vBuffer[idx++]);
                        if (vdata.color)
                            m4m.math.colorSet(vdata.color, vBuffer[idx++], vBuffer[idx++], vBuffer[idx++], vBuffer[idx++]);
                        if (vdata.uv)
                            m4m.math.vec2Set(vdata.uv, vBuffer[idx++], vBuffer[idx++]);
                        if (vdata.uv2)
                            m4m.math.vec2Set(vdata.uv2, vBuffer[idx++], vBuffer[idx++]);
                        if (vdata.blendIndex)
                            render.number4.set(vdata.blendIndex, vBuffer[idx++], vBuffer[idx++], vBuffer[idx++], vBuffer[idx++]);
                        if (vdata.blendWeight)
                            render.number4.set(vdata.blendWeight, vBuffer[idx++], vBuffer[idx++], vBuffer[idx++], vBuffer[idx++]);
                        if (vdata.colorex)
                            m4m.math.colorSet(vdata.colorex, vBuffer[idx++], vBuffer[idx++], vBuffer[idx++], vBuffer[idx++]);
                        //callBack
                        callbackfn(vdata, i);
                    }
                }
            };
            /**
             * 遍历三角形索引数据
             * @param callbackfn 遍历每个三角形索引时调用的函数
             */
            meshData.prototype.foreachTriIndexData = function (callbackfn) {
                if (callbackfn == null)
                    return;
                var arr = this.isBufferDataMode ? this.triIndexBufferData : this.trisindex;
                if (arr == null)
                    return;
                for (var i = 0, len = arr.length; i < len; i++) {
                    callbackfn(arr[i], i);
                }
            };
            /**
             * 获取 OBJ 格式模型 顶点数据字符串
             * @param face 导出三角形面
             * @param uv 导出顶点纹理坐标
             * @param normal 导出顶点法线
             * @returns OBJ 格式模型 顶点数据字符串
             */
            meshData.prototype.makeOBJFormatData = function (face, uv, normal) {
                if (face === void 0) { face = true; }
                if (uv === void 0) { uv = false; }
                if (normal === void 0) { normal = false; }
                var vStr = "";
                var uvStr = "";
                var nStr = "";
                var faceStr = "";
                this.foreachVertexData(function (val, i) {
                    var pos = val.pos;
                    var _uv = val.uv;
                    var _n = val.normal;
                    vStr += "v ".concat(pos.x, " ").concat(pos.y, " ").concat(pos.z, "\n");
                    if (uv && _uv)
                        uvStr += "vt ".concat(_uv.x, " ").concat(_uv.y, "\n");
                    if (normal && _n)
                        nStr += "vn ".concat(_n.x, " ").concat(_n.y, " ").concat(_n.z, "\n");
                });
                if (face) {
                    this.foreachTriIndexData(function (val, i) {
                        var triCount = i % 3;
                        var _v = val + 1;
                        if (triCount == 0) {
                            faceStr += "f ".concat(_v);
                        }
                        else if (triCount == 1) {
                            faceStr += " ".concat(_v);
                        }
                        else if (triCount == 2) {
                            faceStr += " ".concat(_v, "\n");
                        }
                    });
                }
                return vStr + uvStr + nStr + faceStr;
            };
            // static timer = 0;
            /**
             * 生成顶点数据buffer
             * @param vf 顶点数据格式
             * @returns 点数据buffer
             */
            meshData.prototype.genVertexDataArray = function (vf) {
                var _this = this;
                //buffer 数据模式 ，直接返回
                if (_this.isBufferDataMode)
                    return _this.vertexBufferData;
                // if (_this.tmpVArr)
                //     return _this.tmpVArr;
                var vertexCount = _this.pos.length;
                var total = meshData.calcByteSize(vf) / 4;
                var varray = new Float32Array(total * vertexCount);
                // _this.tmpVArr = varray;
                for (var i = 0; i < vertexCount; i++) {
                    var nseek = 0;
                    //pos
                    varray[i * total + nseek] = _this.pos[i].x;
                    nseek++;
                    varray[i * total + nseek] = _this.pos[i].y;
                    nseek++;
                    varray[i * total + nseek] = _this.pos[i].z;
                    nseek++;
                    if (vf & render.VertexFormatMask.Normal) {
                        if (_this.normal == undefined || _this.normal.length == 0) {
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = _this.normal[i].x;
                            nseek++;
                            varray[i * total + nseek] = _this.normal[i].y;
                            nseek++;
                            varray[i * total + nseek] = _this.normal[i].z;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.Tangent) {
                        if (_this.tangent == undefined || _this.tangent.length == 0) {
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = _this.tangent[i].x;
                            nseek++;
                            varray[i * total + nseek] = _this.tangent[i].y;
                            nseek++;
                            varray[i * total + nseek] = _this.tangent[i].z;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.Color) {
                        if (_this.color == undefined || _this.color.length == 0) {
                            varray[i * total + nseek] = 1;
                            nseek++;
                            varray[i * total + nseek] = 1;
                            nseek++;
                            varray[i * total + nseek] = 1;
                            nseek++;
                            varray[i * total + nseek] = 1;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = _this.color[i].r;
                            nseek++;
                            varray[i * total + nseek] = _this.color[i].g;
                            nseek++;
                            varray[i * total + nseek] = _this.color[i].b;
                            nseek++;
                            varray[i * total + nseek] = _this.color[i].a;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.UV0) {
                        if (_this.uv == undefined || _this.uv.length == 0) {
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = _this.uv[i].x;
                            nseek++;
                            varray[i * total + nseek] = _this.uv[i].y;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.UV1) {
                        if (_this.uv2 == undefined || _this.uv2.length == 0) {
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = _this.uv2[i].x;
                            nseek++;
                            varray[i * total + nseek] = _this.uv2[i].y;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.BlendIndex4) {
                        if (_this.blendIndex == undefined || _this.blendIndex.length == 0) {
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = _this.blendIndex[i].v0;
                            nseek++;
                            varray[i * total + nseek] = _this.blendIndex[i].v1;
                            nseek++;
                            varray[i * total + nseek] = _this.blendIndex[i].v2;
                            nseek++;
                            varray[i * total + nseek] = _this.blendIndex[i].v3;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.BlendWeight4) {
                        if (_this.blendWeight == undefined || _this.blendWeight.length == 0) {
                            varray[i * total + nseek] = 1;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                            varray[i * total + nseek] = 0;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = _this.blendWeight[i].v0;
                            nseek++;
                            varray[i * total + nseek] = _this.blendWeight[i].v1;
                            nseek++;
                            varray[i * total + nseek] = _this.blendWeight[i].v2;
                            nseek++;
                            varray[i * total + nseek] = _this.blendWeight[i].v3;
                            nseek++;
                        }
                    }
                    if (vf & render.VertexFormatMask.ColorEX) {
                        if (_this.colorex == undefined || _this.colorex.length == 0) {
                            varray[i * total + nseek] = 1;
                            nseek++;
                            varray[i * total + nseek] = 1;
                            nseek++;
                            varray[i * total + nseek] = 1;
                            nseek++;
                            varray[i * total + nseek] = 1;
                            nseek++;
                        }
                        else {
                            varray[i * total + nseek] = _this.colorex[i].r;
                            nseek++;
                            varray[i * total + nseek] = _this.colorex[i].g;
                            nseek++;
                            varray[i * total + nseek] = _this.colorex[i].b;
                            nseek++;
                            varray[i * total + nseek] = _this.colorex[i].a;
                            nseek++;
                        }
                    }
                }
                // let tttttt = performance.now() - timeaa;
                // meshData.timer += tttttt;
                // console.error("解析Mesh总耗时：" + meshData.timer);
                return varray;
            };
            /**
             * 生成 三角形索引buffer数据
             * @returns 三角形索引buffer数据
             */
            meshData.prototype.genIndexDataArray = function () {
                if (this.isBufferDataMode)
                    return this.triIndexBufferData;
                return this.triIndexUint32Mode ? new Uint32Array(this.trisindex) : new Uint16Array(this.trisindex);
            };
            meshData.prototype.genIndexDataArrayTri2Line = function () {
                var line = [];
                for (var i = 0; i < ((this.trisindex.length / 3) | 0); i++) {
                    line.push(this.trisindex[i * 3 + 0]);
                    line.push(this.trisindex[i * 3 + 1]);
                    line.push(this.trisindex[i * 3 + 1]);
                    line.push(this.trisindex[i * 3 + 2]);
                    line.push(this.trisindex[i * 3 + 2]);
                    line.push(this.trisindex[i * 3 + 0]);
                }
                // return new Uint16Array(line);
                return this.triIndexUint32Mode ? new Uint32Array(line) : new Uint16Array(line);
            };
            meshData.prototype.genIndexDataArrayQuad2Line = function () {
                var line = [];
                for (var i = 0; i < ((this.trisindex.length / 4) | 0); i++) {
                    line.push(this.trisindex[i * 4 + 0]);
                    line.push(this.trisindex[i * 4 + 1]);
                    line.push(this.trisindex[i * 4 + 1]);
                    line.push(this.trisindex[i * 4 + 2]);
                    line.push(this.trisindex[i * 4 + 2]);
                    line.push(this.trisindex[i * 4 + 3]);
                }
                // return new Uint16Array(line);
                return this.triIndexUint32Mode ? new Uint32Array(line) : new Uint16Array(line);
            };
            meshData.cloneByObj = function (target) {
                var md = new meshData();
                target.originVF = md.originVF;
                if (target.pos) {
                    md.pos = [];
                    target.pos.forEach(function (element, idx) {
                        md.pos[idx] = new m4m.math.vector3();
                        md.pos[idx].x = element.x;
                        md.pos[idx].y = element.y;
                        md.pos[idx].z = element.z;
                    });
                }
                if (target.color) {
                    md.color = [];
                    target.color.forEach(function (element, idx) {
                        md.color[idx] = new m4m.math.color();
                        md.color[idx].r = element.r;
                        md.color[idx].g = element.g;
                        md.color[idx].b = element.b;
                        md.color[idx].a = element.a;
                    });
                }
                if (target.colorex) {
                    md.colorex = [];
                    target.colorex.forEach(function (element, idx) {
                        md.colorex[idx] = new m4m.math.color();
                        md.colorex[idx].r = element.r;
                        md.colorex[idx].g = element.g;
                        md.colorex[idx].b = element.b;
                        md.colorex[idx].a = element.a;
                    });
                }
                if (target.uv) {
                    md.uv = [];
                    target.uv.forEach(function (element, idx) {
                        md.uv[idx] = new m4m.math.vector2();
                        md.uv[idx].x = element.x;
                        md.uv[idx].y = element.y;
                    });
                }
                if (target.uv2) {
                    md.uv2 = [];
                    target.uv2.forEach(function (element, idx) {
                        md.uv2[idx] = new m4m.math.vector2();
                        md.uv2[idx].x = element.x;
                        md.uv2[idx].y = element.y;
                    });
                }
                if (target.normal) {
                    md.normal = [];
                    target.normal.forEach(function (element, idx) {
                        md.normal[idx] = new m4m.math.vector3();
                        md.normal[idx].x = element.x;
                        md.normal[idx].y = element.y;
                        md.normal[idx].z = element.z;
                    });
                }
                if (target.tangent) {
                    md.tangent = [];
                    target.tangent.forEach(function (element, idx) {
                        md.tangent[idx] = new m4m.math.vector3();
                        md.tangent[idx].x = element.x;
                        md.tangent[idx].y = element.y;
                        md.tangent[idx].z = element.z;
                    });
                }
                if (target.blendIndex) {
                    md.blendIndex = [];
                    target.blendIndex.forEach(function (element, idx) {
                        md.blendIndex[idx] = new render.number4();
                        md.blendIndex[idx].v0 = element.v0;
                        md.blendIndex[idx].v1 = element.v1;
                        md.blendIndex[idx].v2 = element.v2;
                        md.blendIndex[idx].v3 = element.v3;
                    });
                }
                if (target.blendWeight) {
                    md.blendWeight = [];
                    target.blendWeight.forEach(function (element, idx) {
                        md.blendWeight[idx] = new render.number4();
                        md.blendWeight[idx].v0 = element.v0;
                        md.blendWeight[idx].v1 = element.v1;
                        md.blendWeight[idx].v2 = element.v2;
                        md.blendWeight[idx].v3 = element.v3;
                    });
                }
                if (target.trisindex) {
                    md.trisindex = [];
                    target.trisindex.forEach(function (element) {
                        md.trisindex.push(element);
                    });
                }
                return md;
            };
            /**
             * 获取AABB
             *
             * @param recalculate 是否重新计算AABB
             */
            meshData.prototype.getAABB = function (recalculate) {
                if (recalculate === void 0) { recalculate = false; }
                if (!this._aabb || recalculate) {
                    var minimum = new m4m.math.vector3();
                    var maximum = new m4m.math.vector3();
                    m4m.math.vec3SetByFloat(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, minimum);
                    m4m.math.vec3SetByFloat(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, maximum);
                    var len = this.pos.length;
                    var pos = this.pos;
                    for (var i = 0; i < len; i++) {
                        m4m.math.vec3Max(pos[i], maximum, maximum);
                        m4m.math.vec3Min(pos[i], minimum, minimum);
                    }
                    this._aabb = new m4m.framework.aabb(minimum, maximum);
                }
                return this._aabb;
            };
            return meshData;
        }());
        render.meshData = meshData;
    })(render = m4m.render || (m4m.render = {}));
})(m4m || (m4m = {}));
// namespace m4m.render
// {
//     /**
//      * @private
//      */
//     export class staticMeshRenderer
//     {
//         material: glDrawPass;
//         mesh: glMesh;
//         eboIndex: number = 0;
//         drawMode: DrawModeEnum = DrawModeEnum.EboTri;
//         drawbegin: number = 0;
//         drawcount: number = -1;
//         draw(webgl: WebGL2RenderingContext)
//         {
//             this.material.use(webgl);
//             this.mesh.bind(webgl, this.material.program, this.eboIndex);
//             if (this.drawMode == DrawModeEnum.VboTri)
//             {
//                 this.mesh.drawArrayTris(webgl, this.drawbegin, this.drawcount);
//             }
//             else if (this.drawMode == DrawModeEnum.VboLine)
//             {
//                 this.mesh.drawArrayLines(webgl, this.drawbegin, this.drawcount);
//             }
//             else if (this.drawMode == DrawModeEnum.EboTri)
//             {
//                 this.mesh.drawElementTris(webgl, this.drawbegin, this.drawcount);
//             }
//             else if (this.drawMode == DrawModeEnum.EboLine)
//             {
//                 this.mesh.drawElementLines(webgl, this.drawbegin, this.drawcount);
//             }
//         }
//     }
//     /**
//      * @private
//      */
//     export class batchRenderer
//     {
//         curmaterial: glDrawPass;
//         mesh: glMesh;
//         drawMode: DrawModeEnum;
//         vboCount: number = 0;
//         eboCount: number = 0;
//         dataForVbo: Float32Array;
//         dataForEbo: Uint16Array;
//         initBuffer(webgl: WebGL2RenderingContext, vf: VertexFormatMask, drawMode: DrawModeEnum)
//         {
//             this.mesh = new glMesh();
//             this.mesh.initBuffer(webgl, vf, 128, MeshTypeEnum.Dynamic);
//             this.dataForVbo = new Float32Array(128);
//             this.drawMode = drawMode;
//             if (drawMode == DrawModeEnum.EboLine || drawMode == DrawModeEnum.EboTri)
//             {
//                 this.mesh.addIndex(webgl, 128);
//                 this.dataForEbo = new Uint16Array(128);
//             }
//         }
//         begin(webgl: WebGL2RenderingContext, mat: glDrawPass)
//         {
//             //if (mat == this.curmaterial) return;
//             if (this.vboCount > 0)
//                 this.end(webgl);
//             this.curmaterial = mat;
//         }
//         push(webgl: WebGL2RenderingContext, vbodata: number[], ebodata: number[])
//         {
//             if (this.vboCount + vbodata.length > 2048
//                 ||
//                 (ebodata != null && this.eboCount + ebodata.length > 2048))
//             {
//                 this.end(webgl);
//             }
//             if (this.vboCount + vbodata.length > this.dataForVbo.length)
//             {
//                 let narr = new Float32Array(this.dataForVbo.length * 2);
//                 for (let i = 0, len = this.dataForVbo.length; i < len; ++i)
//                 {
//                     narr[i] = this.dataForVbo[i];
//                 }
//                 this.dataForVbo = narr;
//                 this.mesh.resetVboSize(webgl, this.dataForVbo.length);
//             }
//             for (let i = 0,len = vbodata.length; i < len; ++i)
//             {
//                 this.dataForVbo[this.vboCount + i] = vbodata[i];
//             }
//             this.vboCount += vbodata.length;
//             if (this.drawMode == DrawModeEnum.VboLine || this.drawMode == DrawModeEnum.VboTri)
//                 return;
//             if (ebodata != null)
//             {
//                 if (this.eboCount + ebodata.length > this.dataForEbo.length)
//                 {
//                     let narr = new Uint16Array(this.dataForEbo.length * 2);
//                     for (let i = 0,len = this.dataForEbo.length; i < len; ++i)
//                     {
//                         narr[i] = this.dataForEbo[i];
//                     }
//                     this.dataForEbo = narr;
//                     this.mesh.resetEboSize(webgl, 0, this.dataForEbo.length);
//                 }
//                 for (let i = 0,len = ebodata.length; i < len; ++i)
//                 {
//                     this.dataForEbo[this.eboCount + i] = ebodata[i];
//                 }
//                 this.eboCount += ebodata.length;
//             }
//         }
//         end(webgl: WebGL2RenderingContext)
//         {
//             if (this.vboCount == 0) return;
//             this.mesh.uploadVertexData(webgl, this.dataForVbo.slice(0, this.vboCount));
//             if (this.eboCount > 0)
//                 this.mesh.uploadIndexData(webgl, 0, this.dataForEbo.slice(0, this.eboCount));
//             var vertexcount = (this.vboCount / (this.mesh.vertexByteSize / 4)) | 0;
//             this.curmaterial.use(webgl);
//             this.mesh.bind(webgl, this.curmaterial.program, (this.drawMode == DrawModeEnum.EboLine || this.drawMode == DrawModeEnum.EboTri) ? 0 : -1);
//             if (this.drawMode == DrawModeEnum.EboLine)
//             {
//                 this.mesh.drawElementLines(webgl, 0, this.eboCount);
//             }
//             else if (this.drawMode == DrawModeEnum.EboTri)
//             {
//                 this.mesh.drawElementTris(webgl, 0, this.eboCount);
//             }
//             else if (this.drawMode == DrawModeEnum.VboLine)
//             {
//                 this.mesh.drawArrayLines(webgl, 0, vertexcount);
//             }
//             else if (this.drawMode == DrawModeEnum.VboTri)
//             {
//                 this.mesh.drawArrayTris(webgl, 0, vertexcount);
//             }
//             this.vboCount = 0;
//             this.eboCount = 0;
//         }
//     }
// }
var m4m;
(function (m4m) {
    var render;
    (function (render) {
        var shaderUniform = /** @class */ (function () {
            function shaderUniform() {
            }
            shaderUniform.initApplyUnifmFunc = function () {
                var _this = this;
                this.applyuniformFunc[render.UniformTypeEnum.Float] = function (location, value) {
                    _this.webgl.uniform1f(location, value);
                };
                this.applyuniformFunc[render.UniformTypeEnum.Int] = function (location, value) {
                    _this.webgl.uniform1i(location, value);
                };
                this.applyuniformFunc[render.UniformTypeEnum.Floatv] = function (location, value) {
                    _this.webgl.uniform1fv(location, value);
                };
                this.applyuniformFunc[render.UniformTypeEnum.Float4] = function (location, value) {
                    _this.webgl.uniform4f(location, value.x, value.y, value.z, value.w);
                };
                this.applyuniformFunc[render.UniformTypeEnum.Float4v] = function (location, value) {
                    _this.webgl.uniform4fv(location, value);
                };
                this.applyuniformFunc[render.UniformTypeEnum.Float4x4] = function (location, value) {
                    _this.webgl.uniformMatrix4fv(location, false, value.rawData);
                };
                this.applyuniformFunc[render.UniformTypeEnum.Float4x4v] = function (location, value) {
                    _this.webgl.uniformMatrix4fv(location, false, value);
                };
                this.applyuniformFunc[render.UniformTypeEnum.Texture] = function (location, value) {
                    var tex = value.glTexture.texture;
                    _this.webgl.activeTexture(render.webglkit.GetTextureNumber(_this.texindex));
                    _this.webgl.bindTexture(_this.webgl.TEXTURE_2D, tex);
                    _this.webgl.uniform1i(location, _this.texindex);
                    _this.texindex++;
                };
                this.applyuniformFunc[render.UniformTypeEnum.CubeTexture] = function (location, value) {
                    var tex = value.glTexture.texture;
                    _this.webgl.activeTexture(render.webglkit.GetTextureNumber(_this.texindex));
                    _this.webgl.bindTexture(_this.webgl.TEXTURE_CUBE_MAP, tex);
                    _this.webgl.uniform1i(location, _this.texindex);
                    _this.texindex++;
                };
            };
            shaderUniform.texindex = 0;
            shaderUniform.applyuniformFunc = {};
            return shaderUniform;
        }());
        render.shaderUniform = shaderUniform;
    })(render = m4m.render || (m4m.render = {}));
})(m4m || (m4m = {}));
// namespace m4m.render
// {
//     /**
//      * @private
//      */
//     export class glWindow
//     {
//         renderTarget: m4m.render.glRenderTarget;
//         clearop_Color: boolean = false;
//         backColor: m4m.math.color = new m4m.math.color(1, 0, 1, 1);
//         clearop_Depth: boolean = false;
//         clearop_Stencil: boolean = false;
//         viewport: m4m.math.rect = new m4m.math.rect(0, 0, 1, 1);
//         use(webgl: WebGL2RenderingContext)
//         {
//             //rendertarget
//             if (this.renderTarget != null)
//             {
//                 this.renderTarget.use(webgl);
//             }
//             else
//             {
//                 m4m.render.glRenderTarget.useNull(webgl);
//             }
//             //clear
//             if (this.backColor != null)
//                 webgl.clearColor(this.backColor.r, this.backColor.g, this.backColor.b, this.backColor.a);
//             var n = 0;
//             if (this.clearop_Color) n |= webgl.COLOR_BUFFER_BIT;
//             if (this.clearop_Depth) n |= webgl.DEPTH_BUFFER_BIT;
//             if (this.clearop_Stencil) n |= webgl.STENCIL_BUFFER_BIT;
//             webgl.clear(n);
//             //viewport
//             if (this.renderTarget != null)
//             {
//                 webgl.viewport(this.renderTarget.width * this.viewport.x, this.renderTarget.height * this.viewport.y,
//                     this.renderTarget.width * this.viewport.w, this.renderTarget.height * this.viewport.h);
//             }
//             else
//             {
//                 webgl.viewport(webgl.canvas.width * this.viewport.x, webgl.canvas.height * this.viewport.y,
//                     webgl.canvas.width * this.viewport.w, webgl.canvas.height * this.viewport.h);
//             }
//         }
//     }
// }
var m4m;
(function (m4m) {
    var render;
    (function (render) {
        /**
         * @public
         * @language zh_CN
         * @classdesc
         * uniform类型枚举
         * @version m4m 1.0
         */
        var UniformTypeEnum;
        (function (UniformTypeEnum) {
            UniformTypeEnum[UniformTypeEnum["Texture"] = 0] = "Texture";
            UniformTypeEnum[UniformTypeEnum["Float"] = 1] = "Float";
            UniformTypeEnum[UniformTypeEnum["Floatv"] = 2] = "Floatv";
            UniformTypeEnum[UniformTypeEnum["Float4"] = 3] = "Float4";
            UniformTypeEnum[UniformTypeEnum["Float4v"] = 4] = "Float4v";
            UniformTypeEnum[UniformTypeEnum["Float4x4"] = 5] = "Float4x4";
            UniformTypeEnum[UniformTypeEnum["Float4x4v"] = 6] = "Float4x4v";
            UniformTypeEnum[UniformTypeEnum["CubeTexture"] = 7] = "CubeTexture";
            UniformTypeEnum[UniformTypeEnum["Int"] = 8] = "Int";
        })(UniformTypeEnum = render.UniformTypeEnum || (render.UniformTypeEnum = {}));
        /**
         * @private
         */
        var uniform = /** @class */ (function () {
            function uniform() {
            }
            return uniform;
        }());
        render.uniform = uniform;
        var attribute = /** @class */ (function () {
            function attribute() {
            }
            return attribute;
        }());
        render.attribute = attribute;
        /**
         * @private
         */
        var ShaderTypeEnum;
        (function (ShaderTypeEnum) {
            ShaderTypeEnum[ShaderTypeEnum["VS"] = 0] = "VS";
            ShaderTypeEnum[ShaderTypeEnum["FS"] = 1] = "FS";
        })(ShaderTypeEnum = render.ShaderTypeEnum || (render.ShaderTypeEnum = {}));
        /**
         * @private
         */
        var glShader = /** @class */ (function () {
            function glShader(name, type, shader, code) {
                this.name = name;
                this.type = type;
                this.shader = shader;
                //this._scanUniform(code);
            }
            return glShader;
        }());
        render.glShader = glShader;
        /**
         * @private
         */
        var glProgram = /** @class */ (function () {
            // /**
            //  * 是否是引擎系统内建的 attrib ID
            //  * @param attribID 
            //  */
            // static isBuildInAttrib(attribID: string) {
            //     return this.buildInAtrribute[attribID] != null;
            // }
            function glProgram(vs, fs, program) {
                /** 全部 attribute 地址 map */
                this.mapAllAttrLoc = {};
                /** 全部 attributeID map */
                this.mapAllAttrID = {};
                // //old 顶点地址-------------------------
                // posPos: number = -1;
                // posNormal: number = -1;
                // posTangent: number = -1;
                // posColor: number = -1;
                // posUV0: number = -1;
                // posUV2: number = -1;
                // posBlendIndex4: number = -1;
                // posBlendWeight4: number = -1;
                // posColorEx: number = -1;
                // //------------------------------------
                this.mapUniform = {};
                this.vs = vs;
                this.fs = fs;
                this.program = program;
            }
            // /** GPU Instance attribute ID map */
            // mapInstanceAttribID: { [id: string]: attribute } = {};
            // private _strideInsAttrib: number = 0;
            // get strideInsAttrib() { return this._strideInsAttrib; }
            glProgram.prototype.initAttribute = function (webgl) {
                var attributesLen = webgl.getProgramParameter(this.program, webgl.ACTIVE_ATTRIBUTES);
                // let attMap = glProgram.buildInAtrribute;
                for (var i = 0; i < attributesLen; i++) {
                    var attributeInfo = webgl.getActiveAttrib(this.program, i);
                    if (!attributeInfo)
                        break;
                    var att = new attribute();
                    var name_10 = attributeInfo.name;
                    att.name = name_10;
                    switch (attributeInfo.type) {
                        case webgl.INT:
                        case webgl.FLOAT:
                            att.size = 1;
                            break;
                        case webgl.INT_VEC2:
                        case webgl.FLOAT_VEC2:
                            att.size = 2;
                            break;
                        case webgl.INT_VEC3:
                        case webgl.FLOAT_VEC3:
                            att.size = 3;
                            break;
                        case webgl.INT_VEC4:
                        case webgl.FLOAT_VEC4:
                        case webgl.FLOAT_MAT2:
                            att.size = 4;
                            break;
                        case webgl.FLOAT_MAT2x3:
                        case webgl.FLOAT_MAT3x2:
                            att.size = 6;
                            break;
                        case webgl.FLOAT_MAT2x4:
                        case webgl.FLOAT_MAT4x2:
                            att.size = 8;
                            break;
                        case webgl.FLOAT_MAT3:
                            att.size = 9;
                            break;
                        case webgl.FLOAT_MAT3x4:
                        case webgl.FLOAT_MAT4x3:
                            att.size = 12;
                            break;
                        case webgl.FLOAT_MAT4:
                            att.size = 16;
                            break;
                        default:
                            att.size = 0;
                            break;
                    }
                    att.location = webgl.getAttribLocation(this.program, name_10);
                    //加入all map 
                    this.mapAllAttrLoc[att.location] = att;
                    this.mapAllAttrID[name_10] = att;
                    // //加入instance map
                    // if (att.location >= VertexLocation.GPUInstanceStart) {
                    //     this.mapInstanceAttribID[name] = att;
                    //     // this._strideInsAttrib += att.size * 4;
                    // }
                }
                // //设置 引擎内建的attribute 地址
                // for (let key in attMap) {
                //     let val = attMap[key];
                //     this[val] = this.tryGetLocation(key);
                // }
                //使用了 layout 模式，只需要筛选 自定义的attrib
            };
            glProgram.prototype.use = function (webgl) {
                webgl.useProgram(this.program);
            };
            glProgram.prototype.initUniforms = function (webgl) {
                var numUniforms = webgl.getProgramParameter(this.program, webgl.ACTIVE_UNIFORMS);
                for (var i = 0; i < numUniforms; i++) {
                    var uniformInfo = webgl.getActiveUniform(this.program, i);
                    if (!uniformInfo)
                        break;
                    var name = uniformInfo.name;
                    // remove the array suffix.
                    if (name.substr(-3) === "[0]") {
                        name = name.substr(0, name.length - 3);
                    }
                    var location = webgl.getUniformLocation(this.program, uniformInfo.name);
                    var type = uniformInfo.type;
                    var isArray = (uniformInfo.size > 1 && uniformInfo.name.substr(-3) === "[0]");
                    var _uniform = new uniform();
                    _uniform.name = name;
                    _uniform.location = location;
                    this.mapUniform[name] = _uniform;
                    if (type === webgl.FLOAT && isArray) {
                        _uniform.type = UniformTypeEnum.Floatv;
                    }
                    else if (type === webgl.FLOAT) {
                        _uniform.type = UniformTypeEnum.Float;
                    }
                    else if (type === webgl.INT) {
                        _uniform.type = UniformTypeEnum.Int;
                    }
                    else if (type === webgl.FLOAT_VEC4 && isArray) {
                        _uniform.type = UniformTypeEnum.Float4v;
                    }
                    else if (type === webgl.FLOAT_VEC4) {
                        _uniform.type = UniformTypeEnum.Float4;
                    }
                    else if (type === webgl.FLOAT_MAT4 && isArray) {
                        _uniform.type = UniformTypeEnum.Float4x4v;
                    }
                    else if (type === webgl.FLOAT_MAT4) {
                        _uniform.type = UniformTypeEnum.Float4x4;
                    }
                    else if (type === webgl.SAMPLER_2D) {
                        _uniform.type = UniformTypeEnum.Texture;
                    }
                    else if (type === webgl.SAMPLER_CUBE) {
                        _uniform.type = UniformTypeEnum.CubeTexture;
                    }
                    else {
                        console.log("Unifrom parse Erorr : not have this type!");
                    }
                }
            };
            return glProgram;
        }());
        render.glProgram = glProgram;
        /**
         * @private
         */
        var shaderPool = /** @class */ (function () {
            function shaderPool() {
                this.mapVS = {};
                this.mapFS = {};
                this.mapProgram = {};
                //--------------------------------------shader 版本2
                this.mapVSString = {};
                this.mapFSString = {};
            }
            shaderPool.prototype.disposeVS = function (webgl, id) {
                webgl.deleteShader(this.mapVS[id].shader);
            };
            shaderPool.prototype.disposeFS = function (webgl, id) {
                webgl.deleteShader(this.mapFS[id].shader);
            };
            shaderPool.prototype.disposeProgram = function (webgl, id) {
                webgl.deleteProgram(this.mapProgram[id].program);
            };
            shaderPool.prototype.disposeAll = function (webgl) {
                for (var key in this.mapVS) {
                    this.disposeVS(webgl, key);
                }
                for (var key in this.mapFS) {
                    this.disposeFS(webgl, key);
                }
                for (var key in this.mapProgram) {
                    this.disposeProgram(webgl, key);
                }
                this.mapVS = {};
                this.mapFS = {};
                this.mapProgram = {};
            };
            //编译并扫描 attribute 和 uniform
            shaderPool.prototype.compileVS = function (webgl, name, code) {
                var vs = webgl.createShader(webgl.VERTEX_SHADER);
                webgl.shaderSource(vs, code);
                webgl.compileShader(vs);
                var r1 = webgl.getShaderParameter(vs, webgl.COMPILE_STATUS);
                if (r1 == false) {
                    var error = webgl.getShaderInfoLog(vs);
                    webgl.deleteShader(vs);
                    console.error(code, 'Failed to compile shader: ' + error);
                    return null;
                }
                var s = new glShader(name, ShaderTypeEnum.VS, vs, code);
                this.mapVS[name] = s;
                return s;
            };
            //编译并扫描 attribute 和 uniform
            shaderPool.prototype.compileFS = function (webgl, name, code) {
                var fs = webgl.createShader(webgl.FRAGMENT_SHADER);
                webgl.shaderSource(fs, code);
                webgl.compileShader(fs);
                var r1 = webgl.getShaderParameter(fs, webgl.COMPILE_STATUS);
                if (r1 == false) {
                    var error = webgl.getShaderInfoLog(fs);
                    webgl.deleteShader(fs);
                    console.error(code, 'Failed to compile shader: ' + error);
                    return null;
                }
                var s = new glShader(name, ShaderTypeEnum.FS, fs, code);
                this.mapFS[name] = s;
                return s;
            };
            //link 并寻找出 attribute pos 和 uniform组
            shaderPool.prototype.linkProgram = function (webgl, nameVS, nameFS) {
                var program = webgl.createProgram();
                webgl.attachShader(program, this.mapVS[nameVS].shader);
                webgl.attachShader(program, this.mapFS[nameFS].shader);
                webgl.linkProgram(program);
                var r3 = webgl.getProgramParameter(program, webgl.LINK_STATUS);
                if (r3 == false) {
                    console.error("vs:" + nameVS + "   fs:" + nameFS + "a webgl program error:" + webgl.getProgramInfoLog(program));
                    webgl.deleteProgram(program);
                    return null;
                }
                var name = nameVS + "_" + nameFS;
                var glp = new glProgram(this.mapVS[nameVS], this.mapFS[nameFS], program);
                //----------
                glp.initUniforms(webgl);
                glp.initAttribute(webgl);
                this.mapProgram[name] = glp;
                return glp;
            };
            shaderPool.prototype.linkProgrambyPassType = function (webgl, type, nameVS, nameFS, globalMacros) {
                var vsStr = this.mapVSString[nameVS];
                var fsStr = this.mapFSString[nameFS];
                var es300Tag = "#version 300 es \n";
                var es300Reg = /#version +300 +es[\r|\n]+/;
                var vsIsES300 = es300Reg.test(vsStr);
                var fsIsES300 = es300Reg.test(fsStr);
                if (vsIsES300) {
                    vsStr = vsStr.replace(es300Reg, "");
                }
                if (fsIsES300) {
                    fsStr = fsStr.replace(es300Reg, "");
                }
                // Handle global macros
                for (var i = 0; i < globalMacros.length; i++) {
                    vsStr = "#define ".concat(globalMacros[i], "\n").concat(vsStr);
                    fsStr = "#define ".concat(globalMacros[i], "\n").concat(fsStr);
                }
                if (type == "base") {
                }
                else if (type == "base_fog" || type == "fog") {
                    vsStr = "#define FOG \n" + vsStr;
                    fsStr = "#define FOG \n" + fsStr;
                }
                else if (type == "instance") {
                    vsStr = "#define INSTANCE \n" + vsStr;
                    fsStr = "#define INSTANCE \n" + fsStr;
                }
                else if (type == "instance_fog") {
                    vsStr = "#define FOG \n" + "#define INSTANCE \n" + vsStr;
                    fsStr = "#define FOG \n" + "#define INSTANCE \n" + fsStr;
                }
                else if (type == "skin") {
                    vsStr = "#define SKIN \n" + vsStr;
                    fsStr = "#define SKIN \n" + fsStr;
                }
                else if (type == "skin_fog") {
                    vsStr = "#define SKIN \n" + "#define FOG \n" + vsStr;
                    fsStr = "#define SKIN \n" + "#define FOG \n" + fsStr;
                }
                else if (type == "lightmap") {
                    vsStr = "#define LIGHTMAP \n" + vsStr;
                    fsStr = "#define LIGHTMAP \n" + fsStr;
                }
                else if (type == "lightmap_fog") {
                    vsStr = "#define LIGHTMAP \n" + "#define FOG \n" + vsStr;
                    fsStr = "#define LIGHTMAP \n" + "#define FOG \n" + fsStr;
                }
                else if (type == "quad") {
                    vsStr = "#define QUAD \n" + vsStr;
                    fsStr = "#define QUAD \n" + fsStr;
                }
                //检查 添加 es300 标记
                if (vsIsES300) {
                    vsStr = es300Tag + vsStr;
                }
                if (fsIsES300) {
                    fsStr = es300Tag + fsStr;
                }
                this.compileVS(webgl, nameVS + type, vsStr);
                this.compileFS(webgl, nameFS + type, fsStr);
                var pro = this.linkProgram(webgl, nameVS + type, nameFS + type);
                return pro;
            };
            return shaderPool;
        }());
        render.shaderPool = shaderPool;
    })(render = m4m.render || (m4m.render = {}));
})(m4m || (m4m = {}));
var m4m;
(function (m4m) {
    var render;
    (function (render) {
        /** 是否全局关闭，贴图mipmap */
        render.mipmapCancel = false;
        /**
         * @private
         */
        var TextureFormatEnum;
        (function (TextureFormatEnum) {
            TextureFormatEnum[TextureFormatEnum["RGBA"] = 1] = "RGBA";
            TextureFormatEnum[TextureFormatEnum["RGB"] = 2] = "RGB";
            TextureFormatEnum[TextureFormatEnum["Gray"] = 3] = "Gray";
            TextureFormatEnum[TextureFormatEnum["PVRTC4_RGB"] = 4] = "PVRTC4_RGB";
            TextureFormatEnum[TextureFormatEnum["PVRTC4_RGBA"] = 4] = "PVRTC4_RGBA";
            TextureFormatEnum[TextureFormatEnum["PVRTC2_RGB"] = 4] = "PVRTC2_RGB";
            TextureFormatEnum[TextureFormatEnum["PVRTC2_RGBA"] = 4] = "PVRTC2_RGBA";
            TextureFormatEnum[TextureFormatEnum["KTX"] = 5] = "KTX";
            TextureFormatEnum[TextureFormatEnum["FLOAT16"] = 6] = "FLOAT16";
            TextureFormatEnum[TextureFormatEnum["FLOAT32"] = 7] = "FLOAT32";
            TextureFormatEnum[TextureFormatEnum["ASTC_RGBA_4x4"] = 8] = "ASTC_RGBA_4x4";
            TextureFormatEnum[TextureFormatEnum["ASTC_RGBA_5x4"] = 9] = "ASTC_RGBA_5x4";
            TextureFormatEnum[TextureFormatEnum["ASTC_RGBA_5x5"] = 10] = "ASTC_RGBA_5x5";
            TextureFormatEnum[TextureFormatEnum["ASTC_RGBA_6x5"] = 11] = "ASTC_RGBA_6x5";
            TextureFormatEnum[TextureFormatEnum["ASTC_RGBA_6x6"] = 12] = "ASTC_RGBA_6x6";
            TextureFormatEnum[TextureFormatEnum["ASTC_RGBA_8x5"] = 13] = "ASTC_RGBA_8x5";
            TextureFormatEnum[TextureFormatEnum["ASTC_RGBA_8x6"] = 14] = "ASTC_RGBA_8x6";
            TextureFormatEnum[TextureFormatEnum["ASTC_RGBA_8x8"] = 15] = "ASTC_RGBA_8x8";
            TextureFormatEnum[TextureFormatEnum["ASTC_RGBA_10x5"] = 16] = "ASTC_RGBA_10x5";
            TextureFormatEnum[TextureFormatEnum["ASTC_RGBA_10x6"] = 17] = "ASTC_RGBA_10x6";
            TextureFormatEnum[TextureFormatEnum["ASTC_RGBA_10x8"] = 18] = "ASTC_RGBA_10x8";
            TextureFormatEnum[TextureFormatEnum["ASTC_RGBA_10x10"] = 19] = "ASTC_RGBA_10x10";
            TextureFormatEnum[TextureFormatEnum["ASTC_RGBA_12x10"] = 20] = "ASTC_RGBA_12x10";
            TextureFormatEnum[TextureFormatEnum["ASTC_RGBA_12x12"] = 21] = "ASTC_RGBA_12x12";
        })(TextureFormatEnum = render.TextureFormatEnum || (render.TextureFormatEnum = {}));
        /**
         * @private
         */
        var textureReader = /** @class */ (function () {
            function textureReader(webgl, texRGBA, width, height, gray) {
                if (gray === void 0) { gray = false; }
                this._isDispose = false;
                this._gray = gray;
                this._width = width;
                this._height = height;
                this.webgl = webgl;
                this._data = new Uint8Array(this._width * this._height * 4);
                if (gray)
                    this._grayData = new Uint8Array(this._width * this._height);
                this.refresh(texRGBA);
            }
            Object.defineProperty(textureReader.prototype, "width", {
                get: function () { return this._width; },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(textureReader.prototype, "height", {
                get: function () { return this._height; },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(textureReader.prototype, "data", {
                get: function () {
                    if (this._gray) {
                        return this._grayData;
                    }
                    else {
                        return this._data;
                    }
                },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(textureReader.prototype, "gray", {
                get: function () { return this._gray; },
                enumerable: false,
                configurable: true
            });
            Object.defineProperty(textureReader.prototype, "isDispose", {
                get: function () { return this._isDispose; },
                enumerable: false,
                configurable: true
            });
            textureReader.prototype.getPixel = function (u, v) {
                var x = (u * this._width) | 0;
                var y = (v * this._height) | 0;
                if (x < 0 || x >= this._width || y < 0 || y >= this._height)
                    return 0;
                if (this._gray) {
                    return this._grayData[y * this._width + x];
                }
                else {
                    var i = (y * this._width + x) * 4;
                    return new m4m.math.color(this._data[i], this._data[i + 1], this._data[i + 2], this._data[i + 3]);
                }
            };
            /** 刷新data数据 */
            textureReader.prototype.refresh = function (texRGBA) {
                if (!texRGBA) {
                    console.warn("texRGBA is null ");
                    return;
                }
                var fbo = this.webgl.createFramebuffer();
                var fbold = this.webgl.getParameter(this.webgl.FRAMEBUFFER_BINDING);
                this.webgl.bindFramebuffer(this.webgl.FRAMEBUFFER, fbo);
                this.webgl.framebufferTexture2D(this.webgl.FRAMEBUFFER, this.webgl.COLOR_ATTACHMENT0, this.webgl.TEXTURE_2D, texRGBA, 0);
                // var readData = new Uint8Array(this._width * this._height * 4);
                this._data[0] = 2;
                this.webgl.readPixels(0, 0, this._width, this._height, this.webgl.RGBA, this.webgl.UNSIGNED_BYTE, this._data);
                this.webgl.deleteFramebuffer(fbo);
                this.webgl.bindFramebuffer(this.webgl.FRAMEBUFFER, fbold);
                if (this._gray) {
                    for (var i = 0; i < this._width * this._height; i++) {
                        this._grayData[i] = this._data[i * 4]; //now only rad pass
                    }
                }
            };
            textureReader.prototype.dispose = function () {
                this.webgl = null;
                this._data = null;
                this._grayData = null;
            };
            return textureReader;
        }());
        render.textureReader = textureReader;
        /**
         * @private
         */
        var glRenderTarget = /** @class */ (function () {
            function glRenderTarget(webgl, width, height, depth, stencil, fbo) {
                if (depth === void 0) { depth = false; }
                if (stencil === void 0) { stencil = false; }
                if (fbo === void 0) { fbo = null; }
                this.width = width;
                this.height = height;
                this.fbo = fbo ? fbo : webgl.createFramebuffer();
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, this.fbo);
                if (depth || stencil) {
                    this.renderbuffer = webgl.createRenderbuffer();
                    webgl.bindRenderbuffer(webgl.RENDERBUFFER, this.renderbuffer);
                    if (depth && stencil) {
                        webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.DEPTH_STENCIL, width, height);
                        webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.DEPTH_STENCIL_ATTACHMENT, webgl.RENDERBUFFER, this.renderbuffer);
                    }
                    else if (depth) {
                        webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.DEPTH_COMPONENT16, width, height);
                        webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.DEPTH_ATTACHMENT, webgl.RENDERBUFFER, this.renderbuffer);
                    }
                    else {
                        webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.STENCIL_INDEX8, width, height);
                        webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.STENCIL_ATTACHMENT, webgl.RENDERBUFFER, this.renderbuffer);
                    }
                }
                this.texture = webgl.createTexture();
                this.fbo["width"] = width;
                this.fbo["height"] = height;
                webgl.bindTexture(webgl.TEXTURE_2D, this.texture);
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.LINEAR);
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.LINEAR);
                webgl.texImage2D(webgl.TEXTURE_2D, 0, webgl.RGBA, width, height, 0, webgl.RGBA, webgl.UNSIGNED_BYTE, null);
                webgl.framebufferTexture2D(webgl.FRAMEBUFFER, webgl.COLOR_ATTACHMENT0, webgl.TEXTURE_2D, this.texture, 0);
                //set unUse state
                glRenderTarget.useNull(webgl);
            }
            glRenderTarget.prototype.use = function (webgl) {
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, this.fbo);
                webgl.bindRenderbuffer(webgl.RENDERBUFFER, this.renderbuffer);
                webgl.bindTexture(webgl.TEXTURE_2D, this.texture);
                //webgl.framebufferTexture2D(webgl.FRAMEBUFFER, webgl.COLOR_ATTACHMENT0, webgl.TEXTURE_2D, this.texture, 0);
            };
            glRenderTarget.useNull = function (webgl) {
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, null);
                webgl.bindRenderbuffer(webgl.RENDERBUFFER, null);
            };
            glRenderTarget.prototype.dispose = function (webgl) {
                //if (this.texture == null && this.img != null)
                //    this.disposeit = true;
                if (this.texture != null) {
                    webgl.deleteFramebuffer(this.renderbuffer);
                    this.renderbuffer = null;
                    webgl.deleteTexture(this.texture);
                    this.texture = null;
                }
            };
            glRenderTarget.prototype.caclByteLength = function () {
                //RGBA & no mipmap
                return this.width * this.height * 4;
            };
            glRenderTarget.prototype.isFrameBuffer = function () {
                return true;
            };
            return glRenderTarget;
        }());
        render.glRenderTarget = glRenderTarget;
        /**
         * @private
         */
        var glTexture2D = /** @class */ (function () {
            function glTexture2D(webgl, format, mipmap, linear) {
                if (format === void 0) { format = TextureFormatEnum.RGBA; }
                if (mipmap === void 0) { mipmap = false; }
                if (linear === void 0) { linear = true; }
                this.linear = true;
                this.premultiply = true;
                this.repeat = true;
                this.mirroredU = true;
                this.mirroredV = true;
                //img: HTMLImageElement = null;
                this.loaded = false;
                this.width = 0;
                this.height = 0;
                this.mipmap = false;
                this.webgl = webgl;
                this.format = format;
                this.linear = linear;
                this.mipmap = mipmap;
                if (render.mipmapCancel) {
                    this.mipmap = false;
                }
                //if (url == null)//不给定url 则 texture 不加载
                //    return;
                this.texture = webgl.createTexture();
            }
            glTexture2D.prototype.uploadImage = function (img, mipmap, linear, premultiply, repeat, mirroredU, mirroredV) {
                if (premultiply === void 0) { premultiply = true; }
                if (repeat === void 0) { repeat = false; }
                if (mirroredU === void 0) { mirroredU = false; }
                if (mirroredV === void 0) { mirroredV = false; }
                this.width = img.width;
                this.height = img.height;
                this.mipmap = mipmap;
                if (render.mipmapCancel) {
                    this.mipmap = false;
                }
                this.linear = linear;
                this.premultiply = premultiply;
                this.repeat = repeat;
                this.mirroredU = mirroredU;
                this.mirroredV = mirroredV;
                this.loaded = true;
                this.webgl.bindTexture(this.webgl.TEXTURE_2D, this.texture);
                this.webgl.pixelStorei(this.webgl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiply ? 1 : 0);
                this.webgl.pixelStorei(this.webgl.UNPACK_FLIP_Y_WEBGL, 1);
                var texF = this.getGLFormat();
                // var formatGL = this.webgl.RGBA;
                // if (this.format == TextureFormatEnum.RGB)
                //     formatGL = this.webgl.RGB;
                // else if (this.format == TextureFormatEnum.Gray)
                //     formatGL = this.webgl.LUMINANCE;
                this.webgl.texImage2D(this.webgl.TEXTURE_2D, 0, texF.internalformatGL, texF.formatGL, 
                //最后这个type，可以管格式
                this.webgl.UNSIGNED_BYTE, img);
                if (mipmap) {
                    //生成mipmap
                    this.webgl.generateMipmap(this.webgl.TEXTURE_2D);
                    if (linear) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.LINEAR);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.LINEAR_MIPMAP_LINEAR);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.NEAREST);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.NEAREST_MIPMAP_NEAREST);
                    }
                }
                else {
                    if (linear) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.LINEAR);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.LINEAR);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.NEAREST);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.NEAREST);
                    }
                }
                if (repeat) {
                    if (mirroredU && mirroredV) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                    }
                    else if (mirroredU) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                    }
                    else if (mirroredV) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                    }
                }
                else {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.CLAMP_TO_EDGE);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.CLAMP_TO_EDGE);
                }
                //this.img = null;
                this.webgl.bindTexture(this.webgl.TEXTURE_2D, null);
            };
            glTexture2D.prototype.uploadByteArray = function (mipmap, linear, width, height, data, repeat, mirroredU, mirroredV, premultiplyAlpha, flipY, dataType) {
                if (repeat === void 0) { repeat = false; }
                if (mirroredU === void 0) { mirroredU = false; }
                if (mirroredV === void 0) { mirroredV = false; }
                if (premultiplyAlpha === void 0) { premultiplyAlpha = true; }
                if (flipY === void 0) { flipY = true; }
                if (dataType === void 0) { dataType = this.webgl.UNSIGNED_BYTE; }
                this.width = width;
                this.height = height;
                this.mipmap = mipmap;
                if (render.mipmapCancel) {
                    this.mipmap = false;
                }
                this.linear = linear;
                this.repeat = repeat;
                this.mirroredU = mirroredU;
                this.mirroredV = mirroredV;
                this.loaded = true;
                this.webgl.bindTexture(this.webgl.TEXTURE_2D, this.texture);
                if (premultiplyAlpha) {
                    this.webgl.pixelStorei(this.webgl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);
                }
                else {
                    this.webgl.pixelStorei(this.webgl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
                }
                if (flipY) {
                    // this.webgl.pixelStorei(this.webgl.UNPACK_FLIP_Y_WEBGL, 1);
                }
                var texF = this.getGLFormat();
                this.webgl.texImage2D(this.webgl.TEXTURE_2D, 0, texF.internalformatGL, width, height, 0, texF.formatGL, 
                //最后这个type，可以管格式
                dataType, data);
                if (mipmap) {
                    //生成mipmap
                    this.webgl.generateMipmap(this.webgl.TEXTURE_2D);
                    if (linear) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.LINEAR);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.LINEAR_MIPMAP_LINEAR);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.NEAREST);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.NEAREST_MIPMAP_NEAREST);
                    }
                }
                else {
                    if (linear) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.LINEAR);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.LINEAR);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.NEAREST);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.NEAREST);
                    }
                }
                //this.img = null;
                if (repeat) {
                    if (mirroredU && mirroredV) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                    }
                    else if (mirroredU) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                    }
                    else if (mirroredV) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                    }
                }
                else {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.CLAMP_TO_EDGE);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.CLAMP_TO_EDGE);
                }
                this.webgl.bindTexture(this.webgl.TEXTURE_2D, null);
            };
            glTexture2D.prototype.caclByteLength = function () {
                var pixellen = 1;
                if (this.format == TextureFormatEnum.RGBA) {
                    pixellen = 4;
                }
                else if (this.format == TextureFormatEnum.RGB) {
                    pixellen = 3;
                }
                var len = this.width * this.height * pixellen;
                if (this.mipmap) {
                    len = len * (1 - Math.pow(0.25, 10)) / 0.75;
                }
                return len;
            };
            glTexture2D.prototype.getReader = function (redOnly) {
                if (redOnly === void 0) { redOnly = false; }
                if (this.reader != null) {
                    if (this.reader.gray != redOnly)
                        throw new Error("get param diff with this.reader");
                    return this.reader;
                }
                if (this.format != TextureFormatEnum.RGBA)
                    throw new Error("only rgba texture can read");
                if (this.texture == null)
                    return null;
                if (this.reader == null)
                    this.reader = new textureReader(this.webgl, this.texture, this.width, this.height, redOnly);
                return this.reader;
            };
            //disposeit: boolean = false;
            glTexture2D.prototype.dispose = function (webgl) {
                //if (this.texture == null && this.img != null)
                //    this.disposeit = true;
                if (this.texture != null) {
                    webgl.deleteTexture(this.texture);
                    this.texture = null;
                }
            };
            glTexture2D.prototype.isFrameBuffer = function () {
                return false;
            };
            glTexture2D.prototype.getGLFormat = function () {
                var formatGL = this.webgl.RGBA;
                var internalformatGL = formatGL;
                switch (this.format) {
                    case TextureFormatEnum.RGB:
                        formatGL = this.webgl.RGB;
                        internalformatGL = formatGL;
                        break;
                    case TextureFormatEnum.FLOAT16:
                        formatGL = this.webgl.RGBA;
                        internalformatGL = this.webgl.RGBA16F;
                        // formatGL = this.webgl.RGBA;
                        // var ext = this.webgl.getExtension('OES_texture_half_float');
                        // if (ext == null) throw "nit support oes";
                        // dataType = ext.HALF_FLOAT_OES;
                        break;
                    case TextureFormatEnum.FLOAT32:
                        formatGL = this.webgl.RGBA;
                        internalformatGL = this.webgl.RGBA32F;
                        break;
                    case TextureFormatEnum.Gray:
                        formatGL = this.webgl.LUMINANCE;
                        internalformatGL = formatGL;
                        break;
                }
                return { internalformatGL: internalformatGL, formatGL: formatGL };
            };
            glTexture2D.formGrayArray = function (webgl, array, width, height) {
                var mipmap = false;
                var linear = true;
                var t = new glTexture2D(webgl, TextureFormatEnum.RGBA, mipmap, linear);
                var data = new Uint8Array(array.length * 4);
                for (var y = 0; y < width; y++) {
                    for (var x = 0; x < width; x++) {
                        var fi = y * 512 + x;
                        var i = y * width + x;
                        data[fi * 4] = array[i] * 255;
                        data[fi * 4 + 1] = array[i] * 255;
                        data[fi * 4 + 2] = array[i] * 255;
                        data[fi * 4 + 3] = 255;
                    }
                }
                t.uploadByteArray(mipmap, linear, 512, 512, data);
                return t;
            };
            glTexture2D.staticTexture = function (webgl, name) {
                var t = glTexture2D.mapTexture[name];
                if (t != undefined)
                    return t;
                var mipmap = false;
                var linear = true;
                t = new glTexture2D(webgl, TextureFormatEnum.RGBA, mipmap, linear);
                var size = 1;
                var data;
                if (name == "grid") {
                    size = 256;
                    data = new Uint8Array(size * size * 4);
                    for (var y = 0; y < size; y++) {
                        for (var x = 0; x < size; x++) {
                            var seek = (y * size + x) * 4;
                            if (((x - size * 0.5) * (y - size * 0.5)) > 0) {
                                data[seek] = 0;
                                data[seek + 1] = 0;
                                data[seek + 2] = 0;
                                data[seek + 3] = 255;
                            }
                            else {
                                data[seek] = 255;
                                data[seek + 1] = 255;
                                data[seek + 2] = 255;
                                data[seek + 3] = 255;
                            }
                        }
                    }
                }
                else {
                    var rg = 0, b = 0;
                    switch (name) {
                        case "gray":
                            rg = b = 128;
                            break;
                        case "white":
                            rg = b = 255;
                            break;
                        case "black":
                            rg = b = 0;
                            break;
                        case "normal":
                            rg = 128, b = 255;
                            break;
                    }
                    size = 16;
                    data = new Uint8Array(size * size * 4);
                    for (var y = 0; y < size; y++) {
                        for (var x = 0; x < size; x++) {
                            var seek = (y * size + x) * 4;
                            data[seek] = rg;
                            data[seek + 1] = rg;
                            data[seek + 2] = b;
                            data[seek + 3] = 255;
                        }
                    }
                }
                t.uploadByteArray(mipmap, linear, size, size, data);
                glTexture2D.mapTexture[name] = t;
                return t;
            };
            glTexture2D.particleTexture = function (webgl, name) {
                if (name === void 0) { name = m4m.framework.defTexture.particle; }
                var t = glTexture2D.mapTexture[name];
                if (t != undefined)
                    return t;
                var mipmap = false;
                var linear = true;
                t = new glTexture2D(webgl, TextureFormatEnum.RGBA, mipmap, linear);
                var size = 64;
                var data = new Uint8Array(size * size * 4);
                var half = size / 2;
                for (var i = 0; i < size; i++) {
                    for (var j = 0; j < size; j++) {
                        var l = m4m.math.floatClamp(m4m.math.vec2Length(new m4m.math.vector2(i - half, j - half)), 0, half) / half;
                        // l = l * l;
                        var f = 1 - l;
                        f = f * f;
                        // f = f * f * f;
                        // f = - 8 / 3 * f * f * f + 4 * f * f - f / 3;
                        var pos = (i + j * size) * 4;
                        data[pos] = f * 255;
                        data[pos + 1] = f * 255;
                        data[pos + 2] = f * 255;
                        data[pos + 3] = 255;
                    }
                }
                t.uploadByteArray(mipmap, linear, size, size, data);
                glTexture2D.mapTexture[name] = t;
                return t;
            };
            glTexture2D.mapTexture = {};
            return glTexture2D;
        }());
        render.glTexture2D = glTexture2D;
        var glTextureCube = /** @class */ (function () {
            function glTextureCube(webgl, format, mipmap, linear) {
                if (format === void 0) { format = TextureFormatEnum.RGBA; }
                if (mipmap === void 0) { mipmap = false; }
                if (linear === void 0) { linear = true; }
                //img: HTMLImageElement = null;
                this.loaded = false;
                this.width = 0;
                this.height = 0;
                this.mipmap = false;
                this.linear = false;
                this.webgl = webgl;
                this.format = format;
                this.mipmap = mipmap;
                if (render.mipmapCancel) {
                    this.mipmap = false;
                }
                this.linear = linear;
                this.texture = webgl.createTexture();
            }
            glTextureCube.prototype.uploadImages = function (Texture_NEGATIVE_X, Texture_NEGATIVE_Y, Texture_NEGATIVE_Z, Texture_POSITIVE_X, Texture_POSITIVE_Y, Texture_POSITIVE_Z, min, max, mipmap) {
                if (min === void 0) { min = WebGL2RenderingContext.NEAREST; }
                if (max === void 0) { max = WebGL2RenderingContext.NEAREST; }
                if (mipmap === void 0) { mipmap = null; }
                var wrc = this.webgl;
                var textures = [Texture_NEGATIVE_X, Texture_NEGATIVE_Y, Texture_NEGATIVE_Z, Texture_POSITIVE_X, Texture_POSITIVE_Y, Texture_POSITIVE_Z];
                var typeArr = [wrc.TEXTURE_CUBE_MAP_NEGATIVE_X, wrc.TEXTURE_CUBE_MAP_NEGATIVE_Y, wrc.TEXTURE_CUBE_MAP_NEGATIVE_Z, wrc.TEXTURE_CUBE_MAP_POSITIVE_X, wrc.TEXTURE_CUBE_MAP_POSITIVE_Y, wrc.TEXTURE_CUBE_MAP_POSITIVE_Z];
                for (var i = 0; i < typeArr.length; i++) {
                    var reader = textures[i].glTexture.getReader();
                    if (!reader) {
                        console.warn("getReader() fail : ".concat(textures[i].getName()));
                        return;
                    }
                    this.upload(reader.data, reader.width, reader.height, typeArr[i]);
                }
                wrc.texParameteri(wrc.TEXTURE_CUBE_MAP, wrc.TEXTURE_MIN_FILTER, min);
                wrc.texParameteri(wrc.TEXTURE_CUBE_MAP, wrc.TEXTURE_MAG_FILTER, max);
                wrc.texParameteri(wrc.TEXTURE_CUBE_MAP, wrc.TEXTURE_WRAP_S, wrc.CLAMP_TO_EDGE);
                wrc.texParameteri(wrc.TEXTURE_CUBE_MAP, wrc.TEXTURE_WRAP_T, wrc.CLAMP_TO_EDGE);
                if (mipmap !== null) {
                    wrc.generateMipmap(wrc.TEXTURE_CUBE_MAP);
                }
            };
            glTextureCube.prototype.upload = function (data, width, height, TEXTURE_CUBE_MAP_) {
                this.width = width;
                this.height = height;
                this.loaded = true;
                var gl = this.webgl;
                // gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,1);
                this.webgl.bindTexture(this.webgl.TEXTURE_CUBE_MAP, this.texture);
                var formatGL = this.webgl.RGBA;
                if (this.format == TextureFormatEnum.RGB)
                    formatGL = this.webgl.RGB;
                else if (this.format == TextureFormatEnum.Gray)
                    formatGL = this.webgl.LUMINANCE;
                if (data instanceof HTMLImageElement) {
                    this.webgl.texImage2D(TEXTURE_CUBE_MAP_, 0, formatGL, formatGL, 
                    //最后这个type，可以管格式
                    this.webgl.UNSIGNED_BYTE, data);
                }
                else {
                    this.webgl.texImage2D(TEXTURE_CUBE_MAP_, 0, formatGL, width, height, 0, formatGL, 
                    //最后这个type，可以管格式
                    this.webgl.UNSIGNED_BYTE, data);
                }
                // gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, min);
                // gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, max);
                // gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                // gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                // let mipmap = this.mipmap;
                var linear = this.linear;
                // let repeat = true;
                // let premultiply = true;
                // let mirroredU = false;
                // let mirroredV = false;
                // if (mipmap)
                // {
                //     //生成mipmap
                //     this.webgl.generateMipmap(this.webgl.TEXTURE_2D);
                //     if (linear)
                //     {
                //         this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.LINEAR);
                //         this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.LINEAR_MIPMAP_LINEAR);
                //     }
                //     else
                //     {
                //         this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.NEAREST);
                //         this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.NEAREST_MIPMAP_NEAREST);
                //     }
                // }
                // else
                // {
                //     if (linear)
                //     {
                //         this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.LINEAR);
                //         this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.LINEAR);
                //     }
                //     else
                //     {
                //         this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.NEAREST);
                //         this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.NEAREST);
                //     }
                // }
                //this.img = null;
                // if (repeat)
                // {
                //     if (mirroredU && mirroredV)
                //     {
                //         this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                //         this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                //     }
                //     else if (mirroredU)
                //     {
                //         this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                //         this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                //     }
                //     else if (mirroredV)
                //     {
                //         this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                //         this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                //     }
                //     else
                //     {
                //         this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                //         this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                //     }
                // }
                // else
                // {
                //     this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.CLAMP_TO_EDGE);
                //     this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.CLAMP_TO_EDGE);
                // }
            };
            glTextureCube.prototype.caclByteLength = function () {
                var pixellen = 1;
                if (this.format == TextureFormatEnum.RGBA) {
                    pixellen = 4;
                }
                else if (this.format == TextureFormatEnum.RGB) {
                    pixellen = 3;
                }
                var len = this.width * this.height * pixellen * 6;
                if (this.mipmap) {
                    len = len * (1 - Math.pow(0.25, 10)) / 0.75;
                }
                return len;
            };
            //disposeit: boolean = false;
            glTextureCube.prototype.dispose = function (webgl) {
                if (this.texture != null) {
                    webgl.deleteTexture(this.texture);
                    this.texture = null;
                }
            };
            glTextureCube.prototype.isFrameBuffer = function () {
                return false;
            };
            return glTextureCube;
        }());
        render.glTextureCube = glTextureCube;
        /**
         * @private
         */
        var WriteableTexture2D = /** @class */ (function () {
            function WriteableTexture2D(webgl, format, width, height, linear, premultiply, repeat, mirroredU, mirroredV) {
                if (format === void 0) { format = TextureFormatEnum.RGBA; }
                if (premultiply === void 0) { premultiply = true; }
                if (repeat === void 0) { repeat = false; }
                if (mirroredU === void 0) { mirroredU = false; }
                if (mirroredV === void 0) { mirroredV = false; }
                this.premultiply = true;
                this.repeat = false;
                this.mirroredU = false;
                this.mirroredV = false;
                this.width = 0;
                this.height = 0;
                this.webgl = webgl;
                this.texture = webgl.createTexture();
                this.webgl.pixelStorei(this.webgl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiply ? 1 : 0);
                this.webgl.pixelStorei(this.webgl.UNPACK_FLIP_Y_WEBGL, 0);
                this.webgl.bindTexture(this.webgl.TEXTURE_2D, this.texture);
                this.format = format;
                this.formatGL = this.webgl.RGBA;
                if (format == TextureFormatEnum.RGB)
                    this.formatGL = this.webgl.RGB;
                else if (format == TextureFormatEnum.Gray)
                    this.formatGL = this.webgl.LUMINANCE;
                var data = null;
                //data = new Uint8Array(width * height * 4);
                //for (var x = 0; x < width; x++)
                //    for (var y = 0; y < height; y++) {
                //        var seek = y * width * 4 + x * 4;
                //        data[seek] = 23;
                //        data[seek + 1] = 100;
                //        data[seek + 3] = 255;
                //    }
                this.webgl.texImage2D(this.webgl.TEXTURE_2D, 0, this.formatGL, width, height, 0, this.formatGL, 
                //最后这个type，可以管格式
                this.webgl.UNSIGNED_BYTE, data);
                if (linear) {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.LINEAR);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.LINEAR);
                }
                else {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MAG_FILTER, this.webgl.NEAREST);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_MIN_FILTER, this.webgl.NEAREST);
                }
                if (repeat) {
                    if (mirroredU && mirroredV) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                    }
                    else if (mirroredU) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.MIRRORED_REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                    }
                    else if (mirroredV) {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.MIRRORED_REPEAT);
                    }
                    else {
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.REPEAT);
                        this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.REPEAT);
                    }
                }
                else {
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_S, this.webgl.CLAMP_TO_EDGE);
                    this.webgl.texParameteri(this.webgl.TEXTURE_2D, this.webgl.TEXTURE_WRAP_T, this.webgl.CLAMP_TO_EDGE);
                }
            }
            WriteableTexture2D.prototype.updateRect = function (data, x, y, width, height) {
                this.webgl.bindTexture(this.webgl.TEXTURE_2D, this.texture);
                this.webgl.texSubImage2D(this.webgl.TEXTURE_2D, 0, x, y, width, height, this.formatGL, this.webgl.UNSIGNED_BYTE, data);
            };
            WriteableTexture2D.prototype.updateRectImg = function (data, x, y) {
                this.webgl.bindTexture(this.webgl.TEXTURE_2D, this.texture);
                this.webgl.texSubImage2D(this.webgl.TEXTURE_2D, 0, x, y, this.formatGL, this.webgl.UNSIGNED_BYTE, data);
            };
            WriteableTexture2D.prototype.isFrameBuffer = function () {
                return false;
            };
            WriteableTexture2D.prototype.dispose = function (webgl) {
                if (this.texture != null) {
                    webgl.deleteTexture(this.texture);
                    this.texture = null;
                }
            };
            WriteableTexture2D.prototype.caclByteLength = function () {
                var pixellen = 1;
                if (this.format == TextureFormatEnum.RGBA) {
                    pixellen = 4;
                }
                else if (this.format == TextureFormatEnum.RGB) {
                    pixellen = 3;
                }
                var len = this.width * this.height * pixellen;
                return len;
            };
            return WriteableTexture2D;
        }());
        render.WriteableTexture2D = WriteableTexture2D;
        /**
         * 视频纹理
         */
        var videoTexture = /** @class */ (function () {
            function videoTexture(video) {
                var _this = this;
                this._needUpdateVideo = false;
                this.width = 1;
                this.height = 1;
                this.premultiply = false;
                this.flipY = true;
                this.mipmap = false;
                this.linear = true;
                this.repeat = true;
                this.mirroredU = false;
                this.mirroredV = false;
                this._video = video;
                var gl = m4m.framework.sceneMgr.app.webgl;
                this.texture = gl.createTexture();
                if (!video) {
                    console.error("video is null");
                    return;
                }
                this.width = video.width;
                this.height = video.height;
                this.applyProperty();
                if (video.buffered.length) { //video 有数据了可以上传纹理
                    this.refreshTexture();
                }
                if ('requestVideoFrameCallback' in video) {
                    video.requestVideoFrameCallback(function () {
                        _this.updateVideo();
                    });
                }
            }
            Object.defineProperty(videoTexture.prototype, "video", {
                /** 视频对象 */
                get: function () { return this._video; },
                enumerable: false,
                configurable: true
            });
            /**
             * 应用webgl纹理属性
             */
            videoTexture.prototype.applyProperty = function () {
                if (!this._video) {
                    console.warn("video is null");
                }
                var mipmap = this.mipmap;
                if (render.mipmapCancel) {
                    mipmap = false;
                }
                var linear = this.linear;
                var repeat = this.repeat;
                var mirroredU = this.mirroredU;
                var mirroredV = this.mirroredV;
                var gl = m4m.framework.sceneMgr.app.webgl;
                gl.bindTexture(gl.TEXTURE_2D, this.texture);
                if (mipmap) {
                    //生成mipmap
                    gl.generateMipmap(gl.TEXTURE_2D);
                    if (linear) {
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
                    }
                    else {
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST_MIPMAP_NEAREST);
                    }
                }
                else {
                    if (linear) {
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    }
                    else {
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                    }
                }
                if (repeat) {
                    if (mirroredU && mirroredV) {
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT);
                    }
                    else if (mirroredU) {
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
                    }
                    else if (mirroredV) {
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT);
                    }
                    else {
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
                    }
                }
                else {
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                }
                gl.bindTexture(gl.TEXTURE_2D, null);
            };
            videoTexture.prototype.isFrameBuffer = function () {
                return false;
            };
            videoTexture.prototype.dispose = function (webgl) {
                this._video = null;
                var gl = m4m.framework.sceneMgr.app.webgl;
                if (this.texture) {
                    gl.deleteTexture(this.texture);
                    this.texture = null;
                }
            };
            videoTexture.prototype.caclByteLength = function () {
                return 0;
            };
            /** 开启 视频到纹理的更新循环 */
            videoTexture.prototype.loopVideoToTexture = function () {
                if (this._needUpdateVideo)
                    return;
                this.updateVideo();
            };
            /** 更新 视频帧 到纹理 , */
            videoTexture.prototype.updateVideo = function () {
                var _this = this;
                this._needUpdateVideo = false;
                if (!this._video) {
                    console.warn("video is null");
                    return;
                }
                //更新帧数据到 webgl 纹理
                this.refreshTexture();
                if ('requestVideoFrameCallback' in this._video) {
                    this._needUpdateVideo = true;
                    this._video.requestVideoFrameCallback(function () {
                        _this.updateVideo();
                    });
                }
            };
            /**
             * 更新纹理
             */
            videoTexture.prototype.refreshTexture = function () {
                if (!this._video) {
                    console.warn("video is null");
                }
                var gl = m4m.framework.sceneMgr.app.webgl;
                gl.bindTexture(gl.TEXTURE_2D, this.texture);
                gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiply ? 1 : 0);
                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, this.flipY ? 1 : 0);
                var formatGLxF = gl.RGB;
                var internalformatGL = gl.RGB;
                gl.texImage2D(gl.TEXTURE_2D, 0, internalformatGL, formatGLxF, 
                //最后这个type，可以管格式
                gl.UNSIGNED_BYTE, this._video);
                gl.bindTexture(gl.TEXTURE_2D, null);
            };
            return videoTexture;
        }());
        render.videoTexture = videoTexture;
    })(render = m4m.render || (m4m.render = {}));
})(m4m || (m4m = {}));
//# sourceMappingURL=m4m.js.map